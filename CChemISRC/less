File: ./cchemi/src/Main/cchemi.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* cchemi.c */

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <time.h>
#include <locale.h>

#include <Utils/Types.h>
#include <Utils/Utils.h>
#include <JobControl/Job.h>

int main(int argc, char *argv[])
{
	char* inputFileName = NULL;
	Job job;
	if(argc<2)
	{
		printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		printf("Usage : cchemi inputFileName.ici\n");
		printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		exit(1);
	}
	inputFileName = argv[1];

/*
	g_setenv("LANG","en_US",TRUE);
	g_setenv("GDM_LANG","en_US",TRUE);
*/
	setlocale(LC_ALL,"C");
	setlocale(LC_NUMERIC,"C");

	initAll(argc, argv);
	readRessources();
	job = newJob(inputFileName);
	runJob(&job);
	finalize();

	return 0;
}
File: ./cchemilib/src/QuantumMechanics/SteepestDescentQM.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* SteepestDescentQM.c  */
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>

#include "../Utils/Utils.h"
#include "../Utils/AtomsProp.h"
#include "../Utils/Constants.h"
#include "../Utils/Types.h"
#include "../Molecule/Molecule.h"
#include "../QuantumMechanics/SteepestDescentQM.h"

static void Minimize(SteepestDescentQM* steepestDescentQM);
/**********************************************************************/
void	runSteepestDescentQM(
		SteepestDescentQM* steepestDescentQM, QuantumMechanicsModel* qmModel, 
		int updateFrequency, int maxIterations, double epsilon,
		int maxLines
		)
{

	steepestDescentQM->qmModel = qmModel;
	steepestDescentQM->numberOfAtoms = qmModel->molecule.nAtoms;
	steepestDescentQM->updateFrequency = updateFrequency;
	steepestDescentQM->maxIterations = maxIterations;
	steepestDescentQM->updateNumber = 0;
	steepestDescentQM->epsilon = epsilon;
	steepestDescentQM->rmsDeplacment = 0;
	steepestDescentQM->maxDeplacment = 0;
	steepestDescentQM->gradientNorm = 0;
	steepestDescentQM->maxLines=maxLines;

	Minimize(steepestDescentQM);
}
/**********************************************************************/
void	freeSteepestDescentQM(SteepestDescentQM* steepestDescentQM)
{

	steepestDescentQM->qmModel = NULL;
	steepestDescentQM->numberOfAtoms = 0;
	steepestDescentQM->updateFrequency = 0;
	steepestDescentQM->maxIterations = 0;
	steepestDescentQM->updateNumber = 0;
	steepestDescentQM->epsilon = 0;
	steepestDescentQM->rmsDeplacment = 0;
	steepestDescentQM->maxDeplacment = 0;
	steepestDescentQM->gradientNorm = 0;
	steepestDescentQM->maxLines=0;

}
/**********************************************************************/
static void Minimize(SteepestDescentQM* steepestDescentQM)
{
	double energy;
	int iteration = 0;
	double lastGradientNorm = 1;
	double term = 1;
	char* str = strdup(" ");
	int i;
	int j;
	double f0,f1;
	int ii;
	double fg;
	FILE* fileOut = steepestDescentQM->logfile;

	steepestDescentQM->updateNumber = 0;

	steepestDescentQM->qmModel->klass->calculateGradient(steepestDescentQM->qmModel);

	steepestDescentQM->gradientNorm = 0;
	for (  i = 0; i < steepestDescentQM->numberOfAtoms; i++ )
		for(j=0;j<3;j++)
			steepestDescentQM->gradientNorm += 
				steepestDescentQM->qmModel->molecule.atoms[i].gradient[j] *
				steepestDescentQM->qmModel->molecule.atoms[i].gradient[j]; 

	lastGradientNorm = sqrt( steepestDescentQM->gradientNorm );

	fprintf(fileOut,"=============================================================================================================================================\n");
        fprintf(fileOut,"\t\t\tOptimization by Steepest Descent method\n");
        fprintf(fileOut,"---------------------------------------------------------------------------------------------------------------------------------------------\n");
        fprintf(fileOut,"\t\t\tMaxIteration \t\t= %d\n",steepestDescentQM->maxIterations);
        fprintf(fileOut,"\t\t\tEpsilon \t\t= %0.4e\n",steepestDescentQM->epsilon);
        fprintf(fileOut,"\t\t\tMax lines search \t= %d\n",steepestDescentQM->maxLines);
        fprintf(fileOut,"=============================================================================================================================================\n");
        fflush(fileOut); fflush(stderr);


	while( 
			( lastGradientNorm > steepestDescentQM->epsilon*steepestDescentQM->epsilon) && 
			( iteration++ < steepestDescentQM->maxIterations )
	     )
	{

		steepestDescentQM->qmModel->klass->calculateGradient(steepestDescentQM->qmModel);
		steepestDescentQM->gradientNorm = 0;
		for (  i = 0; i < steepestDescentQM->numberOfAtoms; i++ )
			for(j=0;j<3;j++)
				steepestDescentQM->gradientNorm += 
					steepestDescentQM->qmModel->molecule.atoms[i].gradient[j] *
					steepestDescentQM->qmModel->molecule.atoms[i].gradient[j]; 

		steepestDescentQM->gradientNorm = sqrt( steepestDescentQM->gradientNorm );
		
	
		if(steepestDescentQM->gradientNorm<1e-12) break;

		
        	steepestDescentQM->qmModel->klass->calculateEnergy(steepestDescentQM->qmModel);
		f0 = steepestDescentQM->qmModel->molecule.potentialEnergy;
		term = 0;
		fg = 1.0;
		if(steepestDescentQM->gradientNorm>1) fg = 1.0/steepestDescentQM->gradientNorm;

		for(ii=steepestDescentQM->maxLines;ii>=1;ii--)
		{
			term = ii*0.0001;
			for (  i = 0; i < steepestDescentQM->numberOfAtoms; i++ )
			{
				for(j=0;j<3;j++)
					steepestDescentQM->qmModel->molecule.atoms[i].coordinates[j]-=
					fg*term*steepestDescentQM->qmModel->molecule.atoms[i].gradient[j]; 
			}

        		steepestDescentQM->qmModel->klass->calculateEnergy(steepestDescentQM->qmModel);
			f1 = steepestDescentQM->qmModel->molecule.potentialEnergy;
			if(f1<f0)
				break;
			for (  i = 0; i < steepestDescentQM->numberOfAtoms; i++ )
			{
				for(j=0;j<3;j++)
					steepestDescentQM->qmModel->molecule.atoms[i].coordinates[ j ] += 
					fg*term*steepestDescentQM->qmModel->molecule.atoms[i].gradient[j]; 
			}
		}
		if(ii<=1) 
		{
			fprintf(steepestDescentQM->logfile, ("!!!!!!!!!!Steep descent Max lines exessed\n"));
			break;
		}
		lastGradientNorm = steepestDescentQM->gradientNorm;

		if ( steepestDescentQM->updateNumber++ >= steepestDescentQM->updateFrequency )
		{
			free(str);
			str = strdup_printf(("Gradient = %0.10f Energy = %0.10f"),(double)steepestDescentQM->gradientNorm, (double) f0); 
			/* redrawMolecule(&steepestDescentQM->qmModel->molecule,str);*/
			fprintf(steepestDescentQM->logfile,"%s\n",str);
			fflush(steepestDescentQM->logfile);
			steepestDescentQM->updateNumber = 0;
		}
	}

	steepestDescentQM->qmModel->klass->calculateGradient(steepestDescentQM->qmModel);
	steepestDescentQM->gradientNorm = 0;
	for (  i = 0; i < steepestDescentQM->numberOfAtoms; i++ )
		for(j=0;j<3;j++)
			steepestDescentQM->gradientNorm += 
				steepestDescentQM->qmModel->molecule.atoms[i].gradient[j] *
				steepestDescentQM->qmModel->molecule.atoms[i].gradient[j]; 

	steepestDescentQM->gradientNorm = sqrt( steepestDescentQM->gradientNorm );
       	steepestDescentQM->qmModel->klass->calculateEnergy(steepestDescentQM->qmModel);
	energy = steepestDescentQM->qmModel->molecule.potentialEnergy;
	free(str);
	str = strdup_printf(("Gradient = %0.10f  Energy = %0.10f (Kcal/mol)"),
			(double)steepestDescentQM->gradientNorm,(double)energy); 

	/* redrawMolecule(&steepestDescentQM->qmModel->molecule,str);*/
	fprintf(steepestDescentQM->logfile,"%s\n",str);
	fflush(steepestDescentQM->logfile);
	free(str);
}
/********************************************************************************/
File: ./cchemilib/src/QuantumMechanics/QuantumMechanicsModel.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* QuantumMechanicsModel.c */
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>

#include "../Utils/Utils.h"
#include "../Utils/AtomsProp.h"
#include "../Utils/Constants.h"
#include "../Utils/Types.h"
#include "../Utils/QL.h"
#include "../QuantumMechanics/QuantumMechanicsModel.h"

static void freeQuantumMechanicsModel(QuantumMechanicsModel* qmModel);
static int computeQMFrequenciesNumeric(QuantumMechanicsModel* qmModel, double** frequencies, double*** modes, double** reducedMasses, double** IRIntensities);
static int computeQMFrequenciesAnalytic(QuantumMechanicsModel* qmModel, double** frequencies, double*** modes, double** reducedMasses, double** IRIntensities);
static int computeQMFrequencies(QuantumMechanicsModel* qmModel, double** frequencies, double*** modes, double** reducedMasses, double** IRIntensities);
static QuantumMechanicsModel copyQuantumMechanicsModel(QuantumMechanicsModel* f);
static void setRattleConstraintsParameters(QuantumMechanicsModel* quantumMechanicsModel);
static void removeFragmentedMolecules(QuantumMechanicsModel** qmModels, int* pnumberOfGeometries, double* energies, FILE* logfile);
static void removeSimilarInertiaGeometries(QuantumMechanicsModel** qmModels, int* pnumberOfGeometries, double* energies, FILE* logfile, double tol);
static void removeSimilarBondsGeometries(QuantumMechanicsModel** qmModels, int* pnumberOfGeometries, double* energies, FILE* logfile, double sTol, double distTol);
static void removeSmallDistanceMolecules(QuantumMechanicsModel** qmModels, int* pnumberOfGeometries, double* energies, FILE* logfile);
static void sortByInertia(QuantumMechanicsModel** qmModels, int* pnumberOfGeometries, double* energies);
static void cutByInertia(QuantumMechanicsModel** qmModels, int* pnumberOfGeometries, double* energies, int newNGeoms, FILE* logfile);
static QuantumMechanicsModel** getQuantumMechanicsRDConfo(QuantumMechanicsModel* qmModel, int numberOfGeometries, boolean chain, boolean saveFirstGeom);
static QuantumMechanicsModel** getQuantumMechanicsRDFConfo(QuantumMechanicsModel* qmModel, int numberOfGeometries, boolean saveFirstGeom);
static int computeIR(QuantumMechanicsModel* qmModel, double *F, double** dmu, double** frequencies, double*** modes, double** reducedMasses, double** IRIntensities);
/***********************************************************************************************************************/
static QuantumMechanicsModel** getQuantumMechanicsRDConfo(QuantumMechanicsModel* qmModel, int numberOfGeometries, boolean chain, boolean saveFirstGeom)
{
	int i;
	char* str = NULL;
	QuantumMechanicsModel** geometries = NULL;

	if(qmModel->molecule.nAtoms<1) return NULL;
	if(numberOfGeometries<2) return NULL;
	geometries = malloc(numberOfGeometries*sizeof(QuantumMechanicsModel*));
	fflush(stdout);
	for (i = 0; i < numberOfGeometries; i++ )
	{
		geometries[i] = NULL;
		if(i>0 || !saveFirstGeom) 
		{
			if(chain) qmModel->molecule.klass->setRandomPositionsChain(&qmModel->molecule);
			else qmModel->molecule.klass->setRandomPositions(&qmModel->molecule);
		}
		qmModel->klass->calculateEnergy(qmModel);
		if(str) free(str);
		str = strdup_printf(("Geometry # %d Potential energy \t=  %0.4f"), i+1, qmModel->molecule.potentialEnergy);
		printf("%s ",str);
		geometries[i] = malloc(sizeof(QuantumMechanicsModel));
		*geometries[i] = qmModel->klass->copy(qmModel);

		double I2,I4;
		geometries[i]->molecule.klass->computePseudoInertia(&geometries[i]->molecule, &I2, &I4);
		str = strdup_printf((" \tI2=%0.4f \tI4=%0.4f"), I2,I4);
		printf("%s\n",str);
		fflush(stdout);
	}
	if(str) free(str);
	return geometries;
}
/***********************************************************************************************************************/
static QuantumMechanicsModel** getQuantumMechanicsRDFConfo(QuantumMechanicsModel* qmModel, int numberOfGeometries, boolean saveFirstGeom)
{
	int i;
	char* str = NULL;
	QuantumMechanicsModel** geometries = NULL;

	if(qmModel->molecule.nAtoms<1) return NULL;
	if(numberOfGeometries<2) return NULL;
	geometries = malloc(numberOfGeometries*sizeof(QuantumMechanicsModel*));
	fflush(stdout);
	for (i = 0; i < numberOfGeometries; i++ )
	{
		geometries[i] = NULL;
		geometries[i] = malloc(sizeof(QuantumMechanicsModel));
		*geometries[i] = qmModel->klass->copy(qmModel);
		if(i>0 || !saveFirstGeom) 
		{
			qmModel->molecule.klass->setRandomFragments(&geometries[i]->molecule);
		}
		qmModel->klass->calculateEnergy(geometries[i]);
		if(str) free(str);
		str = strdup_printf(("Geometry # %d Potential energy \t=  %0.4f"), i+1, geometries[i]->molecule.potentialEnergy);
		printf("%s ",str);

		double I2,I4;
		geometries[i]->molecule.klass->computePseudoInertia(&geometries[i]->molecule, &I2, &I4);
		str = strdup_printf((" \tI2=%0.4f \tI4=%0.4f"), I2,I4);
		printf("%s\n",str);
		fflush(stdout);
	}
	if(str) free(str);
	return geometries;
}
/********************************************************************************************************************************************************/
static void sortByInertia(QuantumMechanicsModel** qmModels, int* pnumberOfGeometries, double* energies)
{
	int i,j;
	int numberOfGeometries = *pnumberOfGeometries;
	double* s = NULL;
	Molecule* mol;
	double I2,I4;
	double t;
	QuantumMechanicsModel* qm;
	double smax=-1;
	int nG=0; 

	if(numberOfGeometries<2) return;
	s = malloc(numberOfGeometries*sizeof(double));

	smax=-1;
	for (i = 0; i < numberOfGeometries; i++ ) 
	{
			s[i]= -1;
			if(!qmModels[i]) continue;
			mol = &qmModels[i]->molecule;
			mol->klass->computePseudoInertia(mol, &I2, &I4);
			s[i]= I4+I2;
			if(smax<0 || smax<s[i]) smax=s[i];
	}
	//fprintf(stderr,"End calcul s, smax=%f\n",smax); fflush(stderr);
	
	for (i = 0; i < numberOfGeometries; i++ ) if(!qmModels[i]) s[i]= smax+1e10;

	//if(qmModels && qmModels[0] && qmModels[0]->molecule.nAtoms<1) return;
	for (i = 0; i < numberOfGeometries; i++ )
	{
		int k=i;
		for (j = i+1; j < numberOfGeometries; j++ ) if(s[j]<s[k]) k=j;
		if(k!=i)
		{
			t = s[i];
			s[i]=s[k];
			s[k]=t;

			if(energies)
			{
				t = energies[i];
				energies[i]=energies[k];
				energies[k]=t;
			}

			qm=qmModels[i];
			qmModels[i]=qmModels[k];
			qmModels[k]=qm;
		}
	}

	nG=0; 
	for (i = 0; i < numberOfGeometries; i++ ) if(qmModels[i])  nG++;

	free(s);
	*pnumberOfGeometries = nG;
}
/********************************************************************************************************************************************************/
static void cutByInertia(QuantumMechanicsModel** qmModels, int* pnumberOfGeometries, double* energies, int newNGeoms, FILE* logfile)
{
	int i,j;
	int numberOfGeometries = *pnumberOfGeometries;
	int nG=0; 
	int* toRemove = NULL;
	int iBegin;

	if(numberOfGeometries<newNGeoms) return;
	//fprintf(stderr,"begin sorting\n");
	sortByInertia(qmModels, &numberOfGeometries, energies);
	//fprintf(stderr,"end sorting, nG=%d\n",numberOfGeometries); fflush(stderr);

	*pnumberOfGeometries = numberOfGeometries;
	if(numberOfGeometries<=newNGeoms) return;
	int nStep=numberOfGeometries/newNGeoms+1;

	//fprintf(stderr,"nStep=%d\n",nStep); fflush(stderr);
	//fprintf(stderr,"newNGeoms=%d\n",newNGeoms); fflush(stderr);

	toRemove = malloc(numberOfGeometries*sizeof(int));
	for (i = 0; i < numberOfGeometries; i++ ) toRemove[i]=1;

	nG=0;
	for (i = 0; i < numberOfGeometries; i+=nStep)
	{
		toRemove[i]=0;
		nG++;
		if(nG==newNGeoms) break;
	}
	//fprintf(stderr,"nG avant while=%d\n",nG); fflush(stderr);

	iBegin=0;
	while(nG<newNGeoms)
	{
		iBegin++;
		for (i = iBegin; i < numberOfGeometries; i+=nStep)
		{
			if(toRemove[i]==0) continue;
			toRemove[i]=0;
			nG++;
			if(nG==newNGeoms) break;
		}
	}
	//fprintf(stderr,"nG=%d\n",nG); fflush(stderr);

	//if(qmModels && qmModels[0] && qmModels[0]->molecule.nAtoms<1) return;
	for (i = 0; i < numberOfGeometries; i++ )
	{
		if(toRemove[i]==1 && qmModels[i]) 
		{
			qmModels[i]->klass->free(qmModels[i]);
			qmModels[i] = NULL;
		}
	}
	nG=numberOfGeometries;
	for (i = 0; i < nG; i++ ) 
	if(!qmModels[i]) 
	{
		for (j = i; j < nG-1; j++ ) 
		{
			qmModels[j]=qmModels[j+1];
			toRemove[j]=toRemove[j+1];
			if(energies) energies[j]=energies[j+1];
		}
		i--;
		nG--;
	}
	free(toRemove);
	fprintf(stderr,"After cutting by inertia, the new number of geometries = %d\n",nG);
	fflush(stderr);
	fprintf(logfile,"After cutting by inertia, the new number of geometries = %d\n",nG);
	fflush(logfile);
	*pnumberOfGeometries = nG;
}
/***********************************************************************************************************************/
static void removeSmallDistanceMolecules(QuantumMechanicsModel** qmModels, int* pnumberOfGeometries, double* energies, FILE* logfile)
{
	int i,j;
	int numberOfGeometries = *pnumberOfGeometries;
	int* toRemove = NULL;
	Molecule* mol;

	if(numberOfGeometries<2) return;
	toRemove = malloc(numberOfGeometries*sizeof(int));
	for (i = 0; i < numberOfGeometries; i++ ) toRemove[i]=0;

	//if(qmModels && qmModels[0] && qmModels[0]->molecule.nAtoms<1) return;
	for (i = 0; i < numberOfGeometries; i++ )
	{
		if(!qmModels[i]) { toRemove[i]=1; continue;}
		if(toRemove[i]==1) continue;

		mol = &qmModels[i]->molecule;
		if(mol->klass->smallDistance(mol)) 
		{
			if(energies) fprintf(logfile,"Mol num %4d : small distance, E = %0.8f\n",i+1,energies[i]);
			else fprintf(logfile,"Mol num %4d : small distance fragment\n",i+1);
			fflush(logfile);
			toRemove[i]=1;
		}
	}
	for (i = 0; i < numberOfGeometries; i++ )
	{
		if(toRemove[i]==1 && qmModels[i]) 
		{
			qmModels[i]->klass->free(qmModels[i]);
			qmModels[i] = NULL;
		}
	}
	int nG0=0; 
	for (i = 0; i < numberOfGeometries; i++ ) if(!qmModels[i])  nG0++;

	int nG=numberOfGeometries;
	for (i = 0; i < nG; i++ ) 
	if(!qmModels[i]) 
	{
		for (j = i; j < nG-1; j++ ) 
		{
			qmModels[j]=qmModels[j+1];
			toRemove[j]=toRemove[j+1];
			if(energies) energies[j]=energies[j+1];
		}
		i--;
		nG--;
	}
	free(toRemove);
	fprintf(stderr,"Number of removed geometries with small distance %d ; ",numberOfGeometries-nG);
	fprintf(stderr,"new number of geometries %d\n",nG);
	fflush(stderr);
	fprintf(logfile,"Number of removed geometries with small distance %d ; ",numberOfGeometries-nG);
	fprintf(logfile,"new number of geometries %d\n",nG);
	fflush(logfile);
	*pnumberOfGeometries = nG;
}
/***********************************************************************************************************************/
static void removeSimilarBondsGeometries(QuantumMechanicsModel** qmModels, int* pnumberOfGeometries, double* energies, FILE* logfile, double sTol, double distTol)
{
	int i,j;
	int numberOfGeometries = *pnumberOfGeometries;
	int* toRemove = NULL;
	Molecule* mol1;
	Molecule* mol2;

	if(numberOfGeometries<2) return;
	toRemove = malloc(numberOfGeometries*sizeof(int));
	for (i = 0; i < numberOfGeometries; i++ ) toRemove[i]=0;

	//if(qmModels && qmModels[0] && qmModels[0]->molecule.nAtoms<1) return;
	for (i = 0; i < numberOfGeometries; i++ )
	{
		if(!qmModels[i]) { toRemove[i]=1; continue;}
		if(toRemove[i]==1) continue;

		mol1 = &qmModels[i]->molecule;
		for (j = i+1; j < numberOfGeometries; j++ )
		{
			mol2 = &qmModels[j]->molecule;
			if(mol1->klass->similarBonds(mol1, mol2,sTol,distTol)) 
			{
				double s,maxDiffDistance;
				double I22,I42;
				s= mol1->klass->getSimilatityByBonds(mol1, mol2,&maxDiffDistance);
				mol2->klass->computePseudoInertia(mol2, &I22, &I42);
				fprintf(logfile,"Two (%4d, %4d) similar bonds : s=%+0.4f \tmax difference between distances=%+0.4f\n",
						i+1,j+1,s,maxDiffDistance);
				fflush(logfile);
				toRemove[j]=1;
			}
		}
	}
	for (i = 0; i < numberOfGeometries; i++ )
	{
		if(toRemove[i]==1 && qmModels[i]) 
		{
			qmModels[i]->klass->free(qmModels[i]);
			qmModels[i] = NULL;
		}
	}
	int nG0=0; 
	for (i = 0; i < numberOfGeometries; i++ ) if(!qmModels[i])  nG0++;

	int nG=numberOfGeometries;
	for (i = 0; i < nG; i++ ) 
	if(!qmModels[i]) 
	{
		for (j = i; j < nG-1; j++ ) 
		{
			qmModels[j]=qmModels[j+1];
			toRemove[j]=toRemove[j+1];
			if(energies) energies[j]=energies[j+1];
		}
		i--;
		nG--;
	}
	free(toRemove);
	fprintf(stderr,"Number of removed geometries due to similar bonds %d ; ",numberOfGeometries-nG);
	fprintf(stderr,"new number of geometries %d\n",nG);
	fflush(stderr);
	fprintf(logfile,"Number of removed geometries due to similar bonds %d ; ",numberOfGeometries-nG);
	fprintf(logfile,"new number of geometries %d\n",nG);
	fflush(logfile);
	*pnumberOfGeometries = nG;
}
/***********************************************************************************************************************/
static void removeFragmentedMolecules(QuantumMechanicsModel** qmModels, int* pnumberOfGeometries, double* energies, FILE* logfile)
{
	int i,j;
	int numberOfGeometries = *pnumberOfGeometries;
	int* toRemove = NULL;
	Molecule* mol;

	if(numberOfGeometries<2) return;
	toRemove = malloc(numberOfGeometries*sizeof(int));
	for (i = 0; i < numberOfGeometries; i++ ) toRemove[i]=0;

	//if(qmModels && qmModels[0] && qmModels[0]->molecule.nAtoms<1) return;
	for (i = 0; i < numberOfGeometries; i++ )
	{
		if(!qmModels[i]) { toRemove[i]=1; continue;}
		if(toRemove[i]==1) continue;

		mol = &qmModels[i]->molecule;
		if(!mol->klass->oneFragment(mol)) 
		{
			if(energies) fprintf(logfile,"Mol num %4d : more one fragment, E = %0.8f\n",i+1,energies[i]);
			else fprintf(logfile,"Mol num %4d : more one fragment\n",i+1);
			fflush(logfile);
			toRemove[i]=1;
		}
	}
	for (i = 0; i < numberOfGeometries; i++ )
	{
		if(toRemove[i]==1 && qmModels[i]) 
		{
			qmModels[i]->klass->free(qmModels[i]);
			qmModels[i] = NULL;
		}
	}
	int nG0=0; 
	for (i = 0; i < numberOfGeometries; i++ ) if(!qmModels[i])  nG0++;

	int nG=numberOfGeometries;
	for (i = 0; i < nG; i++ ) 
	if(!qmModels[i]) 
	{
		for (j = i; j < nG-1; j++ ) 
		{
			qmModels[j]=qmModels[j+1];
			toRemove[j]=toRemove[j+1];
			if(energies) energies[j]=energies[j+1];
		}
		i--;
		nG--;
	}
	free(toRemove);
	fprintf(stderr,"Number of removed fragmented geometries %d ; ",numberOfGeometries-nG);
	fprintf(stderr,"new number of geometries %d\n",nG);
	fflush(stderr);
	fprintf(logfile,"Number of removed fragmented geometries %d ; ",numberOfGeometries-nG);
	fprintf(logfile,"new number of geometries %d\n",nG);
	fflush(logfile);
	*pnumberOfGeometries = nG;
}
/***********************************************************************************************************************/
static void removeSimilarInertiaGeometries(QuantumMechanicsModel** qmModels, int* pnumberOfGeometries, double* energies, FILE* logfile, double tol)
{
	int i,j;
	int numberOfGeometries = *pnumberOfGeometries;
	int* toRemove = NULL;
	Molecule* mol1;
	Molecule* mol2;

	if(numberOfGeometries<2) return;
	toRemove = malloc(numberOfGeometries*sizeof(int));
	for (i = 0; i < numberOfGeometries; i++ ) toRemove[i]=0;

	//if(qmModels && qmModels[0] && qmModels[0]->molecule.nAtoms<1) return;
	for (i = 0; i < numberOfGeometries; i++ )
	{
		if(!qmModels[i]) { toRemove[i]=1; continue;}
		if(toRemove[i]==1) continue;

		mol1 = &qmModels[i]->molecule;
		for (j = i+1; j < numberOfGeometries; j++ )
		{
			mol2 = &qmModels[j]->molecule;
			if(mol1->klass->similarInertia(mol1, mol2,tol)) 
			{
				double I21,I41;
				double I22,I42;
				mol1->klass->computePseudoInertia(mol1, &I21, &I41);
				mol2->klass->computePseudoInertia(mol2, &I22, &I42);
				fprintf(logfile,"Two (%4d, %4d) similar geometries : I2=%+0.4f %+0.4f %+0.4f \tI4=%+0.4f %+0.4f %+0.4f\n",
						i+1,j+1,I21,I22,I22-I21,I41,I42,I42-I41);
				fflush(logfile);
				toRemove[j]=1;
			}
		}
	}
	for (i = 0; i < numberOfGeometries; i++ )
	{
		if(toRemove[i]==1 && qmModels[i]) 
		{
			qmModels[i]->klass->free(qmModels[i]);
			qmModels[i] = NULL;
		}
	}
	int nG0=0; 
	for (i = 0; i < numberOfGeometries; i++ ) if(!qmModels[i])  nG0++;

	int nG=numberOfGeometries;
	for (i = 0; i < nG; i++ ) 
	if(!qmModels[i]) 
	{
		for (j = i; j < nG-1; j++ ) 
		{
			qmModels[j]=qmModels[j+1];
			toRemove[j]=toRemove[j+1];
			if(energies) energies[j]=energies[j+1];
		}
		i--;
		nG--;
	}
	free(toRemove);
	fprintf(stderr,"Number of removed geometries due to similar inertia %d ; ",numberOfGeometries-nG);
	fprintf(stderr,"new number of geometries %d\n",nG);
	fflush(stderr);
	fprintf(logfile,"Number of removed geometries due to similar inertia %d ; ",numberOfGeometries-nG);
	fprintf(logfile,"new number of geometries %d\n",nG);
	fflush(logfile);
	*pnumberOfGeometries = nG;
}

/**********************************************************************/
static void setRattleConstraintsParameters(QuantumMechanicsModel* quantumMechanicsModel)
{
	Molecule* m = &quantumMechanicsModel->molecule;
	m->klass->resetConstraints(m, m->constraints);
}
/**********************************************************************/
QuantumMechanicsModel newQuantumMechanicsModel(char* method, char* dirName, char* nameCommand, char* N2P2Dir, char* tmModule, Constraints constraints, FILE* logfile)
{
	QuantumMechanicsModel qmModel;

	qmModel.molecule = *(newMolecule());

	qmModel.molecule.constraints = constraints;

	qmModel.klass = malloc(sizeof(QuantumMechanicsModelClass));
	qmModel.klass->calculateHessian = NULL;
	qmModel.klass->calculateGradient = NULL;
	qmModel.klass->calculateEnergy = NULL;
	qmModel.klass->free = freeQuantumMechanicsModel;
	qmModel.klass->computeQMFrequenciesNumeric = computeQMFrequenciesNumeric;
	qmModel.klass->computeQMFrequenciesAnalytic = computeQMFrequenciesAnalytic;
	qmModel.klass->computeQMFrequencies = computeQMFrequencies;
	qmModel.klass-> computeIR = computeIR;
	qmModel.klass->copy = copyQuantumMechanicsModel;
	qmModel.klass->setRattleConstraintsParameters = setRattleConstraintsParameters;
	qmModel.klass->removeFragmentedMolecules = removeFragmentedMolecules;
	qmModel.klass->removeSmallDistanceMolecules = removeSmallDistanceMolecules;
	qmModel.klass->removeSimilarInertiaGeometries = removeSimilarInertiaGeometries;
	qmModel.klass-> removeSimilarBondsGeometries = removeSimilarBondsGeometries;
	qmModel.klass-> sortByInertia = sortByInertia;
	qmModel.klass-> cutByInertia = cutByInertia;
	qmModel.klass-> getQuantumMechanicsRDConfo = getQuantumMechanicsRDConfo;
	qmModel.klass-> getQuantumMechanicsRDFConfo = getQuantumMechanicsRDFConfo;

	qmModel.firstRun = TRUE;
	qmModel.addD3Correction = FALSE;
	qmModel.addWallCorrection = FALSE;
	qmModel.logfile = logfile;
	qmModel.H4Parameters = NULL;
	qmModel.SRBParameters = NULL;
	qmModel.dx=1e-3;

	qmModel.N2P2Dir=NULL;
	if(N2P2Dir) qmModel.N2P2Dir=strdup(N2P2Dir);
	qmModel.interfaceLibN2P2 = NULL;
	qmModel.interfaceLibN2P2ES = NULL;

#ifdef ENABLE_PYTHON
	qmModel.tmModule=NULL;
	if(tmModule) qmModel.tmModule=strdup(tmModule);
	qmModel.interfaceTM = NULL;
#endif

	qmModel.method = NULL;
	if(method) qmModel.method = strdup(method);
	if(dirName) qmModel.workDir = strdup(dirName);
	else qmModel.workDir = strdup_printf("%s%stmp",cchemiDirectory(),DIR_SEPARATOR_S);
	if(nameCommand) qmModel.nameCommand = strdup(nameCommand);
	else qmModel.nameCommand = strdup("/opt/mopac/MOPAC2012");
	return qmModel;

}
/**********************************************************************/
static void freeQuantumMechanicsModel(QuantumMechanicsModel* qmModel)
{

	qmModel->molecule.klass->free(&qmModel->molecule);

	if(qmModel->klass != NULL)
	{
		free(qmModel->klass);
		qmModel->klass = NULL;
	}
	if(qmModel->method != NULL)
	{
		free(qmModel->method);
		qmModel->method = NULL;
	}
	if(qmModel->workDir != NULL)
	{
		free(qmModel->workDir);
		qmModel->workDir = NULL;
	}
	if(qmModel->nameCommand != NULL)
	{
		free(qmModel->nameCommand);
		qmModel->nameCommand = NULL;
	}
	if(qmModel->N2P2Dir != NULL)
	{
		free(qmModel->N2P2Dir);
		qmModel->N2P2Dir = NULL;
	}
	/* NON
	if(qmModel->interfaceLibN2P2 != NULL)
	{
		interfaceCChemIDestroy(qmModel->interfaceLibN2P2);
		qmModel->interfaceLibN2P2 = NULL;
	}
	if(qmModel->interfaceLibN2P2ES != NULL)
	{
		interfaceCChemIESDestroy(qmModel->interfaceLibN2P2ES);
		qmModel->interfaceLibN2P2ES = NULL;
	}
        */
#ifdef ENABLE_PYTHON
	if(qmModel->tmModule != NULL)
	{
		free(qmModel->tmModule);
		qmModel->tmModule = NULL;
	}
	if(qmModel->interfaceTM != NULL)
	{
		interfaceTMDestroy(qmModel->interfaceTM);
		qmModel->interfaceTM = NULL;
	}
#endif
}
/*****************************************************************************/
static QuantumMechanicsModel copyQuantumMechanicsModel(QuantumMechanicsModel* f)
{
	QuantumMechanicsModel qmModel = newQuantumMechanicsModel(NULL,NULL,NULL,NULL, NULL, NOCONSTRAINTS, stdout);

	qmModel.molecule = *(f->molecule.klass->copy(&f->molecule));
	qmModel.method = NULL;
	if(f->method) qmModel.method = strdup(f->method);
	qmModel.workDir = NULL;
	if(f->workDir) qmModel.workDir = strdup(f->workDir);

	qmModel.N2P2Dir = NULL;
	if(f->N2P2Dir) qmModel.N2P2Dir = strdup(f->N2P2Dir);
	qmModel.interfaceLibN2P2 = NULL;
	qmModel.interfaceLibN2P2ES = NULL;
	if(f->interfaceLibN2P2) qmModel.interfaceLibN2P2 = f->interfaceLibN2P2;// to do  make a copy of interfaceLibN2P2
	if(f->interfaceLibN2P2ES) qmModel.interfaceLibN2P2ES = f->interfaceLibN2P2ES;// to do make a copy of interfaceLibN2P2ES

#ifdef ENABLE_PYTHON
	qmModel.tmModule = NULL;
	if(f->tmModule) qmModel.tmModule = strdup(f->tmModule);
	qmModel.interfaceTM = NULL;
	if(f->interfaceTM) qmModel.interfaceTM = f->interfaceTM;// make a copy of interfaceTM
#endif

	qmModel.nameCommand = NULL;
	if(f->nameCommand) qmModel.nameCommand = strdup(f->nameCommand);

	qmModel.klass->calculateHessian = f->klass->calculateHessian;
	qmModel.klass->calculateGradient = f->klass->calculateGradient;
	qmModel.klass->calculateEnergy = f->klass->calculateEnergy;
	qmModel.logfile = f->logfile;
	qmModel.firstRun = f->firstRun;
	qmModel.addD3Correction = f->addD3Correction;
	qmModel.addWallCorrection = f->addWallCorrection;
	qmModel.H4Parameters = NULL;
	qmModel.SRBParameters = NULL;
	if(f->SRBParameters) *(qmModel.SRBParameters) = *(f->SRBParameters);

	return qmModel;
}
/*****************************************************************************/
static void copyGradients(Molecule* mol, double* g[])
{
	int i,k;
	if(!mol) return;
	for(i=0;i<mol->nAtoms;i++)
		for(k=0;k<3;k++)
			g[k][i] = mol->atoms[i].gradient[k];
}
/*****************************************************************************/
static void sortFrequencies(int nModes, double* frequencies, double** modes, double* reducedMasses, double* IRIntensities)
{
	int i;
	int j;
	int k;
	double dum;
	if(nModes<1 || !frequencies || !modes || !reducedMasses || !IRIntensities) return;
	for(i=0;i<nModes;i++)
	{
		k = i;
		for(j=i+1;j<nModes;j++)
			if(frequencies[j]<frequencies[k]) k = j;
		if(k==i) continue;
		/* swap i and k modes */
		dum = frequencies[i];
		frequencies[i] = frequencies[k];
		frequencies[k] = dum;
		dum = reducedMasses[i];
		reducedMasses[i] = reducedMasses[k];
		reducedMasses[k] = dum;
		dum = IRIntensities[i];
		IRIntensities[i] = IRIntensities[k];
		IRIntensities[k] = dum;
		for(j=0;j<nModes;j++)
		{
			dum =  modes[j][i];
			modes[j][i] = modes[j][k];
			modes[j][k] = dum;
		}
	}
}
/****************************************************************************************************************************************************/
static int computeIR(QuantumMechanicsModel* qmModel, double *F, double** dmu, double** frequencies, double*** modes, double** reducedMasses, double** IRIntensities)
{
	Molecule* mol = &qmModel->molecule;
	int nAtoms = mol->nAtoms;
	int i;
	int j;
	int k;
	int c;
	*frequencies = malloc(3*nAtoms*sizeof(double));
	*reducedMasses = malloc(3*nAtoms*sizeof(double));
	*IRIntensities = malloc(3*nAtoms*sizeof(double));
	*modes = malloc(3*nAtoms*sizeof(double*));
	for(i=0;i<3*nAtoms;i++) (*modes)[i] = malloc(3*nAtoms*sizeof(double));

	//printf("begin diag\n");
	eigenQL(3*nAtoms, F, *frequencies, *modes);

	//printf("end eigneQL\n");
	for(i=0;i<3*nAtoms;i++) (*IRIntensities)[i] = 0.0;
	
	/* convert in atomic unit  from kcal/Ang^2/amu */
	for(i=0;i<3*nAtoms;i++) (*frequencies)[i] *= 1.59360150e-03*0.529177*0.529177*5.48579911e-04; 
	/* convert frequencies in cm-1 */
	for(i=0;i<3*nAtoms;i++) 
		if( (*frequencies)[i]>0) (*frequencies)[i] = sqrt((*frequencies)[i])*219474.63633664;
		else (*frequencies)[i] = -sqrt(-(*frequencies)[i])*219474.63633664;

	/* compute the IR intensities */
	for(i=0;i<nAtoms;i++)
	for(k=0;k<3;k++)
	{
		int id=3*i+k;
		double IRI = 0;
		double D[3] = {0,0,0};
		int kp;
		for(c = 0;c<3;c++)
		for(j=0;j<nAtoms;j++)
		for(kp = 0;kp<3;kp++) 
		{
			int jd = 3*j+kp;
			double Lji = (*modes)[jd][id];
			double a=dmu[c][jd]*Lji/sqrt(mol->atoms[j].mass);
			D[c]+=a;
		}
		IRI = 0;
		for(c = 0;c<3;c++)  IRI+= D[c]*D[c];
		(*IRIntensities)[id] = IRI;
	}
	/* Intensities in 1 (D/Ang)^2 amu^-1 = 42.255 km/mol=171.65 cm^-2 atm^-1 at 0 C and 1 atm */
	/* Refs : D. Porezag and M. R. Pederson, Phys. Rev. B 54, 7830 (1996). and Y. Yamaguchi el al., J. Chem. Phys. 84,2262(1986)*/
	/* conversion in km/mol*/
	for(i=0;i<3*nAtoms;i++) (*IRIntensities)[i] *= 42.255;

	/* compute the reduced mass */
	for(i=0;i<3*nAtoms;i++) 
	{
		double m = 0;
		for(j=0;j<mol->nAtoms;j++)
		{
			double r2 = 0;
			for(c=0;c<3;c++) r2+= (*modes)[3*j+c][i]*(*modes)[3*j+c][i];
			m+= r2/(mol->atoms[j].mass); 
		}
		if(m<=0) m = 1;
		m = 1/m;
		for(j=0;j<mol->nAtoms;j++)
		{
			double r =sqrt(m)/sqrt(mol->atoms[j].mass);
			for(c=0;c<3;c++) (*modes)[3*j+c][i]*=r;
		}

		//printf("%f %f\n",(*frequencies)[i],m);
		(*reducedMasses)[i] = m;
	}
	sortFrequencies(3*nAtoms, *frequencies, *modes, *reducedMasses, *IRIntensities);
	return 3*nAtoms;
}
/*****************************************************************************/
static int computeQMFrequenciesNumeric(QuantumMechanicsModel* qmModel, double** frequencies, double*** modes, double** reducedMasses, double** IRIntensities)
{
	int i;
	int j;
	int k;
	int c;
	int id,jd,index;
	double* F;
	double* gp[3];
	double* gm[3];
	double** dmu;
	Molecule* mol;
	double Dp[3];
	double Dm[3];
	int nAtoms;
	boolean show = FALSE;
	double dx;
	int ret;

	if(!qmModel || qmModel->molecule.nAtoms<1) return 0;
	dx = qmModel->dx;

	mol = &qmModel->molecule;
	nAtoms = mol->nAtoms;
	if(nAtoms>4) show = TRUE;
	printf("nAtoms = %d\n",nAtoms);
	for(k=0;k<3;k++) gp[k] = malloc(nAtoms*sizeof(double));
	for(k=0;k<3;k++) gm[k] = malloc(nAtoms*sizeof(double));
	dmu = malloc(3*sizeof(double*));
	for(k=0;k<3;k++) dmu[k] = malloc(3*nAtoms*sizeof(double));

	F = malloc(3*nAtoms*(3*nAtoms+1)/2*sizeof(double));

	index = 0;
	for(i=0;i<nAtoms;i++)
	for(k=0;k<3;k++)
	{
		id=3*i+k;
		if(show && k ==0) { printf("Computing of derivatives for atom # %d/%d\n",i+1,nAtoms);};
		mol->atoms[i].coordinates[k] += dx;
		qmModel->klass->calculateGradient(qmModel);
		copyGradients(mol, gp);
		for(c = 0;c<3;c++)  Dp[c] = mol->dipole[c];
		
		mol->atoms[i].coordinates[k] -= 2*dx;
		qmModel->klass->calculateGradient(qmModel);
		copyGradients(mol, gm);
		for(c = 0;c<3;c++)  Dm[c] = mol->dipole[c];
		for(c = 0;c<3;c++) dmu[c][id] = (Dp[c]-Dm[c])/dx/2;
		mol->atoms[i].coordinates[k] += dx;

		for(j=0;j<=i;j++)
		{
			double invm = 1.0/sqrt( mol->atoms[i].mass* mol->atoms[j].mass);
			for(c = 0;c<3;c++) 
			{
				jd = 3*j+c;
				//printf("id = %d jd = %d\n",id,jd);
				if(jd>id) continue;
				index = jd + id*(id+1)/2;
				//printf("index = %d i = %d k = %d j = %d c = %d\n",index,i,k,j,c);
				F[index] = (gp[c][j]-gm[c][j])/dx/2; 
				F[index] *= invm;
			}
		}
	}
	//printf("F\n");
	/*
	for(id=0;id<3*nAtoms;id++)
	{
		for(jd=0;jd<=id;jd++) 
		{
			index = jd + id*(id+1)/2;
			printf("%14.8f",F[index]);
		}
		printf("\n");
	}
	*/

	for(k=0;k<3;k++) free(gp[k]);
	for(k=0;k<3;k++) free(gm[k]);
	ret = computeIR(qmModel, F, dmu, frequencies, modes, reducedMasses, IRIntensities);
	free(F);
	for(k=0;k<3;k++) free(dmu[k]);
	if(dmu) free(dmu);
	return ret;

}
/*****************************************************************************/
static int computeQMFrequenciesAnalytic(QuantumMechanicsModel* qmModel, double** frequencies, double*** modes, double** reducedMasses, double** IRIntensities)
{
	double* F;
	double** dmu;
	int ret;
	int k;

	if(!qmModel || qmModel->molecule.nAtoms<1) return 0;
	if(!qmModel->interfaceLibN2P2 || !qmModel->interfaceLibN2P2ES) return 0;
	qmModel->klass->calculateHessian(qmModel,&F, &dmu);
	ret = computeIR(qmModel, F, dmu, frequencies, modes, reducedMasses, IRIntensities);
	free(F);
	for(k=0;k<3;k++) free(dmu[k]);
	if(dmu) free(dmu);
	return ret;

}
static int computeQMFrequencies(QuantumMechanicsModel* qmModel, double** frequencies, double*** modes, double** reducedMasses, double** IRIntensities)
{
	int ret = 0;
	if(qmModel->SRBParameters || qmModel->addD3Correction || qmModel->addWallCorrection || qmModel->H4Parameters || !qmModel->interfaceLibN2P2 || !qmModel->interfaceLibN2P2ES)
		ret = computeQMFrequenciesNumeric(qmModel, frequencies, modes, reducedMasses, IRIntensities);
	else 
		ret = computeQMFrequenciesAnalytic(qmModel, frequencies, modes, reducedMasses, IRIntensities);

	return ret;

}
File: ./cchemilib/src/QuantumMechanics/QuantumMechanics.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* QuantumMechanics.c */

#ifndef OS_WIN32
#include <unistd.h>
#endif

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#ifdef ENABLE_MPI
#include <mpi.h>
#endif

#include "../Utils/Utils.h"
#include "../Utils/AtomsProp.h"
#include "../Utils/Constants.h"
#include "../Utils/Types.h"
#include "../Molecule/Molecule.h"
#include "../QuantumMechanics/QuantumMechanicsModel.h"
#include "../QuantumMechanics/QuantumMechanics.h"
#include "../EmpriricalCorrections/HydrogenBondCorrection.h"
#include "../EmpriricalCorrections/ShortRangeBasisSetCorrection.h"
#include "../EmpriricalCorrections/DispersionCorrection.h"
#include "../EmpriricalCorrections/WallCorrection.h"

static void calculateGradientMopac(QuantumMechanicsModel* qmModel);
static void calculateEnergyMopac(QuantumMechanicsModel* qmModel);
static void calculateGradientFireFly(QuantumMechanicsModel* qmModel);
static void calculateEnergyFireFly(QuantumMechanicsModel* qmModel);
static void calculateGradientOrca(QuantumMechanicsModel* qmModel);
static void calculateEnergyOrca(QuantumMechanicsModel* qmModel);
static void calculateGradientGaussian(QuantumMechanicsModel* qmModel);
static void calculateEnergyGaussian(QuantumMechanicsModel* qmModel);
static void calculateGradientGeneric(QuantumMechanicsModel* qmModel);
static void calculateEnergyGeneric(QuantumMechanicsModel* qmModel);
static void calculateGradientOpenBabel(QuantumMechanicsModel* qmModel);
static void calculateEnergyOpenBabel(QuantumMechanicsModel* qmModel);
static void calculateHessianN2P2(QuantumMechanicsModel* qmModel, double **F, double*** dmu);
static void calculateGradientN2P2(QuantumMechanicsModel* qmModel);
static void calculateEnergyN2P2(QuantumMechanicsModel* qmModel);

#ifdef ENABLE_PYTHON
static void calculateGradientTM(QuantumMechanicsModel* qmModel);
static void calculateEnergyTM(QuantumMechanicsModel* qmModel);
#endif

static boolean getDipoleGaussian(char* fileNameOut, double* dipole);

/*****************************************************************************/
void setSRBCorrection(FILE* file,QuantumMechanicsModel* qmModel) 
{
	char* fileName = NULL;

	if(readOneString(file,"SRBCorrection",&fileName) && fileName) 
	{
		char tmp[BSIZE];
		sprintf(tmp,"%s",fileName);
		uppercase(tmp);
		if(!strstr(tmp,"NONE"))
		{
			ShortRangeBasisSetCorrectionParameters parameters;
			if(!strstr(tmp,"DEFAULT")) setShortRangeBasisSetCorrectionParameters(&parameters, fileName, NULL);
			else setShortRangeBasisSetCorrectionParameters(&parameters, NULL, qmModel->method);
			qmModel->SRBParameters = malloc(sizeof(ShortRangeBasisSetCorrectionParameters));
			*(qmModel->SRBParameters) = parameters;
			return;
		}
	}
	qmModel->SRBParameters= NULL;
}
/**********************************************************************/
static void addSRBCorrection(QuantumMechanicsModel* qmModel,boolean addGradient)
{
	if(qmModel->SRBParameters)
		qmModel->molecule.potentialEnergy += getSRBCorrection(&qmModel->molecule, qmModel->SRBParameters, addGradient);
	//if(!qmModel->SRBParameters) { fprintf(stdout,"DEBUG SRB=NULL\n"); exit(1);}
}
/*****************************************************************************/
void setH4Correction(FILE* file,QuantumMechanicsModel* qmModel) 
{
	char* fileName = NULL;

	if(readOneString(file,"H4Correction",&fileName) && fileName) 
	{
		char tmp[BSIZE];
		sprintf(tmp,"%s",fileName);
		uppercase(tmp);
		if(!strstr(tmp,"NONE"))
		{
			HyhrogenBondCorrectionParameters parameters;
			if(!strstr(tmp,"DEFAULT")) setHydrogenBondCorrectionParameters(&parameters, fileName, NULL);
			else setHydrogenBondCorrectionParameters(&parameters, NULL, qmModel->method);
			qmModel->H4Parameters = malloc(sizeof(HyhrogenBondCorrectionParameters));
			*(qmModel->H4Parameters) = parameters;
			return;
		}
	}
	qmModel->H4Parameters= NULL;
}
/**********************************************************************/
static void addH4Correction(QuantumMechanicsModel* qmModel,boolean addGradient)
{
	if(qmModel->H4Parameters)
		qmModel->molecule.potentialEnergy += getH4Correction(&qmModel->molecule, qmModel->H4Parameters, addGradient);
}
/**********************************************************************/
static void addD3Correction(QuantumMechanicsModel* qmModel,boolean addGradient)
{
	if(qmModel->addD3Correction)
		qmModel->molecule.potentialEnergy += getD3Correction(&qmModel->molecule, qmModel->method, addGradient);
}
/**********************************************************************/
static void addWallCorrection(QuantumMechanicsModel* qmModel,boolean addGradient)
{
	if(qmModel->addWallCorrection)
	qmModel->molecule.potentialEnergy += getWallCorrection(&qmModel->molecule, addGradient);
}
/****************************************************************/
static void getMultiplicityName(int multiplicity, char* buffer)
{
//printf("mult = %d\n",multiplicity);
	if(multiplicity==1) sprintf(buffer,"Singlet");
	else if(multiplicity==2) sprintf(buffer,"Doublet");
	else if(multiplicity==3) sprintf(buffer,"Triplet");
	else if(multiplicity==4) sprintf(buffer,"Quartet");
	else if(multiplicity==5) sprintf(buffer,"Quintet");
	else if(multiplicity==6) sprintf(buffer,"Sextet");
	else sprintf(buffer,"UNKNOWN");
}
/*****************************************************************************/
static boolean getEnergyMopac(char* fileNameOut, double* energy)
{
	FILE* file = NULL;
	char buffer[1024];
	char* pdest = NULL;

 	file = fopen(fileNameOut, "r");
	if(!file) return FALSE;
	 while(!feof(file))
	 {
		if(!fgets(buffer,BSIZE,file))break;
		pdest = strstr( buffer, " FINAL HEAT OF FORMATION");
		if(pdest) 
		{
			pdest = strstr( buffer, "=");
			if(pdest)
			{
				int l = strlen(pdest);
				int i;
				for(i=0;i<l;i++) if(pdest[i]=='D' || pdest[i]=='E') pdest[i] ='E';
				if(sscanf(pdest+1,"%lf",energy)==1)
				{
					fclose(file);
					return TRUE;
				}
			}
		}
	 }
	fclose(file);
	return FALSE;
}
/*****************************************************************************/
static boolean getDipoleMopac(char* fileNameOut, double* dipole)
{
	FILE* file = NULL;
	char buffer[1024];
	char* pdest = NULL;

 	file = fopen(fileNameOut, "r");
	if(!file) return FALSE;
	 while(!feof(file))
	 {
		if(!fgets(buffer,BSIZE,file))break;
		if(
		strstr( buffer, "DIPOLE")&&
		strstr( buffer, "X")&&
		strstr( buffer, "Y")&&
		strstr( buffer, "TOTAL"))
		{
			if(!fgets(buffer,BSIZE,file))break;
			if(!fgets(buffer,BSIZE,file))break;
			if(!fgets(buffer,BSIZE,file))break;
			if(strstr( buffer, "SUM"))
			{
				int l,i;
				pdest =strstr(buffer, "SUM")+strlen("SUM")+1;
				l = strlen(pdest);
				for(i=0;i<l;i++) if(pdest[i]=='D' || pdest[i]=='E') pdest[i] ='E';
				if(sscanf(pdest+1,"%lf %lf %lf",&dipole[0],&dipole[1],&dipole[2])==3)
				{
					fclose(file);
					return TRUE;
				}
			}
		}
	 }
	fclose(file);
	return FALSE;
}
/*****************************************************************************/
/*
static int getNumberOfTv(QuantumMechanicsModel *qmModel)
{
	int i;
	char tmp[100];
	int k = 0;
	for(i=0;i<qmModel->molecule.nAtoms;i++)
	{
		sprintf(tmp,"%s",qmModel->molecule.atoms[i].prop.symbol);
		uppercase(tmp);
		if(!strcmp(tmp,"TV")) k++;
	}
	return k;
}
*/
/*****************************************************************************/
static boolean getGradientMopac(char* fileNameOut, QuantumMechanicsModel *qmModel)
{
	FILE* file = NULL;
	char buffer[1024];
	char* pdest = NULL;
	boolean Ok = FALSE;
	double tmp;
	int i;
	int j;
	int k;
	int dum;
	/* int nTv= 0;*/

 	file = fopen(fileNameOut, "r");
	if(!file) return FALSE;
	/*
	nTv=getNumberOfTv(qmModel);
	printf("nTv=%d\n",nTv);
	*/
	for(i=0;i<qmModel->molecule.nAtoms;i++)
		for(j=0;j<3;j++) 
			qmModel->molecule.atoms[i].gradient[j] =0;

	 while(!feof(file))
	 {
		if(!fgets(buffer,BSIZE,file))break;
		pdest = strstr( buffer, "PARAMETER     ATOM    TYPE            VALUE       GRADIENT");
		if(pdest) 
		{
			for(k=0;k<3*qmModel->molecule.nAtoms;k++)
			{
				if(!fgets(buffer,BSIZE,file))break;
				pdest = strstr( buffer, "CARTESIAN");
				if(!pdest) break;
				j = 0;
				if(strstr( buffer, "CARTESIAN X"))j=0;
				if(strstr( buffer, "CARTESIAN Y"))j=1;
				if(strstr( buffer, "CARTESIAN Z"))j=2;
				if(2==sscanf(buffer,"%d %d",&dum,&i))
				{
					i--;
					if(i<0 || i> qmModel->molecule.nAtoms-1) 
					{
						fclose(file);
						return FALSE;
					}
					pdest = strstr( buffer, "CARTESIAN");
					if(sscanf(pdest+12,"%lf %lf",&tmp,&qmModel->molecule.atoms[i].gradient[j])!=2)
					{
						fclose(file);
						return FALSE;
					}
				}
				
			}
			Ok = TRUE;
			break;
	 	}
		pdest = strstr( buffer, "Cartesian Gradients"); /* MOZYME Keyword */
		if(pdest) 
		{
			char td[100];
			int d;
			if(!fgets(buffer,BSIZE,file))break; /*Atom       X  ....*/
			if(!fgets(buffer,BSIZE,file))break; /* backspace */
			for(k=0;k<qmModel->molecule.nAtoms;k++)
			{
				if(!fgets(buffer,BSIZE,file)) /* 1  O    0.000   -4.566    0.027  */
				{
					fclose(file);
					return FALSE;
				}
				if(1!=sscanf(buffer,"%d",&i)) break;
				i--;
				if(i<0 || i>=qmModel->molecule.nAtoms)
				{
					fclose(file);
					return FALSE;
				}
				if(sscanf(buffer,"%d %s %lf %lf %lf",&d, td, 
						&qmModel->molecule.atoms[i].gradient[0],
						&qmModel->molecule.atoms[i].gradient[1],
						&qmModel->molecule.atoms[i].gradient[2]
					 )
						!=5)
					{
						fclose(file);
						return FALSE;
					}
			}
			Ok = TRUE;
			break;
	 	}
	 }
	fclose(file);
	return Ok;
}
/*****************************************************************************/
static char* runOneMopac(QuantumMechanicsModel* qmModel, char* keyWords)
{
	FILE* file = NULL;
	FILE* fileSH = NULL;
	int j;
	char* fileNameIn = NULL;
	char* fileNameOut = NULL;
	char* fileNameSH = NULL;
	char multiplicityStr[100];
	char buffer[1024];
	Molecule m = qmModel->molecule;
	int rank = 0;
#ifdef ENABLE_MPI
	MPI_Comm_rank( MPI_COMM_WORLD,&rank);
#endif

#ifdef OS_WIN32
	char c='%';
#endif

	if(m.nAtoms<1) return fileNameOut;
#ifndef OS_WIN32
	fileNameSH = strdup_printf("%s%sMopacOne%d.sh",qmModel->workDir,DIR_SEPARATOR_S,rank);
#else
	fileNameSH = strdup_printf("%s%sMopacOne%d.bat",qmModel->workDir,DIR_SEPARATOR_S,rank);
#endif
 	fileSH = fopen(fileNameSH, "w");
	if(!fileSH) return FALSE;

	getMultiplicityName(qmModel->molecule.spinMultiplicity, multiplicityStr);

	fileNameIn = strdup_printf("%s%sOne%d.mop",qmModel->workDir,DIR_SEPARATOR_S,rank);
 	file = fopen(fileNameIn, "w");
	if(!file) 
	{
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		return FALSE;
	}
	if(qmModel->molecule.spinMultiplicity>1)
		fprintf(file,"%s UHF CHARGE=%d %s\n",keyWords,qmModel->molecule.totalCharge,multiplicityStr);
	else
		fprintf(file,"%s CHARGE=%d %s\n",keyWords,qmModel->molecule.totalCharge,multiplicityStr);
	fprintf(file,"\n");
	fprintf(file,"Mopac file generated by Gabedit\n");

	for(j=0;j<m.nAtoms;j++)
	{
	fprintf(file," %s %f %d %f %d %f %d\n", 
			m.atoms[j].prop.symbol,
			m.atoms[j].coordinates[0],
			1,
			m.atoms[j].coordinates[1],
			1,
			m.atoms[j].coordinates[2],
			1
			);
	}
	fclose(file);
#ifndef OS_WIN32
	fprintf(fileSH,"%s %s\n",qmModel->nameCommand,fileNameIn);
	fclose(fileSH);
	sprintf(buffer,"chmod u+x %s",fileNameSH);
	system(buffer);
	system(fileNameSH);
#else
	fprintf(fileSH,"\"%s\" \"%s\"\n",qmModel->nameCommand,fileNameIn);
	fclose(fileSH);
	sprintf(buffer,"\"%s\"",fileNameSH);
	system(buffer);
#endif

	unlink(fileNameIn);
	unlink(fileNameSH);
 	if(fileNameIn) free(fileNameIn);
 	if(fileNameSH) free(fileNameSH);
	fileNameOut = strdup_printf("%s%sOne%d.out",qmModel->workDir,DIR_SEPARATOR_S,rank);
	return fileNameOut;
}
/**********************************************************************/
static QuantumMechanicsModel newMopacModel(char* method, char* dirName, char* nameCommand, Constraints constraints, FILE* logfile)
{
	QuantumMechanicsModel qmModel = newQuantumMechanicsModel(method, dirName, nameCommand, NULL, NULL, constraints, logfile);

	qmModel.klass->calculateGradient = calculateGradientMopac;
	qmModel.klass->calculateEnergy = calculateEnergyMopac;

	return qmModel;
}
/**********************************************************************/
static void calculateGradientMopac(QuantumMechanicsModel* qmModel)
{
	int i;
	int j;
	Molecule m = qmModel->molecule;
	char* keyWords = NULL;
	char* fileOut = NULL;
	if(!qmModel) return;
	if(qmModel->molecule.nAtoms<1) return;
	if(!qmModel->method) return;
	keyWords = strdup_printf("%s 1SCF GRAD",qmModel->method);
	fileOut = runOneMopac(qmModel, keyWords);

	if(fileOut)
	{
		for(j=0;j<3;j++)
			for( i=0; i<m.nAtoms;i++)
				m.atoms[i].gradient[j] = 0.0;
		if(!getGradientMopac(fileOut, qmModel))
		{
			printf(("Problem : I cannot compute the Gradient by OpenMopac... "));
			exit(1);
			return;
		}
		getEnergyMopac(fileOut, &qmModel->molecule.potentialEnergy);
		addH4Correction(qmModel,TRUE);
		addSRBCorrection(qmModel,TRUE);
		addD3Correction(qmModel,TRUE);
		addWallCorrection(qmModel,TRUE);
		getDipoleMopac(fileOut, qmModel->molecule.dipole);
		/* printf("Energy = %f\n",qmModel->molecule.potentialEnergy);*/
		free(fileOut);
	}

}
/**********************************************************************/
static void calculateEnergyMopac(QuantumMechanicsModel* qmModel)
{
	char* keyWords = NULL;
	char* fileOut = NULL;
	if(!qmModel) return;
	if(qmModel->molecule.nAtoms<1) return;
	if(!qmModel->method) return;
	keyWords = strdup_printf("%s 1SCF",qmModel->method);
	fileOut = runOneMopac(qmModel, keyWords);
	if(fileOut)
	{
		getEnergyMopac(fileOut, &qmModel->molecule.potentialEnergy);
		addH4Correction(qmModel,FALSE);
		addSRBCorrection(qmModel,FALSE);
		addD3Correction(qmModel,FALSE);
		addWallCorrection(qmModel,FALSE);
		getDipoleMopac(fileOut, qmModel->molecule.dipole);
		free(fileOut);
	}

}
/**********************************************************************/
QuantumMechanicsModel createMopacModel (Molecule* mol, char* method, char* dirName, char* nameCommand, Constraints constraints, FILE* logfile)
{
	QuantumMechanicsModel qmModel = newMopacModel(method, dirName, nameCommand, constraints, logfile);

	qmModel.molecule = *(mol->klass->copy(mol));
	qmModel.molecule.constraints = constraints;
	qmModel.klass->setRattleConstraintsParameters(&qmModel);
	
	return qmModel;
}
/*****************************************************************************/
static boolean getDipoleFireFly(char* fileNameOut, double* dipole)
{
	FILE* file = NULL;
	char buffer[1024];

 	file = fopen(fileNameOut, "r");
	if(!file) return FALSE;

	 while(!feof(file))
	 {
		if(!fgets(buffer,BSIZE,file))break;
		if(
		strstr( buffer, "DX")&&
		strstr( buffer, "DY")&&
		strstr( buffer, "DZ") &&
		strstr( buffer, "(DEBYE)")
		)
		{
			int l,i;
			if(!fgets(buffer,BSIZE,file))break;
			l = strlen(buffer);
			for(i=0;i<l;i++) if(buffer[i]=='D' || buffer[i]=='E') buffer[i] ='E';
			l = sscanf(buffer,"%lf %lf %lf",&dipole[0], &dipole[1], &dipole[2]);
			if(l!=3) for(i=0;i<3;i++) dipole[i] = 0.0;
		}
	 }
	fclose(file);
	return FALSE;
}
/**********************************************************************/
static boolean getEnergyFireFly(char* fileNameOut, double* energy)
{
	FILE* file = NULL;
	char buffer[1024];
	char* pdest = NULL;
	boolean OK = FALSE;

 	file = fopen(fileNameOut, "r");
	if(!file) return FALSE;
	 while(!feof(file))
	 {
		if(!fgets(buffer,BSIZE,file))break;
		pdest = strstr( buffer, "HEAT OF FORMATION IS");
		if(!pdest) pdest = strstr( buffer, "FINAL ENERGY IS");
		if(pdest) 
		{
			pdest = strstr( buffer, "S");
			if(pdest)
			{
				int l = strlen(pdest);
				int i;
				for(i=0;i<l;i++) if(pdest[i]=='D' || pdest[i]=='E') pdest[i] ='E';
				if(sscanf(pdest+1,"%lf",energy)==1)
				{
					OK = TRUE;
					if(strstr( buffer, "FINAL ENERGY IS")) *energy *= AUTOKCAL;
					/* break;*/
				}
			}
		}
	 }
	fclose(file);
	return OK;
}
/*****************************************************************************/
static boolean getGradientFireFly(char* fileNameOut, QuantumMechanicsModel *qmModel)
{
	FILE* file = NULL;
	char buffer[1024];
	char stmp[1024];
	char* pdest = NULL;
	boolean Ok = FALSE;
	int itmp;
	int i;
	int j;

 	file = fopen(fileNameOut, "r");
	if(!file) return FALSE;
	 while(!feof(file))
	 {
		if(!fgets(buffer,BSIZE,file))break;
		pdest = strstr( buffer, "ATOM                 E'X               E'Y               E'Z");
		if(pdest) 
		{
			for(i=0;i<qmModel->molecule.nAtoms;i++)
			{
				if(!fgets(buffer,BSIZE,file))break;
				if(sscanf(buffer,"%d %s %lf %lf %lf",&itmp, stmp,
							&qmModel->molecule.atoms[i].gradient[0],
							&qmModel->molecule.atoms[i].gradient[1],
							&qmModel->molecule.atoms[i].gradient[2]
							)!=5)
				{
					fclose(file);
					return FALSE;
				}
				for(j=0;j<3;j++) qmModel->molecule.atoms[i].gradient[j] *= AUTOKCAL/BOHRTOANG;
			}
			Ok = TRUE;
			break;
	 	}
	 }
	fclose(file);
	return Ok;
}
/*****************************************************************************/
static char* runOneFireFly(QuantumMechanicsModel* qmModel, char* keyWords)
{
	FILE* file = NULL;
	FILE* fileSH = NULL;
	int j;
	char* fileNameIn = NULL;
	char* fileNameOut = NULL;
	char* fileNameSH = NULL;
	char multiplicityStr[100];
	char buffer[1024];
	Molecule m = qmModel->molecule;
	char* fileNamePrefix = NULL;
	int rank = 0;
#ifdef ENABLE_MPI
	MPI_Comm_rank( MPI_COMM_WORLD,&rank);
#endif
#ifdef OS_WIN32
	char c='%';
#endif

	if(m.nAtoms<1) return fileNameOut;
#ifndef OS_WIN32
	fileNameSH = strdup_printf("%s%sFireFlyOne%d.sh",qmModel->workDir,DIR_SEPARATOR_S,rank);
#else
	fileNameSH = strdup_printf("%s%sFireFlyOne%d.bat",qmModel->workDir,DIR_SEPARATOR_S,rank);
#endif
 	fileSH = fopen(fileNameSH, "w");
	if(!fileSH) return FALSE;
#ifdef OS_WIN32
	fprintf(fileSH,"@echo off\n");
	fprintf(fileSH,"set PATH=%cPATH%c;\"%s\"\n",c,c,fireflyDirectory);
#endif

	getMultiplicityName(qmModel->molecule.spinMultiplicity, multiplicityStr);

	fileNameIn = strdup_printf("%s%sOne%d.inp",qmModel->workDir,DIR_SEPARATOR_S,rank);
	fileNameOut = strdup_printf("%s%sOne%d.out",qmModel->workDir,DIR_SEPARATOR_S,rank);


 	file = fopen(fileNameIn, "w");
	if(!file) 
	{
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		return FALSE;
	}
	fprintf(file,"! ======================================================\n");
	fprintf(file,"!  Input file for FireFly\n"); 
	fprintf(file,"! ======================================================\n");
	if(strstr(keyWords,"RUNTYP"))
	{
		sscanf(strstr(keyWords,"RUNTYP"),"%s",buffer);
		fprintf(file," $CONTRL %s $END\n",buffer);
	}
	if(strstr(keyWords,"SCFTYP"))
	{
		sscanf(strstr(keyWords,"SCFTYP"),"%s",buffer);
		fprintf(file," $CONTRL %s $END\n",buffer);
	}
	else
	{
		if(qmModel->molecule.spinMultiplicity==1)
			fprintf(file," $CONTRL SCFTYP=RHF $END\n");
		else
			fprintf(file," $CONTRL SCFTYP=UHF $END\n");
	}

	fprintf(file," $CONTRL ICHARG=%d MULT=%d $END\n",qmModel->molecule.totalCharge,qmModel->molecule.spinMultiplicity);
	if(strstr(keyWords,"GBASIS"))
	{
		sscanf(strstr(keyWords,"GBASIS"),"%s",buffer);
		fprintf(file," $BASIS %s $END\n",buffer);
	}
	fprintf(file," $DATA\n");
	fprintf(file,"Molecule specification\n");
	fprintf(file,"C1\n");
	for(j=0;j<m.nAtoms;j++)
	{
		char* symbol = m.atoms[j].prop.symbol;
		SAtomsProp prop = propAtomGet(symbol);
		fprintf(file,"%s %f %f %f %f\n", 
			symbol,
			(double)prop.atomicNumber,
			m.atoms[j].coordinates[0],
			m.atoms[j].coordinates[1],
			m.atoms[j].coordinates[2]
			);
	}
	fprintf(file," $END\n");
	fclose(file);
	fileNamePrefix = strdup_printf("%s%sWorkFF",qmModel->workDir,DIR_SEPARATOR_S);
#ifndef OS_WIN32
	if(!strcmp(qmModel->nameCommand,"pcgamess") || !strcmp(qmModel->nameCommand,"nohup pcgamess")
	|| !strcmp(qmModel->nameCommand,"firefly") || !strcmp(qmModel->nameCommand,"nohup firefly"))
	{
		fprintf(fileSH,"mkdir %stmp\n",fileNamePrefix);
		fprintf(fileSH,"cd %stmp\n",fileNamePrefix);
		fprintf(fileSH,"cp %s input\n",fileNameIn);
		fprintf(fileSH,"%s -p -o %s\n",qmModel->nameCommand,fileNameOut);
		fprintf(fileSH,"cd ..\n");
		fprintf(fileSH,"rm PUNCH\n");
		fprintf(fileSH,"/bin/rm -r  %stmp\n",fileNamePrefix);
	}
	else
		fprintf(fileSH,"%s %s",qmModel->nameCommand,fileNameIn);
#else
	 if(!strcmp(qmModel->nameCommand,"pcgamess") ||
	 !strcmp(qmModel->nameCommand,"firefly") )
	{
        	fprintf(fileSH,"mkdir \"%stmp\"\n",fileNamePrefix);
		addUnitDisk(fileSH, fileNamePrefix);
	 	fprintf(fileSH,"cd \"%stmp\"\n",fileNamePrefix);
         	fprintf(fileSH,"copy \"%s\" input\n",fileNameIn);
         	fprintf(fileSH,"%s -p -o \"%s\"\n",qmModel->nameCommand,fileNameOut);
	 	fprintf(fileSH,"cd ..\n");
         	fprintf(fileSH,"del PUNCH 2>nul\n");
         	fprintf(fileSH,"del /Q  \"%stmp\"\n",fileNamePrefix);
         	fprintf(fileSH,"rmdir  \"%stmp\"\n",fileNamePrefix);
	}
	else
		fprintf(fileSH,"%s %s",qmModel->nameCommand,fileNameIn);
#endif
	fclose(fileSH);
#ifndef OS_WIN32
	sprintf(buffer,"chmod u+x %s",fileNameSH);
	system(buffer);
	system(fileNameSH);
#else
	sprintf(buffer,"\"%s\"",fileNameSH);
	system(buffer);
#endif
	unlink(fileNameIn);
	unlink(fileNameSH);
 	if(fileNamePrefix) free(fileNamePrefix);
 	if(fileNameIn) free(fileNameIn);
 	if(fileNameSH) free(fileNameSH);
	return fileNameOut;
}
/**********************************************************************/
static QuantumMechanicsModel newFireFlyModel(char* method, char* dirName, char* nameCommand, Constraints constraints, FILE* logfile)
{
	QuantumMechanicsModel qmModel = newQuantumMechanicsModel(method, dirName, nameCommand, NULL, NULL, constraints, logfile);

	qmModel.klass->calculateGradient = calculateGradientFireFly;
	qmModel.klass->calculateEnergy = calculateEnergyFireFly;

	return qmModel;
}
/**********************************************************************/
static void calculateGradientFireFly(QuantumMechanicsModel* qmModel)
{
	int i;
	int j;
	Molecule m = qmModel->molecule;
	char* keyWords = NULL;
	char* fileOut = NULL;
	if(!qmModel) return;
	if(qmModel->molecule.nAtoms<1) return;
	if(!qmModel->method) return;
	keyWords = strdup_printf("RUNTYP=GRADIENT GBASIS=%s",qmModel->method);
	fileOut = runOneFireFly(qmModel, keyWords);

	if(fileOut)
	{
		for(j=0;j<3;j++)
			for( i=0; i<m.nAtoms;i++)
				m.atoms[i].gradient[j] = 0.0;
		if(!getGradientFireFly(fileOut, qmModel))
		{
#ifdef OS_WIN32
			char* comm = strdup_printf("type %s",fileOut);
#else
			char* comm = strdup_printf("cat %s",fileOut);
#endif
			printf(("Problem : I cannot caculate the Gradient... "));
			printf(("Calculation Stopped "));
			system(comm);
			free(fileOut);
			free(comm);
			exit(1);
			return;
		}
		getEnergyFireFly(fileOut, &qmModel->molecule.potentialEnergy);
		addH4Correction(qmModel,TRUE);
		addSRBCorrection(qmModel,TRUE);
		addD3Correction(qmModel,TRUE);
		addWallCorrection(qmModel,TRUE);
		getDipoleFireFly(fileOut, qmModel->molecule.dipole);
		free(fileOut);
	}

}
/**********************************************************************/
static void calculateEnergyFireFly(QuantumMechanicsModel* qmModel)
{
	char* keyWords = NULL;
	char* fileOut = NULL;
	if(!qmModel) return;
	if(qmModel->molecule.nAtoms<1) return;
	if(!qmModel->method) return;
	keyWords = strdup_printf("RUNTYP=Energy GBASIS=%s",qmModel->method);
	fileOut = runOneFireFly(qmModel, keyWords);
	if(fileOut)
	{
		getEnergyFireFly(fileOut, &qmModel->molecule.potentialEnergy);
		addH4Correction(qmModel,FALSE);
		addSRBCorrection(qmModel,FALSE);
		addD3Correction(qmModel,FALSE);
		addWallCorrection(qmModel,FALSE);
		getDipoleFireFly(fileOut, qmModel->molecule.dipole);
		free(fileOut);
	}

}
/**********************************************************************/
QuantumMechanicsModel createFireFlyModel (Molecule* mol, char* method, char* dirName, char* nameCommand, Constraints constraints, FILE* logfile)
{
	QuantumMechanicsModel qmModel = newFireFlyModel(method,dirName, nameCommand, constraints, logfile);

	qmModel.molecule = *(mol->klass->copy(mol));
	qmModel.molecule.constraints = constraints;
	qmModel.klass->setRattleConstraintsParameters(&qmModel);
	
	return qmModel;
}
/**********************************************************************/
/*
static boolean getEnergyGaussian(char* fileNameOut, double* energy)
{
	FILE* file = NULL;
	char buffer[1024];
	char* pdest = NULL;
	boolean OK = FALSE;

 	file = fopen(fileNameOut, "r");
	if(!file) return FALSE;
	 while(!feof(file))
	 {
		if(!fgets(buffer,BSIZE,file))break;
		pdest = strstr( buffer, "SCF Done:  E(");
		if(!pdest) if(strstr( buffer, "Energy=") && !strstr( buffer, "hange") ) pdest = strstr( buffer, "Energy=");
		if(pdest) 
		{
			pdest = strstr( buffer, "=");
			if(pdest)
			{
				int l = strlen(pdest);
				int i;
				for(i=0;i<l;i++) if(pdest[i]=='D' || pdest[i]=='E') pdest[i] ='E';
				if(sscanf(pdest+1,"%lf",energy)==1)
				{
					*energy *= AUTOKCAL;
					OK = TRUE;
					// break;
				}
			}
		}
	 }
	fclose(file);
	return OK;
}
*/
/**********************************************************************/
static boolean getEnergyGaussian(char* fileNameOut, double* energy)
{
	FILE* file = NULL;
	char buffer[1024];
	char* pdest = NULL;
	char* pos = NULL;
	boolean OK = FALSE;

 	file = fopen(fileNameOut, "r");
	if(!file) return FALSE;
	 while(!feof(file))
	 {
		if(!fgets(buffer,BSIZE,file))break;
		pdest = NULL;
		if(strstr( buffer, "SCF Done:  E(") && strstr( buffer, "=")) pdest = strstr( buffer, "=")+1;
		if(!pdest) if(strstr( buffer, "Energy=") && !strstr( buffer, "hange") ) pdest = strstr( buffer, "Energy=")+strlen("Energy=");
		if(!pdest) if(strstr( buffer, "UMP") && strstr( buffer, "=")) { pos = strstr( buffer, "UMP"); pdest = strstr(pos, "=")+1;};
		if(!pdest) if(strstr( buffer, " E(B2PLYP)") && strstr( buffer, "=")) { pos = strstr( buffer, " E(B2PLYP)"); pdest = strstr(pos, "=")+1;};
		if(!pdest) if(strstr( buffer, "E(CI") && strstr( buffer, "=")) { pos = strstr( buffer, "E(CI"); pdest = strstr(pos, "=")+1;};
		if(!pdest) if(strstr( buffer, " E(CORR)") && strstr( buffer, "=")) { pos = strstr( buffer, " E(CORR)"); pdest = strstr(pos, "=")+1;};
		if(!pdest) if(strstr( buffer, "CCSD(T)=")) { pos = strstr( buffer, "CCSD(T)="); pdest = strstr(pos, "=")+1;};
		if(pdest) 
		{
			int l = strlen(pdest);
			int i;
			for(i=0;i<l;i++) if(pdest[i]=='D' || pdest[i]=='E') pdest[i] ='E';
			if(sscanf(pdest+1,"%lf",energy)==1)
			{
				*energy *= AUTOKCAL;
				OK = TRUE;
				/* break;*/
			}
		}
	 }
	fclose(file);
	return OK;
}
/*****************************************************************************/
boolean getGradientGaussian(char* fileNameOut, QuantumMechanicsModel *qmModel)
{
	FILE* file = NULL;
	char buffer[1024];
	char stmp[1024];
	char* pdest = NULL;
	boolean Ok = FALSE;
	int itmp;
	int i;
	int j;

 	file = fopen(fileNameOut, "r");
	if(!file) return FALSE;
	 while(!feof(file))
	 {
		if(!fgets(buffer,BSIZE,file))break;
		pdest = strstr( buffer, " Forces (Hartrees/Bohr)");
		if(pdest) 
		{
			do{
				if(!fgets(buffer,BSIZE,file))break;
			}while(!feof(file)&&!strstr(buffer,"------"));
			if(!strstr(buffer,"------"))break;
			for(i=0;i<qmModel->molecule.nAtoms;i++)
			{
				if(!fgets(buffer,BSIZE,file))break;
				/* printf("%s\n",buffer);*/
				if(sscanf(buffer,"%d %s %lf %lf %lf",&itmp, stmp,
							&qmModel->molecule.atoms[i].gradient[0],
							&qmModel->molecule.atoms[i].gradient[1],
							&qmModel->molecule.atoms[i].gradient[2]
							)!=5)
				{
					fclose(file);
					return FALSE;
				}
				for(j=0;j<3;j++) qmModel->molecule.atoms[i].gradient[j] *= AUTOKCAL/BOHRTOANG;
				for(j=0;j<3;j++) qmModel->molecule.atoms[i].gradient[j] = - qmModel->molecule.atoms[i].gradient[j];
			}
			Ok = TRUE;
			break;
	 	}
	 }
	fclose(file);
	return Ok;
}
/*****************************************************************************/
static char* runOneGaussian(QuantumMechanicsModel* qmModel, char* keyWords)
{
	FILE* file = NULL;
	FILE* fileSH = NULL;
	int j;
	char* fileNameIn = NULL;
	char* fileNameChk = NULL;
	char* fileNameOut = NULL;
	char* fileNameSH = NULL;
	char buffer[1024];
	Molecule m = qmModel->molecule;
	int rank = 0;
#ifdef ENABLE_MPI
	MPI_Comm_rank( MPI_COMM_WORLD,&rank);
#endif
#ifdef OS_WIN32
	char c='%';
#endif

	if(m.nAtoms<1) return fileNameOut;
#ifndef OS_WIN32
	fileNameSH = strdup_printf("%s%sGaussianOne%d.sh",qmModel->workDir,DIR_SEPARATOR_S,rank);
#else
	fileNameSH = strdup_printf("%s%sGaussianOne%d.bat",qmModel->workDir,DIR_SEPARATOR_S,rank);
#endif
 	fileSH = fopen(fileNameSH, "w");
	if(!fileSH) return FALSE;
#ifdef OS_WIN32
	fprintf(fileSH,"@echo off\n");
	fprintf(fileSH,"set PATH=%cPATH%c;\"%s\"\n",c,c,gaussianDirectory);
#endif

	fileNameIn = strdup_printf("%s%sOne%d.com",qmModel->workDir,DIR_SEPARATOR_S,rank);
	fileNameOut = strdup_printf("%s%sOne%d.log",qmModel->workDir,DIR_SEPARATOR_S,rank);
	fileNameChk = strdup_printf("%s%sOne%d",qmModel->workDir,DIR_SEPARATOR_S,rank);

 	file = fopen(fileNameIn, "w");
	if(!file) 
	{
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		return FALSE;
	}
	fprintf(file,"%%chk=%s\n",fileNameChk);
	fprintf(file,"# %s\n",keyWords);
	fprintf(file,"\n");
	fprintf(file,"! ======================================================\n");
	fprintf(file,"!  Input file for Gaussian\n"); 
	fprintf(file,"! ======================================================\n");
	fprintf(file,"\n");

	fprintf(file,"%d %d\n",qmModel->molecule.totalCharge,qmModel->molecule.spinMultiplicity);
	for(j=0;j<m.nAtoms;j++)
	{
		char* symbol = m.atoms[j].prop.symbol;
		fprintf(file,"%s %f %f %f\n", 
			symbol,
			m.atoms[j].coordinates[0],
			m.atoms[j].coordinates[1],
			m.atoms[j].coordinates[2]
			);
	}
	fprintf(file,"\n");
	fclose(file);
#ifndef OS_WIN32
	fprintf(fileSH,"%s %s",qmModel->nameCommand,fileNameIn);
#else
	fprintf(fileSH,"%s %s",qmModel->nameCommand,fileNameIn);
#endif
	fclose(fileSH);
#ifndef OS_WIN32
	sprintf(buffer,"chmod u+x %s",fileNameSH);
	system(buffer);
	system(fileNameSH);
#else
	sprintf(buffer,"\"%s\"",fileNameSH);
	system(buffer);
#endif
	unlink(fileNameIn);
	unlink(fileNameSH);
 	if(fileNameIn) free(fileNameIn);
 	if(fileNameSH) free(fileNameSH);
	return fileNameOut;
}
/**********************************************************************/
static QuantumMechanicsModel newGaussianModel(char* method, char* dirName, char* nameCommand, Constraints constraints, FILE* logfile)
{
	QuantumMechanicsModel qmModel = newQuantumMechanicsModel(method, dirName, nameCommand, NULL,  NULL, constraints, logfile);

	qmModel.klass->calculateGradient = calculateGradientGaussian;
	qmModel.klass->calculateEnergy = calculateEnergyGaussian;

	return qmModel;
}
/**********************************************************************/
static void calculateGradientGaussian(QuantumMechanicsModel* qmModel)
{
	int i;
	int j;
	Molecule m = qmModel->molecule;
	char* keyWords = NULL;
	char* fileOut = NULL;
	if(!qmModel) return;
	if(qmModel->molecule.nAtoms<1) return;
	if(!qmModel->method) return;
	if(qmModel->firstRun) keyWords = strdup_printf("%s NoSym Force SCF(XQC) Test Pop=None",qmModel->method);
	else keyWords = strdup_printf("%s Force SCF(XQC) Guess=Read Test Pop=None",qmModel->method);
	fileOut = runOneGaussian(qmModel, keyWords);

	if(fileOut)
	{
		for(j=0;j<3;j++)
			for( i=0; i<m.nAtoms;i++)
				m.atoms[i].gradient[j] = 0.0;
		if(!getGradientGaussian(fileOut, qmModel))
		{
#ifdef OS_WIN32
			char* comm = strdup_printf("type %s",fileOut);
#else
			char* comm = strdup_printf("cat %s",fileOut);
#endif
			printf(("Problem : I cannot caculate the Gradient... "));
			printf(("Calculation Stopped "));
			system(comm);
			free(fileOut);
			free(comm);
			exit(1);
			return;
		}
		getEnergyGaussian(fileOut, &qmModel->molecule.potentialEnergy);
		addH4Correction(qmModel,TRUE);
		addSRBCorrection(qmModel,TRUE);
		addD3Correction(qmModel,TRUE);
		addWallCorrection(qmModel,TRUE);
		getDipoleGaussian(fileOut, qmModel->molecule.dipole);
		free(fileOut);
	}

}
/*****************************************************************************/
static boolean getDipoleGaussian(char* fileNameOut, double* dipole)
{
	FILE* file = NULL;
	char buffer[1024];
	char* pdest = NULL;

 	file = fopen(fileNameOut, "r");
	if(!file) return FALSE;

	 while(!feof(file))
	 {
		if(!fgets(buffer,BSIZE,file))break;
		if(
		strstr( buffer, " X=")&&
		strstr( buffer, " Y=")&&
		strstr( buffer, " Z=")
		)
		{
			int l,i;
			pdest =strstr(buffer, "X=")+strlen("X=")+1;
			l = strlen(pdest);
			for(i=0;i<l;i++) if(pdest[i]=='D' || pdest[i]=='E') pdest[i] ='E';
			l = 0;
			pdest =strstr(buffer, "X=")+strlen("X=")+1;
			l += sscanf(pdest,"%lf",&dipole[0]);
			pdest =strstr(buffer, "Y=")+strlen("Y=")+1;
			l += sscanf(pdest,"%lf",&dipole[1]);
			pdest =strstr(buffer, "Z=")+strlen("Z=")+1;
			l += sscanf(pdest,"%lf",&dipole[2]);
			if(l!=3) for(i=0;i<3;i++) dipole[i] = 0.0;
		}
	 }
	fclose(file);
	return FALSE;
}
/**********************************************************************/
static void calculateEnergyGaussian(QuantumMechanicsModel* qmModel)
{
	char* keyWords = NULL;
	char* fileOut = NULL;
	if(!qmModel) return;
	if(qmModel->molecule.nAtoms<1) return;
	if(!qmModel->method) return;
	keyWords = strdup_printf("%s  SCF(XQC) Test",qmModel->method);
	fileOut = runOneGaussian(qmModel, keyWords);
	if(fileOut)
	{
		getEnergyGaussian(fileOut, &qmModel->molecule.potentialEnergy);
		addH4Correction(qmModel,FALSE);
		addSRBCorrection(qmModel,FALSE);
		addWallCorrection(qmModel,FALSE);
		getDipoleGaussian(fileOut, qmModel->molecule.dipole);
		free(fileOut);
	}

}
/**********************************************************************/
QuantumMechanicsModel createGaussianModel (Molecule* mol, char* method, char* dirName, char* nameCommand, Constraints constraints, FILE* logfile)
{
	QuantumMechanicsModel qmModel = newGaussianModel(method,dirName, nameCommand, constraints, logfile);

	qmModel.molecule = *(mol->klass->copy(mol));
	qmModel.molecule.constraints = constraints;
	qmModel.klass->setRattleConstraintsParameters(&qmModel);
	
	return qmModel;
}
/*****************************************************************************/
static boolean getDipoleOrca(char* fileNameOut, double* dipole)
{
	FILE* file = NULL;
	char buffer[1024];
	char* pdest = NULL;

 	file = fopen(fileNameOut, "r");
	if(!file) return FALSE;

	 while(!feof(file))
	 {
		if(!fgets(buffer,BSIZE,file))break;
		if(
		strstr( buffer, "Total")&&
		strstr( buffer, "Dipole")&&
		strstr( buffer, "Moment")
		)
		{
			int l,i;
			pdest =strstr(buffer, ":")+strlen(":")+1;
			l = strlen(pdest);
			for(i=0;i<l;i++) if(pdest[i]=='D' || pdest[i]=='E') pdest[i] ='E';
			if(sscanf(pdest,"%lf %lf %lf",&dipole[0],&dipole[1],&dipole[2])==3)
			{
				for(i=0;i<3;i++) dipole[i] *= AUTODEB;
			}
		}
	 }
	fclose(file);
	return FALSE;
}
/*****************************************************************************/
static boolean getEnergyOrca(char* fileNameOut, double* energy)
{
	FILE* file = NULL;
	char buffer[1024];
	char* pdest = NULL;
	char* energyTag = "FINAL SINGLE POINT ENERGY";

 	file = fopen(fileNameOut, "r");
	if(!file) return FALSE;
	 while(!feof(file))
	 {
		if(!fgets(buffer,BSIZE,file))break;
		pdest = strstr( buffer, energyTag);
		if(pdest)
		{
			int l = strlen(pdest);
			int i;
			for(i=0;i<l;i++) if(pdest[i]=='D' || pdest[i]=='E') pdest[i] ='E';
		}
		if(pdest &&sscanf(pdest+strlen(energyTag)+1,"%lf",energy)==1)
		{
			fclose(file);
			*energy *= AUTOKCAL;
			return TRUE;
		}
	 }
	fclose(file);
	return FALSE;
}
/*****************************************************************************/
boolean getGradientOrca(char* fileNameOut, QuantumMechanicsModel *qmModel)
{
	FILE* file = NULL;
	char buffer[1024];
	char* pdest = NULL;
	boolean Ok = FALSE;
	int i;
	int k;
	char* gradTag = "# The current gradient in Eh/bohr";

 	file = fopen(fileNameOut, "r");
	if(!file) return FALSE;
	 while(!feof(file))
	 {
		if(!fgets(buffer,BSIZE,file))break;
		pdest = strstr( buffer, gradTag);
		if(pdest)
		{
			i=0;
			k=0;
	 		while(!feof(file) && i< qmModel->molecule.nAtoms)
	 		{
				if(!fgets(buffer,BSIZE,file))break;
				if(strstr(buffer,"#")) continue;
				/* printf("%s\n",buffer);*/
				if(sscanf(buffer,"%lf",&qmModel->molecule.atoms[i].gradient[k])!=1)
				{
					fclose(file);
					return FALSE;
				}
				k++;
				if(k==3) { k = 0; i++;}
			}
			Ok = TRUE;
		}
	 }
	fclose(file);
	if(Ok)
	{
		for(i=0;i<qmModel->molecule.nAtoms;i++)
		{
			for(k=0;k<3;k++) qmModel->molecule.atoms[i].gradient[k] *= AUTOKCAL/BOHRTOANG;
			//for(k=0;k<3;k++) qmModel->molecule.atoms[i].gradient[k] = - qmModel->molecule.atoms[i].gradient[k];
		}
	}
	return Ok;
}
/*****************************************************************************/
static char* runOneOrca(QuantumMechanicsModel* qmModel, char* keyWords)
{
	FILE* file = NULL;
	FILE* fileSH = NULL;
	int i;
	int nV = 0;
	char* fileNameIn = NULL;
	char* fileNameOut = NULL;
	char* fileNameSH = NULL;
	char buffer[1024];
	Molecule* mol = &qmModel->molecule;
	char* NameCommandOrca = qmModel->nameCommand;
	int rank = 0;
#ifdef ENABLE_MPI
	MPI_Comm_rank( MPI_COMM_WORLD,&rank);
#endif
#ifdef OS_WIN32
	char c='%';
#endif

	if(mol->nAtoms<1) return fileNameOut;
#ifndef OS_WIN32
	fileNameSH = strdup_printf("%s%sOrcaOne%d.sh",qmModel->workDir,DIR_SEPARATOR_S,rank);
#else
	fileNameSH = strdup_printf("%s%sOrcaOne%d.bat",qmModel->workDir,DIR_SEPARATOR_S,rank);
#endif
 	fileSH = fopen(fileNameSH, "w");
	if(!fileSH) return FALSE;
#ifdef OS_WIN32
	fprintf(fileSH,"@echo off\n");
	fprintf(fileSH,"set PATH=%cPATH%c;\"%s\"\n",c,c,orcaDirectory);
#endif

	fileNameIn = strdup_printf("%s%sOne%d.inp",qmModel->workDir,DIR_SEPARATOR_S,rank);
	fileNameOut = strdup_printf("%s%sOne%d.out",qmModel->workDir,DIR_SEPARATOR_S,rank);

 	file = fopen(fileNameIn, "w");
	if(!file) 
	{
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		return FALSE;
	}
	fprintf(file,"# ======================================================\n");
	fprintf(file,"#  Orca input file made in Gabedit\n"); 
	fprintf(file,"# ======================================================\n");
	fprintf(file,"! %s\n",keyWords);
	{
		fprintf(file,"* xyz %d   %d\n",mol->totalCharge,mol->spinMultiplicity);
		nV = 0;
      		for (i=0;i<mol->nAtoms;i++)
		{
			char X[100];
			char Y[100];
			char Z[100];
			sprintf(X,"%20.14f",mol->atoms[i].coordinates[0]);
			sprintf(Y,"%20.14f",mol->atoms[i].coordinates[1]);
			sprintf(Z,"%20.14f",mol->atoms[i].coordinates[2]);

			fprintf(file," %s  %s %s %s\n",mol->atoms[i].prop.symbol, X,Y,Z);
			if(mol->atoms[i].variable) nV+=3;
		}
		fprintf(file,"*\n");
		if(nV>0&&nV!=3*mol->nAtoms) 
		{
			fprintf(file,"%cgeom Constraints\n",'%');
      			for (i=0;i<mol->nAtoms;i++)
			{
				if(mol->atoms[i].variable)
				{
					fprintf(file,"  {C %d C}\n",i);
				}
			}
			fprintf(file," end #Constraints\n");
			fprintf(file," invertConstraints true\n");
			fprintf(file," end #geom\n");
		}
	}

	fclose(file);
#ifndef OS_WIN32
	if(!strcmp(NameCommandOrca,"orca") || !strcmp(NameCommandOrca,"nohup orca"))
	{
		fprintf(fileSH,"%s %s > %s\n",NameCommandOrca,fileNameIn,fileNameOut);
		fprintf(fileSH,"exit\n");
	}
	else
		fprintf(fileSH,"%s %s",NameCommandOrca,fileNameIn);
#else
	 if(!strcmp(NameCommandOrca,"orca") )
	{
		if(strstr(orcaDirectory,"\"")) fprintf(fileSH,"set PATH=%s;%cPATH%c\n",orcaDirectory,'%','%');
		else fprintf(fileSH,"set PATH=\"%s\";%cPATH%c\n",orcaDirectory,'%','%');
		fprintf(fileSH,"%s %s > %s\n",NameCommandOrca,fileNameIn,fileNameOut);
		fprintf(fileSH,"exit\n");
	}
	else
		fprintf(fileSH,"%s %s",NameCommandOrca,fileNameIn);
#endif
	fclose(fileSH);
#ifndef OS_WIN32
	sprintf(buffer,"chmod u+x %s",fileNameSH);
	system(buffer);
	system(fileNameSH);
#else
	sprintf(buffer,"\"%s\"",fileNameSH);
	system(buffer);
#endif
	unlink(fileNameIn);
	unlink(fileNameSH);
 	if(fileNameIn) free(fileNameIn);
 	if(fileNameSH) free(fileNameSH);
	return fileNameOut;
}
/**********************************************************************/
static QuantumMechanicsModel newOrcaModel(char* method, char* dirName, char* nameCommand, Constraints constraints, FILE* logfile)
{
	QuantumMechanicsModel qmModel = newQuantumMechanicsModel(method, dirName, nameCommand, NULL, NULL, constraints, logfile);

	qmModel.klass->calculateGradient = calculateGradientOrca;
	qmModel.klass->calculateEnergy = calculateEnergyOrca;

	return qmModel;
}
/**********************************************************************/
static void calculateGradientOrca(QuantumMechanicsModel* qmModel)
{
	int i;
	int j;
	Molecule m = qmModel->molecule;
	char* keyWords = NULL;
	char* fileOut = NULL;
	if(!qmModel) return;
	if(qmModel->molecule.nAtoms<1) return;
	if(!qmModel->method) return;
	if(qmModel->firstRun) keyWords = strdup_printf("%s ENGRAD ",qmModel->method);
	else keyWords = strdup_printf("%s ENGRAD ",qmModel->method);
	fileOut = runOneOrca(qmModel, keyWords);

	if(fileOut)
	{
		for(j=0;j<3;j++)
			for( i=0; i<m.nAtoms;i++)
				m.atoms[i].gradient[j] = 0.0;
		if(!getGradientOrca(fileOut, qmModel))
		{
#ifdef OS_WIN32
			char* comm = strdup_printf("type %s",fileOut);
#else
			char* comm = strdup_printf("cat %s",fileOut);
#endif
			printf(("Problem : I cannot caculate the Gradient... "));
			printf(("Calculation Stopped "));
			system(comm);
			free(fileOut);
			free(comm);
			exit(1);
			return;
		}
		getEnergyOrca(fileOut, &qmModel->molecule.potentialEnergy);
		addH4Correction(qmModel,TRUE);
		addSRBCorrection(qmModel,TRUE);
		addD3Correction(qmModel,TRUE);
		addWallCorrection(qmModel,TRUE);
		getDipoleOrca(fileOut, qmModel->molecule.dipole);
		free(fileOut);
	}

}
/**********************************************************************/
static void calculateEnergyOrca(QuantumMechanicsModel* qmModel)
{
	char* keyWords = NULL;
	char* fileOut = NULL;
	if(!qmModel) return;
	if(qmModel->molecule.nAtoms<1) return;
	if(!qmModel->method) return;
	keyWords = strdup_printf("%s ",qmModel->method);
	fileOut = runOneOrca(qmModel, keyWords);
	if(fileOut)
	{
		getEnergyOrca(fileOut, &qmModel->molecule.potentialEnergy);
		addH4Correction(qmModel,FALSE);
		addSRBCorrection(qmModel,FALSE);
		addWallCorrection(qmModel,FALSE);
		getDipoleOrca(fileOut, qmModel->molecule.dipole);
		free(fileOut);
	}

}
/**********************************************************************/
QuantumMechanicsModel createOrcaModel (Molecule* mol, char* method, char* dirName, char* nameCommand, Constraints constraints, FILE* logfile)
{
	QuantumMechanicsModel qmModel = newOrcaModel(method,dirName, nameCommand, constraints, logfile);

	qmModel.molecule = *(mol->klass->copy(mol));
	qmModel.molecule.constraints = constraints;
	qmModel.klass->setRattleConstraintsParameters(&qmModel);
	
	return qmModel;
}
/**********************************************************************/
static boolean getDipoleGeneric(char* fileNameOut, double* dipole)
{
	FILE* file = NULL;
	char buffer[1024];
	int i;
 	file = fopen(fileNameOut, "r");
	if(!file) return FALSE;
	if(!fgets(buffer,BSIZE,file)) { fclose(file); return FALSE;}/* first line for energy in Hartree*/
	if(!fgets(buffer,BSIZE,file)) { fclose(file); return FALSE;}/* dipole in au */
	for(i=0;i<strlen(buffer);i++) if(buffer[i]=='D' || buffer[i]=='d') buffer[i] ='E';
	if(sscanf(buffer,"%lf %lf %lf",&dipole[0],&dipole[1],&dipole[2])==3)
	{
		for(i=0;i<3;i++) dipole[i] *= AUTODEB;
		fclose(file);
		return TRUE;
	}
	fclose(file);
	return FALSE;
}
/*****************************************************************************/
static boolean getEnergyGeneric(char* fileNameOut, double* energy)
{
	FILE* file = NULL;
	char buffer[1024];
	int i;
 	file = fopen(fileNameOut, "r");
	if(!file) return FALSE;
	if(!fgets(buffer,BSIZE,file)) { fclose(file); return FALSE;}/* first line for energy in Hartree*/

	for(i=0;i<strlen(buffer);i++) if(buffer[i]=='D' || buffer[i]=='d') buffer[i] ='E';
	if(sscanf(buffer,"%lf",energy)==1)
	{
		fclose(file);
		*energy *= AUTOKCAL;
		return TRUE;
	}
	fclose(file);
	return FALSE;
}
/*****************************************************************************/
boolean getGradientGeneric(char* fileNameOut, QuantumMechanicsModel *qmModel)
{
	FILE* file = NULL;
	char buffer[1024];
	boolean Ok = FALSE;
	int i;
	int j;

 	file = fopen(fileNameOut, "r");
	if(!file) return FALSE;
	if(!fgets(buffer,BSIZE,file)) { fclose(file); return FALSE;}/* first line for energy in Hartree*/
	if(!fgets(buffer,BSIZE,file)) { fclose(file); return FALSE;}/* dipole in au */
	for(i=0;i<qmModel->molecule.nAtoms;i++)
	{
		if(!fgets(buffer,BSIZE,file))break;
		for(j=0;j<strlen(buffer);j++) if(buffer[j]=='D' || buffer[j]=='d') buffer[j] ='E';
		if(sscanf(buffer,"%lf %lf %lf",
					&qmModel->molecule.atoms[i].gradient[0],
					&qmModel->molecule.atoms[i].gradient[1],
					&qmModel->molecule.atoms[i].gradient[2]
					)!=3)
		{
			fclose(file);
			return FALSE;
		}
		for(j=0;j<3;j++) qmModel->molecule.atoms[i].gradient[j] *= AUTOKCAL/BOHRTOANG;
		for(j=0;j<3;j++) qmModel->molecule.atoms[i].gradient[j] = - qmModel->molecule.atoms[i].gradient[j];
	}
	Ok = TRUE;
	fclose(file);
	return Ok;
}
/*****************************************************************************/
char* runOneGeneric(QuantumMechanicsModel* qmModel, char* keyWords)
{
	FILE* file = NULL;
	FILE* fileSH = NULL;
	char* fileNameIn = NULL;
	char* fileNameOut = NULL;
	char* fileNameSH = NULL;
	char buffer[1024];
	Molecule* mol = &qmModel->molecule;
	char* NameCommandGeneric = qmModel->nameCommand;
	int rank = 0;
	int type = 0;
#ifdef ENABLE_MPI
	MPI_Comm_rank( MPI_COMM_WORLD,&rank);
#endif
#ifdef OS_WIN32
	char c='%';
#endif

	if(mol->nAtoms<1) return fileNameOut;
#ifndef OS_WIN32
	fileNameSH = strdup_printf("%s%sGenericOne%d.sh",qmModel->workDir,DIR_SEPARATOR_S,rank);
#else
	fileNameSH = strdup_printf("%s%sGenericOne%d.bat",qmModel->workDir,DIR_SEPARATOR_S,rank);
#endif
 	fileSH = fopen(fileNameSH, "w");
	if(!fileSH) return FALSE;
#ifdef OS_WIN32
	fprintf(fileSH,"@echo off\n");
#endif

	fileNameIn = strdup_printf("%s%sOne%d.inp",qmModel->workDir,DIR_SEPARATOR_S,rank);
	fileNameOut = strdup_printf("%s%sOne%d.out",qmModel->workDir,DIR_SEPARATOR_S,rank);

 	file = fopen(fileNameIn, "w");
	if(!file) 
	{
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		return FALSE;
	}
	/*
	fprintf(file,"# ======================================================\n");
	fprintf(file,"#  Generic input file made in CChemI\n"); 
	fprintf(file,"# ======================================================\n");
	*/
	if(strstr(keyWords,"ENGRAD")) type = 1;
	fprintf(file,"%d\n",type);
	mol->klass->addMolecule(mol,file);
	fclose(file);

#ifndef OS_WIN32
	fprintf(fileSH,"%s %s %s",NameCommandGeneric,fileNameIn,fileNameOut);
	fclose(fileSH);
	sprintf(buffer,"chmod u+x %s",fileNameSH);
	system(buffer);
	system(fileNameSH);
#else
	fprintf(fileSH,"\"%s\" \"%s\" \"%s\"",NameCommandGeneric,fileNameIn,fileNameOut);
	fclose(fileSH);
	sprintf(buffer,"\"%s\"",fileNameSH);
	system(buffer);
#endif
	unlink(fileNameIn);
	unlink(fileNameSH);
 	if(fileNameIn) free(fileNameIn);
 	if(fileNameSH) free(fileNameSH);
	return fileNameOut;
}
/**********************************************************************/
static QuantumMechanicsModel newGenericModel(char* method, char* dirName, char* nameCommand, Constraints constraints, FILE* logfile)
{
	QuantumMechanicsModel qmModel = newQuantumMechanicsModel(method, dirName, nameCommand, NULL, NULL, constraints, logfile);

	qmModel.klass->calculateGradient = calculateGradientGeneric;
	qmModel.klass->calculateEnergy = calculateEnergyGeneric;

	return qmModel;
}
/**********************************************************************/
static void calculateGradientGeneric(QuantumMechanicsModel* qmModel)
{
	int i;
	int j;
	Molecule m = qmModel->molecule;
	char* keyWords = NULL;
	char* fileOut = NULL;
	if(!qmModel) return;
	if(qmModel->molecule.nAtoms<1) return;
	if(!qmModel->method) return;
	if(qmModel->firstRun) keyWords = strdup_printf("%s ENGRAD ",qmModel->method);
	else keyWords = strdup_printf("%s ENGRAD ",qmModel->method);
	fileOut = runOneGeneric(qmModel, keyWords);

	if(fileOut)
	{
		for(j=0;j<3;j++)
			for( i=0; i<m.nAtoms;i++)
				m.atoms[i].gradient[j] = 0.0;
		if(!getGradientGeneric(fileOut, qmModel))
		{
#ifdef OS_WIN32
			char* comm = strdup_printf("type %s",fileOut);
#else
			char* comm = strdup_printf("cat %s",fileOut);
#endif
			printf(("Problem : I cannot caculate the Gradient... "));
			printf(("Calculation Stopped "));
			system(comm);
			free(fileOut);
			free(comm);
			exit(1);
			return;
		}
		getEnergyGeneric(fileOut, &qmModel->molecule.potentialEnergy);
		addH4Correction(qmModel,TRUE);
		addSRBCorrection(qmModel,TRUE);
		addD3Correction(qmModel,TRUE);
		addWallCorrection(qmModel,TRUE);
		getDipoleGeneric(fileOut, qmModel->molecule.dipole);
		free(fileOut);
	}

}
/**********************************************************************/
static void calculateEnergyGeneric(QuantumMechanicsModel* qmModel)
{
	char* keyWords = NULL;
	char* fileOut = NULL;
	if(!qmModel) return;
	if(qmModel->molecule.nAtoms<1) return;
	if(!qmModel->method) return;
	keyWords = strdup_printf("%s ",qmModel->method);
	fileOut = runOneGeneric(qmModel, keyWords);
	if(fileOut)
	{
		getEnergyGeneric(fileOut, &qmModel->molecule.potentialEnergy);
		addH4Correction(qmModel,FALSE);
		addSRBCorrection(qmModel,FALSE);
		addD3Correction(qmModel,FALSE);
		addWallCorrection(qmModel,FALSE);
		getDipoleGeneric(fileOut, qmModel->molecule.dipole);
		free(fileOut);
	}

}
/**********************************************************************/
QuantumMechanicsModel createGenericModel (Molecule* mol, char* method, char* dirName, char* nameCommand, Constraints constraints, FILE* logfile)
{
	QuantumMechanicsModel qmModel = newGenericModel(method,dirName, nameCommand, constraints, logfile);

	qmModel.molecule = *(mol->klass->copy(mol));
	qmModel.molecule.constraints = constraints;
	qmModel.klass->setRattleConstraintsParameters(&qmModel);
	
	return qmModel;
}
/**********************************************************************/
/*
static boolean getDipoleOpenBabel(char* fileNameOut, Molecule* mol, double dipole[])
{
	FILE* file = NULL;
	char buffer[1024];
	boolean ok = FALSE;

 	file = fopen(fileNameOut, "r");
	if(!file) return FALSE;

	 while(!feof(file))
	 {
		if(!fgets(buffer,BSIZE,file))break;
		if(
		strstr( buffer, "IDX")&&
		strstr( buffer, "CHARGE")
		)
		{
			int i = 0;
			int k;
			for(k=0;k<3;k++) dipole[k] = 0.0;
			for(i=0;i<mol->nAtoms;i++)
			{
				if(!fgets(buffer,BSIZE,file))break;
				for(k=0;k<3;k++) dipole[k] += mol->atoms[i].coordinates[k]*atof(buffer)*BOHRTOANG;
			}
			if(i!=mol->nAtoms) break;
			for(k=0;k<3;k++) dipole[i] *= AUTODEB;
			ok = TRUE;
		}
	 }
	fclose(file);
	return ok;
}
*/
/*****************************************************************************/
static boolean getEnergyOpenBabel(char* fileNameOut, double* energy)
{
	FILE* file = NULL;
	char buffer[1024];
	char* pdest = NULL;
	//char* energyTag = "TOTAL ENERGY =";
	char* energyTag = "FINAL ENERGY:";

 	file = fopen(fileNameOut, "r");
	if(!file) return FALSE;
	 while(!feof(file))
	 {
		if(!fgets(buffer,BSIZE,file))break;
		pdest = strstr( buffer, energyTag);
		if(pdest &&sscanf(pdest+strlen(energyTag)+1,"%lf",energy)==1)
		{
			fclose(file);
			if(strstr(pdest,"kJ")) *energy /= KCALTOKJ;
			return TRUE;
		}
	 }
	fclose(file);
	return FALSE;
}
/*****************************************************************************/
static char* runOneOpenBabel(QuantumMechanicsModel* qmModel, char* keyWords)
{
	FILE* fileSH = NULL;
	char* fileNameIn = NULL;
	char* fileNameOut = NULL;
	char* fileNameSH = NULL;
	char buffer[1024];
	Molecule* mol = &qmModel->molecule;
	char* NameCommandOpenBabel = qmModel->nameCommand;
	int rank = 0;
#ifdef ENABLE_MPI
	MPI_Comm_rank( MPI_COMM_WORLD,&rank);
#endif
#ifdef OS_WIN32
	char c='%';
#endif

	if(mol->nAtoms<1) return fileNameOut;
#ifndef OS_WIN32
	fileNameSH = strdup_printf("%s%sOpenBabelOne%d.sh",qmModel->workDir,DIR_SEPARATOR_S,rank);
#else
	fileNameSH = strdup_printf("%s%sOpenBabelOne%d.bat",qmModel->workDir,DIR_SEPARATOR_S,rank);
#endif
 	fileSH = fopen(fileNameSH, "w");
	if(!fileSH) return FALSE;
#ifdef OS_WIN32
	fprintf(fileSH,"@echo off\n");
	fprintf(fileSH,"set PATH=%cPATH%c;\"%s\"\n",c,c,openBabelDirectory);
#endif

	fileNameIn = strdup_printf("%s%sOne%d.hin",qmModel->workDir,DIR_SEPARATOR_S,rank);
	fileNameOut = strdup_printf("%s%sOne%d.out",qmModel->workDir,DIR_SEPARATOR_S,rank);

	if(!mol->klass->saveHIN(mol,fileNameIn))
	{
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		return FALSE;
	}
#ifndef OS_WIN32
	if(!strcmp(NameCommandOpenBabel,"obenergy") || !strcmp(NameCommandOpenBabel,"nohup obenergy"))
	{
		fprintf(fileSH,"%s -ff gaff %s > %s 2>/dev/null\n",NameCommandOpenBabel,fileNameIn,fileNameOut);
		fprintf(fileSH,"exit\n");
	}
	else
		fprintf(fileSH,"%s %s >%s 2>/dev/null",NameCommandOpenBabel,fileNameIn, fileNameOut);
#else
	 if(!strcmp(NameCommandOpenBabel,"obenergy") )
	{
		if(strstr(openBabelDirectory,"\"")) fprintf(fileSH,"set PATH=%s;%cPATH%c\n",openBabelDirectory,'%','%');
		else fprintf(fileSH,"set PATH=\"%s\";%cPATH%c\n",openBabelDirectory,'%','%');
		fprintf(fileSH,"%s -ff gaff %s > %s\n",NameCommandOpenBabel,fileNameIn,fileNameOut);
		fprintf(fileSH,"exit\n");
	}
	else
		fprintf(fileSH,"%s %s > %s",NameCommandOpenBabel,fileNameIn, fileNameOut);
#endif
	fclose(fileSH);
#ifndef OS_WIN32

	/*
	sprintf(buffer,"cat %s",fileNameSH);
	system(buffer);
	sprintf(buffer,"cat %s",fileNameIn);
	system(buffer);
	*/

	sprintf(buffer,"chmod u+x %s",fileNameSH);
	system(buffer);
	system(fileNameSH);

	/*
	sprintf(buffer,"cat %s",fileNameOut);
	system(buffer);
	*/
#else
	sprintf(buffer,"\"%s\"",fileNameSH);
	system(buffer);
#endif
	unlink(fileNameIn);
	unlink(fileNameSH);
 	if(fileNameIn) free(fileNameIn);
 	if(fileNameSH) free(fileNameSH);
	return fileNameOut;
}
/**********************************************************************/
static QuantumMechanicsModel newOpenBabelModel(char* method, char* dirName, char* nameCommand, Constraints constraints, FILE* logfile)
{
	QuantumMechanicsModel qmModel = newQuantumMechanicsModel(method, dirName, nameCommand, NULL, NULL, constraints, logfile);

	qmModel.klass->calculateGradient = calculateGradientOpenBabel;
	qmModel.klass->calculateEnergy = calculateEnergyOpenBabel;

	return qmModel;
}
/**********************************************************************/
/*
static void calculateGradientOpenBabelNumeric(QuantumMechanicsModel* qmModel)
{
	double dx = 0.01;
        Molecule* mol = &qmModel->molecule;
        int nAtoms = mol->nAtoms;
	int i,k;
	double Em,Ep;

        for(i=0;i<nAtoms;i++)
        for(k=0;k<3;k++)
                mol->atoms[i].gradient[k] = 0.0;

        for(i=0;i<nAtoms;i++)
        for(k=0;k<3;k++)
        {
                mol->atoms[i].coordinates[k] += dx;
                qmModel->klass->calculateEnergy(qmModel);
                Ep = mol->potentialEnergy;


                mol->atoms[i].coordinates[k] -= 2*dx;
                qmModel->klass->calculateEnergy(qmModel);
                Em = mol->potentialEnergy;

                mol->atoms[i].gradient[k] = (Ep-Em)/dx/2;
                mol->atoms[i].coordinates[k] += dx;
        }
        qmModel->klass->calculateEnergy(qmModel);

}
*/
/*****************************************************************************/
static boolean getGradientsOpenBabel(char* fileNameOut, Molecule* mol)
{
	FILE* file = NULL;
	char buffer[1024];
	char* pdest = NULL;
	//char* energyTag = "TOTAL ENERGY =";
	char* energyTag = "FINAL ENERGY:";
	char* gradTag = "Gradients:";
	boolean kj = FALSE;
	double conv = 1.0;
	int i;

 	file = fopen(fileNameOut, "r");
	if(!file) return FALSE;
	 while(!feof(file))
	 {
		if(!fgets(buffer,BSIZE,file))break;
		pdest = strstr( buffer, energyTag);
		if(pdest &&sscanf(pdest+strlen(energyTag)+1,"%lf",&mol->potentialEnergy)==1)
		{
			if(strstr(pdest,"kJ")) { kj = TRUE;}
			break;
		}
	 }
	 while(!feof(file))
	 {
		if(!fgets(buffer,BSIZE,file))break;
		if(strstr(buffer, gradTag))
		{
			for(i=0;i<mol->nAtoms;i++)
			{
				if(!fgets(buffer,BSIZE,file))break;
				//printf("%s\n",buffer);
				if(sscanf(buffer,"%lf %lf %lf",
					&mol->atoms[i].gradient[0],
					&mol->atoms[i].gradient[1],
					&mol->atoms[i].gradient[2]
					)!=3) break;
			}
			break;
		}
	 }
	if(kj) conv /= KCALTOKJ;
	mol->potentialEnergy *= conv;
	for(i=0;i<mol->nAtoms;i++)
	{
		mol->atoms[i].gradient[0] *= conv;
		mol->atoms[i].gradient[1] *= conv;
		mol->atoms[i].gradient[2] *= conv;
	}

	fclose(file);
	return FALSE;
}
/**********************************************************************/
static void calculateGradientOpenBabelAnalytic(QuantumMechanicsModel* qmModel)
{
	char* keyWords = NULL;
	char* fileOut = NULL;
	if(!qmModel) return;
	if(qmModel->molecule.nAtoms<1) return;
	if(!qmModel->method) return;
	keyWords = strdup_printf("%s ",qmModel->method);
	fileOut = runOneOpenBabel(qmModel, keyWords);
	if(fileOut)
	{
		getGradientsOpenBabel(fileOut, &qmModel->molecule);
		addH4Correction(qmModel,TRUE);
		addSRBCorrection(qmModel,TRUE);
		addWallCorrection(qmModel,TRUE);
		//getDipoleOpenBabel(fileOut, &qmModel->molecule, qmModel->molecule.dipole);
		qmModel->molecule.klass->computeDipole(&qmModel->molecule);
		free(fileOut);
	}
}
/**********************************************************************/
static void calculateGradientOpenBabel(QuantumMechanicsModel* qmModel)
{
	//calculateGradientOpenBabelNumeric(qmModel);
	calculateGradientOpenBabelAnalytic(qmModel);
}
/**********************************************************************/
static void calculateEnergyOpenBabel(QuantumMechanicsModel* qmModel)
{
	char* keyWords = NULL;
	char* fileOut = NULL;
	if(!qmModel) return;
	if(qmModel->molecule.nAtoms<1) return;
	if(!qmModel->method) return;
	keyWords = strdup_printf("%s ",qmModel->method);
	fileOut = runOneOpenBabel(qmModel, keyWords);
	if(fileOut)
	{
		getEnergyOpenBabel(fileOut, &qmModel->molecule.potentialEnergy);
		addSRBCorrection(qmModel,FALSE);
		addWallCorrection(qmModel,FALSE);
		//getDipoleOpenBabel(fileOut, &qmModel->molecule, qmModel->molecule.dipole);
		qmModel->molecule.klass->computeDipole(&qmModel->molecule);
		free(fileOut);
	}

}
/**********************************************************************/
QuantumMechanicsModel createOpenBabelModel (Molecule* mol, char* method, char* dirName, char* nameCommand, Constraints constraints, FILE* logfile)
{
	QuantumMechanicsModel qmModel = newOpenBabelModel(method,dirName, nameCommand, constraints, logfile);

	qmModel.molecule = *(mol->klass->copy(mol));
	qmModel.molecule.constraints = constraints;
	qmModel.klass->setRattleConstraintsParameters(&qmModel);
	
	return qmModel;
}
/**********************************************************************/
static void calculateEnergyN2P2(QuantumMechanicsModel* qmModel)
{
	int err = 0;
	Molecule* mol = &qmModel->molecule;
	if(!qmModel) return;
	if(qmModel->molecule.nAtoms<1) return;
	err = interfaceCChemIComputeEnergy(qmModel->interfaceLibN2P2, mol);
	if(!err)
	{
		addH4Correction(qmModel,TRUE);
		addSRBCorrection(qmModel,TRUE);
		addD3Correction(qmModel,TRUE);
		addWallCorrection(qmModel,TRUE);
		//getDipoleN2P2(fileOut, qmModel->molecule.dipole);
		if(qmModel->interfaceLibN2P2ES)
		{
			double charge = 0;
			err = interfaceCChemIESComputeChargeAndDipole(qmModel->interfaceLibN2P2ES, mol, &charge);
			/*
			if(!err)
			{
				fprintf(stderr,"charge NN = %f\n",charge);
				fprintf(stderr,"dipole NN = %f %f %f\n",mol->dipole[0], mol->dipole[1],mol->dipole[2]);
			}
			else fprintf(stderr,"Error NN charge & dipole calculationn\n");
			mol->dipole[0]= mol->dipole[1]=mol->dipole[2]=0;
			qmModel->molecule.klass->computeDipole(mol);
			fprintf(stderr,"dipole from molecule = %f %f %f\n",mol->dipole[0], mol->dipole[1],mol->dipole[2]);
			*/
		}
		
	}
	else
	{
		fprintf(stderr,"Error : in interfaceCChemIComputeForces, Stopped\n");
		exit(1);
	}

}
/**********************************************************************/
static void calculateGradientN2P2(QuantumMechanicsModel* qmModel)
{
	int err = 0;
	Molecule* mol = &qmModel->molecule;
	if(!qmModel) return;
	if(qmModel->molecule.nAtoms<1) return;

	err = interfaceCChemIComputeGradients(qmModel->interfaceLibN2P2, mol);
	if(!err)
	{
		addH4Correction(qmModel,TRUE);
		addSRBCorrection(qmModel,TRUE);
		addD3Correction(qmModel,TRUE);
		addWallCorrection(qmModel,TRUE);
		//getDipoleN2P2(fileOut, qmModel->molecule.dipole);
		if(qmModel->interfaceLibN2P2ES)
		{
			double charge = 0;
			err = interfaceCChemIESComputeChargeAndDipole(qmModel->interfaceLibN2P2ES, mol, &charge);
			/*
			if(!err)
			{
				fprintf(stderr,"charge NN = %f\n",charge);
				fprintf(stderr,"dipole NN = %f %f %f\n",mol->dipole[0], mol->dipole[1],mol->dipole[2]);
			}
			else fprintf(stderr,"Error NN charge & dipole calculationn\n");
			*/
			
		}
	}
	else
	{
		fprintf(stderr,"Error : in interfaceCChemIComputeForces, Stopped\n");
		exit(1);
	}
}
/**********************************************************************/
static void calculateHessianN2P2(QuantumMechanicsModel* qmModel, double **F, double*** dmu)
{
	int err = 0;
	int nAtoms;
	int i;
	int j,k,c,index,id,jd;
	Molecule* mol = NULL;
	if(!qmModel) return;
	if(qmModel->molecule.nAtoms<1) return;

	if(qmModel->SRBParameters || qmModel->addD3Correction || qmModel->addWallCorrection || qmModel->H4Parameters || !qmModel->interfaceLibN2P2 || !qmModel->interfaceLibN2P2ES)
	{
		fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		fprintf(stderr,"Analytical calculation of Hessian with N2P2\n");
		fprintf(stderr,"AND empirical corrections is not yes implemented\n");
		fprintf(stderr,"Analytical calculation of Hessian with N2P2 is implemented only without corrections\n");
		fprintf(stderr,"Add dx=value to your input file to do that numerically\n");
		fprintf(stderr,"Example : dx=1e-3\n");
		fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		exit(1);
	}
	mol = &qmModel->molecule;
	nAtoms = mol->nAtoms;
	err = interfaceCChemIComputeHessian(qmModel->interfaceLibN2P2, mol, F);

	if(!err)
	{
		for(i=0;i<nAtoms;i++)
        		for(k=0;k<3;k++)
        		{
                		id=3*i+k;
                		for(j=0;j<=i;j++)
                		{
                        		double invm = 1.0/sqrt( mol->atoms[i].mass* mol->atoms[j].mass);
                        		for(c = 0;c<3;c++)
                        		{
                                		jd = 3*j+c;
                                		if(jd>id) continue;
                                		index = jd + id*(id+1)/2;
                                		(*F)[index] *= invm;
                        		}
                		}
        	}
	}

	if(!err)
	{
		if(qmModel->interfaceLibN2P2ES)
		{
			double charge = 0;
			err = interfaceCChemIESComputedDipole(qmModel->interfaceLibN2P2ES, mol, dmu, &charge);
			/*
			if(!err)
			{
				fprintf(stderr,"charge NN = %f\n",charge);
				fprintf(stderr,"dipole NN = %f %f %f\n",mol->dipole[0], mol->dipole[1],mol->dipole[2]);
			}
			else fprintf(stderr,"Error NN charge & dipole calculationn\n");
			*/
			
		}
	}
	else
	{
		fprintf(stderr,"Error : in interfaceCChemIComputeHessian, Stopped\n");
		exit(1);
	}

}
/**********************************************************************/
static QuantumMechanicsModel newN2P2Model(char*  HNNDir, Constraints constraints, FILE* logfile)
{
	QuantumMechanicsModel qmModel = newQuantumMechanicsModel(NULL, NULL, NULL, HNNDir, NULL, constraints, logfile);
	double cfenergy = 1.0/(AUTOKCAL);
	double cflength = ANGTOBOHR;
	double cfdipole = 1.0/(AUTODEB);

	qmModel.interfaceLibN2P2 = newInterfaceCChemI(HNNDir, cflength, cfenergy, 0);
	qmModel.interfaceLibN2P2ES = newInterfaceCChemIES(HNNDir, cflength, cfdipole, 0);
	qmModel.klass->calculateGradient = calculateGradientN2P2;
	qmModel.klass->calculateHessian = calculateHessianN2P2;
	qmModel.klass->calculateEnergy = calculateEnergyN2P2;
	return qmModel;
}
/**********************************************************************/
QuantumMechanicsModel createN2P2Model (Molecule* mol, char* HNNDir, Constraints constraints, FILE* logfile)
{
	QuantumMechanicsModel qmModel = newN2P2Model(HNNDir, constraints, logfile);

	qmModel.molecule = *(mol->klass->copy(mol));
	qmModel.molecule.constraints = constraints;
	qmModel.klass->setRattleConstraintsParameters(&qmModel);
	
	return qmModel;
}
/**********************************************************************/
#ifdef ENABLE_PYTHON
static void calculateEnergyTM(QuantumMechanicsModel* qmModel)
{
	int err = 0;
	Molecule* mol = &qmModel->molecule;
	if(!qmModel) return;
	if(qmModel->molecule.nAtoms<1) return;
	err = interfaceTMComputeEnergy(qmModel->interfaceTM, mol);
	if(!err)
	{
		addH4Correction(qmModel,TRUE);
		addSRBCorrection(qmModel,TRUE);
		addD3Correction(qmModel,TRUE);
		addWallCorrection(qmModel,TRUE);
		//getDipoleTM(fileOut, qmModel->molecule.dipole);
		
	}
	else
	{
		fprintf(stderr,"Error : in interfaceTMComputeForces, Stopped\n");
		exit(1);
	}

}
/**********************************************************************/
static void calculateGradientTM(QuantumMechanicsModel* qmModel)
{
	int err = 0;
	Molecule* mol = &qmModel->molecule;
	if(!qmModel) return;
	if(qmModel->molecule.nAtoms<1) return;

	err = interfaceTMComputeGradients(qmModel->interfaceTM, mol);
	if(!err)
	{
		addH4Correction(qmModel,TRUE);
		addSRBCorrection(qmModel,TRUE);
		addD3Correction(qmModel,TRUE);
		addWallCorrection(qmModel,TRUE);
		//getDipoleTM(fileOut, qmModel->molecule.dipole);
	}
	else
	{
		fprintf(stderr,"Error : in interfaceTMComputeForces, Stopped\n");
		exit(1);
	}

}
/**********************************************************************/
static QuantumMechanicsModel newTMModel(char*  tmModule, Constraints constraints, FILE* logfile)
{
	QuantumMechanicsModel qmModel = newQuantumMechanicsModel(NULL, NULL, NULL, tmModule, NULL, constraints, logfile);

	qmModel.interfaceTM = newInterfaceTM(tmModule);
	qmModel.klass->calculateGradient = calculateGradientTM;
	qmModel.klass->calculateEnergy = calculateEnergyTM;
	return qmModel;
}
/**********************************************************************/
QuantumMechanicsModel createTMModel (Molecule* mol, char* tmModule, Constraints constraints, FILE* logfile)
{
	QuantumMechanicsModel qmModel = newTMModel(tmModule, constraints, logfile);

	qmModel.molecule = *(mol->klass->copy(mol));
	qmModel.molecule.constraints = constraints;
	qmModel.klass->setRattleConstraintsParameters(&qmModel);
	
	return qmModel;
}
#else
/**********************************************************************/
QuantumMechanicsModel createTMModel (Molecule* mol, char* tmModule, Constraints constraints, FILE* logfile)
{
	QuantumMechanicsModel qmModel;
	fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
	fprintf(stderr," If you want to use the interface to TensorMol software\n");
	fprintf(stderr," You must compile cchemi with enable_python = 1 in CONFIG file\n");
	fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
	exit(1);
	return qmModel;
}
#endif /* ENABLE_PYTHON */
File: ./cchemilib/src/QuantumMechanics/GeneticAlgorithm.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* GeneticAlgorithm.c */

#include "QuantumMechanics.h"
#include "GeneticAlgorithm.h"

static void freeGeneticAlgorithm(GeneticAlgorithm* ga);
static void evaluatePopulation(GeneticAlgorithm* ga);
static void saveGeometries(GeneticAlgorithm* ga);
static void elitist(GeneticAlgorithm* ga);
static void applyMutation(GeneticAlgorithm* ga);
static void makeSelection(GeneticAlgorithm* ga);
static void makeCrossover(GeneticAlgorithm* ga);
static void run(GeneticAlgorithm* ga);
static boolean runOneOptGeneric(QuantumMechanicsModel* qm, char* fileNamePrefix, FILE* logfile);
static boolean runGenericFiles(int numberOfGeometries, QuantumMechanicsModel** qm, char* fileNamePrefix, FILE* logfile);
static void computeEnergies(GeneticAlgorithm* ga);
static void computeChildsEnergies(GeneticAlgorithm* ga);
static void computePseudoInertia(GeneticAlgorithm* ga);
static void computePopPseudoInertia(GeneticAlgorithm* ga);
static void computeChildsPseudoInertia(GeneticAlgorithm* ga);
static void printPopEnergies(GeneticAlgorithm* ga);
static void printChildsEnergies(GeneticAlgorithm* ga);
static void printEnergies(GeneticAlgorithm* ga);
static void savePopGeometries(GeneticAlgorithm* ga);
static void saveChildsGeometries(GeneticAlgorithm* ga);
static void savePopEnergies(GeneticAlgorithm* ga, FILE* file);
static void saveChildsEnergies(GeneticAlgorithm* ga, FILE* file);
/*********************************************************************************************************************/
static void freeGeneticAlgorithm(GeneticAlgorithm* ga)
{
	if(ga->fun) free(ga->fun);
	if(ga->FitnessFun) free(ga->FitnessFun);
	if(ga->pseudoInertia) free(ga->pseudoInertia);
	if(ga->childsPseudoInertia) free(ga->childsPseudoInertia);
	if(ga->suffixFileName) free(ga->suffixFileName);
	if(ga->inputFileName) free(ga->inputFileName);
}
/*********************************************************************************************************************/
static void computeEnergies(GeneticAlgorithm* ga)
{
	runGenericFiles(ga->popSize, ga->pop, ga->suffixFileName,ga->logfile);
	// TEST, TO REMOVE
	/*
	computePopPseudoInertia(ga); 
	for (int i=0; i<ga->popSize; i++) 
		ga->pop[i]->molecule.potentialEnergy=ga->pseudoInertia[i];
		*/
}
/*********************************************************************************************************************/
static void computeChildsEnergies(GeneticAlgorithm* ga)
{
	runGenericFiles(ga->nChilds, ga->childs, ga->suffixFileName, ga->logfile);
	// TEST, TO REMOVE
	/*
	computeChildsPseudoInertia(ga); 
	for (int i=0; i<ga->nChilds; i++) 
		if(ga->childs[i])
			ga->childs[i]->molecule.potentialEnergy=ga->childsPseudoInertia[i];
			*/
}
/*********************************************************************************************************************/
static void computePopPseudoInertia(GeneticAlgorithm* ga)
{
	int i;
	for (i=0; i<ga->popSize; i++) 
	{
		Molecule* mol =  &ga->pop[i]->molecule;
		double I2;
		double I4;
		mol->klass->computePseudoInertia(mol, &I2, &I4);
		ga->pseudoInertia[i] = I4+I2;
	}
}
/*********************************************************************************************************************/
static void computeChildsPseudoInertia(GeneticAlgorithm* ga)
{
	int i;
	for (i=0; i<ga->nChilds; i++) 
	{
		if(!ga->childs[i]) continue;
		Molecule* mol =  &ga->childs[i]->molecule;
		double I2;
		double I4;
		mol->klass->computePseudoInertia(mol, &I2, &I4);
		ga->childsPseudoInertia[i] = I4+I2;
	}
}
/*********************************************************************************************************************/
static void computePseudoInertia(GeneticAlgorithm* ga)
{
	computePopPseudoInertia(ga);
	computeChildsPseudoInertia(ga);
}
/*********************************************************************************************************************/
static void printPopEnergies(GeneticAlgorithm* ga)
{
	fprintf(ga->logfile,"Energies of generation # %-12d : ",ga->numGen);
	int i;
	for (i=0; i<ga->popSize; i++) 
	{
		Molecule* mol =  &ga->pop[i]->molecule;
		fprintf(ga->logfile,"%-14.10lf ",mol->potentialEnergy);
		if((i+1)%5==0) fprintf(ga->logfile,"\n %39s"," ");
	}
	fprintf(ga->logfile,"\n");
	fflush(ga->logfile);
}
/*********************************************************************************************************************/
static void printChildsEnergies(GeneticAlgorithm* ga)
{
	fprintf(ga->logfile,"Childs energies of generation # %-5d : ",ga->numGen);
	int i;
	for (i=0; i<ga->nChilds; i++) 
	{
		if(!ga->childs[i]) continue;
		Molecule* mol =  &ga->childs[i]->molecule;
		fprintf(ga->logfile,"%-14.10lf ",mol->potentialEnergy);
		if((i+1)%5==0) fprintf(ga->logfile,"\n %39s"," ");
	}
	fprintf(ga->logfile,"\n");
	fflush(ga->logfile);
}
/*********************************************************************************************************************/
static void printEnergies(GeneticAlgorithm* ga)
{
	printPopEnergies(ga);
	printChildsEnergies(ga);
}
/*********************************************************************************************************************/
static FILE* openFile(GeneticAlgorithm* ga, char* name, char* message)
{
	char* suff = ga->suffixFileName;
	FILE* file=NULL;
	char tmp[BSIZE];
	sprintf(tmp,"%s_%s_GA.txt",suff,name);
	file = fopen(tmp,"w");
	if(message) fprintf(ga->logfile,"%s %s\n",message,tmp);
	return file;
}
/*********************************************************************************************************************/
static void savePopEnergies(GeneticAlgorithm* ga,FILE* file)
{
	int i;
	for (i=0; i<ga->popSize; i++) 
	{
		Molecule* mol =  &ga->pop[i]->molecule;
		fprintf(file,"%-20.12lf\n",mol->potentialEnergy);
	}
	fflush(file);
}
/*********************************************************************************************************************/
static void saveChildsEnergies(GeneticAlgorithm* ga,FILE* file)
{
	int i;
	for (i=0; i<ga->nChilds; i++) 
	{
		if(!ga->childs[i]) continue;
		Molecule* mol =  &ga->childs[i]->molecule;
		fprintf(file,"%-20.12lf\n",mol->potentialEnergy);
	}
	fflush(file);
}
/*********************************************************************************************************************/
static void evaluatePopulation(GeneticAlgorithm* ga)
{
	int i;
	for (i=0; i<ga->popSize; i++) ga->fun[i] = ga->pop[i]->molecule.potentialEnergy;
	// Evaluate the population
	double emax =  ga->pop[0]->molecule.potentialEnergy;
	double emin =  ga->pop[0]->molecule.potentialEnergy;
	for (i=0; i<ga->popSize; i++) 
		if(emin>ga->pop[i]->molecule.potentialEnergy) 
			emin=ga->pop[i]->molecule.potentialEnergy;
	for (i=0; i<ga->popSize; i++) 
		if(emax<ga->pop[i]->molecule.potentialEnergy) 
			emax=ga->pop[i]->molecule.potentialEnergy;

	double de=emax-emin;
	if(de<=0) de =1;
	// Population fitness
	for (i=0; i<ga->popSize; i++) 
	{
		// Roy L. Johnston Dalton Trans. 2003, 4193-4207 
		double rho = (ga->pop[i]->molecule.potentialEnergy-emin)/de;
		ga->FitnessFun[i] = exp(-3.0*rho);
		/*
		ga->FitnessFun[i] = 1-0.7*rho;
		ga->FitnessFun[i] = 0.5*(1-tanh(2*rho-1));
		*/
	}
	//cout<<"End Calcul "<<endl;

	ga->fmin = ga->fun[0];
	for (i=1; i<ga->popSize; i++) 
		if(ga->fmin > ga->fun[i]) 
			ga->fmin = ga->fun[i]; 


}
/*********************************************************************************************************************/
/*
static void saveGeometries(GeneticAlgorithm* ga)
{
	char* suff = ga->suffixFileName;
	char tmp[BSIZE];
	for (int i=0; i<ga->popSize; i++) 
	{
		sprintf(tmp,"%s%d_GA.gab",suff,i+1);
		Molecule* mol= &ga->pop[i]->molecule;
		mol->klass->save(mol,tmp);
	}
}
*/

/*********************************************************************************************************************/
static void saveGeometriesInGabeditFile(GeneticAlgorithm* ga,char* fileNameGab)
{
	FILE* file = NULL;
	int form = 1;
	int nG=0;
	int* index =NULL;
	int i;

	if(ga->popSize<1) return;
	if(!ga->pop) return;
	for(i=0;i<ga->popSize;i++) if(ga->pop[i]) nG++;
	if(nG<1) return;
	//fprintf(stderr,"nG=%d\n",nG); fflush(stderr);
 	file = fopen(fileNameGab, "w");
	if(!file) return;
	// index by energy values
	index = malloc(ga->popSize*sizeof(int));
	for(i=0;i<ga->popSize;i++) index[i] = i;

	for(i=0;i<ga->popSize;i++) 
	{
		int ii=index[i];
		if(!ga->pop[ii]) continue;
		int k=i;
		int j;
		for(j=i+1;j<ga->popSize;j++) 
		{
			int jj=index[j];
			if(!ga->pop[jj]) continue;
			if(ga->pop[jj]->molecule.potentialEnergy<ga->pop[index[k]]->molecule.potentialEnergy) k=j;

		}
		if(k!=i)
		{
			int t=index[i];
			index[i]= index[k];
			index[k]= t;
		}
	}
	//fprintf(stderr,"end sorting\n"); fflush(stderr);


	fprintf(file,"[Gabedit Format]\n");
	fprintf(file,"[GEOCONV]\n");
	fprintf(file,"energy\n");
	for(i=0;i<ga->popSize;i++) if(ga->pop[index[i]]) fprintf(file,"%f\n",ga->pop[index[i]]->molecule.potentialEnergy);
	fprintf(file,"max-force\n");
	for(i=0;i<nG;i++) fprintf(file,"0.0\n");
	fprintf(file,"rms-force\n");
	for(i=0;i<nG;i++) fprintf(file,"0.0\n");
	fprintf(file,"\n");
	fprintf(file,"[GEOMETRIES]\n");
	for (i=0; i<ga->popSize; i++) 
	{
		int id=index[i];
		Molecule* mol;
		if(!ga->pop[id]) continue;
		mol =  &ga->pop[id]->molecule;

		fprintf(file,"%d\n",mol->nAtoms);
		fprintf(file,"%d %d\n",mol->totalCharge, mol->spinMultiplicity);
		int j;
		for(j=0;j<mol->nAtoms;j++)
		fprintf(file," %s %0.8f %0.8f %0.8f\n", 
				mol->atoms[j].prop.symbol,
				mol->atoms[j].coordinates[0],
				mol->atoms[j].coordinates[1],
				mol->atoms[j].coordinates[2]
				);
	}
	//fprintf(stderr,"end save first part\n"); fflush(stderr);
	fprintf(file,"\n");
	fprintf(file,"[GEOMS] %d\n",form);
	fprintf(file,"%d 2\n",nG);
	fprintf(file,"energy kcal/mol 1\n");
	fprintf(file,"deltaE eV 1\n");
	int k=-1;
	double e0=0;
	for (i=0; i<ga->popSize; i++) 
	{
		int id=index[i];
		Molecule* mol;
		if(!ga->pop[id]) continue;
		mol =  &ga->pop[id]->molecule;
		if(k<0){ 
			k=i; 
			e0=ga->pop[index[k]]->molecule.potentialEnergy;
		}
		fprintf(file,"%f\n",mol->potentialEnergy);

		//if(k>=0) fprintf(file,"%f\n",(mol->potentialEnergy-e0)*503.21892494);// in K
		if(k>=0) fprintf(file,"%f\n",(mol->potentialEnergy-e0)*0.04336410);// in eV
		else fprintf(file,"0\n");
		mol->klass->addGeometryToGabedit(mol, file);
	}
	//fprintf(stderr,"end save second part\n"); fflush(stderr);
	fclose(file);
	k = -1;
	free(index);
	fprintf(ga->logfile,"Population of the GA are saved in %s\n",fileNameGab);
}
/*********************************************************************************************************************/
static void saveGeometries(GeneticAlgorithm* ga)
{
	char* suff = ga->suffixFileName;
	char tmp[BSIZE];
	sprintf(tmp,"%s_Gen%d_GA.gab",suff,ga->numGen);
	saveGeometriesInGabeditFile(ga,tmp); 
}
/*********************************************************************************************************************/
static void saveFinalGeometries(GeneticAlgorithm* ga)
{
	char tmp[BSIZE];
	int nG=0;
	int i;

	if(ga->popSize<1) return;
	if(!ga->pop) return;
	for(i=0;i<ga->popSize;i++) if(ga->pop[i]) nG++;
	if(nG<1) return;
	
	QuantumMechanicsModel* qm=NULL;
	int nGeoms=ga->popSize;
	for(i=0;i<ga->popSize;i++) { if(ga->pop[i]) qm=ga->pop[i]; break;}
	nGeoms =ga->popSize;
	if(qm)
	{
		if(ga->removeSimilarInertia) 
			qm->klass->removeSimilarInertiaGeometries(ga->pop, &nGeoms, ga->fun,ga->logfile,ga->inertiaTol); 
		if(ga->removeFragmented) 
			qm->klass->removeFragmentedMolecules(ga->pop, &nGeoms, ga->fun, ga->logfile);
		if(ga->removeSmallDistance) 
			qm->klass->removeSmallDistanceMolecules(ga->pop, &nGeoms, ga->fun, ga->logfile);
		if(ga->removeSimilarBonds) 
			qm->klass->removeSimilarBondsGeometries(ga->pop, &nGeoms, ga->fun,ga->logfile,ga->sTol, ga->distMaxTol);
	}
	ga->popSize=nGeoms;

	//fprintf(stderr,"nG=%d\n",nG); fflush(stderr);

	sprintf(tmp,"%s_FinalGen_GA.gab",ga->suffixFileName);
	saveGeometriesInGabeditFile(ga,tmp); 
}
/*********************************************************************************************************************/
static void saveGeometry(Molecule* mol, int nGeoms, char* suff)
{
	char fname[BSIZE];
	sprintf(fname,"%s_SelectedGeom%d_GA.gab",suff, nGeoms);
	mol->klass->save(mol,fname);
}
/*********************************************************************************************************************/
static void savePopGeometries(GeneticAlgorithm* ga)
{
	char* suff = ga->suffixFileName;
	char fname[BSIZE];
	int ibegin= 1;
	int i;
	for (i=0; i<ga->popSize; i++) 
	{
		Molecule* mol = &ga->pop[i]->molecule;
		sprintf(fname,"%s_GeomNumber%d_GA.gab",suff,ibegin+i);
		mol->klass->save(mol,fname);
	}
}
/*********************************************************************************************************************/
static void saveChildsGeometries(GeneticAlgorithm* ga)
{
	char* suff = ga->suffixFileName;
	char fname[BSIZE];
	int ibegin= ga->popSize+(ga->numGen-1)*ga->nChilds+1;
	int i;
	for (i=0; i<ga->nChilds; i++) 
	{
		if(!ga->childs[i]) continue;
		Molecule* mol = &ga->childs[i]->molecule;
		sprintf(fname,"%s_GeomNumber%d_GA.gab",suff,ibegin+i);
		mol->klass->save(mol,fname);
	}
}
/*********************************************************************************************************************/
static void elitist(GeneticAlgorithm* ga)
{
	// Elitist
	int ic;
	for(ic=0;ic<ga->nChilds;ic++)
	{
		if(!ga->childs[ic]) continue;
		Molecule* mol = &ga->childs[ic]->molecule;
		double childEnergy = ga->childs[ic]->molecule.potentialEnergy;
		int ir=-1;
		int i;
		for (i=0; i<ga->popSize; i++) 
			if(mol->klass->similarInertia(mol, &ga->pop[i]->molecule, 0.04)) { 
				ir = i; 
				break;
			}

		if(ir==-1)
		{
			int imax = 0;
			int i;
			for (i=1; i<ga->popSize; i++) 
				if(ga->pop[i]->molecule.potentialEnergy > ga->pop[imax]->molecule.potentialEnergy) imax = i;
			if(ga->pop[imax]->molecule.potentialEnergy > childEnergy) ir = imax;
		}
		//fprintf(ga->logfile,"ir=%d\n",ir); fflush(ga->logfile);

		if(ir>-1 && childEnergy<ga->pop[ir]->molecule.potentialEnergy)
		{
			ga->nGeoms++;
			saveGeometry(mol, ga->nGeoms,ga->suffixFileName);
			fflush(ga->logfile);
			fprintf(ga->fileSelectedEnergies,"%-20.12lf\n",mol->potentialEnergy);

			ga->pop[ir]->klass->free(ga->pop[ir]);
			ga->pop[ir] = ga->childs[ic];
			ga->childs[ic]=NULL;
		}
		else
		{
			ga->childs[ic]->klass->free(ga->childs[ic]);
			ga->childs[ic]=NULL;
		}
	}
	ga->klass->evaluatePopulation(ga);

}
/*********************************************************************************************************************/
static void applyMutation(GeneticAlgorithm* ga)
{
	//int itr = ga->numGen-1;
	int i;
	for (i=0; i<ga->nChilds; i++)
	{
		double r = rand()/(double)(RAND_MAX);
		if(r < ga->pMutation) 
		{
			if(ga->mutationType ==GA_MUTATION_SPHERICAL_LOCAL)
				ga->childs[i]->molecule.klass->makeLocalSphericalMutation(&ga->childs[i]->molecule,0.05);
			else if(ga->mutationType ==GA_MUTATION_SPHERICAL_GLOBAL)
				ga->childs[i]->molecule.klass->makeCenterOfMassSphericalMutation(&ga->childs[i]->molecule);
		}
	}
}
/*********************************************************************************************************************/
static void makeSelection(GeneticAlgorithm* ga)
{
	double p[ga->popSize];
	double q[ga->popSize];
	double fit = 0;
	double cProb = 0;
	double r;
	//int crossPos[ga->popSize];

	fit = 0;
	int i;
	for (i=0; i<ga->popSize; i++) fit += ga->FitnessFun[i];
	q[0] = 0;
	cProb = 0;
	// Cummulative probability of individuals
	for (i=0; i<ga->popSize; i++)
	{
		p[i] = ga->FitnessFun[i]/fit;
		cProb += p[i];
		q[i] = cProb;
	}
	// Selection process
	for (i=0; i<ga->nChilds; i++)
	{
		int j;
		r = rand()/(double)(RAND_MAX);
		if (r < q[0]) ga->parent1[i]=i;
		else for (j=1; j<ga->popSize; j++) if ( (r > q[j-1]) && (r < q[j]) ) ga->parent1[i] = j;
		for (j=0; j<ga->popSize; j++) 
		{
			if(ga->parent1[i] == j) continue;
			ga->parent2[i]=j;
			boolean alreadyUsed=FALSE;
			int k;
			for (k=0; k<i; k++) 
			{
				if(ga->parent1[i] == ga->parent1[k] && ga->parent2[i] == ga->parent2[k] ) { alreadyUsed=TRUE; break;}
				if(ga->parent1[i] == ga->parent2[k] && ga->parent2[i] == ga->parent1[k] ) { alreadyUsed=TRUE; break;}
			}
			if(!alreadyUsed) break;
		}

	}
}
/*********************************************************************************************************************/
static void makeCrossover(GeneticAlgorithm* ga)
{
	// Arithmetic Crossover
	Molecule* molChild = NULL;
	QuantumMechanicsModel* p1=NULL;
	QuantumMechanicsModel* p2=NULL;
	int err = 0;
	//for (int i=0; i<ga->nChilds; i++) { fprintf(stderr,"Child %d P1=%d P2=%d\n",i+1,ga->parent1[i], ga->parent2[i]); fflush(stderr); }

	int i;
	for (i=0; i<ga->nChilds; i++)
	{
		p1=ga->pop[ga->parent1[i]];
		p2=ga->pop[ga->parent2[i]];
		if(ga->childs[i]) ga->childs[i]->klass->free(ga->childs[i]);
		ga->childs[i] = malloc(sizeof(QuantumMechanicsModel));
		Molecule* mol1 = &p1->molecule;
		Molecule* mol2 = &p2->molecule;
		err = 0;
		if(ga->crossType == GA_CROSS_PLANE) molChild = mol1->klass->makePlaneCutSpliceCrossover(mol1, mol2, &err);
		else if(ga->crossType == GA_CROSS_SPHERICAL ) molChild = mol1->klass->makeSphereCutSpliceCrossover(mol1, mol2, &err);

		//if(err!=0) continue;
		*ga->childs[i] = createGenericModel(molChild, p1->method, p1->workDir, p1->nameCommand, p1->molecule.constraints, p1->logfile);
	}
}
/*********************************************************************************************************************/
static void printLine(FILE* logfile, char* s)
{
	int i;
        for(i=0;i<120;i++) 
		fprintf(logfile,"%s",s); 
	fprintf(logfile,"\n");
}
/*********************************************************************************************************************/
static void run(GeneticAlgorithm* ga)
{
	ga->fileAllEnergies = openFile(ga, "AllEnergies", "All energies saved in");
	ga->fileSelectedEnergies = openFile(ga, "SelectedEnergies", "Selected energies saven in");
	// TO DO 
	ga->klass->computeEnergies(ga);
	computePseudoInertia(ga);

	//fprintf(stderr,"evaluatePopulation\n"); fflush(stderr);
	ga->klass->evaluatePopulation(ga);
	//fprintf(stderr,"end evaluatePopulation\n"); fflush(stderr);
	savePopGeometries(ga);
	savePopEnergies(ga,ga->fileAllEnergies);
	savePopEnergies(ga,ga->fileSelectedEnergies);
	
	// Evaluate Generations
	//fprintf(stderr,"initial value %f\n",ga->fmin); fflush(stderr);
	ga->klass->saveGeometries(ga);
	//fprintf(stderr,"end save geometries\n"); fflush(stderr);
	printLine(ga->logfile, "=");
        fprintf(ga->logfile,"Step # %d/%d Fmin= %f\n",0,ga->maxGens,ga->fmin);
	printLine(ga->logfile, "=");
	int itr;
	for (itr=0; itr<ga->maxGens; itr++)
	{
		/*
                fprintf(stderr,"Step # %d/%d Fmin= %f\n",itr,ga->maxGens,ga->fmin);
                fprintf(stderr,"Begin makeSel\n");
		fflush(stderr);
		*/
		ga->numGen = itr+1;
		ga->klass->makeSelection(ga);

		ga->klass->makeCrossover(ga);
		ga->klass->applyMutation(ga);
                fprintf(ga->logfile,"After crossing & mutation\n");
                fprintf(ga->logfile,"=========================\n");
		ga->klass->computeChildsEnergies(ga);
		computeChildsPseudoInertia(ga);
		printEnergies(ga);
		/*
                fprintf(stderr,"Begin makeCross\n"); fflush(stderr);
		ga->klass->makeCrossover(ga);
                fprintf(ga->logfile,"After crossing\n");
                fprintf(ga->logfile,"==============\n");
		ga->klass->computeChildsEnergies(ga);
		computeChildsPseudoInertia(ga);
		printEnergies(ga);

                fprintf(stderr,"Begin applyMutation\n"); fflush(stderr);
		ga->klass->applyMutation(ga);
                fprintf(ga->logfile,"After mutation\n");
                fprintf(ga->logfile,"==============\n");
		ga->klass->computeChildsEnergies(ga);
		printEnergies(ga);
		*/

		saveChildsEnergies(ga,ga->fileAllEnergies);

		// before elitist to take all geoms inluding if not selected 
		saveChildsGeometries(ga);

                //fprintf(stderr,"Begin elitist\n"); fflush(stderr);
		ga->klass->elitist(ga);
		ga->klass->saveGeometries(ga);
                fprintf(ga->logfile,"Step # %d/%d Fmin= %f\n",itr+1,ga->maxGens,ga->fmin);
		printLine(ga->logfile, "=");
                fflush(ga->logfile);
	}
	saveFinalGeometries(ga);
	if(ga->fileAllEnergies) fclose(ga->fileAllEnergies);
	if(ga->fileSelectedEnergies) fclose(ga->fileSelectedEnergies);
	ga->fileAllEnergies = NULL;
	ga->fileSelectedEnergies = NULL;
}
/*********************************************************************************************************************/
static boolean getEnergyGeneric(char* fileNameOut, double* energy)
{
	FILE* file = NULL;
	char buffer[1024];
	int i;
 	file = fopen(fileNameOut, "r");
	if(!file) return FALSE;
	if(!fgets(buffer,BSIZE,file)) { fclose(file); return FALSE;}/* first line for energy in Hartree*/

	for(i=0;i<strlen(buffer);i++) if(buffer[i]=='D' || buffer[i]=='d') buffer[i] ='E';
	if(sscanf(buffer,"%lf",energy)==1)
	{
		fclose(file);
		*energy *=AUTOKCAL;
		return TRUE;
	}
	fclose(file);
	return FALSE;
}
/***********************************************************************************************************************/
static boolean runOneOptGeneric(QuantumMechanicsModel* qm, char* fileNamePrefix, FILE* logfile)
{
	char* keyWords = "OPT";
	char* genericCommand = qm->nameCommand;
	FILE* file = NULL;
	FILE* fileSH = NULL;
	char* fileNameIn = NULL;
	char* fileNameOut = NULL;
	char* fileNameLog = NULL;
	char* fileNameSH = NULL;
	char buffer[1024];
	int ir;
	int type = 0;
	Molecule* mol = &qm->molecule;
	mol->potentialEnergy=1e10;
	fflush(logfile);
#ifdef OS_WIN32
	char c='%';
#endif
	if(!qm) { fprintf(logfile,"Error qm=NULL\n"); fflush(logfile);}
	if(!qm) return FALSE;
	if(qm->molecule.nAtoms<1) { fprintf(logfile,"Error nAtoms<1\n"); fflush(logfile);}
	if(qm->molecule.nAtoms<1) return FALSE;
#ifndef OS_WIN32
	if(fileNamePrefix[0]=='/') fileNameSH = strdup_printf("%sGeneOne.sh",fileNamePrefix);
	else fileNameSH = strdup_printf("./%sGeneOne.sh",fileNamePrefix);
#else
	fileNameSH = strdup_printf("%sGeneOne.bat",fileNamePrefix);
#endif
 	fileSH = fopen(fileNameSH, "w");
	if(!fileSH) 
	{
		fprintf(logfile,"I cannot create %s\n",fileNameSH); fflush(logfile);
		return FALSE;
	}

	fileNameIn = strdup_printf("%sOne.inp",fileNamePrefix);
	fileNameOut = strdup_printf("%sOne.out",fileNamePrefix);

	fileNameLog = strdup_printf("%sOne.log",fileNamePrefix);

 	file = fopen(fileNameIn, "w");
	if(!file) 
	{
		fprintf(logfile,"I cannot create %s\n",fileNameIn); fflush(logfile);
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
 		if(fileNameLog) free(fileNameLog);
		return FALSE;
	}

	if(strstr(keyWords,"Opt")) type = 2;
	if(strstr(keyWords,"OPT")) type = 2;
	if(strstr(keyWords,"ENGRAD")) type = 1;
	fprintf(file,"%d\n",type);
	mol->klass->addMolecule(mol,file);
	fclose(file);
	/*
	{
		char* str = NULL;
		if(strstr(keyWords,"OPT")) str = strdup_printf("Minimization by Generic/%s ... Please wait",genericCommand);
		else str = strdup_printf("Computing of energy by Generic/%s .... Please wait ",genericCommand);
		fprintf(logfile,"%s\n",str);
		fflush(logfile);
		if(str) free(str);
	}
	*/
	//fprintf(stdout,"1=====>%s %s %s\n",genericCommand,fileNameIn,fileNameOut);
#ifndef OS_WIN32
	//fprintf(stdout,"2=====>%s %s %s\n",genericCommand,fileNameIn,fileNameOut);
	//fprintf(fileSH,"%s %s %s",genericCommand,fileNameIn,fileNameOut);
	fprintf(fileSH,"#!/bin/bash\n");
	fprintf(fileSH,"%s %s %s >& %s",genericCommand,fileNameIn,fileNameOut, fileNameLog);
	fclose(fileSH);

	//sprintf(buffer,"cat %s",fileNameSH); fprintf(stdout,"%s\n",buffer);system(buffer); fflush(stdout);
	//sprintf(buffer,"cat %s",fileNameIn); ir=system(buffer); fprintf(logfile,"ir=%d\n",ir); fflush(logfile);

	sprintf(buffer,"chmod u+x %s",fileNameSH);
	ir=system(buffer);
	if(ir!=0) { fprintf(logfile,"ir=%d\n",ir); fflush(logfile); }
	ir=system(fileNameSH);
	if(ir!=0) { fprintf(logfile,"ir=%d\n",ir); fflush(logfile); }

	//sprintf(buffer,"cat %s",fileNameOut); ir=system(buffer); fprintf(logfile,"ir=%d\n",ir); fflush(logfile);
#else
	//fprintf(fileSH,"\"%s\" \"%s\" \"%s\"",genericCommand,fileNameIn,fileNameOut);
	fprintf(fileSH,"\"%s\" \"%s\" \"%s\" >& \"%s\"",genericCommand,fileNameIn,fileNameOut, fileNameLog);
	fclose(fileSH);
	sprintf(buffer,"\"%s\"",fileNameSH);
	system(buffer);
#endif
	boolean ok=TRUE;
	if(getEnergyGeneric(fileNameOut,&mol->potentialEnergy))
	{
		fprintf(logfile,"Energy by Generic = %f\n", mol->potentialEnergy);
		fflush(logfile);
		ok=mol->klass->readGeometry(mol,fileNameOut);
	}
	else ok=FALSE;

 	remove(fileNameIn);
 	remove(fileNameOut);
 	remove(fileNameSH);
 	remove(fileNameLog);
 	if(fileNameIn) free(fileNameIn);
 	if(fileNameOut) free(fileNameOut);
 	if(fileNameSH) free(fileNameSH);
 	if(fileNameLog) free(fileNameLog);
	fflush(logfile);
	return ok;
}
/*************************************************************************************************************************************************************/
static boolean runGenericFiles(int numberOfGeometries, QuantumMechanicsModel** qm, char* fileNamePrefix, FILE* logfile)
{
	int i;
	int nG = 0;
	int nM = 0;
	char buffer[BSIZE];
	for(i=0;i<numberOfGeometries;i++)
	{
		if(!qm[i]) continue;
		nG++;
		fprintf(logfile,"Minimization by Generic of geometry n = %d... Please wait\n", i+1);
		fflush(logfile);
		sprintf(buffer,"%s%d",fileNamePrefix,i);
		if(runOneOptGeneric(qm[i], buffer, logfile)) 
		{
			nM++;
		}
		else
		{
			qm[i]->klass->free(qm[i]);
			qm[i] =NULL;
		}
		fflush(logfile);

	}
	/*
	if(nM==nG) return TRUE;
	return FALSE;
	*/
	fprintf(logfile,"Number of generic runs with errors = %d\n", nG-nM); fflush(logfile);
	fprintf(logfile,"-------------------------------------------\n"); fflush(logfile);
	return (nM>0);

}
/*********************************************************************************************************************/
static boolean checkSizes(GeneticAlgorithm* ga)
{
	if(ga->nChilds<1) ga->nChilds = 1;
	if(ga->popSize<2) return FALSE;
	// can be extended to popSize*(popSize-1)/2;
	if(ga->nChilds>ga->popSize-1) ga->nChilds = ga->popSize-1;
	return TRUE;
}

/*********************************************************************************************************************/
static void initTables(GeneticAlgorithm* ga)
{
	ga->fun =(double*)malloc(ga->popSize*sizeof(double));
	ga->FitnessFun =(double*)malloc(ga->popSize*sizeof(double));
	ga->pseudoInertia =(double*)malloc(ga->popSize*sizeof(double));
	ga->childsPseudoInertia =(double*)malloc(ga->popSize*sizeof(double));
	if(ga->nChilds>0) ga->parent1 =(int*)malloc(ga->nChilds*sizeof(int));
	if(ga->nChilds>0) ga->parent2 =(int*)malloc(ga->nChilds*sizeof(int));
	if(ga->nChilds>0) ga->childs =(QuantumMechanicsModel**)malloc(ga->nChilds*sizeof(QuantumMechanicsModel*));
	int i;
	for(i=0;i<ga->nChilds;i++) ga->childs[i] = NULL;
}
/*********************************************************************************************************************/
static void setMethods(GeneticAlgorithm* ga)
{
	ga->klass = (GeneticAlgorithmClass*)malloc(sizeof(GeneticAlgorithmClass));

	ga->klass->free = freeGeneticAlgorithm;
	ga->klass->run = run;
	ga->klass->evaluatePopulation = evaluatePopulation;
	ga->klass->saveGeometries = saveGeometries ;
	ga->klass->elitist = elitist ;
	ga->klass->applyMutation = applyMutation ;
	ga->klass->makeSelection = makeSelection ;
	ga->klass->makeCrossover = makeCrossover;
	ga->klass->computeEnergies = computeEnergies ;
	ga->klass->computeChildsEnergies = computeChildsEnergies ;
}
/*********************************************************************************************************************/
static void readParameters(GeneticAlgorithm* ga)
{
	char* dirName = NULL;
	char* QMKeys = NULL;
	int maxGen=100;
	int nChilds;
	double pCross=0.5;
	double pMut=0.08;
	FILE* logfile = stdout;
	FILE* file = fopen(ga->inputFileName,"rb");
	char* genericCommand=strdup("runGeneric");
	CCHEMIGACrossType crossType =  GA_CROSS_PLANE;
	CCHEMIGAMutationType mutationType  = GA_MUTATION_SPHERICAL_LOCAL;
	char* tmp = NULL;
	char* model = NULL;
	int popSize=-1;
	boolean chain=FALSE;
	boolean saveFirstGeom=FALSE;
	int nTimesGeoms=1;
	boolean removeSimilarInertia = FALSE;
	boolean removeFragmented = FALSE;
	boolean removeSmallDistance = FALSE;
	Constraints constraints = NOCONSTRAINTS;
	double inertiaTol = 0.04; // recomended byjun Zhao et al (2016)
       	//Comprehensive genetic algorithm for ab initio global optimisation of clusters, Molecular Simulation,
	// 42:10, 809-819, DOI: 10.1080/08927022.2015.1121386	     

	boolean removeSimilarBonds = FALSE;
	double sTol=0.02;
	double distMaxTol=0.7;
	// sTol = 0.02 , distMaxTol = 0.7 Ang, recommanded in Jorgensen et al JCTC, 2017
//Mathias S. Jrgensen , Michael N. Groves, and Bjrk Hammer
//J. Chem. Theory Comput., 2017, 13 (3), pp 14861493
//DOI: 10.1021/acs.jctc.6b01119


	model = strdup("GENERIC");
	if(readOneString(file,"Model",&model)) 
	{
		uppercase(model);
		if(!strstr(model,"GENERIC")) { 
			fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
			fprintf(stderr," Sorry, The genetic algorithim works only with Generc model\n"); 
			fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
			fflush(stderr); 
			exit(1);
		}
	}

	if(readOneString(file,"CrossType",&tmp) || readOneString(file,"GACrossType",&tmp)) 
	{
		uppercase(tmp);
		if(strstr(tmp,"SPHER")) crossType =  GA_CROSS_SPHERICAL;
	}
	if(readOneString(file,"MutationType",&tmp) || readOneString(file,"GAMutationType",&tmp)) 
	{
		uppercase(tmp);
		if(strstr(tmp,"GLOBAL")) mutationType =  GA_MUTATION_SPHERICAL_GLOBAL;
		if(strstr(tmp,"CM")) mutationType =  GA_MUTATION_SPHERICAL_GLOBAL;
	}

	readOneString(file,"genericCommand",&genericCommand);
	if(!readOneString(file,"QMKeys",&QMKeys)) QMKeys = strdup("NONE");
	readOneInt(file,"popSize",&popSize);
	readOneInt(file,"maxGen",&maxGen);
	readOneInt(file,"maxGeneration",&maxGen);
	readOneInt(file,"nChilds",&nChilds);
	readOneInt(file,"numberOfChilds",&nChilds);
	readOneReal(file,"pCross",&pCross);
	readOneReal(file,"pMut",&pMut);
	readOneReal(file,"mutationRate",&pMut);
	readOneReal(file,"pMutation",&pMut);
	if(readOneBoolean(file,"removeSimilarInertia",&removeSimilarInertia) && removeSimilarInertia) 
		readOneReal(file,"InertiaTol",&inertiaTol);

	readOneBoolean(file,"removeFragmented",&removeFragmented);
	readOneBoolean(file,"removeDissociated",&removeFragmented);
	readOneBoolean(file,"removeSmallDistance",&removeSmallDistance);

	if(readOneBoolean(file,"removeSimilarBonds",&removeSimilarBonds) && removeSimilarBonds)
	{
		readOneReal(file,"sTol",&sTol);
		readOneReal(file,"distMaxTol",&distMaxTol);
	}

	readOneBoolean(file,"RDChain",&chain);
	readOneBoolean(file,"RDSaveFirstGeom",&saveFirstGeom);
	readOneInt(file,"nTimesGeoms",&nTimesGeoms);

	ga->chain = chain ;
	ga->saveFirstGeom =saveFirstGeom ;
	ga-> nTimesGeoms=nTimesGeoms;

	dirName = strdup(getenv("PWD"));

	ga->removeSimilarInertia = removeSimilarInertia;
	ga->inertiaTol = inertiaTol;
	ga->removeFragmented = removeFragmented;
	ga->removeSmallDistance = removeSmallDistance;
	ga->removeSimilarBonds = removeSimilarBonds;
	ga->sTol = sTol;
	ga->distMaxTol = distMaxTol ;

	ga->maxGens = maxGen;
	ga->popSize = popSize;
	// pCross not used, The number of childs is fixed by nChilds (pCross=nChilds/popSize)
	ga->pCross = pCross;
	ga->pMutation = pMut;
	ga->crossType = crossType;
	ga->mutationType = mutationType;
	ga->pop = NULL;
	ga->nChilds = nChilds;

	ga->numGen = 0;
	ga->nGeoms = popSize;
	ga->fmin=0;

	ga->suffixFileName = getSuffixNameFile(ga->inputFileName);

	ga->logfile=logfile;
	ga->fileAllEnergies=NULL;
	ga->fileSelectedEnergies=NULL;

	ga->constraints = constraints;
	ga->command = genericCommand;
	ga->QMKeys = QMKeys;
	ga->dirName = dirName;
}

/*********************************************************************************************************************/
static boolean popFromInputFiles(GeneticAlgorithm* ga)
{

	//fprintf(stderr,"Begin readMolecules\n"); fflush(stderr);
	Molecule** mols = mols = readMolecules(ga->inputFileName,FALSE);
	int popSize=0;
	while(mols && mols[popSize] != NULL) popSize++;
	//fprintf(stderr,"End readMolecules popSize=%d\n",popSize); fflush(stderr);

	if(popSize<2) return FALSE;
	ga->popSize=popSize;

	int i;
	ga->pop = malloc(ga->popSize*sizeof(QuantumMechanicsModel*));
	for (i = 0; i < ga->popSize; i++ )
	{
		//fprintf(stderr,"create mol n %d\n",i+1); fflush(stderr);
		ga->pop[i] = malloc(sizeof(QuantumMechanicsModel));
		*ga->pop[i] = createGenericModel(mols[i], ga->QMKeys, ga->dirName, ga->command, ga->constraints, ga->logfile);
	}
	return TRUE;

}
/*********************************************************************************************************************/
static boolean popRandom(GeneticAlgorithm* ga)
{
	Molecule* mol = readMolecule(ga->inputFileName,TRUE);
	double* energies = NULL;

	QuantumMechanicsModel qmModel = createGenericModel(mol, ga->QMKeys, ga->dirName, ga->command, ga->constraints, ga->logfile);

/*
	setH4Correction(file,&qmModel);
	readOneBoolean(file,"addD3Correction",&qmModel.addD3Correction);
	checkWallCorrection(file, &qmModel);
*/

	int nOld = ga->popSize*ga->nTimesGeoms;
	if(ga->nTimesGeoms>1) ga->popSize = nOld;
	ga->pop = qmModel.klass->getQuantumMechanicsRDConfo(&qmModel, ga->popSize, ga->chain, ga->saveFirstGeom);

	if(ga->removeSimilarInertia) 
		qmModel.klass->removeSimilarInertiaGeometries(ga->pop, &ga->popSize, energies,ga->logfile,ga->inertiaTol);
	if(ga->removeFragmented) 
		qmModel.klass->removeFragmentedMolecules(ga->pop, &ga->popSize, energies, ga->logfile);
	if(ga->removeSmallDistance) 
		qmModel.klass->removeSmallDistanceMolecules(ga->pop, &ga->popSize, energies, ga->logfile);
	if(ga->removeSimilarBonds) 
		qmModel.klass->removeSimilarBondsGeometries(ga->pop, &ga->popSize, energies,ga->logfile,ga->sTol, ga->distMaxTol);

	if(ga->nTimesGeoms>1) qmModel.klass->cutByInertia(ga->pop, &ga->popSize, energies,nOld/ga->nTimesGeoms,ga->logfile);

	return TRUE;

}
/*********************************************************************************************************************/
GeneticAlgorithm* newGeneticAlgorithm(char* inputFileName)
{
	GeneticAlgorithm* ga= malloc(sizeof(GeneticAlgorithm));

	if(inputFileName) ga->inputFileName=strdup(inputFileName);
	else ga->inputFileName=strdup("Pop.ici");

	readParameters(ga);
	if(ga->popSize>1)
	{
		if(!popRandom(ga)) return NULL;
	}
	else
	{
		if(!popFromInputFiles(ga)) return NULL;
	}
	if(!checkSizes(ga)) return NULL;
	initTables(ga);
	setMethods(ga);
	return ga;

}
File: ./cchemilib/src/QuantumMechanics/QuasiNewtonQM.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* QuasiNewtonQM.c */
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>

#include "../Utils/Utils.h"
#include "../Utils/AtomsProp.h"
#include "../Utils/Constants.h"
#include "../Utils/Types.h"
#include "../Molecule/Molecule.h"
#include "../QuantumMechanics/QuasiNewtonQM.h"

static double maxarg1,maxarg2;
#define FMIN(a,b) (maxarg1=(a),maxarg2=(b),(maxarg1) > (maxarg2) ?(maxarg2) : (maxarg1))
#define FMAX(a,b) (maxarg1=(a),maxarg2=(b),(maxarg1) > (maxarg2) ?(maxarg1) : (maxarg2))


static int lbfgs( 
		int n , int m , double x[] , double f , double g[] ,
		int diagco , double diag[] , double eps ,
		double xtol , int maxLines,int iflag[]
	);
/**********************************************************************/
void runQuasiNewtonQM(QuasiNewtonQM* quasiNewtonQM)
{

	int j;
	int i,i3;
	int iter;
	int nAtomsX3;
	int diagco = FALSE;
	double* x = NULL;
	double* g = NULL;
	double* diag = NULL;
	int iflag = 0;
	double energy = 0;
	int nAtoms;
	int updateNumber = 0;
	char str[BSIZE];
	double gradientNorm;
	FILE* fileOut = quasiNewtonQM->logfile;

	QuantumMechanicsModel* qmModel = quasiNewtonQM->qmModel;

	if(qmModel->molecule.nAtoms<1) return;
	fprintf(fileOut,"=============================================================================================================================================\n");
        fprintf(fileOut,"\t\t\tOptimization by Quasi-Newton method\n");
        fprintf(fileOut,"---------------------------------------------------------------------------------------------------------------------------------------------\n");
        fprintf(fileOut,"\t\t\tMaxIteration \t\t= %d\n",quasiNewtonQM->maxIterations);
        fprintf(fileOut,"\t\t\tEpsilon \t\t= %0.4e\n",quasiNewtonQM->epsilon);
        fprintf(fileOut,"\t\t\tMax lines search \t= %d\n",quasiNewtonQM->maxLines);
        fprintf(fileOut,"=============================================================================================================================================\n");
        fflush(fileOut); fflush(stderr);


	nAtoms = qmModel->molecule.nAtoms;
	nAtomsX3 = 3*nAtoms;

	diag = malloc(nAtomsX3*sizeof(double));
	x = malloc(nAtomsX3*sizeof(double));
	g = malloc(nAtomsX3*sizeof(double));

	qmModel->klass->calculateEnergy(qmModel);
	qmModel->klass->calculateGradient(qmModel);
	energy = qmModel->molecule.potentialEnergy;

	gradientNorm = 0;
	for (  i = 0; i < nAtoms; i++ )
	for(j=0;j<3;j++) gradientNorm += qmModel->molecule.atoms[i].gradient[j]*qmModel->molecule.atoms[i].gradient[j]; 
	sprintf(str,("Gradient(kcal/mol/Ang) = %0.14f\tEnergy = %0.14f "),sqrt(gradientNorm),energy); 
	fprintf(quasiNewtonQM->logfile,"%s\n",str);
	fflush(quasiNewtonQM->logfile);

	for(iter=0;iter<quasiNewtonQM->maxIterations;iter++)
	{

		//fprintf(stdout,"Begin calculateGradient\n");
		qmModel->klass->calculateGradient(qmModel);
		//fprintf(stdout,"End calculateGradient\n");
		/* energy = qmModel->klass->calculateEnergyTmp(qmModel, &qmModel->molecule );*/
		//qmModel->klass->calculateEnergy(qmModel);
		energy = qmModel->molecule.potentialEnergy;
		//printf("energy = %f energyC = %f\n",energy,qmModel->molecule.potentialEnergy);
		/* set x  and g table from coordinates and gradient */
		for(i=0,i3=0;i<nAtoms;i++)
		{
			if(!qmModel->molecule.atoms[i].variable) continue;
			x[i3  ] = qmModel->molecule.atoms[i].coordinates[0];
			x[i3+1] = qmModel->molecule.atoms[i].coordinates[1];
			x[i3+2] = qmModel->molecule.atoms[i].coordinates[2];

			g[i3  ] = qmModel->molecule.atoms[i].gradient[0];
			g[i3+1] = qmModel->molecule.atoms[i].gradient[1];
			g[i3+2] = qmModel->molecule.atoms[i].gradient[2];
			i3 += 3;
		}
		lbfgs(i3, i3,x, energy,g,diagco,diag,
				quasiNewtonQM->epsilon,quasiNewtonQM->tolerence,
				quasiNewtonQM->maxLines,
				&iflag);
		/*
		lbfgs(nAtomsX3, nAtomsX3,x, energy,g,diagco,diag,
				quasiNewtonQM->epsilon,quasiNewtonQM->tolerence,
				quasiNewtonQM->maxLines,
				&iflag);
				*/
		/* set coordinates from x */
		for(i=0,i3=0;i<nAtoms;i++)
		{
			if(qmModel->molecule.atoms[i].variable) 
			{
				double dmax=quasiNewtonQM->maxStep;
				double dd;
				int c;
				for(c=0;c<3;c++)
				{
					double sign=1.0;
					int ic=i3+c;
					dd = x[ic]-qmModel->molecule.atoms[i].coordinates[c];
					if(dd<0) sign=-1.0;
					if( dmax>0 && fabs(dd)>dmax) x[ic] = qmModel->molecule.atoms[i].coordinates[c]+dmax*sign;
					else qmModel->molecule.atoms[i].coordinates[c] = x[ic];
				}
				i3+=3;
			}
		}

		if ( updateNumber >= quasiNewtonQM->updateFrequency )
		{
			gradientNorm = 0;
			for (  i = 0; i < nAtoms; i++ ) for(j=0;j<3;j++) gradientNorm += qmModel->molecule.atoms[i].gradient[j]*qmModel->molecule.atoms[i].gradient[j]; 


			sprintf(str,("Iter # %d/%d\t Gradient(kcal/mol/Ang) = %0.14f\tEnergy(kcal/mol) = %0.14f "),
			iter,
			quasiNewtonQM->maxIterations,
			sqrt(gradientNorm),energy); 
			fprintf(quasiNewtonQM->logfile,"%s\n",str);
			fflush(quasiNewtonQM->logfile);
			/* redrawMolecule(&qmModel->molecule,str);*/
			updateNumber = 0;
		}
		updateNumber++;
		if(iflag<=0)
			break;
	}
	gradientNorm = 0;
	for (  i = 0; i < nAtoms; i++ )
		for(j=0;j<3;j++)
			gradientNorm += 
			qmModel->molecule.atoms[i].gradient[j]
			*qmModel->molecule.atoms[i].gradient[j]; 

	sprintf(str,("End Optimization\nGradient(kcal/mol/Ang) = %0.14f\tEnergy(kcal/mol) = %0.14f "),sqrt(gradientNorm),energy); 
	/* redrawMolecule(&qmModel->molecule,str);*/
	fprintf(quasiNewtonQM->logfile,"%s\n\n",str);
	fflush(quasiNewtonQM->logfile);
	free(diag);
	free(x);
	free(g);
}
/**********************************************************************/
void	freeQuasiNewtonQM(QuasiNewtonQM* quasiNewtonQM)
{
	quasiNewtonQM->qmModel = NULL;
	quasiNewtonQM->updateFrequency = 0;
	quasiNewtonQM->maxIterations = 0;
	quasiNewtonQM->maxLines = 0;
	quasiNewtonQM->epsilon = 0;
	quasiNewtonQM->tolerence = 0;
	quasiNewtonQM->maxStep = -1;
}
/**********************************************************************/
static double sqr( double x )
{ 
	return x*x;
}
/******************************************************************************/
static double max3( double x, double y, double z )
{
	return x < y ? ( y < z ? z : y ) : ( x < z ? z : x );
}
/** The purpose of this function is to compute a safeguarded step for
  * a linesearch and to update an interval of uncertainty for
  * a minimizer of the function.<p>
*/ 
static void mcstep (   double stx[] , double fx[] , double dx[] ,
		double sty[] , double fy[] , double dy[] ,
		double stp[] , double fp , double dp ,
		int brackt[] , double stpmin , double stpmax , int info[]
   	    )
{
	int bound;
	double gamma, p, q, r, s, sgnd, stpc, stpf, stpq, theta;

	info[0] = 0;

	if ( (
		brackt[0] && 
		( stp[0] <= FMIN ( stx[0] , sty[0] ) || stp[0] >= FMAX ( stx[0] , sty[0] ))
	     ) 
	     || dx[0] * ( stp[0] - stx[0] ) >= 0.0 
	     || stpmax < stpmin
	    )
		return;

	/* Determine if the derivatives have opposite sign.*/

	sgnd = dp * ( dx[0] / fabs ( dx[0] ) );

	if ( fp > fx[0] )
	{
		/* 
		 First case. A higher function value.
		 The minimum is bracketed. If the cubic step is closer
		 to stx than the quadratic step, the cubic step is taken,
		 else the average of the cubic and quadratic steps is taken.
		*/

		info[0] = 1;
		bound = TRUE;
		theta = 3 * ( fx[0] - fp ) / ( stp[0] - stx[0] ) + dx[0] + dp;
		s = max3 ( fabs ( theta ) , fabs ( dx[0] ) , fabs ( dp ) );
		gamma = s * sqrt ( sqr( theta / s ) - ( dx[0] / s ) * ( dp / s ) );
		if ( stp[0] < stx[0] ) gamma = - gamma;
		p = ( gamma - dx[0] ) + theta;
		q = ( ( gamma - dx[0] ) + gamma ) + dp;
		r = p/q;
		stpc = stx[0] + r * ( stp[0] - stx[0] );
		stpq = stx[0] 
			+ ( ( dx[0] / ( ( fx[0] - fp ) / ( stp[0] - stx[0] ) + dx[0] ) ) / 2 )
			*( stp[0] - stx[0] );

		if ( fabs ( stpc - stx[0] ) < fabs ( stpq - stx[0] ) )
			stpf = stpc;
		else
			stpf = stpc + ( stpq - stpc ) / 2;

		brackt[0] = TRUE;
	}
	else if ( sgnd < 0.0 )
	{
		/* Second case. A lower function value and derivatives of
		   opposite sign. The minimum is bracketed. If the cubic
		   step is closer to stx than the quadratic (secant) step,
		   the cubic step is taken, else the quadratic step is taken.
		 */

		info[0] = 2;
		bound = FALSE;
		theta = 3 * ( fx[0] - fp ) / ( stp[0] - stx[0] ) + dx[0] + dp;
		s = max3 ( fabs ( theta ) , fabs ( dx[0] ) , fabs ( dp ) );
		gamma = s * sqrt ( sqr( theta / s ) - ( dx[0] / s ) * ( dp / s ) );
		if ( stp[0] > stx[0] ) gamma = - gamma;
		p = ( gamma - dp ) + theta;
		q = ( ( gamma - dp ) + gamma ) + dx[0];
		r = p/q;
		stpc = stp[0] + r * ( stx[0] - stp[0] );
		stpq = stp[0] + ( dp / ( dp - dx[0] ) ) * ( stx[0] - stp[0] );
		if ( fabs ( stpc - stp[0] ) > fabs ( stpq - stp[0] ) )
			stpf = stpc;
		else
			stpf = stpq;

		brackt[0] = TRUE;
	}
	else if ( fabs ( dp ) < fabs ( dx[0] ) )
	{
		/* Third case. A lower function value, derivatives of the
		   same sign, and the magnitude of the derivative decreases.
		   The cubic step is only used if the cubic tends to infinity
		   in the direction of the step or if the minimum of the cubic
		   is beyond stp. Otherwise the cubic step is defined to be
		   either stpmin or stpmax. The quadratic (secant) step is also
		   computed and if the minimum is bracketed then the the step
		 closest to stx is taken, else the step farthest away is taken.
		 */

		info[0] = 3;
		bound = TRUE;
		theta = 3 * ( fx[0] - fp ) / ( stp[0] - stx[0] ) + dx[0] + dp;
		s = max3 ( fabs ( theta ) , fabs ( dx[0] ) , fabs ( dp ) );
		gamma = s * sqrt ( FMAX ( 0, sqr( theta / s ) - ( dx[0] / s ) * ( dp / s ) ) );
		if ( stp[0] > stx[0] )
		       	gamma = - gamma;
		p = ( gamma - dp ) + theta;
		q = ( gamma + ( dx[0] - dp ) ) + gamma;
		r = p/q;
		if ( r < 0.0 && gamma != 0.0 )
			stpc = stp[0] + r * ( stx[0] - stp[0] );
		else if ( stp[0] > stx[0] )
			stpc = stpmax;
		else
			stpc = stpmin;

		stpq = stp[0] + ( dp / ( dp - dx[0] ) ) * ( stx[0] - stp[0] );
		if ( brackt[0] )
		{
			if ( fabs ( stp[0] - stpc ) < fabs ( stp[0] - stpq ) )
				stpf = stpc;
			else
				stpf = stpq;
		}
		else
		{
			if ( fabs ( stp[0] - stpc ) > fabs ( stp[0] - stpq ) )
				stpf = stpc;
			else
				stpf = stpq;
		}
	}
	else
	{
		/* Fourth case. A lower function value, derivatives of the
		   same sign, and the magnitude of the derivative does
		   not decrease. If the minimum is not bracketed, the step
		   is either stpmin or stpmax, else the cubic step is taken.
		*/

		info[0] = 4;
		bound = FALSE;
		if ( brackt[0] )
		{
			theta = 3 * ( fp - fy[0] ) / ( sty[0] - stp[0] ) + dy[0] + dp;
			s = max3 ( fabs ( theta ) , fabs ( dy[0] ) , fabs ( dp ) );
			gamma = s * sqrt ( sqr( theta / s ) - ( dy[0] / s ) * ( dp / s ) );
			if ( stp[0] > sty[0] ) gamma = - gamma;
			p = ( gamma - dp ) + theta;
			q = ( ( gamma - dp ) + gamma ) + dy[0];
			r = p/q;
			stpc = stp[0] + r * ( sty[0] - stp[0] );
			stpf = stpc;
		}
		else if ( stp[0] > stx[0] )
		{
			stpf = stpmax;
		}
		else
		{
			stpf = stpmin;
		}
	}

	/* Update the interval of uncertainty. This update does not
	   depend on the new step or the case analysis above.
	*/

	if ( fp > fx[0] )
	{
		sty[0] = stp[0];
		fy[0] = fp;
		dy[0] = dp;
	}
	else
	{
		if ( sgnd < 0.0 )
		{
			sty[0] = stx[0];
			fy[0] = fx[0];
			dy[0] = dx[0];
		}
		stx[0] = stp[0];
		fx[0] = fp;
		dx[0] = dp;
	}

	/* Compute the new step and safeguard it.*/

	stpf = FMIN ( stpmax , stpf );
	stpf = FMAX ( stpmin , stpf );
	stp[0] = stpf;

	if ( brackt[0] && bound )
	{
		if ( sty[0] > stx[0] )
		{
			stp[0] = FMIN ( stx[0] + 0.66 * ( sty[0] - stx[0] ) , stp[0] );
		}
		else
		{
			stp[0] = FMAX ( stx[0] + 0.66 * ( sty[0] - stx[0] ) , stp[0] );
		}
	}

	return;
}
/******************************************************************************/
/* Minimize a function along a search direction. */
static void mcsrch ( int n , double x[] , double f , double g[] ,
	      double s[] , int is0 , double stp[] , double ftol , double xtol ,
	      int maxfev , int info[] , int nfev[] , double wa[] )
{

	double LBFGS_gtol = 0.1;
	double LBFGS_stpmin = 1e-16;
	double LBFGS_stpmax = 1e16;
	static int infoc[1];
	int j = 0;
	static double dg = 0, dgm = 0, dginit = 0, dgtest = 0;
	static double dgx[1];
	static double dgxm[1];
	static double dgy[1];
        static double dgym[1];
       	static double finit = 0, ftest1 = 0, fm = 0;
	static double fx[1];
	static double fxm[1];
	static double fy[1];
	static double fym[1];
	static double p5 = 0, p66 = 0;
	static double stx[1];
	static double sty[1];
	static double stmin = 0, stmax = 0, width = 0, width1 = 0, xtrapf = 0;
	static int brackt[1];
	static int stage1 = FALSE;

	p5 = 0.5;
	p66 = 0.66;
	xtrapf = 4;

	if ( info[0] != - 1 )
	{
		infoc[0] = 1;
		if ( 	n <= 0 || stp[0] <= 0 || ftol < 0 || 
			LBFGS_gtol < 0 || xtol < 0 || LBFGS_stpmin < 0 || 
			LBFGS_stpmax < LBFGS_stpmin || maxfev <= 0
		   ) 
			return;

		/* 
		 * Compute the initial gradient in the search direction
		 * and check that s is a descent direction.
		 */

		dginit = 0;

		for ( j = 0 ; j < n ; j++ )
		{
			dginit = dginit + g [j] * s [is0+j];
		}

		if ( dginit >= 0 )
		{
			printf(("The search direction is not a descent direction."));
			return;
		}

		brackt[0] = FALSE;
		stage1 = TRUE;
		nfev[0] = 0;
		finit = f;
		dgtest = ftol*dginit;
		width = LBFGS_stpmax - LBFGS_stpmin;
		width1 = width/p5;

		for ( j = 0 ; j < n ; j++ )
		{
			wa [j] = x [j];
		}

		/*
		 The variables stx, fx, dgx contain the values of the step,
		 function, and directional derivative at the best step.
		 The variables sty, fy, dgy contain the value of the step,
		 function, and derivative at the other endpoint of
		 the interval of uncertainty.
		 The variables stp, f, dg contain the values of the step,
		 function, and derivative at the current step.
		 */

		stx[0] = 0;
		fx[0] = finit;
		dgx[0] = dginit;
		sty[0] = 0;
		fy[0] = finit;
		dgy[0] = dginit;
	}

	while ( TRUE )
	{
		if ( info[0] != -1 )
		{
			/*
			 Set the minimum and maximum steps to correspond
			 to the present interval of uncertainty.
			*/

			if ( brackt[0] )
			{
				stmin = FMIN ( stx[0] , sty[0] );
				stmax = FMAX ( stx[0] , sty[0] );
			}
			else
			{
				stmin = stx[0];
				stmax = stp[0] + xtrapf * ( stp[0] - stx[0] );
			}

			/* Force the step to be within the bounds stpmax and stpmin.*/

			stp[0] = FMAX ( stp[0] , LBFGS_stpmin );
			stp[0] = FMIN ( stp[0] , LBFGS_stpmax );

			/* If an unusual termination is to occur then let
			   stp be the lowest point obtained so far.
			 */

			if ( 	( brackt[0] && ( stp[0] <= stmin || stp[0] >= stmax ) ) ||
			       	nfev[0] >= maxfev - 1 || infoc[0] == 0 || 
				( brackt[0] && stmax - stmin <= xtol * stmax )
			   )
				stp[0] = stx[0];

			/* Evaluate the function and gradient at stp
			   and compute the directional derivative.
			   We return to main program to obtain F and G.
			*/

			for ( j = 0 ; j < n ; j++ )
				x [j] = wa [j] + stp[0] * s [is0+j];

			info[0]=-1;
			return;
		}

		info[0]=0;
		nfev[0] = nfev[0] + 1;
		dg = 0;

		for ( j = 0 ; j < n ; j++ )
		{
			dg = dg + g [j] * s [is0+j];
		}

		ftest1 = finit + stp[0]*dgtest;

		/* Test for convergence.*/

		if ( 	( brackt[0] && ( stp[0] <= stmin || stp[0] >= stmax ) ) || infoc[0] == 0)
		       	info[0] = 6;

		if ( stp[0] == LBFGS_stpmax && f <= ftest1 && dg <= dgtest ) 
			info[0] = 5;

		if ( stp[0] == LBFGS_stpmin && ( f > ftest1 || dg >= dgtest ) ) 
			info[0] = 4;

		if ( nfev[0] >= maxfev )
		       	info[0] = 3;

		if ( brackt[0] && stmax - stmin <= xtol * stmax )
			info[0] = 2;

		if ( f <= ftest1 && fabs ( dg ) <= LBFGS_gtol * ( - dginit ) )
			info[0] = 1;

		/* Check for termination.*/

		if ( info[0] != 0 )
			return;

		/* In the first stage we seek a step for which the modified
		   function has a nonpositive value and nonnegative derivative.
		*/

		if ( stage1 && f <= ftest1 && dg >= FMIN ( ftol , LBFGS_gtol ) * dginit )
			stage1 = FALSE;

		/* 
		 * A modified function is used to predict the step only if
		   we have not obtained a step for which the modified
		   function has a nonpositive function value and nonnegative
		   derivative, and if a lower function value has been
		   obtained but the decrease is not sufficient.
		*/

		if ( stage1 && f <= fx[0] && f > ftest1 )
		{
			/* Define the modified function and derivative values.*/

			fm = f - stp[0]*dgtest;
			fxm[0] = fx[0] - stx[0]*dgtest;
			fym[0] = fy[0] - sty[0]*dgtest;
			dgm = dg - dgtest;
			dgxm[0] = dgx[0] - dgtest;
			dgym[0] = dgy[0] - dgtest;

			/* Call cstep to update the interval of uncertainty
			   and to compute the new step.
			*/

			mcstep ( stx , fxm , dgxm , sty , fym , dgym , stp , fm , dgm , 
					brackt , stmin , stmax , infoc );

			/* Reset the function and gradient values for f.*/

			fx[0] = fxm[0] + stx[0]*dgtest;
			fy[0] = fym[0] + sty[0]*dgtest;
			dgx[0] = dgxm[0] + dgtest;
			dgy[0] = dgym[0] + dgtest;
		}
		else
		{
			/* Call mcstep to update the interval of uncertainty
			   and to compute the new step.
			*/

			mcstep ( stx , fx , dgx , sty , fy , dgy , stp , f , dg ,
					brackt , stmin , stmax , infoc );
		}

		/* Force a sufficient decrease in the size of the
		   interval of uncertainty.
		*/

		if ( brackt[0] )
		{
			if ( fabs ( sty[0] - stx[0] ) >= p66 * width1 )
				stp[0] = stx[0] + p5 * ( sty[0] - stx[0] );
			width1 = width;
			width = fabs ( sty[0] - stx[0] );
		}
	}
}
/**************************************************************************/
static void arrayCopy(double* a,double*b,int n)
{
	int i;
	for(i=0;i<n;i++)
		b[i] = a[i];
}
/************************************************************************************************/
/** Compute the sum of a vector times a scalara plus another vector.
  * Adapted from the subroutine <code>daxpy</code> in <code>lbfgs.f</code>.
  * There could well be faster ways to carry out this operation; this
  * code is a straight translation from the Fortran.
  */ 
static void daxpy ( int n , double da , double dx[] , int ix0, int incx , double dy[] , int iy0, int incy )
{
	int i, ix, iy, m, mp1;

	if ( n <= 0 ) return;

	if ( da == 0 ) return;

	if  ( ! ( incx == 1 && incy == 1 ) )
	{
		ix = 1;
		iy = 1;

		if ( incx < 0 ) ix = ( - n + 1 ) * incx + 1;
		if ( incy < 0 ) iy = ( - n + 1 ) * incy + 1;

		for ( i = 0 ; i < n ; i++ )
		{
			dy [iy0+iy] = dy [iy0+iy] + da * dx [ix0+ix];
			ix = ix + incx;
			iy = iy + incy;
		}

		return;
	}

	m = n % 4;
	if ( m != 0 )
	{
		for ( i = 0 ; i < m ; i++ )
			dy [iy0+i] = dy [iy0+i] + da * dx [ix0+i];

		if ( n < 4 ) return;
	}

	mp1 = m + 1;
	for ( i = mp1-1 ; i < n ; i += 4 )
	{
		dy [iy0+i] = dy [iy0+i] + da * dx [ix0+i];
		dy [iy0+i + 1] = dy [iy0+i + 1] + da * dx [ix0+i + 1];
		dy [iy0+i + 2] = dy [iy0+i + 2] + da * dx [ix0+i + 2];
		dy [iy0+i + 3] = dy [iy0+i + 3] + da * dx [ix0+i + 3];
	}
	return;
}

/** Compute the dot product of two vectors.
  * Adapted from the subroutine <code>ddot</code> in <code>lbfgs.f</code>.
  * There could well be faster ways to carry out this operation; this
  * code is a straight translation from the Fortran.
  */ 
static double ddot ( int n, double dx[], int ix0, int incx, double dy[], int iy0, int incy )
{
	double dtemp;
	int i, ix, iy, m, mp1;

	dtemp = 0;

	if ( n <= 0 ) return 0;

	if ( !( incx == 1 && incy == 1 ) )
	{
		ix = 1;
		iy = 1;
		if ( incx < 0 ) ix = ( - n + 1 ) * incx + 1;
		if ( incy < 0 ) iy = ( - n + 1 ) * incy + 1;
		for ( i = 0 ; i < n ; i++ )
		{
			dtemp = dtemp + dx [ix0+ix] * dy [iy0+iy];
			ix = ix + incx;
			iy = iy + incy;
		}
		return dtemp;
	}

	m = n % 5;
	if ( m != 0 )
	{
		for ( i = 0 ; i < m ; i++ )
			dtemp = dtemp + dx [ix0+i] * dy [iy0+i];
		if ( n < 5 ) return dtemp;
	}

	mp1 = m + 1;
	for ( i = mp1-1 ; i < n ; i += 5 )
	{
		dtemp +=  dx [ix0+i] * dy [ iy0+i] 
			+ dx [ix0+i + 1] * dy [iy0+i + 1] 
			+ dx [ix0+i + 2] * dy [iy0+i + 2] 
			+ dx [ix0+i + 3] * dy [iy0+i + 3] 
			+ dx [ix0+i + 4] * dy [iy0+i + 4];
	}

	return dtemp;
}
/**************************************************************************/
static int lbfgs( 
		int n , int m , double x[] , double f , double g[] ,
		int diagco , double diag[] , double eps ,
		double xtol , int maxLines,int iflag[]
	)
{
	int execute_entire_while_loop = FALSE;
	static double gtol = 0.1;
	static double* solution_cache = NULL;
	static double gnorm = 0, stp1 = 0, ftol = 0;
	static double stp[1];
       	static double ys = 0, yy = 0, sq = 0, yr = 0, beta = 0, xnorm = 0;
	static int iter = 0, nfun = 0, point = 0, ispt = 0, iypt = 0, maxfev = 0;
	static int info[1];
	static int bound = 0, npt = 0, cp = 0, i = 0;
	static int nfev[1];
	static int inmc = 0, iycn = 0, iscn = 0;
	static int finish = FALSE;
	static double* w = NULL;
	static int wlength = 0;
	static int cacheLength = 0;


	if ( w == NULL || wlength != n*(2*m+1)+2*m )
	{
		if(w)
			free(w);

		wlength = n*(2*m+1)+2*m;
		w = malloc(wlength*sizeof(double));
	}
	if ( solution_cache == NULL || cacheLength != n )
	{
		if(solution_cache)
			free(solution_cache);

		cacheLength = n;
		solution_cache = malloc(cacheLength*sizeof(double));
	}

	if ( iflag[0] == 0 )
	{
		/* Initialize.*/

		arrayCopy(x,solution_cache,n);

		iter = 0;

		if ( n <= 0 || m <= 0 )
		{
			iflag[0]= -3;
			printf(("Improper input parameters  (n or m are not positive.)") );
		}

		if ( gtol <= 0.0001 )
		{
			printf(
				(
				"lbfgs: gtol is less than or equal to 0.0001."
				"It has been reset to 0.9."
				)
			      );
			gtol= 0.1;
		}

		nfun= 1;
		point= 0;
		finish= FALSE;
		if ( diagco )
		{
			for ( i = 0 ; i < n ; i++ )
			{
				if ( diag [i] <= 0 )
				{
					iflag[0]=-2;
					printf(
						(
						"The %d-th diagonal element of the inverse"
						" hessian approximation is not positive.")
						,i
					      );
				}
			}
		}
		else
		{
			for ( i = 0 ; i < n ; i++)
				diag [i] = 1;
		}
		ispt= n+2*m;
		iypt= ispt+n*m;

		for ( i = 0 ; i < n ; i++ )
			w [ispt + i] = - g [i] * diag [i];

		gnorm = sqrt ( ddot ( n , g , 0, 1 , g , 0, 1 ) );
		stp1= 1/gnorm;
		ftol= 0.0001; 
		maxfev= maxLines;

		execute_entire_while_loop = TRUE;
	}

	while ( TRUE )
	{
		if ( execute_entire_while_loop )
		{
			iter= iter+1;
			info[0]=0;
			bound=iter-1;
			if ( iter != 1 )
			{
				if ( iter > m ) bound = m;
				ys = ddot ( n , w , iypt + npt , 1 , w , ispt + npt , 1 );
				if ( ! diagco )
				{
					yy = ddot( 
						n , w , iypt + npt , 1 , w , iypt + npt , 1
						);
					for ( i = 0 ; i < n ; i++ )
						diag [i] = ys / yy;
				}
				else
				{
					iflag[0]=2;
					return 1;
				}
			}
		}

		if ( execute_entire_while_loop || iflag[0] == 2 )
		{
			if ( iter != 1 )
			{
				if ( diagco )
				{
					for ( i = 0 ; i < n ; i++ )
					{
						if ( diag [i] <= 0 )
						{
							iflag[0]=-2;
							printf(
							(
							"The %d-th diagonal element"
							" of the inverse hessian approximation"
							" is not positive.")
							, i);
						}
					}
				}
				cp= point;
				if ( point == 0 ) cp = m;
				w [ n + cp -1] = 1 / ys;

				for ( i = 0 ; i < n ; i++ )
					w [i] = - g [i];

				cp= point;

				for ( i = 0 ; i < bound ; i++ )
				{
					cp=cp-1;
					if ( cp == - 1 ) cp = m - 1;
					sq = ddot ( n , w , ispt + cp * n , 1 , w , 0 , 1 );
					inmc=n+m+cp+1;
					iycn=iypt+cp*n;
					w [ inmc -1] = w [ n + cp + 1 -1] * sq;
					daxpy ( n , - w [ inmc -1] , w , iycn , 1 , w , 0 , 1 );
				}

				for ( i = 0 ; i < n ; i++ )
					w [i] = diag [i] * w [i];

				for ( i = 0 ; i < bound ; i++ )
				{
					yr = ddot ( n , w , iypt + cp * n , 1 , w , 0 , 1 );
					beta = w [ n + cp + 1 -1] * yr;
					inmc=n+m+cp+1;
					beta = w [ inmc -1] - beta;
					iscn=ispt+cp*n;
					daxpy ( n , beta , w , iscn , 1 , w , 0 , 1 );
					cp=cp+1;
					if ( cp == m ) cp = 0;
				}

				for ( i = 0 ; i < n ; i++ )
					w [ispt + point * n + i] = w [i];
			}

			nfev[0]=0;
			stp[0]=1;
			if ( iter == 1 ) stp[0] = stp1;

			for ( i = 0 ; i < n ; i++ )
				w [i] = g [i];
		}

		mcsrch(
			n , x , f , g , w , ispt + point * n , stp ,
			ftol , xtol ,maxfev , info , nfev , diag
		      );

		if ( info[0] == - 1 )
		{
			iflag[0]=1;
			return 1;
		}

		if ( info[0] != 1 )
		{
			iflag[0]=-1;
			printf(
			(
			"Line search failed. See documentation of routine mcsrch.\n"
			" Error return of line search: info = %d Possible causes:\n"
			" function or gradient are incorrect, or incorrect tolerances.\n"
			)
			,info[0]);
			return 0;
		}

		nfun= nfun + nfev[0];
		npt=point*n;

		for ( i = 0; i < n ; i++ )
		{
			w [ispt + npt + i] = stp[0] * w [ispt + npt + i];
			w [iypt + npt + i] = g [i] - w [i];
		}

		point=point+1;
		if ( point == m ) point = 0;

		gnorm = sqrt ( ddot ( n , g , 0 , 1 , g , 0 , 1 ) );
		xnorm = sqrt ( ddot ( n , x , 0 , 1 , x , 0 , 1 ) );
		xnorm = FMAX ( 1.0 , xnorm );

		if ( gnorm / xnorm <= eps ) finish = TRUE;

		arrayCopy( x,solution_cache,n);

		if ( finish )
		{
			iflag[0]=0;
			return 0;
		}

		/* from now on, execute whole loop*/
		execute_entire_while_loop = TRUE;
	}
}
/*****************************************************************************************************************************************************/
void setQNQMOptions(FILE* file, QuasiNewtonQM* quasiNewtonQM)
{
	quasiNewtonQM->maxIterations = 100;
	quasiNewtonQM->updateFrequency = 1;
	quasiNewtonQM->epsilon  = 0.001;
	quasiNewtonQM->tolerence = 1e-16;  
	quasiNewtonQM->maxLines =  25;
	quasiNewtonQM->qmModel = NULL;
	quasiNewtonQM->maxStep = -1;// Angstrm, nolimit if maxStep<0
	readOneInt(file,"quasiNewtonMaxIterations",&quasiNewtonQM->maxIterations);
	readOneInt(file,"quasiNewtonUpdateFrequency",&quasiNewtonQM->updateFrequency);
	readOneReal(file,"quasiNewtonEpsilon",&quasiNewtonQM->epsilon);
	readOneReal(file,"quasiNewtonTolerence",&quasiNewtonQM->tolerence);
	readOneInt(file,"quasiNewtonMaxLines",&quasiNewtonQM->maxLines);
	readOneReal(file,"quasiNewtonMaxStep",&quasiNewtonQM->maxStep);
}
File: ./cchemilib/src/QuantumMechanics/ConjugateGradientQM.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* ConjugateGradientQM.c */
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>

#include "../Utils/Utils.h"
#include "../Utils/AtomsProp.h"
#include "../Utils/Constants.h"
#include "../Utils/Types.h"
#include "../Molecule/Molecule.h"
#include "../QuantumMechanics/ConjugateGradientQM.h"


static double maxarg1,maxarg2;
#define FMAX(a,b) (maxarg1=(a),maxarg2=(b),(maxarg1) > (maxarg2) ?\
        (maxarg1) : (maxarg2))

static void hestenesStiefel(ConjugateGradientQM* conjugateGradientQM);
static void fletcherReeves(ConjugateGradientQM* conjugateGradientQM);
static void polakRibiere(ConjugateGradientQM* conjugateGradientQM);
static void wolfPowell(ConjugateGradientQM* conjugateGradientQM);
static double lineMinimize(ConjugateGradientQM* conjugateGradientQM);
static void bracketMinimum(ConjugateGradientQM* conjugateGradientQM, double pointA[], double pointB[], double pointC[] );
static double oneDimensionalEnergy(ConjugateGradientQM* conjugateGradientQM, double factor );
static double inverseParabolicInterpolation(ConjugateGradientQM* conjugateGradientQM,
		double pointa[], double mid[], double pointb[], 
		double minimum[] );
/**********************************************************************/
void	runConjugateGradientQM(ConjugateGradientQM* conjugateGradientQM, QuantumMechanicsModel* qmModel, 
		ConjugateGradientQMOptions conjugateGradientQMOptions)
{

	int i;
	int minimizerOptions = conjugateGradientQMOptions.method;
	conjugateGradientQM->qmModel = qmModel;
	conjugateGradientQM->numberOfAtoms = qmModel->molecule.nAtoms;
	conjugateGradientQM->updateFrequency = conjugateGradientQMOptions.updateFrequency;
	conjugateGradientQM->maxIterations = conjugateGradientQMOptions.maxIterations;
	conjugateGradientQM->updateNumber = 0;
	conjugateGradientQM->maxLine = conjugateGradientQMOptions.maxLines;
	conjugateGradientQM->epsilon = conjugateGradientQMOptions.gradientNorm;
	conjugateGradientQM->initialStep = conjugateGradientQMOptions.initialStep;
	conjugateGradientQM->rmsDeplacment = 0;
	conjugateGradientQM->maxDeplacment = 0;
	conjugateGradientQM->gradientNorm = 0;
	conjugateGradientQM->initialBracket = conjugateGradientQMOptions.initialStep;
	conjugateGradientQM->lastInitialBracket = 0;
	conjugateGradientQM->term = 0;
	FILE* fileOut = conjugateGradientQM->logfile;
	fprintf(fileOut,"=============================================================================================================================================\n");
        fprintf(fileOut,"\t\t\tOptimization by Conjugate Gradient method\n");
        fprintf(fileOut,"---------------------------------------------------------------------------------------------------------------------------------------------\n");
        fprintf(fileOut,"\t\t\tMaxIteration \t\t= %d\n",conjugateGradientQM->maxIterations);
        fprintf(fileOut,"\t\t\tEpsilon \t\t= %0.4e\n",conjugateGradientQM->epsilon);
        fprintf(fileOut,"\t\t\tMax lines search \t= %d\n",conjugateGradientQM->maxLine);
	switch(minimizerOptions)
	{
		case 1 : fprintf(fileOut,"\t\t\tHestenes Stiefel approach\n");break;
		case 2 : fprintf(fileOut,"\t\t\tFletcher Reeves approach\n");break;
		case 3 : fprintf(fileOut,"\t\t\tPolak Ribiere  approach\n");break;
		case 4 : fprintf(fileOut,"\t\t\tWolf Powell approach\n");break;
	}
        fprintf(fileOut,"=============================================================================================================================================\n");
        fflush(fileOut); fflush(stderr);



	for(i=0;i<3;i++)
	{
		conjugateGradientQM->lastGradient[i] = malloc(conjugateGradientQM->numberOfAtoms*sizeof(double));
		conjugateGradientQM->direction[i] = malloc(conjugateGradientQM->numberOfAtoms*sizeof(double));
	}

	switch(minimizerOptions)
	{
		case 1 : hestenesStiefel(conjugateGradientQM);break;
		case 2 : fletcherReeves(conjugateGradientQM);break;
		case 3 : polakRibiere(conjugateGradientQM);break;
		case 4 : wolfPowell(conjugateGradientQM);break;
	}
}
/**********************************************************************/
void	freeConjugateGradientQM(ConjugateGradientQM* conjugateGradientQM)
{

	int i;
	conjugateGradientQM->qmModel = NULL;
	conjugateGradientQM->numberOfAtoms = 0;
	conjugateGradientQM->updateFrequency = 0;
	conjugateGradientQM->maxIterations = 0;
	conjugateGradientQM->updateNumber = 0;
	conjugateGradientQM->maxLine = 0;
	conjugateGradientQM->epsilon = 0;
	conjugateGradientQM->initialStep = 0;
	conjugateGradientQM->rmsDeplacment = 0;
	conjugateGradientQM->maxDeplacment = 0;
	conjugateGradientQM->gradientNorm = 0;
	conjugateGradientQM->initialBracket = 0;
	conjugateGradientQM->lastInitialBracket = 0;
	conjugateGradientQM->term = 0;

	for(i=0;i<3;i++)
	{
		if(conjugateGradientQM->lastGradient[i] !=NULL)
		{
			free(conjugateGradientQM->lastGradient[i]);
			conjugateGradientQM->lastGradient[i]= NULL;
		}
		if(conjugateGradientQM->direction[i] != NULL)
		{
			free(conjugateGradientQM->direction[i]);
			conjugateGradientQM->direction[i] = NULL; 
		}
	}
}
/**********************************************************************/
static void fletcherReeves(ConjugateGradientQM* conjugateGradientQM)
{
	double lastGradientDotGradient = 0, gradientDotGradient = 0, beta;
	int iterations = 0;
	int i;
	int j;
	double energy;
	char* str = strdup(" ");

	conjugateGradientQM->qmModel->klass->calculateGradient(conjugateGradientQM->qmModel);
	for ( i = 0; i < conjugateGradientQM->numberOfAtoms; i++ )
	{
		for(j=0;j<3;j++)
		{
		conjugateGradientQM->direction[j][ i ] = 
			-conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j];
		lastGradientDotGradient += conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j]
					* conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j]; 
		}
	}
	gradientDotGradient = lastGradientDotGradient;
	while ( 
			( lastGradientDotGradient > conjugateGradientQM->epsilon*conjugateGradientQM->epsilon ) && 
			( iterations++ < conjugateGradientQM->maxIterations ) 
		)
	{

		lineMinimize(conjugateGradientQM);
		conjugateGradientQM->qmModel->klass->calculateGradient(conjugateGradientQM->qmModel);
		lastGradientDotGradient = gradientDotGradient;	
		gradientDotGradient = 0;	
		for (  i = 0; i < conjugateGradientQM->numberOfAtoms; i++ )
			for(j=0;j<3;j++)
			{
				gradientDotGradient += 
					conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j]
					* conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j]; 
			}
		beta = gradientDotGradient / lastGradientDotGradient;
		for (  i = 0; i < conjugateGradientQM->numberOfAtoms; i++ )
		{
			for(j=0;j<3;j++)
			{
				conjugateGradientQM->direction[j][i] = 
					beta *  conjugateGradientQM->direction[j][i] - 
					conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j];
			}
		}
		if ( conjugateGradientQM->updateNumber >= conjugateGradientQM->updateFrequency )
		{
			free(str);
			 str =  strdup_printf(("Iter # %d/%d\t Gradient(kcal/mol/Ang) = %0.14f\tEnergy(kcal/mol) = %0.14f "), iterations, conjugateGradientQM->maxIterations,sqrt(gradientDotGradient),
				conjugateGradientQM->qmModel->molecule.potentialEnergy); 
			/* redrawMolecule(&conjugateGradientQM->qmModel->molecule,str);*/
			fprintf(conjugateGradientQM->logfile, "%s\n",str);
			fflush(conjugateGradientQM->logfile);
			conjugateGradientQM->updateNumber = 0;
		}
		conjugateGradientQM->updateNumber++;
	}	

	conjugateGradientQM->qmModel->klass->calculateGradient(conjugateGradientQM->qmModel);
	conjugateGradientQM->gradientNorm = 0;
	for(  i = 0; i < conjugateGradientQM->numberOfAtoms; i++ )
	{
		for(j=0;j<3;j++)
		{
			conjugateGradientQM->gradientNorm += 
				conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j] *
				conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j]; 
		}
	}
	conjugateGradientQM->gradientNorm = sqrt(conjugateGradientQM->gradientNorm );
	conjugateGradientQM->qmModel->klass->calculateEnergy(conjugateGradientQM->qmModel);
	energy = conjugateGradientQM->qmModel->molecule.potentialEnergy;

	free(str);
	str = strdup_printf(("End optimisation\nGradient(kcal/mol/Ang) = %0.10f  Energy = %0.10f (kcal/mol)\n"),
			(double)conjugateGradientQM->gradientNorm,(double)energy); 

	/* redrawMolecule(&conjugateGradientQM->qmModel->molecule,str);*/
	fprintf(conjugateGradientQM->logfile, "%s\n",str);
	fflush(conjugateGradientQM->logfile);
	free(str);
}
/********************************************************************************/
static void polakRibiere(ConjugateGradientQM* conjugateGradientQM)
{
	double lastGradientDotGradient = 0, gradientDotGradient, beta;
	int iterations = 0;
	double energy;
	int i;
	int j;
	char* str = strdup(" ");

	conjugateGradientQM->qmModel->klass->calculateGradient(conjugateGradientQM->qmModel);

	for ( i = 0; i < conjugateGradientQM->numberOfAtoms; i++ )
	{
		for(j=0;j<3;j++)
		{
		conjugateGradientQM->direction[j][ i ] = 
		conjugateGradientQM->lastGradient[j][i] =
			-conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j];

		lastGradientDotGradient += conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j] 
					* conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j]; 
		}
	}
	gradientDotGradient = lastGradientDotGradient;
	while ( 
			( lastGradientDotGradient > conjugateGradientQM->epsilon*conjugateGradientQM->epsilon ) && 
			( iterations++ < conjugateGradientQM->maxIterations ) 
		)
	{

		lineMinimize(conjugateGradientQM);
		conjugateGradientQM->qmModel->klass->calculateGradient(conjugateGradientQM->qmModel);
		lastGradientDotGradient = gradientDotGradient;
		gradientDotGradient = 0;	
		beta = 0;
		for (  i = 0; i < conjugateGradientQM->numberOfAtoms; i++ )
		{
			for (  j = 0; j < 3; j++ )
			{
				gradientDotGradient += 
					conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j] *
					conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j]; 
				
				beta += ( 
					conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j] - 
					conjugateGradientQM->lastGradient[j][i]
					)* conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j]; 
			}
		}
		beta /= lastGradientDotGradient;
		for (  i = 0; i < conjugateGradientQM->numberOfAtoms; i++ )
		{
			for (  j = 0; j < 3; j++ )
			{
				conjugateGradientQM->direction[j][i] = 
				beta * conjugateGradientQM->direction[j][i] - 
				conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j];
			}
		}
		for ( i = 0; i < conjugateGradientQM->numberOfAtoms; i++ )
		{
			for(j=0;j<3;j++)
			{
				conjugateGradientQM->lastGradient[j][i] = 
				conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j];
			}
		}
		if ( conjugateGradientQM->updateNumber >= conjugateGradientQM->updateFrequency )
		{
			free(str);
			/* str = strdup_printf("gradient = %f ",sqrt(gradientDotGradient)); */
			str = strdup_printf(("Iter # %d/%d\t Gradient(kcal/mol/Ang) = %0.14f\tEnergy(kcal/mol) = %0.14f "), iterations, conjugateGradientQM->maxIterations,sqrt(gradientDotGradient),
				conjugateGradientQM->qmModel->molecule.potentialEnergy); 
			/* redrawMolecule(&conjugateGradientQM->qmModel->molecule,str);*/
			fprintf(conjugateGradientQM->logfile, "%s\n",str);
			fflush(conjugateGradientQM->logfile);
			conjugateGradientQM->updateNumber = 0;
		}
		conjugateGradientQM->updateNumber++;
	}	
	conjugateGradientQM->qmModel->klass->calculateGradient(conjugateGradientQM->qmModel);
	conjugateGradientQM->gradientNorm = 0;
	for(  i = 0; i < conjugateGradientQM->numberOfAtoms; i++ )
	{
		for (  j = 0; j < 3; j++ )
		{
			conjugateGradientQM->gradientNorm += 
				conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j] *
				conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j]; 
		}
	}
	conjugateGradientQM->gradientNorm = sqrt(conjugateGradientQM->gradientNorm );
	conjugateGradientQM->qmModel->klass->calculateEnergy(conjugateGradientQM->qmModel);
	energy = conjugateGradientQM->qmModel->molecule.potentialEnergy;

	free(str);
	str = strdup_printf(("End optimisation\nGradient(kcal/mol/Ang) = %0.10f  Energy = %0.10f (kcal/mol)\n"),
			(double)conjugateGradientQM->gradientNorm,(double)energy); 
	/* redrawMolecule(&conjugateGradientQM->qmModel->molecule,str);*/
	fprintf(conjugateGradientQM->logfile, "%s\n",str);
	fflush(conjugateGradientQM->logfile);
	free(str);
}
/********************************************************************************/
static void hestenesStiefel(ConjugateGradientQM* conjugateGradientQM)
{
	double gradientDotGradient = 1, beta, gradientDiff, denom;
	int iterations = 0;
	double energy;
	int i;
	int j;
	char* str = strdup(" ");

	conjugateGradientQM->qmModel->klass->calculateGradient(conjugateGradientQM->qmModel);
	for ( i = 0; i < conjugateGradientQM->numberOfAtoms; i++ )
	{
		for(j=0;j<3;j++)
		{
		conjugateGradientQM->direction[j][ i ] = 
		conjugateGradientQM->lastGradient[j][i] = 
			-conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j];
		}
	}
	while ( 
			( gradientDotGradient > conjugateGradientQM->epsilon*conjugateGradientQM->epsilon ) && 
			( iterations++ < conjugateGradientQM->maxIterations ) 
		)
	{

		lineMinimize(conjugateGradientQM);
		conjugateGradientQM->qmModel->klass->calculateGradient(conjugateGradientQM->qmModel);
		gradientDotGradient = 0;	
		for (  i = 0; i < conjugateGradientQM->numberOfAtoms; i++ )
		{
			for (  j = 0; j < 3; j++ )
			{
				gradientDotGradient += 
					conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j]*
					conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j];
			}
		}
		beta = 0;
		denom = 0;
		for (  i = 0; i < conjugateGradientQM->numberOfAtoms; i++ )
		{
			for (  j = 0; j < 3; j++ )
			{
				gradientDiff = 
					conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j]-
					conjugateGradientQM->lastGradient[j][i];

				beta += 
					conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j]*
				       	gradientDiff;
				denom += conjugateGradientQM->direction[j][i] * gradientDiff;
			}
		}
		if ( fabs( denom ) > 1.0e-10 )
			beta /= denom;
		else
			beta = 0;

		for (  i = 0; i < conjugateGradientQM->numberOfAtoms; i++ )
		{
			for (  j = 0; j < 3; j++ )
			{
				conjugateGradientQM->direction[j][ i ] = 
					beta * conjugateGradientQM->direction[j][ i ] - 
					conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j];
			}
		}
		for ( i = 0; i < conjugateGradientQM->numberOfAtoms; i++ )
		{
			for(j=0;j<3;j++)
			{
				conjugateGradientQM->lastGradient[j][i] = 
				conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j];
			}
		}
		if ( conjugateGradientQM->updateNumber >= conjugateGradientQM->updateFrequency )
		{
			free(str);
			/* str = strdup_printf(("gradient = %f "),sqrt(gradientDotGradient)); */
			str = strdup_printf(("Iter # %d/%d\t Gradient(kcal/mol/Ang) = %0.14f\tEnergy(kcal/mol) = %0.14f "), iterations, conjugateGradientQM->maxIterations,sqrt(gradientDotGradient),
				conjugateGradientQM->qmModel->molecule.potentialEnergy); 
			/* redrawMolecule(&conjugateGradientQM->qmModel->molecule,str);*/
			fprintf(conjugateGradientQM->logfile, "%s\n",str);
			fflush(conjugateGradientQM->logfile);
			conjugateGradientQM->updateNumber = 0;
		}
		conjugateGradientQM->updateNumber++;
	}	
	conjugateGradientQM->qmModel->klass->calculateGradient(conjugateGradientQM->qmModel);
	conjugateGradientQM->gradientNorm = 0;
	for(  i = 0; i < conjugateGradientQM->numberOfAtoms; i++ )
	{
		for(j=0;j<3;j++)
			conjugateGradientQM->gradientNorm += 
			conjugateGradientQM->direction[j][ i ] *
			conjugateGradientQM->direction[j][ i ];
	}
	conjugateGradientQM->gradientNorm = sqrt( conjugateGradientQM->gradientNorm );
	conjugateGradientQM->qmModel->klass->calculateEnergy(conjugateGradientQM->qmModel);
	energy = conjugateGradientQM->qmModel->molecule.potentialEnergy;

	free(str);
	str = strdup_printf(("End optimisation\nGradient(kcal/mol/Ang) = %0.10f  Energy = %0.10f (kcal/mol)\n"),
			(double)conjugateGradientQM->gradientNorm,(double)energy); 
	/* redrawMolecule(&conjugateGradientQM->qmModel->molecule,str);*/
	fprintf(conjugateGradientQM->logfile, "%s\n",str);
	fflush(conjugateGradientQM->logfile);
	free(str);
}
/********************************************************************************/
static void wolfPowell(ConjugateGradientQM* conjugateGradientQM)
{
	double lastGradientDotGradient = 0, gradientDotGradient, beta;
	int iterations = 0;
	double energy;
	int i;
	int j;
	char* str = strdup(" ");

	conjugateGradientQM->qmModel->klass->calculateGradient(conjugateGradientQM->qmModel);
	for ( i = 0; i < conjugateGradientQM->numberOfAtoms; i++ )
	{
		for(j=0;j<3;j++)
		{
		conjugateGradientQM->direction[j][ i ] = 
		conjugateGradientQM->lastGradient[j][i] =
			-conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j];

		lastGradientDotGradient += conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j]
					* conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j]; 
		}
	}
	while ( 
			( lastGradientDotGradient > conjugateGradientQM->epsilon*conjugateGradientQM->epsilon ) && 
			( iterations++ < conjugateGradientQM->maxIterations ) 
		)
	{

		lineMinimize(conjugateGradientQM);
		conjugateGradientQM->qmModel->klass->calculateGradient(conjugateGradientQM->qmModel);
		gradientDotGradient = 0;	
		for ( i = 0; i < conjugateGradientQM->numberOfAtoms; i++ )
			for ( j = 0; j < 3; j++ )
			{
				gradientDotGradient += 
					conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j]*
					conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j];
			}

		beta = 0;
		for (  i = 0; i < conjugateGradientQM->numberOfAtoms; i++ )
		{
			for ( j = 0; j < 3; j++ )
				beta += ( 
					conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j] - 
					conjugateGradientQM->lastGradient[j][i]
					)* conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j]; 
		}
		beta /= lastGradientDotGradient;
		if ( beta < 0 )
			beta = 0;
		lastGradientDotGradient = gradientDotGradient;
		for (  i = 0; i < conjugateGradientQM->numberOfAtoms; i++ )
			for ( j = 0; j < 3; j++ )
				conjugateGradientQM->direction[j][ i ] = 
					beta * conjugateGradientQM->direction[j][ i ] - 
					conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j];
		
		for ( i = 0; i < conjugateGradientQM->numberOfAtoms; i++ )
		{
			for(j=0;j<3;j++)
			{
				conjugateGradientQM->lastGradient[j][i] = 
				conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j];
			}
		}
		if ( conjugateGradientQM->updateNumber >= conjugateGradientQM->updateFrequency )
		{
			free(str);
			/* str = strdup_printf(("gradient = %f "),sqrt(gradientDotGradient)); */
			str = strdup_printf(("Iter # %d/%d\t Gradient(kcal/mol/Ang) = %0.14f\tEnergy(kcal/mol) = %0.14f "), iterations, conjugateGradientQM->maxIterations,sqrt(gradientDotGradient),
				conjugateGradientQM->qmModel->molecule.potentialEnergy); 
			/* redrawMolecule(&conjugateGradientQM->qmModel->molecule,str);*/
			fprintf(conjugateGradientQM->logfile, "%s\n",str);
			fflush(conjugateGradientQM->logfile);
			conjugateGradientQM->updateNumber = 0;
		}
		conjugateGradientQM->updateNumber++;
	}	
	conjugateGradientQM->qmModel->klass->calculateGradient(conjugateGradientQM->qmModel);
	conjugateGradientQM->gradientNorm = 0;
	for(  i = 0; i < conjugateGradientQM->numberOfAtoms; i++ )
	{
		for(j=0;j<3;j++)
			conjugateGradientQM->gradientNorm += 
			conjugateGradientQM->direction[j][ i ] *
			conjugateGradientQM->direction[j][ i ];
	}
	conjugateGradientQM->gradientNorm = sqrt( conjugateGradientQM->gradientNorm );
	conjugateGradientQM->qmModel->klass->calculateEnergy(conjugateGradientQM->qmModel);
	energy = conjugateGradientQM->qmModel->molecule.potentialEnergy;

	free(str);
	str = strdup_printf(("End optimisation\nGradient(kcal/mol/Ang) = %0.10f  Energy = %0.10f (kcal/mol)\n"),
			(double)conjugateGradientQM->gradientNorm,(double)energy); 
	/* redrawMolecule(&conjugateGradientQM->qmModel->molecule,str);*/
	fprintf(conjugateGradientQM->logfile, "%s\n",str);
	fflush(conjugateGradientQM->logfile);
	free(str);
} 
/**********************************************************************/
static double lineMinimize(ConjugateGradientQM* conjugateGradientQM)
{
	double a;
	double b;
	double c;
	double minimum=0;
	double energy;
        double delta = 1.0e-7;
	int i;
	int j;
		
	a = 0; 
	b = conjugateGradientQM->initialBracket;
	bracketMinimum(conjugateGradientQM, &a, &b, &c );
	energy = inverseParabolicInterpolation(conjugateGradientQM, &a, &b, &c, &minimum );
	conjugateGradientQM->initialBracket = minimum;

	if ( 	( fabs( conjugateGradientQM->initialBracket ) < delta ) || 
		( conjugateGradientQM->initialBracket == conjugateGradientQM->lastInitialBracket ) )
	{
		conjugateGradientQM->initialBracket = 
			rand()/(double)RAND_MAX *conjugateGradientQM->initialStep;

		for (  i = 0; i < conjugateGradientQM->numberOfAtoms; i++ )
		{
			for(j=0;j<3;j++)
			conjugateGradientQM->direction[j][i] = 
				-conjugateGradientQM->qmModel->molecule.atoms[i].gradient[j];
		}
	} 
	conjugateGradientQM->lastInitialBracket = conjugateGradientQM->initialBracket;
	for (  i = 0; i <  conjugateGradientQM->numberOfAtoms; i++ )
	{

			for(j=0;j<3;j++)
				conjugateGradientQM->qmModel->molecule.atoms[i].coordinates[j] += 
				conjugateGradientQM->direction[j][i] * conjugateGradientQM->initialBracket;
	}
	return( energy );
}
/********************************************************************************/
static void bracketMinimum(ConjugateGradientQM* conjugateGradientQM, double pointA[], double pointB[], double pointC[] )
{
	static double GOLDENRATIO = 1.618034;
	double energyA, energyB, energyC, temp;
      	double ulim, u, r, q, fu, denominator;
	int iter = 0;

       	energyA = oneDimensionalEnergy(conjugateGradientQM, pointA[ 0 ] );
        energyB = oneDimensionalEnergy(conjugateGradientQM, pointB[ 0 ] );

        if ( energyB > energyA ) 
	{  
		temp = pointA[ 0 ];
		pointA[ 0 ] = pointB[ 0 ];
		pointB[ 0 ] = temp;
		temp = energyB;
		energyB = energyA;
		energyA = temp;  
        }
        pointC[ 0 ] = pointB[ 0 ] + GOLDENRATIO * ( pointB[ 0 ] - pointA[ 0 ] );
        energyC = oneDimensionalEnergy(conjugateGradientQM, pointC[ 0 ] );
        while ( energyB > energyC )
	{
		iter++;
               	r = ( pointB[ 0 ] - pointA[ 0 ] ) * ( energyB - energyC );
               	q = ( pointB[ 0 ] - pointC[ 0 ] ) * ( energyB - energyA );
		denominator = FMAX( fabs( q - r ), 1.0e-20 );
		if ( ( q - r ) < 0 )
			denominator = -denominator;
               	u = ( pointB[ 0 ] ) - ( ( pointB[ 0 ]-pointC[ 0 ] ) * q - 
			( pointB[ 0 ] - pointA[ 0 ] ) * r ) /
                       	( 2.0 * denominator );
               	ulim = pointB[ 0 ] + 100 * ( pointC[ 0 ] - pointB[ 0 ] );
               	if ( ( pointB[ 0 ] - u ) * ( u - pointC[ 0 ] ) > 0.0 )
		{
                       	fu=oneDimensionalEnergy(conjugateGradientQM, u );
                       	if ( fu < energyC )
			{
                               	pointA[ 0 ] = pointB[ 0 ];
                               	pointB[ 0 ] = u;
                               	energyA = energyB;
                               	energyB = fu;
                               	return;
                       	}
			else if ( fu > energyB )
			{
                               	pointC[ 0 ] = u;
                               	energyC = fu;
                               	return;
			}
                       	u = pointC[ 0 ] + GOLDENRATIO * ( pointC[ 0 ] - pointB[ 0 ] );
                       	fu = oneDimensionalEnergy(conjugateGradientQM, u );
               	}
		else if ( ( pointC[ 0 ] - u ) * ( u - ulim ) > 0.0 )
		{
                       	fu = oneDimensionalEnergy(conjugateGradientQM, u );
                       	if ( fu < energyC )
			{
				pointB[ 0 ] = pointC[ 0 ];
				pointC[ 0 ] = u;
				u = pointC[ 0 ] + GOLDENRATIO * ( pointC[ 0 ] - pointB[ 0 ] );
				energyB = energyC;
				energyC = fu;
				fu = oneDimensionalEnergy(conjugateGradientQM, u );
                       	}
               	}
		else if ( ( u - ulim ) * ( ulim - pointC[ 0 ] ) >= 0.0 )
		{
                       	u = ulim;
                       	fu = oneDimensionalEnergy(conjugateGradientQM, u );
               	}
		else
		{
                       	u = pointC[ 0 ] + GOLDENRATIO * ( pointC[ 0 ] - pointB[ 0 ] );
                       	fu = oneDimensionalEnergy(conjugateGradientQM, u );
               	}
		pointA[ 0 ] = pointB[ 0 ];
		pointB[ 0 ] = pointC[ 0 ];
		pointC[ 0 ] = u;
		energyA = energyB;
		energyB = energyC;
		energyC = fu;
       	}
}
/********************************************************************************/
static double oneDimensionalEnergy(ConjugateGradientQM* conjugateGradientQM, double factor )
{

	int i;
	int j;
	double energy;
	QuantumMechanicsModel copyModel = conjugateGradientQM->qmModel->klass->copy(conjugateGradientQM->qmModel);
	for (  i = 0; i < conjugateGradientQM->numberOfAtoms; i++ )
	{
		for(j=0;j<3;j++)
			copyModel.molecule.atoms[i].coordinates[j] += factor * conjugateGradientQM->direction[j][i];
	}

	conjugateGradientQM->qmModel->klass->calculateEnergy(&copyModel);
	energy = copyModel.molecule.potentialEnergy;
	copyModel.klass->free(&copyModel);
	
	return energy;
}
/********************************************************************************/
static double inverseParabolicInterpolation(ConjugateGradientQM* conjugateGradientQM,
		double pointa[], double mid[], double pointb[], 
		double minimum[] )
{
        int iter;
	int maxIterations = conjugateGradientQM->maxLine;
	static double CGOLD = 0.3819660;
        double a,b,d=0,etemp,fu,fv,fw,fx,p,q,r,tol1,tol2,u,v,w,x,xm;
        double e=0.0, tol=2.0e-4;
	double pointA, pointB;
	double energy;
	
	pointA = pointa[ 0 ];
	pointB = pointb[ 0 ];

        a=(pointA < pointB ? pointA : pointB);
        b=(pointA > pointB ? pointA : pointB);
        x=w=v=mid[ 0 ];
        fw=fv=fx=fu=energy=oneDimensionalEnergy(conjugateGradientQM,x);
        for (iter=1;iter<=maxIterations;iter++)
	{

               	xm=0.5*(a+b);
		tol1 = tol* fabs( x ) + 1.0e-10;
               	tol2=2.0*tol1;
               	if (fabs(x-xm) <= (tol2-0.5*(b-a)))
		{
                       	minimum[0]=x;
                       	return fu;
               	}
               	if (fabs(e) > tol1)
		{
                       	r=(x-w)*(fx-fv);
                       	q=(x-v)*(fx-fw);
                       	p=(x-v)*q-(x-w)*r;
                       	q=2.0*(q-r);
                       	if (q > 0.0) p = -p;
                       	q=fabs(q);
                       	etemp=e;
                       	e=d;
                       	if (fabs(p) >= fabs(0.5*q*etemp) || 
				p <= q*(a-x) || p >= q*(b-x))
                               	d=CGOLD*(e=(x >= xm ? a-x : b-x));
                       	else
			{
                               	d=p/q;
                               	u=x+d;
                               	if (u-a < tol2 || b-u < tol2)
				{
					if ( ( xm - x ) < 0 )
						d = - tol1;
					else
						d = tol1;
				}
                       	}
               	}
		else
		{
                        	d=CGOLD*(e=(x >= xm ? a-x : b-x));
               	}
		if ( fabs( d ) >= tol1 )
		{
			u = x + d;
		}
		else
		{
			if ( d >= 0 )
				u = x + tol1;
			else
				u = x - tol1;
		}
               	fu=oneDimensionalEnergy(conjugateGradientQM,u);
               	if (fu <= fx)
		{
                       	if (u >= x) a=x; else b=x;
			v = w;
			w = x;
			x = u;
			fv = fw;
			fw = fx;
			fx = fu;
               	}
		else
		{
                       	if (u < x) a=u; else b=u;
                       	if (fu <= fw || w == x)
			{
                               	v=w;
                               	w=u;
                               	fv=fw;
                               	fw=fu;
                       	}
			else if (fu <= fv || v == x || v == w)
			{
                               	v=u;
                               	fv=fu;
                       	}
               	}
        }
	return( fu );
}
/*****************************************************************************************************************************************************/
void setCGQMOptions(FILE* file, ConjugateGradientQMOptions* conjugateGradientQMOptions)
{
/* Optimsation options */ 
	conjugateGradientQMOptions->gradientNorm = 1e-3;
	conjugateGradientQMOptions->maxIterations = 100;
	conjugateGradientQMOptions->updateFrequency = 1;
	conjugateGradientQMOptions->maxLines = 25;
	conjugateGradientQMOptions->initialStep = 0.001;
/* 1 : Hestenes Stiefel,  2 : Fletcher Reeves, 3 : Polak Ribiere, 4 : Wolf Powell*/
	conjugateGradientQMOptions->method = 1;

	readOneReal(file,"conjugateGradientGradientNorm",&conjugateGradientQMOptions->gradientNorm);
	readOneInt(file,"conjugateGradientMaxIterations",&conjugateGradientQMOptions->maxIterations);
	readOneInt(file,"conjugateGradientUpdateFrequency",&conjugateGradientQMOptions->updateFrequency);
	readOneInt(file,"conjugateGradientMaxLines",&conjugateGradientQMOptions->maxLines);
	readOneReal(file,"conjugateGradientInitialStep",&conjugateGradientQMOptions->initialStep);
	readOneInt(file,"conjugateGradientMethod",&conjugateGradientQMOptions->method);
	if(conjugateGradientQMOptions->method<1||conjugateGradientQMOptions->method>4) conjugateGradientQMOptions->method=1;
}
File: ./cchemilib/src/QuantumMechanics/QuantumMechanicsMD.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* QuantumMechanicsMD.c  */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <time.h>
#ifdef ENABLE_MPI
#include <mpi.h>
#endif

#include "../Utils/Utils.h"
#include "../Utils/AtomsProp.h"
#include "../Utils/Constants.h"
#include "../Utils/Types.h"
#include "../Molecule/Molecule.h"
#include "../QuantumMechanics/QuantumMechanicsModel.h"
#include "../QuantumMechanics/QuantumMechanics.h"
#include "../QuantumMechanics/QuantumMechanicsMD.h"


/*********************************************************************************/
static void initMD(QuantumMechanicsMD* molecularDynamics, double temperature, double stepSize, MDIntegratorType integratorType, MDThermostatType thermostat, double friction, double omegaMax, int Nf, double collide, double qNH, char* fileNameTraj, char* fileNameProp, int numberOfRunSteps, int index);
static void berendsen(QuantumMechanicsMD* molecularDynamics);
static void scaleV(QuantumMechanicsMD* molecularDynamics);
static void bussi(QuantumMechanicsMD* molecularDynamics);
static void andersen(QuantumMechanicsMD* molecularDynamics);
static void nose_hoover(QuantumMechanicsMD* molecularDynamics);
static void rescaleVelocities(QuantumMechanicsMD* molecularDynamics);
static void computeEnergies(QuantumMechanicsMD* molecularDynamics);
static void applyOneStep(QuantumMechanicsMD* molecularDynamics, int iStep);
static void applyThermostat(QuantumMechanicsMD* molecularDynamics);
static void applyVerlet(QuantumMechanicsMD* molecularDynamics);
static void applyBeeman(QuantumMechanicsMD* molecularDynamics);
static void applyStochastic(QuantumMechanicsMD* molecularDynamics);
static void applyQTB(QuantumMechanicsMD* molecularDynamics);
static void updateQTB(QuantumMechanicsMD* molecularDynamics);
static void resetQTB(QuantumMechanicsMD* molecularDynamics);
static void applyLangevin(QuantumMechanicsMD* molecularDynamics);
static void updateLangevin(QuantumMechanicsMD* molecularDynamics);
static void resetLangevin(QuantumMechanicsMD* molecularDynamics);
static void newProperties(QuantumMechanicsMD* molecularDynamics, char* comments);
static void saveProperties(QuantumMechanicsMD* molecularDynamics, int iStep0, int iStep, char* comments);
static void saveTrajectory(QuantumMechanicsMD* molecularDynamics, int iStep);
static double getEKin(QuantumMechanicsMD* molecularDynamics);
static double getKelvin(QuantumMechanicsMD* molecularDynamics);
static void removeTranslationAndRotationTheta(QuantumMechanicsMD* molecularDynamics);
static void removeTranslationAndRotation(QuantumMechanicsMD* molecularDynamics);
/*****************************************************************************************************************/
// return # temperatures
static int getNumExchangeReplica(double* energies, double* temperatures, int nTemperatures, int* numMDForTemperatures)
{
	int it = rand()%(nTemperatures-1);
	int n = numMDForTemperatures[it];
	int next = numMDForTemperatures[it+1];
	double delta = (1.0/(Kb*temperatures[n])- 1.0/(Kb*temperatures[next]))*(energies[n]-energies[next]);
	boolean exchange= FALSE;
#ifdef DEBUG
	printf("n=%d next=%d delta = %f\n",n,next, delta);
#endif
	if(delta<0) exchange= TRUE;
	else
	{
		if(rand()/(double)RAND_MAX>exp(-delta)) exchange = TRUE;
	}
	if(exchange) return it;
	else return -1;
}
/*****************************************************************************************************************/
static void applyExchangeReplica(QuantumMechanicsMD* md, int nTemperatures, int n, int next)
{
	double r;
	int i,j;
	double t;
	FILE* f;
	r = sqrt(md[next].temperature/md[n].temperature);
	/* exchange temperatures */
	t = md[n].temperature;
	md[n].temperature = md[next].temperature;
	md[next].temperature = t;
	/* exchange filesoutput */
	f = md[n].fileProp;
	md[n].fileProp = md[next].fileProp;
	md[next].fileProp = f;

	f = md[n].fileTraj;
	md[n].fileTraj = md[next].fileTraj;
	md[next].fileTraj = f;

	/* scale velocity */
	for ( i = 0; i < md[n].numberOfAtoms; i++)
	{
		for ( j = 0; j < 3; j++)
		{
			 md[n].qmModel->molecule.atoms[i].velocity[j] *= r;
			 md[next].qmModel->molecule.atoms[i].velocity[j] /= r;
		}
	}
	removeTranslationAndRotation(&md[n]);
	removeTranslationAndRotation(&md[next]);
	resetQTB(&md[n]);
	resetQTB(&md[next]);
	resetLangevin(&md[n]);
	resetLangevin(&md[next]);
}
/*****************************************************************************************************************/
static void changeOneReplica(QuantumMechanicsMD* md, int n, double newTemperature, char* fileNamePrefixProp,  char* fileNamePrefixTraj)
{
	double r;
	int i,j;
	char*  fileNameProp = NULL;
	char*  fileNameTraj = NULL;
	r = sqrt(newTemperature/md[n].temperature);
	/* change temperature */
	md[n].temperature = newTemperature;
	/* close old file and open file for new temperture*/
	if(fileNamePrefixProp) fileNameProp = strdup_printf("%s%0.0f.txt", fileNamePrefixProp, newTemperature);
	if(fileNamePrefixTraj)  fileNameTraj = strdup_printf("%s%0.0f.gab", fileNamePrefixTraj, newTemperature);
	if(fileNameProp) md[n].fileProp = fopen(fileNameProp,"a");
	if(fileNameTraj) md[n].fileTraj = fopen(fileNameTraj,"a");

	/* scale velocity */
	for ( i = 0; i < md[n].numberOfAtoms; i++)
	{
		for ( j = 0; j < 3; j++)
			 md[n].qmModel->molecule.atoms[i].velocity[j] *= r;
	}
	removeTranslationAndRotation(&md[n]);
	if(fileNameProp) free(fileNameProp);
	if(fileNameTraj) free(fileNameTraj);
}
/*****************************************************************************************************************/
/*
static void exchangeReplicaLocalAll(QuantumMechanicsMD* md, int nTemperatures, int* numMDForTemperatures)
{
	int it = rand()%(nTemperatures-1);
	int n = numMDForTemperatures[it];
	int next =  numMDForTemperatures[it+1];
	double delta = (1.0/(Kb*md[n].temperature)- 1.0/(Kb*md[next].temperature))*(md[n].potentialEnergy-md[next].potentialEnergy);
	boolean exchange= FALSE;
	double t;
	double r = 1.0;
	int i,j;
	FILE* f;
	printf("n=%d delta = %f\n",n,delta);
	if(delta<0) exchange= TRUE;
	else
	{
		if(rand()/(double)RAND_MAX>exp(-delta)) exchange = TRUE;
	}
	if(!exchange)return;
	r = sqrt(md[next].temperature/md[n].temperature);
	t = md[n].temperature;
	md[n].temperature = md[next].temperature;
	md[next].temperature = t;
	numMDForTemperatures[it]=next;
	numMDForTemperatures[it+1]=n;
	f = md[n].fileProp;
	md[n].fileProp = md[next].fileProp;
	md[next].fileProp = f;
	f = md[n].fileTraj;
	md[n].fileTraj = md[next].fileTraj;
	md[next].fileTraj = f;

	for ( i = 0; i < md[n].numberOfAtoms; i++)
	{
		for ( j = 0; j < 3; j++)
		{
			 md[n].qmModel->molecule.atoms[i].velocity[j] *= r;
			 md[next].qmModel->molecule.atoms[i].velocity[j] /= r;
		}
	}
	removeTranslationAndRotation(&md[n]);
	removeTranslationAndRotation(&md[next]);
}
*/
/*****************************************************************************************************************/
static void exchangeReplica(QuantumMechanicsMD* md,  double* energiesAll, double* energies,  double* temperaturesAll, int* numMDForTemperatures, int* nTemperaturesLocal, int nTemperaturesAll, int nTemperatures, int nproc, int rank, int iBegin, char* fileNamePrefixProp, char* fileNamePrefixTraj)
{
	if(nproc ==1) 
	{
		//exchangeReplicaLocalAll(md, nTemperatures, numMDForTemperatures);
		int n=-1,next=-1;
		int it;
		int k;
		for(k=0;k<nTemperatures;k++) energiesAll[k] = md[k].potentialEnergy;
		it = getNumExchangeReplica(energiesAll, temperaturesAll, nTemperaturesAll, numMDForTemperatures);
		if(it>=0)
		{
			n = numMDForTemperatures[it];
			next = numMDForTemperatures[it+1];
			numMDForTemperatures[it]=next;
			numMDForTemperatures[it+1]=n;
		}
		if(n>=0 && n<nTemperatures && next>=0 && next<nTemperatures)
		{
			applyExchangeReplica(md, nTemperatures, n,next);
		}
	}
	else
	{
		if(rank==0)
		{
#ifdef ENABLE_MPI
			MPI_Status status ;
			int dum;
			int code;
			int tag=100;
#endif
			int it;
			int n=-1,next=-1;
			int ii;
			int k;
			int j;
			for(k=0;k<nTemperatures;k++) energiesAll[k] = md[k].potentialEnergy;
			for(j=1;j<nproc;j++) 
			{
#if DEBUG
				fprintf(md[0].qmModel->logfile, "Get energies from rank %d\n",j);
#endif
#ifdef ENABLE_MPI
				code = MPI_Recv(energies,nTemperaturesLocal[j],MPI_DOUBLE,j,tag,MPI_COMM_WORLD,&status) ;
#endif
#if DEBUG
				fprintf(md[0].qmModel->logfile, "End Get energies from rank %d\n",j);
#endif
				for(ii=0;ii<nTemperaturesLocal[j];ii++) energiesAll[k++] = energies[ii];
			}
			it = getNumExchangeReplica(energiesAll, temperaturesAll, nTemperaturesAll, numMDForTemperatures);
#if DEBUG
			fprintf(md[0].qmModel->logfile, "\n\nn=%d\n",it);
#endif
			if(it>=0)
			{
				n = numMDForTemperatures[it];
				next = numMDForTemperatures[it+1];
				numMDForTemperatures[it]=next;
				numMDForTemperatures[it+1]=n;
			}
			// send it to all others 
#if DEBUG
			fprintf(md[0].qmModel->logfile, "Send n from 0 to all others rank\n");
#endif
#ifdef ENABLE_MPI
			tag = 200;
			for(j=1;j<nproc;j++) code = MPI_Send(&it,1,MPI_INT,j,tag,MPI_COMM_WORLD) ;
#endif
#if DEBUG
			fprintf(md[0].qmModel->logfile, "End Send n from 0 to all others rank\n");
#endif
			// close file for n and next if nessesar
			if(n>=0 && n<nTemperatures && (next<0 || next>=nTemperatures))
			{
				 if(md[n].fileProp) fclose(md[n].fileProp);
				 if(md[n].fileTraj) fclose(md[n].fileTraj);
			}
			if(next>=0 && next<nTemperatures && (n<0||n>=nTemperatures) )
			{
				 if(md[next].fileProp) fclose(md[next].fileProp);
				 if(md[next].fileTraj) fclose(md[next].fileTraj);
			}
#ifdef ENABLE_MPI
			tag = 300;
#endif
			for(j=1;j<nproc;j++) 
			{
#if DEBUG
				fprintf(md[0].qmModel->logfile, "Get dum val for check close file at rank %d\n",j);
#endif
#ifdef ENABLE_MPI
				code = MPI_Recv(&dum,1,MPI_INT,j,tag,MPI_COMM_WORLD,&status) ;
#endif
#if DEBUG
				fprintf(md[0].qmModel->logfile, "End Get dum val for check close file at rank %d\n",j);
#endif
			}
			/// all files closed on other rank
#ifdef ENABLE_MPI
			tag = 400;
#endif
#if DEBUG
			fprintf(md[0].qmModel->logfile, "Send n from 0 to all others rank\n");
#endif
#ifdef ENABLE_MPI
			for(j=1;j<nproc;j++) code = MPI_Send(&it,1,MPI_INT,j,tag,MPI_COMM_WORLD) ;
#endif

			if(n>=0 && n<nTemperatures && next>=0 && next<nTemperatures)
			{
#if DEBUG
				fprintf(md[0].qmModel->logfile, " Exchange between 2 trajs on one proc rank = 0\n");
#endif
				// 2 trajs on one proc
				applyExchangeReplica(md, nTemperatures, n,next);
			}
			else 
			{
				if(n>=0 && n<nTemperatures) changeOneReplica(md,  n, temperaturesAll[it+1], fileNamePrefixProp, fileNamePrefixTraj);
				if(next>=0 && next<nTemperatures) changeOneReplica(md, next, temperaturesAll[it], fileNamePrefixProp, fileNamePrefixTraj);
			}
		}
#ifdef ENABLE_MPI
		else
		{
			int code, tag=100;
			MPI_Status status ;
			int it;
			int n=-1,next=-1;
			int k;
			for(k=0;k<nTemperatures;k++) energies[k] = md[k].potentialEnergy;
#if DEBUG
			fprintf(md[0].qmModel->logfile, "Send energies from %d to 0\n",rank);
#endif
			code = MPI_Send(energies,nTemperatures,MPI_DOUBLE,0,tag,MPI_COMM_WORLD) ;
#if DEBUG
			fprintf(md[0].qmModel->logfile, "End Send energies from %d to 0\n",rank);
#endif
			tag = 200;
			code = MPI_Recv(&it,1,MPI_INT,0,tag,MPI_COMM_WORLD,&status) ;
			if(it>=0)
			{
				n = numMDForTemperatures[it];
				next = numMDForTemperatures[it+1];
				numMDForTemperatures[it]=next;
				numMDForTemperatures[it+1]=n;
			}
			n -= iBegin;
			next -= iBegin;
			// close file for n and next if nessesar
			if(n>=0 && n<nTemperatures && (next<0 || next>=nTemperatures))
			{
				 if(md[n].fileProp) fclose(md[n].fileProp);
				 if(md[n].fileTraj) fclose(md[n].fileTraj);
			}
			if(next>=0 && next<nTemperatures && (n<0||n>=nTemperatures) )
			{
				 if(md[next].fileProp) fclose(md[next].fileProp);
				 if(md[next].fileTraj) fclose(md[next].fileTraj);
			}
			// send to 0 for tell it all files closed
			tag = 300;
			code = MPI_Send(&it,1,MPI_INT,0,tag,MPI_COMM_WORLD) ;
			tag = 400;
			code = MPI_Recv(&it,1,MPI_INT,0,tag,MPI_COMM_WORLD,&status) ;
			if(n>=0 && n<nTemperatures && next>=0 && next<nTemperatures)
			{
#if DEBUG
				fprintf(md[0].qmModel->logfile, " Exchange between 2 trajs on one proc rank = 0\n");
#endif
				// 2 trajs on one proc
				applyExchangeReplica(md, nTemperatures, n,next);
			}
			else 
			{
				if(n>=0 && n<nTemperatures) changeOneReplica(md,  n, temperaturesAll[it+1], fileNamePrefixProp, fileNamePrefixTraj);
				if(next>=0 && next<nTemperatures) changeOneReplica(md, next, temperaturesAll[it], fileNamePrefixProp, fileNamePrefixTraj);
			}
		}
#endif
	}
}
/*****************************************************************************************************************/
QuantumMechanicsModel**    runQuantumMechanicsREMDConfo(
		QuantumMechanicsMD* molecularDynamics, QuantumMechanicsModel* qmModel, 
		int updateFrequency, 
		double heatTime, double equiTime, double runTime, 
		double heatTemperature, double runTemperature, double runTemperatureMax,
		double stepSize,
		MDIntegratorType integratorType,
		MDThermostatType thermostat,
		double friction,
		double omegaMax,
		int Nf,
		double collide,
		double qNH,
		int numberOfGeometries,
		int nTemperaturesAll,
		int numberOfExchanges,
		char* fileNameTraj,
		char* fileNameProp
		)
{
	int i;
	int j;
	int k;
	char* str = NULL;
        double gradientNorm = 0;
	int numberOfHeatSteps = 0;
	int numberOfEquiSteps = 0;
	int numberOfRunSteps = 0;
	double currentTemp;
	int* updateNumber = NULL;
	int n0 = 0;
	QuantumMechanicsModel** geometries = NULL;
	int iSel = 0;
	int stepSel = 1;
	int stepExchange = 1;
	QuantumMechanicsMD* md = NULL;
	double* runTemps = NULL;
	double a = 1.0;
	double b = 1.0;
	int nTemperatures = nTemperaturesAll;
	int nproc = 1;
	int* nTemperaturesLocal = NULL;
	int rank = 0;
	int n = 0;
	int iBegin = 0;
	double* energies = NULL;
	double* energiesAll = NULL;
	double* temperaturesAll = NULL;
	int* numMDForTemperatures = NULL;
	FILE* logfile = qmModel->logfile;
	char* fileNamePrefixProp = NULL;
	char* fileNamePrefixTraj = NULL;

	if(nTemperaturesAll<1) return NULL;
	if(qmModel->molecule.nAtoms<1) return NULL;
	if(numberOfGeometries<2) return NULL;

#ifdef ENABLE_MPI
	MPI_Comm_rank( MPI_COMM_WORLD,&rank);
	MPI_Comm_size( MPI_COMM_WORLD,&nproc );
	fprintf(logfile, "Rank#=%d  nproc = %d\n", rank, nproc );
	if(nTemperaturesAll<nproc)
	{
		fprintf(logfile, "nTemperatures<number of procs. I set #proc to nTemperatures=%d\n", nTemperaturesAll);
		nproc = nTemperaturesAll;
	}
	if(rank>nproc-1) return NULL;
#else
	rank = 0;
	nproc = 1;
#endif
	nTemperaturesLocal = malloc(nproc*sizeof(int));
	for(i=0;i<nproc;i++) nTemperaturesLocal[i] = 0;
	n = 0;
	i = nproc-1;
	do{
		nTemperaturesLocal[i]++;
		i--;
		if(i<0) i = nproc-1;
		n++;
		fprintf(logfile,"i=%d n = %d\n",i,n);
	}while(n<nTemperaturesAll);
	/* fprintf(logfile, "basname = %s\n",g_path_get_basename(fileNameTraj));*/
	nTemperatures = nTemperaturesLocal[rank];
	energies = malloc(nTemperaturesAll*sizeof(double));
	energiesAll = malloc(nTemperaturesAll*sizeof(double));
	temperaturesAll = malloc(nTemperaturesAll*sizeof(double));

	iBegin = 0;
	for(i=0;i<rank;i++) iBegin += nTemperaturesLocal[i];
	fprintf(logfile, "Rank#=%d  nTemperatures at this proc  = %d nTemperaturesAll = %d iBegin = %d\n", rank, nTemperatures, nTemperaturesAll,iBegin);

	runTemps = malloc(nTemperatures*sizeof(double));
	if(nTemperaturesAll>1) a = pow(runTemperatureMax/runTemperature,1.0/(nTemperaturesAll-1));
	b = 1.0;
	for(i=0;i<nTemperaturesAll;i++) 
	{
		if(i>=iBegin && i<iBegin+nTemperatures) runTemps[i-iBegin] = runTemperature*b;
		temperaturesAll[i] = runTemperature*b;
		b = b*a;
	}
	fprintf(logfile, "\nTemperatures = ");
	for(k=0;k<nTemperatures;k++) fprintf(logfile, "%f ", runTemps[k]);
	fprintf(logfile, "\n\n");
	fflush(logfile);
	numMDForTemperatures = malloc(nTemperaturesAll*sizeof(int));
	for(i=0;i<nTemperaturesAll;i++)  numMDForTemperatures[i] = i;


	md = malloc(nTemperatures*sizeof(QuantumMechanicsMD));
	printf("end md alloc\n");
	fflush(logfile);
	for(k=0;k<nTemperatures;k++) 
	{
		md[k] = *molecularDynamics;
		md[k].qmModel = malloc(sizeof(QuantumMechanicsModel)); 
		*md[k].qmModel = qmModel->klass->copy(qmModel);
		md[k].numberOfAtoms = qmModel->molecule.nAtoms;
		fprintf(logfile, "nAtoms = %d\n",md[k].numberOfAtoms);
		md[k].updateFrequency = updateFrequency;
	}
	fprintf(logfile, "end md copy\n");
	fflush(logfile);
	updateNumber = malloc(nTemperatures*sizeof(int));
	for(k=0;k<nTemperatures;k++) updateNumber[k] = 0;

	fprintf(logfile,"\nTemperatures = ");
	for(k=0;k<nTemperatures;k++) fprintf(logfile,"%f ", runTemps[k]);
	fprintf(logfile,"\n\n");
	fflush(logfile);

	geometries = malloc(numberOfGeometries*sizeof(QuantumMechanicsModel*));
	for(i=0;i<numberOfGeometries;i++) geometries[i] = NULL;

	currentTemp = heatTemperature/2;
	numberOfHeatSteps = heatTime/stepSize*1000;
	numberOfEquiSteps = equiTime/stepSize*1000;; 
	numberOfRunSteps = runTime/stepSize*1000;; 

	fprintf(logfile,"begin init\n");
	fflush(logfile);
	for(k=0;k<nTemperatures;k++) 
	{
		char* fileNamePropk = NULL;
		char* fileNameTrajk = NULL;
		if(fileNameProp) fileNamePrefixProp = getSuffixNameFile(fileNameProp);
		if(fileNamePrefixProp) fileNamePropk = strdup_printf("%s%0.0f.txt",fileNamePrefixProp,runTemps[k]);
		if(fileNameTraj) fileNamePrefixTraj = getSuffixNameFile(fileNameTraj);
		if(fileNamePrefixTraj) fileNameTrajk = strdup_printf("%s%0.0f.gab",fileNamePrefixTraj,runTemps[k]);
		currentTemp = heatTemperature;
		if(numberOfHeatSteps==0) currentTemp = runTemps[k];
		initMD(&md[k],currentTemp,stepSize, integratorType, thermostat, friction, omegaMax, Nf, collide, qNH, fileNameTrajk, fileNamePropk, numberOfRunSteps,k+iBegin);
		md[k].qmModel->klass->calculateGradient(md[k].qmModel);
		computeEnergies(&md[k]);
	}
	fprintf(logfile,"end init\n");
	fflush(logfile);

	iSel = -1;
	if(rank==0)
	{
		if(str) free(str);
		str = strdup_printf("Geometry selected Potential energy =  %0.4f", md[0].potentialEnergy);
		/* redrawMolecule(&md[0].qmModel->molecule,str);*/
		fprintf(logfile,"%s\n",str);
		fflush(logfile);
		iSel++;
		geometries[iSel] = malloc(sizeof(QuantumMechanicsModel));
		*geometries[iSel] = md[0].qmModel->klass->copy(md[0].qmModel);
		/* waiting(0.1);*/
	}


	for(k=0;k<nTemperatures;k++) 
	{
		md[k].temperature = heatTemperature;
		rescaleVelocities(&md[k]);
		newProperties(&md[k]," ");
	}

	currentTemp = heatTemperature;
	n0 = 0;
	for (i = 0; i < numberOfHeatSteps; i++ )
	for(k=0;k<nTemperatures;k++) 
	{
		//md[k].temperature = currentTemp;
		applyOneStep(&md[k],i);
		md[k].qmModel->firstRun = FALSE;
		currentTemp = heatTemperature + ( runTemps[k] - heatTemperature ) *
				( ( double )( i + 1 )/ numberOfHeatSteps );
		md[k].temperature = currentTemp;
		rescaleVelocities(&md[k]);
		if (++updateNumber[k] >= md[k].updateFrequency )
		{
			if(str) free(str);
			str = strdup_printf(("MD Heating: %0.2f fs, T = %0.2f K T(t) = %8.2f Kin = %0.4f Pot =  %0.4f Tot =  %0.4f"), 
					i*stepSize,
					md[k].temperature, 
					md[k].kelvin, 
					md[k].kineticEnergy,
					md[k].potentialEnergy,
					md[k].totalEnergy
					);
			/* redrawMolecule(&md[k].qmModel->molecule,str);*/
			fprintf(logfile,"%s\n",str);
			fflush(logfile);
			updateNumber[k] = 0;
		}
		//saveProperties(&md[k], n0+i+1, i+1," Heating");
	}

	for(k=0;k<nTemperatures;k++) 
	{
		md[k].temperature = runTemps[k];
		rescaleVelocities(&md[k]);
		updateNumber[k] = md[k].updateFrequency;
	}

	n0 += numberOfHeatSteps;
	for (i = 0; i < numberOfEquiSteps; i++ )
	for(k=0;k<nTemperatures;k++) 
	{
		md[k].temperature = runTemps[k];
		md[k].qmModel->firstRun = FALSE;
		md[k].temperature = runTemps[k];
		/* rescaleVelocities(&md[k]);*/
		applyThermostat(&md[k]);
		if (++updateNumber[k] >= md[k].updateFrequency )
		{
			currentTemp =  runTemps[k];
			if(str) free(str);
			str = strdup_printf(("MD Equilibrium: %0.2f fs, T = %0.2f K  T(t) = %8.2f K Kin = %0.4f Pot =  %0.4f Tot =  %0.4f"), 
					i*stepSize, 
					md[k].temperature, 
					md[k].kelvin, 
					md[k].kineticEnergy,
					md[k].potentialEnergy,
					md[k].totalEnergy
					);
			//redrawMolecule(&md[k].qmModel->molecule,str);
			fprintf(logfile, "%s\n",str);
			fflush(logfile);
			updateNumber[k] = 0;
		}
		//saveProperties(&md[k], n0+i+1, i+1, " Equilibrium");
	}
	for(k=0;k<nTemperatures;k++) 
	{
		md[k].temperature = runTemps[k];
		rescaleVelocities(&md[k]);
		updateNumber[k] = md[k].updateFrequency;
	}

	n0 += numberOfEquiSteps;
	if(str) free(str);
	str = strdup_printf(("Geometry selected Potential energy =  %0.4f"), md[0].potentialEnergy);
	fprintf(logfile,"%s\n",str);
	fflush(logfile);
	if(numberOfGeometries>2) stepSel = numberOfRunSteps/(numberOfGeometries-1);
	else stepSel = numberOfRunSteps;
	if(numberOfExchanges>2) stepExchange =  numberOfRunSteps/(numberOfExchanges-1);
	else stepExchange = numberOfRunSteps;

	for(k=0;k<nTemperatures;k++) md[k].temperature = runTemps[k];
	for (i = 0; i < numberOfRunSteps; i++ )
	{
		for(k=0;k<nTemperatures;k++) 
		{
			applyOneStep(&md[k],i);
			md[k].qmModel->firstRun = FALSE;
			applyThermostat(&md[k]);
			if (++updateNumber[k] >= md[k].updateFrequency )
			{
				if(str) free(str);
				str = strdup_printf(("MD Running: %0.2f fs, T = %0.2f K  T(t) = %8.2f K Kin = %0.4f Pot =  %0.4f Tot =  %0.4f"), 
					i*stepSize, 
					md[k].temperature, 
					md[k].kelvin, 
					md[k].kineticEnergy,
					md[k].potentialEnergy,
					md[k].totalEnergy
					);
				//redrawMolecule(&md[k].qmModel->molecule,str);
				fprintf(logfile,"%s\n",str);
				fflush(logfile);
				updateNumber[k] = 0;
				saveTrajectory(&md[k], i+1);
			}
			saveProperties(&md[k], n0+i+1, i+1," Running");
		}
		for(k=0;k<nTemperatures;k++) 
		if(fabs(temperaturesAll[0]-md[k].temperature)<1e-10 && (i+1)%stepSel==0 && (iSel+1)<numberOfGeometries)
		{
			if(str) free(str);
			str = strdup_printf(("Geometry selected Potential energy =  %0.4f"), md[k].potentialEnergy);
			//redrawMolecule(&md[k].qmModel->molecule,str);
			fprintf(logfile,"%s\n",str);
			fflush(logfile);
			iSel++;
			geometries[iSel] = malloc(sizeof(QuantumMechanicsModel));
			*geometries[iSel] = md[k].qmModel->klass->copy(md[k].qmModel);
			/* waiting(0.1);*/
		}
/* Exchange here */
		if((i+1)%stepExchange==0)
		{
			exchangeReplica(md,  energiesAll, energies,  temperaturesAll, numMDForTemperatures, nTemperaturesLocal, nTemperaturesAll, nTemperatures, nproc, rank,  iBegin, fileNamePrefixProp, fileNamePrefixTraj);
		}
	}
	for(k=0;k<nTemperatures;k++) 
	if(fabs(temperaturesAll[0]-md[k].temperature)<1e-10 && iSel<numberOfGeometries-1)
	{
		if(str) free(str);
		str = strdup_printf(("Geometry selected Potential energy =  %0.4f"), md[k].potentialEnergy);
		//redrawMolecule(&md[0].qmModel->molecule,str);
		fprintf(logfile, "%s\n",str);
		fflush(logfile);
		iSel++;
		geometries[iSel] = malloc(sizeof(QuantumMechanicsModel));
		*geometries[iSel] = md[k].qmModel->klass->copy(md[k].qmModel);
		/* waiting(0.1);*/
	}

	n0 += numberOfRunSteps;

	fprintf(logfile,"End of MD Simulation on rank = %d\n",rank);
	fflush(logfile);
	for(k=0;k<nTemperatures;k++) 
	{
		md[k].qmModel->klass->calculateGradient(md[k].qmModel);
        	gradientNorm = 0;
		for (i = 0; i < md[k].numberOfAtoms; i++)
			for ( j = 0; j < 3; j++)
                        	gradientNorm += 
				md[k].qmModel->molecule.atoms[i].gradient[j] * 
				md[k].qmModel->molecule.atoms[i].gradient[j]; 

        	gradientNorm = sqrt( gradientNorm );
		if(str) free(str);
		str = strdup_printf(("T(K) = %0.2f Gradient = %f Ekin = %f (Kcal/mol) EPot =  %0.4f ETot =  %0.4f T(t) = %0.2f"),
			runTemps[k],
			(double)gradientNorm,
			md[k].kineticEnergy,
			md[k].potentialEnergy,
			md[k].totalEnergy,
			md[k].kelvin 
			); 
		//redrawMolecule(&md[0].qmModel->molecule,str);
		fprintf(logfile, "%s\n",str);
		fflush(logfile);
	}
	if(str) free(str);

	for(k=0;k<nTemperatures;k++) 
	{
		if(md[k].fileTraj)fclose(md[k].fileTraj);
		if(md[k].fileProp)fclose(md[k].fileProp);
		freeQuantumMechanicsMD(&md[k]);
	}
	free(updateNumber);
	free(runTemps);

	return geometries;
}
/**********************************************************************/
QuantumMechanicsModel**    runQuantumMechanicsMDConfo(
		QuantumMechanicsMD* molecularDynamics, QuantumMechanicsModel* qmModel, 
		int updateFrequency, 
		double heatTime, double equiTime, double runTime,
		double heatTemperature, double equiTemperature, double runTemperature,
		double stepSize,
		MDIntegratorType integratorType,
		MDThermostatType thermostat,
		double friction,
		double omegaMax,
		int Nf,
		double collide,
		double qNH,
		int numberOfGeometries,
		char* fileNameTraj,
		char* fileNameProp
		)
{
	int i;
	int j;
	char* str = NULL;
        double gradientNorm = 0;
	int numberOfHeatSteps = 0;
	int numberOfEquiSteps = 0;
	int numberOfRunSteps = 0;
	double currentTemp;
	int updateNumber = 0;
	int n0 = 0;
	QuantumMechanicsModel** geometries = NULL;
	int iSel = 0;
	int stepSel = 1;
	double e0  = 0;
	double esum  = 0;
	double e2sum = 0;
	/* 
	 *  physical constants in SI units
	 *   ------------------------------
	 *      Kb = 1.380662 E-23 J/K
	 *      Na = 6.022045 E23  1/mol
	 *      e = 1.6021892 E-19 C
	 *      eps = 8.85418782 E-12 F/m
	 *                       
	 *      1 Kcal = 4184.0 J
	 *      1 amu = 1.6605655 E-27 Kg
	 *      1 A = 1.0 E-10 m
	 *                                       
	 *       Internally, AKMA units are used:
	 *                                        
	 *       timeFactor = SQRT ( ( 1A )**2 * 1amu * Na  / 1Kcal )
	 *       kBoltzmann = Na *Kb  / 1 Kcal
	*/ 

	/* printf("basname = %s\n",g_path_get_basename(fileNameTraj));*/

	if(qmModel->molecule.nAtoms<1) return NULL;
	if(numberOfGeometries<2) return NULL;
	geometries = malloc(numberOfGeometries*sizeof(QuantumMechanicsModel*));
	for(i=0;i<numberOfGeometries;i++) geometries[i] = NULL;

	molecularDynamics->qmModel = qmModel;
	molecularDynamics->numberOfAtoms = qmModel->molecule.nAtoms;
	molecularDynamics->updateFrequency = updateFrequency;

	currentTemp = heatTemperature/2;
	
	numberOfHeatSteps = heatTime/stepSize*1000;
	numberOfEquiSteps = equiTime/stepSize*1000;; 
	numberOfRunSteps = runTime/stepSize*1000;; 


	currentTemp = heatTemperature;
	if(numberOfHeatSteps==0) currentTemp = equiTemperature; 
	if(numberOfHeatSteps==0 && numberOfEquiSteps==0 ) currentTemp = runTemperature; 

	initMD(molecularDynamics,currentTemp,stepSize,integratorType, thermostat, friction, omegaMax, Nf, collide, qNH, fileNameTraj, fileNameProp, numberOfRunSteps,0);
	molecularDynamics->qmModel->klass->calculateGradient(molecularDynamics->qmModel);
	computeEnergies(molecularDynamics);
	e0 = molecularDynamics->potentialEnergy;
	printf("E0 = The first potential energy in kcal = %f\n",e0); 

	iSel =-1;
	if((i+1)%stepSel==0 && (iSel+1)<numberOfGeometries)
	{
		if(str) free(str);
		str = strdup_printf(("Geometry selected Potential energy =  %0.4f"), molecularDynamics->potentialEnergy);
		//redrawMolecule(&molecularDynamics->qmModel->molecule,str);
		printf("%s\n",str);
		iSel++;
		geometries[iSel] = malloc(sizeof(QuantumMechanicsModel));
		*geometries[iSel] = molecularDynamics->qmModel->klass->copy(molecularDynamics->qmModel);
	}

	molecularDynamics->temperature = heatTemperature;
	rescaleVelocities(molecularDynamics);

	currentTemp = heatTemperature;
	n0 = 0;
	newProperties(molecularDynamics," ");
	/*newProperties(molecularDynamics," ----> Heating");*/
	for (i = 0; i < numberOfHeatSteps; i++ )
	{
		molecularDynamics->temperature = currentTemp;
		applyOneStep(molecularDynamics,i);
		molecularDynamics->qmModel->firstRun = FALSE;
		currentTemp = heatTemperature + ( runTemperature - heatTemperature ) *
				( ( double )( i + 1 )/ numberOfHeatSteps );
		molecularDynamics->temperature = currentTemp;
		rescaleVelocities(molecularDynamics);
		if (++updateNumber >= molecularDynamics->updateFrequency )
		{
			if(str) free(str);
			str = strdup_printf(("MD Heating: %0.2f fs, T = %0.2f K T(t) = %8.2f Kin = %0.4f Pot =  %0.4f Tot =  %0.4f"), 
					i*stepSize, 
					molecularDynamics->temperature, 
					molecularDynamics->kelvin, 
					molecularDynamics->kineticEnergy,
					molecularDynamics->potentialEnergy,
					molecularDynamics->totalEnergy
					);
			//redrawMolecule(&molecularDynamics->qmModel->molecule,str);
			printf("%s\n",str);
			updateNumber = 0;
		}
		saveProperties(molecularDynamics, n0+i+1, i+1," Heating");
	}

	currentTemp = equiTemperature;
	molecularDynamics->temperature = currentTemp;
	rescaleVelocities(molecularDynamics);
	updateNumber = molecularDynamics->updateFrequency;
	n0 += numberOfHeatSteps;
	/* newProperties(molecularDynamics," ----> Equilibrium");*/
	for (i = 0; i < numberOfEquiSteps; i++ )
	{
		molecularDynamics->temperature = currentTemp;
		applyOneStep(molecularDynamics,i);
		molecularDynamics->qmModel->firstRun = FALSE;
		molecularDynamics->temperature = currentTemp;
		/* rescaleVelocities(molecularDynamics);*/
		applyThermostat(molecularDynamics);
		if (++updateNumber >= molecularDynamics->updateFrequency )
		{
			if(str) free(str);
			str = strdup_printf(("MD Equilibrium: %0.2f fs, T = %0.2f K  T(t) = %8.2f K Kin = %0.4f Pot =  %0.4f Tot =  %0.4f"), 
					i*stepSize, 
					molecularDynamics->temperature, 
					molecularDynamics->kelvin, 
					molecularDynamics->kineticEnergy,
					molecularDynamics->potentialEnergy,
					molecularDynamics->totalEnergy
					);
			//redrawMolecule(&molecularDynamics->qmModel->molecule,str);
			printf("%s\n",str);
			updateNumber = 0;
		}
		saveProperties(molecularDynamics, n0+i+1, i+1, " Equilibrium");
	}
	updateNumber = molecularDynamics->updateFrequency;

	currentTemp = runTemperature;
	molecularDynamics->temperature = currentTemp;
	rescaleVelocities(molecularDynamics);
	updateNumber = molecularDynamics->updateFrequency;
	n0 += numberOfEquiSteps;
	/* newProperties(molecularDynamics," ----> Runing");*/
	if(str) free(str);
	str = strdup_printf(("Geometry selected Potential energy =  %0.4f"), molecularDynamics->potentialEnergy);
	//redrawMolecule(&molecularDynamics->qmModel->molecule,str);
	printf("%s\n",str);
	if(numberOfGeometries>2) stepSel = numberOfRunSteps/numberOfGeometries;
	else stepSel = numberOfRunSteps;
	/* printf("Isel = %d\n",stepSel);*/
	esum  = 0;
	e2sum = 0;
	for (i = 0; i < numberOfRunSteps; i++ )
	{
		molecularDynamics->temperature = currentTemp;
		applyOneStep(molecularDynamics,i);
		molecularDynamics->qmModel->firstRun = FALSE;
		applyThermostat(molecularDynamics);
		esum  += molecularDynamics->totalEnergy;
		e2sum += molecularDynamics->totalEnergy*molecularDynamics->totalEnergy;
		if (++updateNumber >= molecularDynamics->updateFrequency )
		{
			if(str) free(str);
			str = strdup_printf(("MD Running: %0.2f fs, T = %0.2f K  T(t) = %8.2f K Kin = %0.4f Pot =  %0.4f Tot =  %0.4f Eav = %0.4f sigE = %0.4f Eva-E0(cm^-1) = %0.2f"), 
					i*stepSize, 
					molecularDynamics->temperature, 
					molecularDynamics->kelvin, 
					molecularDynamics->kineticEnergy,
					molecularDynamics->potentialEnergy,
					molecularDynamics->totalEnergy,
					esum/(i+1),
					sqrt(fabs(e2sum/(i+1)-esum/(i+1)*esum/(i+1))),
					(esum/(i+1)-e0)*349.75511054
					);
			//redrawMolecule(&molecularDynamics->qmModel->molecule,str);
			printf("%s\n",str);
			updateNumber = 0;
			saveTrajectory(molecularDynamics, i+1);
		}
		if((i+1)%stepSel==0 && (iSel+1)<numberOfGeometries)
		{
			if(str) free(str);
			str = strdup_printf(("Geometry selected Potential energy =  %0.4f"), molecularDynamics->potentialEnergy);
			//redrawMolecule(&molecularDynamics->qmModel->molecule,str);
			printf("%s\n",str);
			iSel++;
			geometries[iSel] = malloc(sizeof(QuantumMechanicsModel));
			*geometries[iSel] = molecularDynamics->qmModel->klass->copy(molecularDynamics->qmModel);
		}
		saveProperties(molecularDynamics, n0+i+1, i+1," Running");
	}
	if(iSel<numberOfGeometries-1)
	{
		if(str) free(str);
		str = strdup_printf(("Geometry selected Potential energy =  %0.4f"), molecularDynamics->potentialEnergy);
		//redrawMolecule(&molecularDynamics->qmModel->molecule,str);
		printf("%s\n",str);
		iSel++;
		geometries[iSel] = malloc(sizeof(QuantumMechanicsModel));
		*geometries[iSel] = molecularDynamics->qmModel->klass->copy(molecularDynamics->qmModel);
	}

	updateNumber = molecularDynamics->updateFrequency;
	n0 += numberOfRunSteps;

	molecularDynamics->qmModel->klass->calculateGradient(molecularDynamics->qmModel);
        gradientNorm = 0;
	for (i = 0; i < molecularDynamics->numberOfAtoms; i++)
		for ( j = 0; j < 3; j++)
                        gradientNorm += 
				molecularDynamics->qmModel->molecule.atoms[i].gradient[j] * 
				molecularDynamics->qmModel->molecule.atoms[i].gradient[j]; 

        gradientNorm = sqrt( gradientNorm );
	if(str) free(str);
	str = strdup_printf(("End of MD Simulation. Gradient = %f Ekin = %f (Kcal/mol) EPot =  %0.4f ETot =  %0.4f T(t) = %0.2f"),
			(double)gradientNorm,
			molecularDynamics->kineticEnergy,
			molecularDynamics->potentialEnergy,
			molecularDynamics->totalEnergy,
			molecularDynamics->kelvin 
			); 
	//redrawMolecule(&molecularDynamics->qmModel->molecule,str);
	printf("%s\n",str);
	free(str);
	if(molecularDynamics->fileTraj)fclose(molecularDynamics->fileTraj);
	if(molecularDynamics->fileProp)fclose(molecularDynamics->fileProp);
	freeQuantumMechanicsMD(molecularDynamics);
	return geometries;
}
/**********************************************************************/
static void printGeometryAndVelocities(QuantumMechanicsMD* molecularDynamics, char* title)
{
	fprintf(stdout,"========================================================================================================================\n");
	fprintf(stdout,"#  Geometry and velocities at %s ; T0(K) = %0.2f\n", title, molecularDynamics->kelvin);
	molecularDynamics->qmModel->molecule.klass->addGeometry(& molecularDynamics->qmModel->molecule,stdout);
	molecularDynamics->qmModel->molecule.klass->addVelocities(& molecularDynamics->qmModel->molecule,stdout);
	fprintf(stdout,"========================================================================================================================\n");
}
/**********************************************************************/
void	runQuantumMechanicsMD(
		QuantumMechanicsMD* molecularDynamics, QuantumMechanicsModel* qmModel, 
		int updateFrequency, 
		double heatTime, double equiTime, double runTime, double coolTime, 
		double heatTemperature, double equiTemperature, double runTemperature, double coolTemperature, 
		double stepSize,
		MDIntegratorType integratorType,
		MDThermostatType thermostat,
		double friction,
		double omegaMax,
		int Nf,
		double collide,
		double qNH,
		char* fileNameTraj,
		char* fileNameProp
		)
{
	int i;
	int j;
	char* str = NULL;
        double gradientNorm = 0;
	int numberOfHeatSteps = 0;
	int numberOfEquiSteps = 0;
	int numberOfRunSteps = 0;
	int numberOfCoolSteps = 0;
	double currentTemp;
	int updateNumber = 0;
	int n0 = 0;
	double e0  = 0;
	double esum  = 0;
	double e2sum = 0;
	/* 
	 *  physical constants in SI units
	 *   ------------------------------
	 *      Kb = 1.380662 E-23 J/K
	 *      Na = 6.022045 E23  1/mol
	 *      e = 1.6021892 E-19 C
	 *      eps = 8.85418782 E-12 F/m
	 *                       
	 *      1 Kcal = 4184.0 J
	 *      1 amu = 1.6605655 E-27 Kg
	 *      1 A = 1.0 E-10 m
	 *                                       
	 *       Internally, AKMA units are used:
	 *                                        
	 *       timeFactor = SQRT ( ( 1A )**2 * 1amu * Na  / 1Kcal )
	 *       kBoltzmann = Na *Kb  / 1 Kcal
	*/ 

	/* printf("basname = %s\n",g_path_get_basename(fileNameTraj));*/

	if(qmModel->molecule.nAtoms<1) return;

	molecularDynamics->qmModel = qmModel;
	molecularDynamics->numberOfAtoms = qmModel->molecule.nAtoms;
	molecularDynamics->updateFrequency = updateFrequency;

	currentTemp = heatTemperature/2;
	
	numberOfHeatSteps = heatTime/stepSize*1000;
	numberOfEquiSteps = equiTime/stepSize*1000;; 
	numberOfRunSteps = runTime/stepSize*1000;; 
	numberOfCoolSteps = coolTime/stepSize*1000;;


	currentTemp = heatTemperature;
	if(numberOfHeatSteps==0) currentTemp = equiTemperature; 
	if(numberOfHeatSteps==0 && numberOfEquiSteps==0 ) currentTemp = runTemperature; 
	if(numberOfHeatSteps==0 && numberOfEquiSteps==0 && numberOfRunSteps==0 ) currentTemp = coolTemperature; 

	initMD(molecularDynamics,currentTemp,stepSize,integratorType, thermostat, friction, omegaMax, Nf, collide, qNH, fileNameTraj, fileNameProp, numberOfRunSteps,0);
	molecularDynamics->qmModel->klass->calculateGradient(molecularDynamics->qmModel);

	molecularDynamics->temperature = heatTemperature;
	if( numberOfHeatSteps>0) rescaleVelocities(molecularDynamics);

	computeEnergies(molecularDynamics);
	e0 = molecularDynamics->potentialEnergy;
	printf("E0 = The first potential energy in kcal = %f\n",e0); 
	if( numberOfHeatSteps>0) printGeometryAndVelocities(molecularDynamics, "beginning of Heating stage");

	currentTemp = heatTemperature;
	n0 = 0;
	newProperties(molecularDynamics," ");
	/*newProperties(molecularDynamics," ----> Heating");*/
	for (i = 0; i < numberOfHeatSteps; i++ )
	{
		molecularDynamics->temperature = currentTemp;
		applyOneStep(molecularDynamics,i);
		molecularDynamics->qmModel->firstRun = FALSE;
		currentTemp = heatTemperature + ( runTemperature - heatTemperature ) *
				( ( double )( i + 1 )/ numberOfHeatSteps );
		molecularDynamics->temperature = currentTemp;
		rescaleVelocities(molecularDynamics);
		if (++updateNumber >= molecularDynamics->updateFrequency )
		{
			if(str) free(str);
			str = strdup_printf(("MD Heating: %0.2f fs, T = %0.2f K T(t) = %0.2f Kin = %0.4f Pot =  %0.4f Tot =  %0.4f"), 
					i*stepSize, 
					molecularDynamics->temperature, 
					molecularDynamics->kelvin, 
					molecularDynamics->kineticEnergy,
					molecularDynamics->potentialEnergy,
					molecularDynamics->totalEnergy
					);
			//redrawMolecule(&molecularDynamics->qmModel->molecule,str);
			printf("%s\n",str);
			updateNumber = 0;
		}
		saveProperties(molecularDynamics, n0+i+1, i+1," Heating");
	}

	currentTemp = equiTemperature;
	molecularDynamics->temperature = currentTemp;
	if( numberOfHeatSteps>0) rescaleVelocities(molecularDynamics);
	updateNumber = molecularDynamics->updateFrequency;
	n0 += numberOfHeatSteps;
	/* newProperties(molecularDynamics," ----> Equilibrium");*/
	if(numberOfEquiSteps>0) printGeometryAndVelocities(molecularDynamics, "beginning of Equilibrium stage");
	for (i = 0; i < numberOfEquiSteps; i++ )
	{
		molecularDynamics->temperature = currentTemp;
		applyOneStep(molecularDynamics,i);
		molecularDynamics->qmModel->firstRun = FALSE;
		molecularDynamics->temperature = currentTemp;
		applyThermostat(molecularDynamics);
		if (++updateNumber >= molecularDynamics->updateFrequency )
		{
			if(str) free(str);
			str = strdup_printf(("MD Equilibrium: %0.2f fs, T = %0.2f K  T(t) = %0.2f K Kin = %0.4f Pot =  %0.4f Tot =  %0.4f"), 
					i*stepSize, 
					molecularDynamics->temperature, 
					molecularDynamics->kelvin, 
					molecularDynamics->kineticEnergy,
					molecularDynamics->potentialEnergy,
					molecularDynamics->totalEnergy
					);
			//redrawMolecule(&molecularDynamics->qmModel->molecule,str);
			printf("%s\n",str);
			updateNumber = 0;
		}
		saveProperties(molecularDynamics, n0+i+1, i+1, " Equilibrium");
	}
	updateNumber = molecularDynamics->updateFrequency;

	currentTemp = runTemperature;
	molecularDynamics->temperature = currentTemp;
	/* rescaleVelocities(molecularDynamics);*/
	updateNumber = molecularDynamics->updateFrequency;
	n0 += numberOfEquiSteps;
	/* newProperties(molecularDynamics," ----> Runing");*/
	esum  = 0;
	e2sum = 0;
	if(numberOfRunSteps>0) printGeometryAndVelocities(molecularDynamics, "beginning of Production stage");
	for (i = 0; i < numberOfRunSteps; i++ )
	{
		molecularDynamics->temperature = currentTemp;
		applyOneStep(molecularDynamics,i);
		molecularDynamics->qmModel->firstRun = FALSE;
		applyThermostat(molecularDynamics);
		esum  += molecularDynamics->totalEnergy;
		e2sum += molecularDynamics->totalEnergy*molecularDynamics->totalEnergy;
		if (++updateNumber >= molecularDynamics->updateFrequency )
		{
			if(str) free(str);
			str = strdup_printf(("MD Running: %0.2f fs, T = %0.2f K  T(t) = %8.2f K Kin = %0.4f Pot =  %0.4f Tot =  %0.4f Eav = %0.4f sigE = %0.4f Eav-E0(cm^-1) = %0.2f"), 
					i*stepSize, 
					molecularDynamics->temperature, 
					molecularDynamics->kelvin, 
					molecularDynamics->kineticEnergy,
					molecularDynamics->potentialEnergy,
					molecularDynamics->totalEnergy,
					esum/(i+1),
					sqrt(fabs(e2sum/(i+1)-esum/(i+1)*esum/(i+1))),
					(esum/(i+1)-e0)*349.75511054
					);
			//redrawMolecule(&molecularDynamics->qmModel->molecule,str);
			printf("%s\n",str);
			updateNumber = 0;
			saveTrajectory(molecularDynamics, i+1);
		}
		saveProperties(molecularDynamics, n0+i+1, i+1," Running");
	}
	if(numberOfCoolSteps>0) printGeometryAndVelocities(molecularDynamics, "the begining of Cooling stage");
	updateNumber = molecularDynamics->updateFrequency;
	n0 += numberOfRunSteps;
	/* newProperties(molecularDynamics," ----> Cooling");*/
	for (i = 0; i < numberOfCoolSteps; i++ )
	{
		currentTemp = runTemperature - ( runTemperature - coolTemperature ) * 
				( ( double )( i + 1 )/ numberOfCoolSteps );
		molecularDynamics->temperature = currentTemp;
		rescaleVelocities(molecularDynamics);
		molecularDynamics->temperature = currentTemp;
		applyOneStep(molecularDynamics,i);
		molecularDynamics->qmModel->firstRun = FALSE;
		if (++updateNumber >= molecularDynamics->updateFrequency )
		{
			if(str) free(str);
			str = strdup_printf(("MD Cooling: %0.2f fs, T = %0.2f K T(t) = %0.2f K Kin = %0.4f Pot =  %0.4f Tot =  %0.4f"), 
					i*stepSize, 
					molecularDynamics->temperature, 
					molecularDynamics->kelvin, 
					molecularDynamics->kineticEnergy,
					molecularDynamics->potentialEnergy,
					molecularDynamics->totalEnergy
					);
			//redrawMolecule(&molecularDynamics->qmModel->molecule,str);
			printf("%s\n",str);
			updateNumber = 0;
		}
		saveProperties(molecularDynamics, n0+i+1, i+1," Cooling");
	}
	molecularDynamics->qmModel->klass->calculateGradient(molecularDynamics->qmModel);
        gradientNorm = 0;
	for (i = 0; i < molecularDynamics->numberOfAtoms; i++)
		for ( j = 0; j < 3; j++)
                        gradientNorm += 
				molecularDynamics->qmModel->molecule.atoms[i].gradient[j] * 
				molecularDynamics->qmModel->molecule.atoms[i].gradient[j]; 

        gradientNorm = sqrt( gradientNorm );
	if(str) free(str);
	str = strdup_printf(("End of MD Simulation. Gradient = %f Ekin = %f (Kcal/mol) EPot =  %0.4f ETot =  %0.4f T(t) = %0.2f"),
			(double)gradientNorm,
			molecularDynamics->kineticEnergy,
			molecularDynamics->potentialEnergy,
			molecularDynamics->totalEnergy,
			molecularDynamics->kelvin 
			); 
	//redrawMolecule(&molecularDynamics->qmModel->molecule,str);
	printf("%s\n",str);
	free(str);
	printGeometryAndVelocities(molecularDynamics, "the end of simulation");
	if(molecularDynamics->fileTraj)fclose(molecularDynamics->fileTraj);
	if(molecularDynamics->fileProp)fclose(molecularDynamics->fileProp);
	freeQuantumMechanicsMD(molecularDynamics);
}
/*********************************************************************************/
static void initNH(QuantumMechanicsMD* molecularDynamics, double qNH)
{
	int i;

	if(molecularDynamics->thermostat != NOSEHOOVER) return;
	for(i=0;i<MAXNH;i++)
	{
		molecularDynamics->xNH[i] = 0;
		molecularDynamics->vNH[i] = 0;
		molecularDynamics->qNH[i] = qNH;
		molecularDynamics->gNH[i] = 0;
	}
}
/*********************************************************************************/
static void initSD(QuantumMechanicsMD* molecularDynamics, double friction)
{
	int i;


	if(friction<0) friction = 40;
	molecularDynamics->friction = friction/(fsInAKMA)/1000;

	molecularDynamics->positionFriction = NULL;
	molecularDynamics->velocityFriction = NULL;
	molecularDynamics->accelarationFriction = NULL;
	molecularDynamics->gamma = NULL;
	molecularDynamics->positionRandom = NULL;
	molecularDynamics->velocityRandom = NULL;

	if(molecularDynamics->integratorType != STOCHASTIC) return;

	molecularDynamics->positionFriction = malloc(molecularDynamics->numberOfAtoms *sizeof(double)); 
	molecularDynamics->velocityFriction = malloc(molecularDynamics->numberOfAtoms *sizeof(double)); 
	molecularDynamics->accelarationFriction = malloc(molecularDynamics->numberOfAtoms *sizeof(double)); 
	molecularDynamics->gamma = malloc(molecularDynamics->numberOfAtoms *sizeof(double)); 

	molecularDynamics->positionRandom = malloc(molecularDynamics->numberOfAtoms *sizeof(double*)); 
	for(i=0;i<molecularDynamics->numberOfAtoms;i++)
		molecularDynamics->positionRandom[i] = malloc(3*sizeof(double));

	molecularDynamics->velocityRandom = malloc(molecularDynamics->numberOfAtoms *sizeof(double*)); 
	for(i=0;i<molecularDynamics->numberOfAtoms;i++)
		molecularDynamics->velocityRandom[i] = malloc(3*sizeof(double));

}
/*********************************************************************************/
static void removeTranslationAndRotationTheta(QuantumMechanicsMD* molecularDynamics)
{
	Molecule* molecule = &molecularDynamics->qmModel->molecule;
	double* theta = molecularDynamics->theta;
	molecule->klass->removeTranslationAndRotationAcceleration(molecule,theta);
}
/*********************************************************************************/
static void compteThetaQTB(QuantumMechanicsMD* molecularDynamics)
{
	double sigma=sqrt(2.*molecularDynamics->friction*Kb*molecularDynamics->temperature/molecularDynamics->h);
	int i,j,k;

	/* thetaProg = thetaPaper*sigma/sqrt(m) */
	for(i=0;i<molecularDynamics->numberOfAtoms;i++)
	for(j=0;j<3;j++)
	{
		molecularDynamics->theta[3*i+j] = 0.0;
		for(k=0;k<2*molecularDynamics->Nf;k++)
			molecularDynamics->theta[3*i+j] += molecularDynamics->rnoise[3*i+j][2*molecularDynamics->Nf-1-k]*molecularDynamics->Ht[k];
		molecularDynamics->theta[3*i+j] *= sigma/sqrt(molecularDynamics->qmModel->molecule.atoms[i].mass); 
	}
	removeTranslationAndRotationTheta(molecularDynamics);
}
/*********************************************************************************/
static void resetQTB(QuantumMechanicsMD* molecularDynamics)
{
	double* Filter = NULL;
	int k;
	double hbarwOverkT;
	double hbardwOverkT;
	int i,j;
	double T;
	

	if(molecularDynamics->integratorType != QTB) return;
	T = molecularDynamics->temperature;
	if(T<=0) return;

	/* computing of Filter */
	/* Htild/sqrt(kT), sqrt(kT) in sigma */
	Filter = malloc((2*molecularDynamics->Nf)*sizeof(double)); 
	/* h dOmega = pi /Nf */
	hbardwOverkT = 1.0/(molecularDynamics->Nf*molecularDynamics->h*Kb*T);
	for(k=0;k<2*molecularDynamics->Nf;k++)
	{
		int kk= k-molecularDynamics->Nf;
		if(kk==0) Filter[k] = 1.0;
		else
		{
			hbarwOverkT = fabs(kk)*hbardwOverkT;
			Filter[k] = sqrt(hbarwOverkT*(0.5+1./(exp(hbarwOverkT)-1.0)));
			//Filter[k] = 1.0; // to test classic
			Filter[k] *= (kk*M_PI/molecularDynamics->Nf/2)/sin(kk*M_PI/molecularDynamics->Nf/2);
		}
	}
	/* compute Ht */
	for(j=0;j<2*molecularDynamics->Nf;j++)
	{
                molecularDynamics->Ht[j] = 0;
		for(k=0; k<2*molecularDynamics->Nf;k++)
                	molecularDynamics->Ht[j] += Filter[k]*cos(M_PI*(k-molecularDynamics->Nf)*(j-molecularDynamics->Nf)*1.0/molecularDynamics->Nf);
		
               	molecularDynamics->Ht[j] /= 2*molecularDynamics->Nf;
	}
	free(Filter);
	
	for(i=0;i<molecularDynamics->numberOfAtoms;i++)
	for(j=0;j<3;j++)
	for(k=0;k<2*molecularDynamics->Nf;k++)
		 molecularDynamics->rnoise[3*i+j][k] = normal();/* sqrt(h) is in sigma */

	compteThetaQTB(molecularDynamics);

}
/*********************************************************************************/
/* omegaMax in cm-1 */
static void initQTB(QuantumMechanicsMD* molecularDynamics, double omegaMax, double friction, int Nf)
{
/* Refs 
Jean-Louis Barrat , David Rodney
Portable implementation of a quantum thermal bath for molecular dynamics simulations
JOURNAL OF STATISTICAL PHYSICS 670, 144, (2011)
*/
	static double cmM1fsM1 = 2.99792458e-5;
	double Omegafs = omegaMax*cmM1fsM1;/* fs^-1 */ 
	int i,j;
	

	if(Nf<1) Nf = 50;

	molecularDynamics->Ht = NULL;
	molecularDynamics->theta = NULL;
	molecularDynamics->rnoise = NULL;
	molecularDynamics->Nf = 0;
	molecularDynamics->M = 0;

	if(molecularDynamics->integratorType != QTB) return;

	molecularDynamics->Nf = Nf;
	molecularDynamics->h = 1/Omegafs*(fsInAKMA);
	molecularDynamics->M = (int)(molecularDynamics->h/molecularDynamics->dt);
	if(molecularDynamics->M<1) molecularDynamics->M = 1;
	molecularDynamics->h = molecularDynamics->M *molecularDynamics->dt;
	omegaMax = 1.0/molecularDynamics->h*(fsInAKMA)/cmM1fsM1; /* cm-1 */
	if(friction<0) molecularDynamics->friction = (1.0/ molecularDynamics->h)/50;
	else molecularDynamics->friction = friction/1000.0/fsInAKMA;

	molecularDynamics->Ht = malloc((2*Nf)*sizeof(double)); 
	molecularDynamics->theta = malloc(3*molecularDynamics->numberOfAtoms *sizeof(double)); 
	molecularDynamics->rnoise = malloc(3*molecularDynamics->numberOfAtoms *sizeof(double*)); 
	for(i=0;i<molecularDynamics->numberOfAtoms;i++)
	for(j=0;j<3;j++)
		molecularDynamics->rnoise[3*i+j] = malloc((2*Nf)*sizeof(double)); 
	

	printf("\n");
	printf("*************** QTB Parameters ******************************************************************\n");
	printf("Nf\t\t= %d\n",molecularDynamics->Nf);
	printf("M\t\t= %d\n",molecularDynamics->M);
	printf("dt(fs)\t\t= %f\n",molecularDynamics->dt/fsInAKMA);
	printf("h(fs)\t\t= %f\n",molecularDynamics->h/fsInAKMA);
	printf("gamma(ps^-1)\t= %f\n",molecularDynamics->friction*fsInAKMA*1000);
	printf("omegaMax(cm^-1)\t= %f\n",omegaMax);
	printf("*************************************************************************************************\n");
	printf("\n");

	resetQTB(molecularDynamics);

}
/*********************************************************************************/
static void updateQTB(QuantumMechanicsMD* molecularDynamics)
{
	int i,j,k;

	if(molecularDynamics->temperature<=0) return;
	compteThetaQTB(molecularDynamics);
	/* shift rnoise */
	for(i=0;i<molecularDynamics->numberOfAtoms;i++)
	for(j=0;j<3;j++)
	for(k=0;k<2*molecularDynamics->Nf-1;k++)
		 molecularDynamics->rnoise[3*i+j][k] = molecularDynamics->rnoise[3*i+j][k+1];

	/* add one value to the end */
	for(i=0;i<molecularDynamics->numberOfAtoms;i++)
	for(j=0;j<3;j++)
		 molecularDynamics->rnoise[3*i+j][2*molecularDynamics->Nf-1] = normal(); /* sqrt(h) in sigma */

}
/*********************************************************************************/
static void resetLangevin(QuantumMechanicsMD* molecularDynamics)
{
	if(molecularDynamics->integratorType != LANGEVIN) return;
	updateLangevin(molecularDynamics);
}
/*********************************************************************************/
/* omegaMax in cm-1 */
static void initLangevin(QuantumMechanicsMD* molecularDynamics, double friction)
{
	if(molecularDynamics->integratorType != LANGEVIN) return;

	if(friction<0) friction = 40;
	molecularDynamics->friction = friction/1000/fsInAKMA;
	molecularDynamics->theta = malloc(3*molecularDynamics->numberOfAtoms *sizeof(double)); 
	
	printf("\n");
	printf("*************** Langevin Parameters ******************************************************************\n");
	printf("dt(fs)\t\t= %f\n",molecularDynamics->dt/fsInAKMA);
	printf("gamma(ps^-1)\t= %f\n",molecularDynamics->friction*fsInAKMA*1000);
	printf("*************************************************************************************************\n");
	printf("\n");

	resetLangevin(molecularDynamics);

}
/*********************************************************************************/
static void updateLangevin(QuantumMechanicsMD* molecularDynamics)
{
	int i,j;
	double sigma;
	/* update theta */
	/* thetaProg = thetaPaper*sigma/sqrt(m) */
	if(molecularDynamics->integratorType != LANGEVIN) return;
	sigma=sqrt(6.*molecularDynamics->friction*Kb*molecularDynamics->temperature/molecularDynamics->dt);
	for(i=0;i<molecularDynamics->numberOfAtoms;i++)
	for(j=0;j<3;j++)
	{
		molecularDynamics->theta[3*i+j] = normal();
		molecularDynamics->theta[3*i+j] *= sigma/sqrt(molecularDynamics->qmModel->molecule.atoms[i].mass); 
	}
}
/*********************************************************************************/
/*
static void printTranslation(QuantumMechanicsMD* molecularDynamics)
{
	double vtot[3] = {0,0,0};
	int i;
	int j;
	double mass = 1.0;
	for ( j = 0; j < 3; j++)
		vtot[j] = 0;
	for ( i = 0; i < molecularDynamics->numberOfAtoms; i++)
	{
		mass = molecularDynamics->qmModel->molecule.atoms[i].mass;
		for ( j = 0; j < 3; j++)
		{
			vtot[j] += mass*molecularDynamics->qmModel->molecule.atoms[i].velocity[j];
		}
	}
	printf("Trans velocity = %f %f %f\n",vtot[0], vtot[1], vtot[2]);
}
*/
/*********************************************************************************/
static void removeTranslationAndRotation(QuantumMechanicsMD* molecularDynamics)
{
	Molecule* molecule = &molecularDynamics->qmModel->molecule;
	molecule->klass->removeTranslationAndRotation(molecule); 
}
/*********************************************************************************/
static void initMD(QuantumMechanicsMD* molecularDynamics, double temperature, double stepSize, MDIntegratorType integratorType, MDThermostatType thermostat, double friction, double omegaMax, int Nf, double collide, double qNH, char* fileNameTraj, char* fileNameProp, int numberOfRunSteps, int index)
{
	int i;
	int j;
	double dt = stepSize * fsInAKMA;

	molecularDynamics->collide = collide;
	molecularDynamics->potentialEnergy = 0;
	molecularDynamics->kineticEnergy = 0;
	molecularDynamics->totalEnergy = 0;
	molecularDynamics->kelvin = 0;
	molecularDynamics->temperature = temperature;
	molecularDynamics->thermostat = NONE;

	molecularDynamics->integratorType = integratorType;
	molecularDynamics->thermostat = thermostat;
	molecularDynamics->fileTraj = NULL;
	molecularDynamics->fileProp = NULL;
	molecularDynamics->index = index;

	molecularDynamics->a = malloc(molecularDynamics->numberOfAtoms *sizeof(double*)); 
	for(i=0;i<molecularDynamics->numberOfAtoms;i++)
		molecularDynamics->a[i] = malloc(3*sizeof(double));

	molecularDynamics->aold = NULL;
	if(molecularDynamics->integratorType==BEEMAN)
	{
		molecularDynamics->aold = malloc(molecularDynamics->numberOfAtoms *sizeof(double*)); 
		for(i=0;i<molecularDynamics->numberOfAtoms;i++)
			molecularDynamics->aold[i] = malloc(3*sizeof(double));
	}
	molecularDynamics->coordinatesOld = NULL;
	molecularDynamics->moved = NULL;
	molecularDynamics->update = NULL;
	if(molecularDynamics->qmModel->molecule.constraints!=NOCONSTRAINTS)
	{
		molecularDynamics->coordinatesOld = malloc(molecularDynamics->numberOfAtoms *sizeof(double*)); 
		for(i=0;i<molecularDynamics->numberOfAtoms;i++)
			molecularDynamics->coordinatesOld[i] = malloc(3*sizeof(double));
		molecularDynamics->moved = malloc(molecularDynamics->numberOfAtoms *sizeof(boolean)); 
		molecularDynamics->update = malloc(molecularDynamics->numberOfAtoms *sizeof(boolean)); 

	}
	if(fileNameTraj)
	{
 		molecularDynamics->fileTraj = fopen(fileNameTraj, "w");
		if(molecularDynamics->fileTraj != NULL)
		{
			fprintf(molecularDynamics->fileTraj,"[Gabedit Format]\n");
			fprintf(molecularDynamics->fileTraj,"\n");
			fprintf(molecularDynamics->fileTraj,"[MD]\n");
			if(molecularDynamics->updateFrequency>0) numberOfRunSteps/=molecularDynamics->updateFrequency;
			fprintf(molecularDynamics->fileTraj," %d\n",numberOfRunSteps);
		}
	}
	if(fileNameProp)
	{
 		molecularDynamics->fileProp = fopen(fileNameProp, "w");
	}

	/* srand ( (unsigned)time (NULL));*/
	
	molecularDynamics->dt = dt;
	molecularDynamics->dt_2 = dt/2.0;
	molecularDynamics->dt_4 = dt/4.0;
	molecularDynamics->dt2_2 = dt*dt/2;;
	molecularDynamics->dt_8 = dt/8.0;
	molecularDynamics->dt2_8 = dt*dt/8.0;

	initSD(molecularDynamics, friction);
	initNH(molecularDynamics,qNH);
	initQTB(molecularDynamics,omegaMax, friction, Nf);
	initLangevin(molecularDynamics,friction);


	molecularDynamics->qmModel->klass->calculateGradient(molecularDynamics->qmModel);
	for ( i = 0; i < molecularDynamics->numberOfAtoms; i++)
	{
		double m = molecularDynamics->qmModel->molecule.atoms[i].mass;
		for ( j = 0; j < 3; j++)
			molecularDynamics->a[i][j] = -molecularDynamics->qmModel->molecule.atoms[i].gradient[j]/m;
		if(molecularDynamics->aold)
			for ( j = 0; j < 3; j++)
				molecularDynamics->aold[i][j]  = molecularDynamics->a[i][j];
	}
	if(molecularDynamics->qmModel->molecule.klass->setMaxwellVelocitiesIfNull(&molecularDynamics->qmModel->molecule, temperature)) rescaleVelocities(molecularDynamics);
	removeTranslationAndRotation(molecularDynamics);
#ifdef DEBUG
	printf("nfree =%d\n",molecularDynamics->qmModel->molecule.nfree);
#endif
}
/*********************************************************************************/
static void rescaleVelocities(QuantumMechanicsMD* molecularDynamics)
{
	/* berendsen(molecularDynamics);*/
	scaleV(molecularDynamics);
	resetQTB(molecularDynamics);
	resetLangevin(molecularDynamics);
}
/*********************************************************************************/
static void scaleV(QuantumMechanicsMD* molecularDynamics)
{
	int i;
	int j;
	double ekin = 0;
	double kelvin = 0;
	int nfree = molecularDynamics->qmModel->molecule.nFree;
	double scale = 1.0;
	double mass = 1.0;
	if(molecularDynamics->temperature<=0) return;
	if(nfree<1) return;
	for ( i = 0; i < molecularDynamics->numberOfAtoms; i++)
	{
		mass = molecularDynamics->qmModel->molecule.atoms[i].mass;
		for ( j = 0; j < 3; j++)
			ekin += molecularDynamics->qmModel->molecule.atoms[i].velocity[j]*molecularDynamics->qmModel->molecule.atoms[i].velocity[j]*mass;
	}
	/*
	ekin /= 2;
	kelvin = 2* ekin / ( nfree * Kb);
	*/
	kelvin = ekin / ( nfree * Kb);
	scale = sqrt(molecularDynamics->temperature/kelvin);
#ifdef DEBUG
	printf("temp = %f kelvin = %f scale = %f\n",molecularDynamics->temperature, kelvin, scale);
#endif
	for ( i = 0; i < molecularDynamics->numberOfAtoms; i++)
		if(molecularDynamics->qmModel->molecule.atoms[i].variable)
		for ( j = 0; j < 3; j++)
			molecularDynamics->qmModel->molecule.atoms[i].velocity[j] *= scale;
	removeTranslationAndRotation(molecularDynamics);

/*
	ekin = 0;
	for ( i = 0; i < molecularDynamics->numberOfAtoms; i++)
	{
		mass = molecularDynamics->qmModel->molecule.atoms[i].mass;
		for ( j = 0; j < 3; j++)
			ekin += molecularDynamics->qmModel->molecule.atoms[i].velocity[j]*molecularDynamics->qmModel->molecule.atoms[i].velocity[j]*mass;
	}
	kelvin = ekin / ( nfree * Kb);
	scale = sqrt(molecularDynamics->temperature/kelvin);
	printf("Rem temp = %f kelvin = %f scale = %f\n",molecularDynamics->temperature, kelvin, scale);
*/
}
/*********************************************************************************/
static void berendsen(QuantumMechanicsMD* molecularDynamics)
{
	int i;
	int j;
	double ekin = 0;
	double kelvin = 0;
	int nfree = molecularDynamics->qmModel->molecule.nFree;
	double scale = 1.0;
	double dt = molecularDynamics->dt;
	double tautemp = 1.0/(molecularDynamics->collide)*1000*fsInAKMA;
	double mass = 1.0;
	if(molecularDynamics->temperature<=0) return;
	if(nfree<1) return;
	for ( i = 0; i < molecularDynamics->numberOfAtoms; i++)
	{
		mass = molecularDynamics->qmModel->molecule.atoms[i].mass;
		for ( j = 0; j < 3; j++)
			ekin += molecularDynamics->qmModel->molecule.atoms[i].velocity[j]*molecularDynamics->qmModel->molecule.atoms[i].velocity[j]*mass;
	}
	/*
	ekin /= 2;
	kelvin = 2* ekin / ( nfree * Kb);
	*/
	kelvin = ekin / ( nfree * Kb);
	/* if(tautemp>dt) tautemp = dt;*/
	scale = sqrt(1.0 + (dt/tautemp)*(molecularDynamics->temperature/kelvin-1.0));
#ifdef DEBUG
	printf("temp = %f kelvin = %f scale = %f\n",molecularDynamics->temperature, kelvin, scale);
#endif
	for ( i = 0; i < molecularDynamics->numberOfAtoms; i++)
		if(molecularDynamics->qmModel->molecule.atoms[i].variable)
		for ( j = 0; j < 3; j++)
			molecularDynamics->qmModel->molecule.atoms[i].velocity[j] *= scale;
	removeTranslationAndRotation(molecularDynamics);
}
/*********************************************************************************/
static void andersen(QuantumMechanicsMD* molecularDynamics)
{
	int i;
	double tau = 1.0/molecularDynamics->collide*1000*fsInAKMA; /* in fs */
	double rate;
	if(molecularDynamics->temperature<=0) return;
	if(molecularDynamics->numberOfAtoms<1) return;

	rate = molecularDynamics->dt / tau;
	rate /= pow(molecularDynamics->nvariables,2.0/3.0);

	for ( i = 0; i < molecularDynamics->numberOfAtoms; i++)
	{
		double trial = drandom();
		double m = molecularDynamics->qmModel->molecule.atoms[i].mass;
		if(trial<rate)
		{
/*
			double speed = maxwel(
					molecularDynamics->qmModel->molecule.atoms[i].mass,
					molecularDynamics->temperature
					);
			getRandVect(speed, molecularDynamics->qmModel->molecule.atoms[i].velocity);
*/
			double speed = sqrt(Kb* molecularDynamics->temperature/m);
                	double pnorm = normal();
			molecularDynamics->qmModel->molecule.atoms[i].velocity[0] = pnorm*speed;
                	pnorm = normal();
			molecularDynamics->qmModel->molecule.atoms[i].velocity[1] = pnorm*speed;
                	pnorm = normal();
			molecularDynamics->qmModel->molecule.atoms[i].velocity[2] = pnorm*speed;
		}
	}
}
/*********************************************************************************/
static void bussi(QuantumMechanicsMD* molecularDynamics)
{
	int nfree = molecularDynamics->qmModel->molecule.nFree;
	double scale = 1.0;
	double dt = molecularDynamics->dt;
	double tautemp = 1.0/(molecularDynamics->collide)*1000*fsInAKMA;
        double c = exp(-dt/tautemp);
	double ekin = getEKin(molecularDynamics);
	double kelvin = 2*ekin / ( nfree * Kb);
	double d = (1.0-c) * (molecularDynamics->temperature/kelvin) / (nfree);
	double r = normal ();
	double si = 0.0;
	double s = 0.0;
	int i,j;
	if(molecularDynamics->temperature<=0) return;
	if(nfree<1) return;
        for(i=0;i<nfree-1;i++)
	{
            si = normal ();
            s += si*si;
	}
	scale = c + (s+r*r)*d + 2.0*r*sqrt(c*d);
	scale = sqrt(scale);
	if (r+sqrt(c/d)<0)  scale = -scale;
	for ( i = 0; i < molecularDynamics->numberOfAtoms; i++)
		if(molecularDynamics->qmModel->molecule.atoms[i].variable)
		for ( j = 0; j < 3; j++)
			molecularDynamics->qmModel->molecule.atoms[i].velocity[j] *= scale;
	removeTranslationAndRotation(molecularDynamics);
}
/*********************************************************************************/
static void nose_hoover(QuantumMechanicsMD* molecularDynamics)
{
	int nfree = molecularDynamics->qmModel->molecule.nFree;
	double scale = 1.0;
	double ekin = getEKin(molecularDynamics);
	double kT = Kb* molecularDynamics->temperature;
	int i,j;
	if(molecularDynamics->temperature<=0) return;
	if(nfree<1) return;
	molecularDynamics->gNH[1] = (molecularDynamics->qNH[0]*molecularDynamics->vNH[0]*molecularDynamics->vNH[0]-kT) / molecularDynamics->qNH[1];
	//printf("gNH = %f\n",molecularDynamics->gNH[1]);
	molecularDynamics->vNH[1] = molecularDynamics->vNH[1] + molecularDynamics->gNH[1]*molecularDynamics->dt_4;
	molecularDynamics->vNH[0] = molecularDynamics->vNH[0] * exp(-molecularDynamics->vNH[1]*molecularDynamics->dt_8);
	molecularDynamics->gNH[0] = (2.0*ekin-molecularDynamics->qmModel->molecule.nFree*kT) / molecularDynamics->qNH[0];
	molecularDynamics->vNH[0] = molecularDynamics->vNH[0] + molecularDynamics->gNH[0]*molecularDynamics->dt_4;
	molecularDynamics->vNH[0] = molecularDynamics->vNH[0] * exp(-molecularDynamics->vNH[1]*molecularDynamics->dt_8);
	molecularDynamics->xNH[0] = molecularDynamics->xNH[0] + molecularDynamics->vNH[0]*molecularDynamics->dt_2;
	molecularDynamics->xNH[1] = molecularDynamics->xNH[1] + molecularDynamics->vNH[1]*molecularDynamics->dt_2;
	//printf("vnH0 = %f\n",molecularDynamics->vNH[0]);
	scale = exp(-molecularDynamics->vNH[0]*molecularDynamics->dt_2);
	//printf("scale = %f\n",scale);
	for ( i = 0; i < molecularDynamics->numberOfAtoms; i++)
		for ( j = 0; j < 3; j++)
			molecularDynamics->qmModel->molecule.atoms[i].velocity[j] *= scale;
	//removeTranslationAndRotation(molecularDynamics);
	ekin = ekin * scale * scale;
	molecularDynamics->vNH[0] = molecularDynamics->vNH[0] * exp(-molecularDynamics->vNH[1]*molecularDynamics->dt_8);
	molecularDynamics->gNH[0] = (2.0*ekin-nfree*kT) /  molecularDynamics->qNH[0];
	molecularDynamics->vNH[0] = molecularDynamics->vNH[0] + molecularDynamics->gNH[0]*molecularDynamics->dt_4;
	molecularDynamics->vNH[0] = molecularDynamics->vNH[0] * exp(-molecularDynamics->vNH[1]*molecularDynamics->dt_8);
	molecularDynamics->gNH[1] = ( molecularDynamics->qNH[0]*molecularDynamics->vNH[0]*molecularDynamics->vNH[0]-kT) /  molecularDynamics->qNH[1];
	molecularDynamics->vNH[1] = molecularDynamics->vNH[1] + molecularDynamics->gNH[1]*molecularDynamics->dt_4;

}
/*********************************************************************************/
static void newAccelaration(QuantumMechanicsMD* molecularDynamics)
{
	int i;
	int j;
	molecularDynamics->qmModel->klass->calculateGradient(molecularDynamics->qmModel);
	for ( i = 0; i < molecularDynamics->numberOfAtoms; i++)
	{
		double m = molecularDynamics->qmModel->molecule.atoms[i].mass;
		if(molecularDynamics->aold)
			for ( j = 0; j < 3; j++)
				molecularDynamics->aold[i][j]  = molecularDynamics->a[i][j];

		for ( j = 0; j < 3; j++)
			molecularDynamics->a[i][j] = -molecularDynamics->qmModel->molecule.atoms[i].gradient[j]/m;
	}
}
/*********************************************************************************/
static void computeEnergies(QuantumMechanicsMD* molecularDynamics)
{
	molecularDynamics->kineticEnergy = getEKin(molecularDynamics);
	molecularDynamics->potentialEnergy = molecularDynamics->qmModel->molecule.potentialEnergy;
	molecularDynamics->totalEnergy = molecularDynamics->kineticEnergy + molecularDynamics->potentialEnergy;
	molecularDynamics->kelvin = getKelvin(molecularDynamics);
}
/*********************************************************************************/
static void applyThermostat(QuantumMechanicsMD* molecularDynamics)
{
	if(molecularDynamics->integratorType == STOCHASTIC) return;
	if(molecularDynamics->integratorType == QTB) return;
	if(molecularDynamics->integratorType == LANGEVIN) return;
	if(molecularDynamics->thermostat == ANDERSEN) andersen(molecularDynamics);
	if(molecularDynamics->thermostat == BERENDSEN) berendsen(molecularDynamics);
	if(molecularDynamics->thermostat == BUSSI) bussi(molecularDynamics);
}
/*********************************************************************************/
static void applyOneStep(QuantumMechanicsMD* molecularDynamics, int iStep)
{
	if(molecularDynamics->integratorType == VERLET) applyVerlet(molecularDynamics);
	else if(molecularDynamics->integratorType == BEEMAN) applyBeeman(molecularDynamics);
	else if(molecularDynamics->integratorType == STOCHASTIC) applyStochastic(molecularDynamics);
	else if(molecularDynamics->integratorType == LANGEVIN) 
	{
		updateLangevin(molecularDynamics);
		applyLangevin(molecularDynamics);
	}
	else {
		if((iStep+1)%molecularDynamics->M==0) updateQTB(molecularDynamics);
		applyQTB(molecularDynamics);
	}
	computeEnergies(molecularDynamics);
	/*
	printTranslation(molecularDynamics);
	printRotation(molecularDynamics);
	*/
	removeTranslationAndRotation(molecularDynamics);

}
/*********************************************************************************/
static void applyRattleFirstPortion(QuantumMechanicsMD* quantumMechanicsMD)
{
	int i;
	int k;
	int maxIter = 100;
	double omega = 1.2; 
	double tolerance = 1e-6; 
	boolean done = FALSE;
	int nIter = 0;
	int a1 = 0;
	int a2 = 0;
	double r2ij;
	double dot;
	double invMass1;
	double invMass2;
	double delta;
	double term = 0;
	double terms[3];
	double d;
	Molecule* m = &quantumMechanicsMD->qmModel->molecule;
	QuantumMechanicsModel* qmModel = quantumMechanicsMD->qmModel;
	double deltaMax = 0;

	if(qmModel->molecule.constraints==NOCONSTRAINTS) return;
	for (i = 0; i < quantumMechanicsMD->numberOfAtoms; i++)
	{
			quantumMechanicsMD->moved[i] = quantumMechanicsMD->qmModel->molecule.atoms[i].variable;
			quantumMechanicsMD->update[i] = FALSE;
	}
	maxIter *= quantumMechanicsMD->qmModel->molecule.numberOfRattleConstraintsTerms;
	do{
		nIter++;
		done=TRUE;
		deltaMax = 0;
		for (i = 0; i < quantumMechanicsMD->qmModel->molecule.numberOfRattleConstraintsTerms; i++)
		{
			a1 = (int)quantumMechanicsMD->qmModel->molecule.rattleConstraintsTerms[0][i];
			a2 = (int)quantumMechanicsMD->qmModel->molecule.rattleConstraintsTerms[1][i];
			if( !quantumMechanicsMD->moved[a1] && !quantumMechanicsMD->moved[a2] ) continue;
			r2ij = 0;
			for (k=0;k<3;k++)
			{
				d = m->atoms[a2].coordinates[k]-m->atoms[a1].coordinates[k];
				r2ij +=d*d;
			}
			delta = quantumMechanicsMD->qmModel->molecule.rattleConstraintsTerms[2][i]-r2ij;
			if(deltaMax<fabs(delta)) deltaMax = fabs(delta);
			if(fabs(delta)<=tolerance) continue;
			done = FALSE;
			quantumMechanicsMD->update[a1] = TRUE;
			quantumMechanicsMD->update[a2] = TRUE;
			/* here : rattle image for PBC, not yet implemented */
			dot = 0;
			for (k=0;k<3;k++)
			{
				d = m->atoms[a2].coordinates[k]-m->atoms[a1].coordinates[k];
				dot +=d*(quantumMechanicsMD->coordinatesOld[a2][k]-quantumMechanicsMD->coordinatesOld[a1][k]);
			}
			invMass1 = 1/m->atoms[a1].mass;
			invMass2 = 1/m->atoms[a2].mass;
		        term = omega*delta / (2.0*(invMass1+invMass2)*dot);
			for (k=0;k<3;k++)
			{
				terms[k] = (quantumMechanicsMD->coordinatesOld[a2][k]-quantumMechanicsMD->coordinatesOld[a1][k])*term;
			}
			for (k=0;k<3;k++) m->atoms[a1].coordinates[k] -= terms[k]*invMass1;
			for (k=0;k<3;k++) m->atoms[a2].coordinates[k] += terms[k]*invMass2;

			invMass1 /= quantumMechanicsMD->dt;
			invMass2 /= quantumMechanicsMD->dt;
			for (k=0;k<3;k++) quantumMechanicsMD->qmModel->molecule.atoms[a1].velocity[k] -= terms[k]*invMass1;
			for (k=0;k<3;k++) quantumMechanicsMD->qmModel->molecule.atoms[a2].velocity[k] += terms[k]*invMass2;
		}
		for (i = 0; i < quantumMechanicsMD->numberOfAtoms; i++)
		{
			quantumMechanicsMD->moved[i] = quantumMechanicsMD->update[i];
			quantumMechanicsMD->update[i] = FALSE;
		}
	}while(!done && nIter<maxIter);
	if(nIter>=maxIter && deltaMax>tolerance*10)
	{
		printf(("Rattle first portion : Warning, distance constraints not satisfied\n"));
	}
	for (i = 0; i <  quantumMechanicsMD->numberOfAtoms; i++)
	if(!m->atoms[i].variable)
	{
		for (k=0;k<3;k++)  quantumMechanicsMD->qmModel->molecule.atoms[i].velocity[k] = 0.0;
		for (k=0;k<3;k++)  for (k=0;k<3;k++) m->atoms[i].coordinates[k] =  quantumMechanicsMD->coordinatesOld[i][k];
	}

}
/*********************************************************************************/
static void applyRattleSecondPortion(QuantumMechanicsMD* quantumMechanicsMD)
{
	int i;
	int k;
	int maxIter = 100;
	double omega = 1.2;
	double tolerance = 1e-6;
	boolean done = FALSE;
	int nIter = 0;
	int a1 = 0;
	int a2 = 0;
	double r2ij;
	double dot;
	double invMass1;
	double invMass2;
	double term = 0;
	double terms[3];
	double d;
	Molecule* m = &quantumMechanicsMD->qmModel->molecule;
	QuantumMechanicsModel* qmModel = quantumMechanicsMD->qmModel;
	double deltaMax = 0;

	if(qmModel->molecule.constraints==NOCONSTRAINTS) return;
	tolerance /= quantumMechanicsMD->dt;
	for (i = 0; i < quantumMechanicsMD->numberOfAtoms; i++)
	{
			quantumMechanicsMD->moved[i] = quantumMechanicsMD->qmModel->molecule.atoms[i].variable;
			quantumMechanicsMD->update[i] = FALSE;
	}
	maxIter *= quantumMechanicsMD->qmModel->molecule.numberOfRattleConstraintsTerms;
	do{
		nIter++;
		done=TRUE;
		deltaMax = 0;
		for (i = 0; i < quantumMechanicsMD->qmModel->molecule.numberOfRattleConstraintsTerms; i++)
		{
			a1 = (int)quantumMechanicsMD->qmModel->molecule.rattleConstraintsTerms[0][i];
			a2 = (int)quantumMechanicsMD->qmModel->molecule.rattleConstraintsTerms[1][i];
			r2ij = quantumMechanicsMD->qmModel->molecule.rattleConstraintsTerms[2][i];
			if( !quantumMechanicsMD->moved[a1] && !quantumMechanicsMD->moved[a2] ) continue;
			/* here : rattle image for PBC, not yet implemented */
			dot = 0;
			for (k=0;k<3;k++)
			{
				d = m->atoms[a2].coordinates[k]-m->atoms[a1].coordinates[k];
				dot +=d*(quantumMechanicsMD->qmModel->molecule.atoms[a2].velocity[k]-quantumMechanicsMD->qmModel->molecule.atoms[a1].velocity[k]);
			}
			invMass1 = 1/quantumMechanicsMD->qmModel->molecule.atoms[a1].mass;
			invMass2 = 1/quantumMechanicsMD->qmModel->molecule.atoms[a2].mass;
		        term = -dot / ((invMass1+invMass2)*r2ij);
			if(deltaMax<fabs(term)) deltaMax = fabs(term);
			if(fabs(term)<=tolerance) continue;
			done = FALSE;
			quantumMechanicsMD->update[a1] = TRUE;
			quantumMechanicsMD->update[a2] = TRUE;
		        term *= omega;

			for (k=0;k<3;k++)
			{
				d = m->atoms[a2].coordinates[k]-m->atoms[a1].coordinates[k];
				terms[k] = d*term;
			}
			for (k=0;k<3;k++) quantumMechanicsMD->qmModel->molecule.atoms[a1].velocity[k] -= terms[k]*invMass1;
			for (k=0;k<3;k++) quantumMechanicsMD->qmModel->molecule.atoms[a2].velocity[k] += terms[k]*invMass2;
		}
		for (i = 0; i < quantumMechanicsMD->numberOfAtoms; i++)
		{
			quantumMechanicsMD->moved[i] = quantumMechanicsMD->update[i];
			quantumMechanicsMD->update[i] = FALSE;
		}
	}while(!done && nIter<maxIter);
	if(nIter>=maxIter && deltaMax>tolerance*10)
	{
		printf(("Rattle second portion : Warning, velocity constraints not satisfied\n"));
	}
	for (i = 0; i <  quantumMechanicsMD->numberOfAtoms; i++)
			if(!m->atoms[i].variable)
			for (k=0;k<3;k++)  quantumMechanicsMD->qmModel->molecule.atoms[i].velocity[k] = 0.0;
}
/*********************************************************************************/
static void applyVerlet(QuantumMechanicsMD* molecularDynamics)
{
	int i;
	int j;

	if(molecularDynamics->qmModel->molecule.constraints!=NOCONSTRAINTS)
	for (i = 0; i < molecularDynamics->numberOfAtoms; i++)
		for ( j = 0; j < 3; j++)
				molecularDynamics->coordinatesOld[i][j]= molecularDynamics->qmModel->molecule.atoms[i].coordinates[j];

	for (i = 0; i < molecularDynamics->numberOfAtoms; i++)
	{
		if(!molecularDynamics->qmModel->molecule.atoms[i].variable) continue;

		for ( j = 0; j < 3; j++)
		{
			molecularDynamics->qmModel->molecule.atoms[i].coordinates[j] += 
				molecularDynamics->qmModel->molecule.atoms[i].velocity[j] * molecularDynamics->dt +
				molecularDynamics->a[i][j]*molecularDynamics->dt2_2;	
		}
		for ( j = 0; j < 3; j++)
			molecularDynamics->qmModel->molecule.atoms[i].velocity[j] += molecularDynamics->a[i][j] * molecularDynamics->dt_2;
	}

	if(molecularDynamics->qmModel->molecule.constraints!=NOCONSTRAINTS) applyRattleFirstPortion(molecularDynamics);
	if(molecularDynamics->thermostat==NOSEHOOVER) nose_hoover(molecularDynamics);

	newAccelaration(molecularDynamics);

	for (i = 0; i < molecularDynamics->numberOfAtoms; i++)
		if(molecularDynamics->qmModel->molecule.atoms[i].variable)
		for ( j = 0; j < 3; j++)
			molecularDynamics->qmModel->molecule.atoms[i].velocity[j] += molecularDynamics->a[i][j] * molecularDynamics->dt_2;
	if(molecularDynamics->qmModel->molecule.constraints!=NOCONSTRAINTS) applyRattleSecondPortion(molecularDynamics);
}
/*********************************************************************************/
static void applyBeeman(QuantumMechanicsMD* molecularDynamics)
{
	int i;
	int j;
	double terms[3];
	if(molecularDynamics->qmModel->molecule.constraints!=NOCONSTRAINTS)
	for (i = 0; i < molecularDynamics->numberOfAtoms; i++)
		for ( j = 0; j < 3; j++)
				molecularDynamics->coordinatesOld[i][j]= molecularDynamics->qmModel->molecule.atoms[i].coordinates[j];

	for (i = 0; i < molecularDynamics->numberOfAtoms; i++)
	{
		if(!molecularDynamics->qmModel->molecule.atoms[i].variable) continue;

		for ( j = 0; j < 3; j++)
			terms[j] = 5.0*molecularDynamics->a[i][j]-molecularDynamics->aold[i][j];

		for ( j = 0; j < 3; j++)
		{
			molecularDynamics->qmModel->molecule.atoms[i].coordinates[j] += 
				molecularDynamics->qmModel->molecule.atoms[i].velocity[j] * molecularDynamics->dt +
				terms[j]*molecularDynamics->dt2_8;	
		}
		for ( j = 0; j < 3; j++)
			molecularDynamics->qmModel->molecule.atoms[i].velocity[j] += terms[j] * molecularDynamics->dt_8;
	}

	if(molecularDynamics->qmModel->molecule.constraints!=NOCONSTRAINTS) applyRattleFirstPortion(molecularDynamics);
	if(molecularDynamics->thermostat==NOSEHOOVER) nose_hoover(molecularDynamics);

	newAccelaration(molecularDynamics);

	for (i = 0; i < molecularDynamics->numberOfAtoms; i++)
		if(molecularDynamics->qmModel->molecule.atoms[i].variable)
		for ( j = 0; j < 3; j++)
			molecularDynamics->qmModel->molecule.atoms[i].velocity[j] += (3.0*molecularDynamics->a[i][j]+molecularDynamics->aold[i][j]) * molecularDynamics->dt_8;
	if(molecularDynamics->qmModel->molecule.constraints!=NOCONSTRAINTS) applyRattleSecondPortion(molecularDynamics);
}
/*********************************************************************************/
static void newProperties(QuantumMechanicsMD* molecularDynamics, char* comments)
{
	if( molecularDynamics->fileProp == NULL) return;
	fprintf(molecularDynamics->fileProp,"Time0(fs)\tTime(fs)\tTotal Energy(Kcal/mol)\tPotential Energy(kcal/mol)\tKinetic Energy(Kcal/mol)\tT(t) (K)\tTaver(K)\tsigma(T)(K)\tIndex\tmuX\tmuY\tmuZ");
	if(molecularDynamics->thermostat==NOSEHOOVER) fprintf(molecularDynamics->fileProp,"\tEtot+Etherm");
	if(comments) fprintf(molecularDynamics->fileProp,"%s\n", comments);
	else fprintf(molecularDynamics->fileProp,"\n");
}
/*********************************************************************************/
static void saveProperties(QuantumMechanicsMD* molecularDynamics, int iStep0, int iStep, char* comments)
{
	double dt = molecularDynamics->dt/(fsInAKMA);
	static double Ttot = 0;
	static double T2tot = 0;
	double Taver = 0;
	double T2aver = 0;
	double totalEnergy =  molecularDynamics->totalEnergy;

	if( molecularDynamics->thermostat==NOSEHOOVER)
	{
		int i;
		double kT = Kb* molecularDynamics->temperature;
		double e = molecularDynamics->vNH[0]*molecularDynamics->vNH[0]* molecularDynamics->qNH[0]/2 + (molecularDynamics->qmModel->molecule.nFree)*kT* molecularDynamics->xNH[0];
		for(i=1;i<MAXNH;i++) e += molecularDynamics->vNH[i]*molecularDynamics->vNH[i]* molecularDynamics->qNH[i]/2 + kT* molecularDynamics->xNH[i];
		
		totalEnergy += e;
	}

	if( molecularDynamics->fileProp == NULL) return;
	if(iStep==1)
	{
			Ttot = 0;
			T2tot = 0;
	}
	Ttot += molecularDynamics->kelvin;
	T2tot += molecularDynamics->kelvin*molecularDynamics->kelvin;
	Taver = Ttot/iStep;
	T2aver = T2tot/iStep;


	fprintf(molecularDynamics->fileProp,"%f\t%f\t%f\t\t%f\t\t\t%f\t\t\t%f\t%f\t%f\t%d\t", 
			(iStep0)*dt, 
			(iStep)*dt, 
			molecularDynamics->totalEnergy,
			molecularDynamics->potentialEnergy,
			molecularDynamics->kineticEnergy,
			molecularDynamics->kelvin,
			Taver,
			sqrt(fabs(T2aver-Taver*Taver)),
			molecularDynamics->index
			 );
	fprintf(molecularDynamics->fileProp,"%f\t%f\t%f\t", 
			molecularDynamics->qmModel->molecule.dipole[0], 
			molecularDynamics->qmModel->molecule.dipole[1], 
			molecularDynamics->qmModel->molecule.dipole[2]);
	if( molecularDynamics->thermostat==NOSEHOOVER) fprintf(molecularDynamics->fileProp,"%f\t",totalEnergy);
	if(comments) fprintf(molecularDynamics->fileProp,"%s\n", comments);
	else fprintf(molecularDynamics->fileProp,"\n");
}
/*********************************************************************************/
static void saveTrajectory(QuantumMechanicsMD* molecularDynamics, int iStep)
{
	double dt = molecularDynamics->dt/(fsInAKMA);
	int i;
	if( molecularDynamics->fileTraj == NULL) return;

	fprintf(molecularDynamics->fileTraj," %d %f %f %f %f nAtoms time(fs) TotalEnery(Kcal/mol) Kinetic Potential\n", 
			molecularDynamics->numberOfAtoms,
			 (iStep)*dt, 
			molecularDynamics->totalEnergy,
			molecularDynamics->kineticEnergy,
			molecularDynamics->potentialEnergy
			 );
	fprintf(molecularDynamics->fileTraj," %s\n", "Coord in Ang, Velocity in AKMA, time in fs");

	for (i = 0; i < molecularDynamics->numberOfAtoms; i++)
	{
		fprintf(molecularDynamics->fileTraj," %s %f %f %f %f %f %f %f %s %s %s %d %d\n", 
				molecularDynamics->qmModel->molecule.atoms[i].prop.symbol,
				molecularDynamics->qmModel->molecule.atoms[i].coordinates[0],
				molecularDynamics->qmModel->molecule.atoms[i].coordinates[1],
				molecularDynamics->qmModel->molecule.atoms[i].coordinates[2],
				molecularDynamics->qmModel->molecule.atoms[i].velocity[0],
				molecularDynamics->qmModel->molecule.atoms[i].velocity[1],
				molecularDynamics->qmModel->molecule.atoms[i].velocity[2],
				molecularDynamics->qmModel->molecule.atoms[i].charge,
				molecularDynamics->qmModel->molecule.atoms[i].mmType,
				molecularDynamics->qmModel->molecule.atoms[i].pdbType,
				molecularDynamics->qmModel->molecule.atoms[i].residueName,
				molecularDynamics->qmModel->molecule.atoms[i].residueNumber,
				molecularDynamics->qmModel->molecule.atoms[i].variable
				);
	}
}

/**********************************************************************/
void	freeQuantumMechanicsMD(QuantumMechanicsMD* molecularDynamics)
{

	molecularDynamics->qmModel = NULL;
	molecularDynamics->numberOfAtoms = 0;
	molecularDynamics->updateFrequency = 0;
	if(molecularDynamics->a)
	{
		int i;
		for(i=0;i<molecularDynamics->numberOfAtoms;i++)
			if(molecularDynamics->a[i]) free(molecularDynamics->a[i]);
		free(molecularDynamics->a);
	}
	if(molecularDynamics->aold)
	{
		int i;
		for(i=0;i<molecularDynamics->numberOfAtoms;i++)
			if(molecularDynamics->aold[i]) free(molecularDynamics->aold[i]);
		free(molecularDynamics->aold);
	}
	if(molecularDynamics->coordinatesOld)
	{
		int i;
		for(i=0;i<molecularDynamics->numberOfAtoms;i++)
			if(molecularDynamics->coordinatesOld[i]) free(molecularDynamics->coordinatesOld[i]);
		free(molecularDynamics->coordinatesOld);
	}
	if(molecularDynamics->moved) free(molecularDynamics->moved);
	if(molecularDynamics->update) free(molecularDynamics->update);
	if(molecularDynamics->positionFriction) free(molecularDynamics->positionFriction);
	if(molecularDynamics->velocityFriction) free(molecularDynamics->velocityFriction);
	if(molecularDynamics->accelarationFriction) free(molecularDynamics->accelarationFriction);
	if(molecularDynamics->gamma) free(molecularDynamics->gamma);
	if(molecularDynamics->positionRandom) free(molecularDynamics->positionRandom);
	if(molecularDynamics->velocityRandom) free(molecularDynamics->velocityRandom);
	if(molecularDynamics->Ht) free(molecularDynamics->Ht);
	if(molecularDynamics->theta) free(molecularDynamics->theta);
	if(molecularDynamics->rnoise)
	{
		int i,j;
		for(i=0;i<molecularDynamics->numberOfAtoms;i++)
		for(j=0;j<3;j++)
			if(molecularDynamics->rnoise[3*i+j]) free(molecularDynamics->rnoise[3*i+j]);
		free(molecularDynamics->rnoise);
	}
}
/********************************************************************************/
static double getEKin(QuantumMechanicsMD* molecularDynamics)
{
	double ekin = 0;
	int i;
	int j;
	double mass;
	for ( i = 0; i < molecularDynamics->numberOfAtoms; i++)
	{
		mass = molecularDynamics->qmModel->molecule.atoms[i].mass;
		for ( j = 0; j < 3; j++)
			ekin += molecularDynamics->qmModel->molecule.atoms[i].velocity[j]*molecularDynamics->qmModel->molecule.atoms[i].velocity[j]*
				mass;
	}
	return ekin/2;
}
/********************************************************************************/
static double getKelvin(QuantumMechanicsMD* molecularDynamics)
{
	int nfree = molecularDynamics->qmModel->molecule.nFree;
	/* printf("nfree = %d\n",nfree);*/
	if(nfree<1) return 0;
	return 2*getEKin(molecularDynamics) / ( nfree * Kb);
}
/********************************************************************************/
/*
     literature references:

     M. P. Allen, "Brownian Dynamics Simulation of a Chemical
     Reaction in Solution", Molecular Physics, 40, 1073-1087 (1980)

     F. Guarnieri and W. C. Still, "A Rapidly Convergent Simulation
     Method: Mixed Monte Carlo / Stochastic Dynamics", Journal of
     Computational Chemistry, 15, 1302-1310 (1994)
*/
/*********************************************************************************/
static void getsFrictionalAndRandomForce(QuantumMechanicsMD* molecularDynamics)
{
	double* gamma = molecularDynamics->gamma;
	double* positionFriction = molecularDynamics->positionFriction;
	double* velocityFriction = molecularDynamics->velocityFriction;
	double* accelarationFriction = molecularDynamics->accelarationFriction;
	double** positionRandom = molecularDynamics->positionRandom;
	double** velocityRandom = molecularDynamics->velocityRandom;
	double dt = molecularDynamics->dt;
	
	int n = molecularDynamics->numberOfAtoms;

	int i;
	int j;
	double gdt;
	double egdt;
	double ktm = 0;
	double pterm;
	double vterm;
        double psig;
        double vsig;
        double rho;
        double rhoc;
	double pnorm;
	double vnorm;

	for(i=0;i<n;i++)
        	gamma[i] = molecularDynamics->friction;

	/* printf(" friction = %f\n", molecularDynamics->friction);*/
	for(i=0;i<n;i++)
	{
		gdt = gamma[i] * dt;
		/* printf("gdt = %f\n",gdt);*/
		if (gdt <= 0.0)
		{
               		positionFriction[i] = 1.0;
			velocityFriction[i] = dt;
			accelarationFriction[i] = 0.5 * dt * dt;
			for(j=0;j<3;j++)
			{
                  		positionRandom[i][j] = 0.0;
                  		velocityRandom[i][j] = 0.0;
			}
		}
            	else
		{
			/* analytical expressions when friction coefficient is large */
               		if (gdt>=0.05)
			{
                  		egdt = exp(-gdt);
                  		positionFriction[i] = egdt;
                  		velocityFriction[i] = (1.0-egdt) / gamma[i];
                  		accelarationFriction[i] = (dt-velocityFriction[i]) / gamma[i];
                  		pterm = 2.0*gdt - 3.0 + (4.0-egdt)*egdt;
                  		vterm = 1.0 - egdt*egdt;
                  		rho = (1.0-egdt)*(1.0-egdt) / sqrt(pterm*vterm);
			}
			/* use series expansions when friction coefficient is small */
			else
			{
                  		double gdt2 = gdt * gdt;
                  		double gdt3 = gdt * gdt2;
                  		double gdt4 = gdt2 * gdt2;
                  		double gdt5 = gdt2 * gdt3;
                  		double gdt6 = gdt3 * gdt3;
                  		double gdt7 = gdt3 * gdt4;
                  		double gdt8 = gdt4 * gdt4;
                  		double gdt9 = gdt4 * gdt5;
                  		accelarationFriction[i] = (gdt2/2.0 - gdt3/6.0 + gdt4/24.0
                               	- gdt5/120.0 + gdt6/720.0
                               	- gdt7/5040.0 + gdt8/40320.0
                               	- gdt9/362880.0) / gamma[i]/gamma[i];
                  		velocityFriction[i] = dt - gamma[i]*accelarationFriction[i];
                  		positionFriction[i] = 1.0 - gamma[i]*velocityFriction[i];
                  		pterm = 2.0*gdt3/3.0 - gdt4/2.0
                            	+ 7.0*gdt5/30.0 - gdt6/12.0
                            	+ 31.0*gdt7/1260.0 - gdt8/160.0
                            	+ 127.0*gdt9/90720.0;
                  		vterm = 2.0*gdt - 2.0*gdt2 + 4.0*gdt3/3.0
                            	- 2.0*gdt4/3.0 + 4.0*gdt5/15.0
                            	- 4.0*gdt6/45.0 + 8.0*gdt7/315.0
                            	- 2.0*gdt8/315.0 + 4.0*gdt9/2835.0;
                  		rho = sqrt(3.0) * (0.5 - 3.0*gdt/16.0
                            	- 17.0*gdt2/1280.0
                            	+ 17.0*gdt3/6144.0
                            	+ 40967.0*gdt4/34406400.0
                            	- 57203.0*gdt5/275251200.0
                            	- 1429487.0*gdt6/13212057600.0);
			}
               		ktm = Kb * molecularDynamics->temperature / molecularDynamics->qmModel->molecule.atoms[i].mass;
               		psig = sqrt(ktm*pterm) / gamma[i];
               		vsig = sqrt(ktm*vterm);
               		rhoc = sqrt(1.0 - rho*rho);
			for(j=0;j<3;j++)
			{
                		pnorm = normal();
             			vnorm = normal ();
				positionRandom[i][j] = psig * pnorm;
                  		velocityRandom[i][j] = vsig * (rho*pnorm+rhoc*vnorm);
			}
		}
	}
}
/*********************************************************************************/
static void applyStochastic(QuantumMechanicsMD* molecularDynamics)
{
	double* positionFriction = molecularDynamics->positionFriction;
	double* velocityFriction = molecularDynamics->velocityFriction;
	double* accelarationFriction = molecularDynamics->accelarationFriction;
	double** positionRandom = molecularDynamics->positionRandom;
	double** velocityRandom = molecularDynamics->velocityRandom;
	double**a = molecularDynamics->a;
	
	int n = molecularDynamics->numberOfAtoms;
	int i;
	int j;
	Atom* atoms = molecularDynamics->qmModel->molecule.atoms;

	getsFrictionalAndRandomForce(molecularDynamics);

	if(molecularDynamics->qmModel->molecule.constraints!=NOCONSTRAINTS)
	for (i = 0; i < n; i++)
		for ( j = 0; j < 3; j++)
				molecularDynamics->coordinatesOld[i][j]= molecularDynamics->qmModel->molecule.atoms[i].coordinates[j];

	for(i=0;i<n;i++)
	{
		if(!molecularDynamics->qmModel->molecule.atoms[i].variable) continue;
		for(j=0;j<3;j++)
			atoms[i].coordinates[j] += molecularDynamics->qmModel->molecule.atoms[i].velocity[j]*velocityFriction[i] + a[i][j]*accelarationFriction[i] + positionRandom[i][j];
		for(j=0;j<3;j++)
			molecularDynamics->qmModel->molecule.atoms[i].velocity[j] = molecularDynamics->qmModel->molecule.atoms[i].velocity[j]*positionFriction[i] + 0.5*a[i][j]*velocityFriction[i];
	}

	if(molecularDynamics->qmModel->molecule.constraints!=NOCONSTRAINTS) applyRattleFirstPortion(molecularDynamics);

	newAccelaration(molecularDynamics);

	for (i = 0; i < n; i++)
		if(molecularDynamics->qmModel->molecule.atoms[i].variable)
		for ( j = 0; j < 3; j++)
			molecularDynamics->qmModel->molecule.atoms[i].velocity[j] += 0.5*a[i][j]*velocityFriction[i] + velocityRandom[i][j];
	if(molecularDynamics->qmModel->molecule.constraints!=NOCONSTRAINTS) applyRattleSecondPortion(molecularDynamics);
	removeTranslationAndRotation(molecularDynamics);
	computeEnergies(molecularDynamics);
}
/*********************************************************************************/
static void applyQTB(QuantumMechanicsMD* molecularDynamics)
{
	
	int n = molecularDynamics->numberOfAtoms;
	int i;
	int j;
	double gp = 1/(1+molecularDynamics->friction*molecularDynamics->dt_2);
	double gm = (1-molecularDynamics->friction*molecularDynamics->dt_2)*gp;

	/* printf("gm = %f gp =%f\n",gm,gp);*/
	if(molecularDynamics->qmModel->molecule.constraints!=NOCONSTRAINTS)
	for (i = 0; i < n; i++)
		for ( j = 0; j < 3; j++)
				molecularDynamics->coordinatesOld[i][j]= molecularDynamics->qmModel->molecule.atoms[i].coordinates[j];

	for (i = 0; i < n; i++)
		if(molecularDynamics->qmModel->molecule.atoms[i].variable)
		for ( j = 0; j < 3; j++)
		{
			molecularDynamics->qmModel->molecule.atoms[i].coordinates[j] += 
			molecularDynamics->qmModel->molecule.atoms[i].velocity[j]*molecularDynamics->dt +
			(molecularDynamics->a[i][j]+molecularDynamics->theta[3*i+j]-molecularDynamics->qmModel->molecule.atoms[i].velocity[j]*molecularDynamics->friction)*molecularDynamics->dt2_2;	
		}
	for (i = 0; i < n; i++)
		if(molecularDynamics->qmModel->molecule.atoms[i].variable)
		for ( j = 0; j < 3; j++)
			molecularDynamics->qmModel->molecule.atoms[i].velocity[j] = 
			gm*molecularDynamics->qmModel->molecule.atoms[i].velocity[j] +
			gp*(molecularDynamics->a[i][j]+molecularDynamics->theta[3*i+j])*molecularDynamics->dt_2;
            
	if(molecularDynamics->qmModel->molecule.constraints!=NOCONSTRAINTS) applyRattleFirstPortion(molecularDynamics);

	newAccelaration(molecularDynamics);

	for (i = 0; i < n; i++)
		if(molecularDynamics->qmModel->molecule.atoms[i].variable)
		for ( j = 0; j < 3; j++)
			molecularDynamics->qmModel->molecule.atoms[i].velocity[j] += gp*(molecularDynamics->a[i][j]+molecularDynamics->theta[3*i+j])*molecularDynamics->dt_2;

	if(molecularDynamics->qmModel->molecule.constraints!=NOCONSTRAINTS) applyRattleSecondPortion(molecularDynamics);
	removeTranslationAndRotation(molecularDynamics);
	computeEnergies(molecularDynamics);
}
/*********************************************************************************/
static void applyLangevin(QuantumMechanicsMD* molecularDynamics)
{
	
	int n = molecularDynamics->numberOfAtoms;
	int i;
	int j;
	double gp = 1/(1+molecularDynamics->friction*molecularDynamics->dt_2);
	double gm = (1-molecularDynamics->friction*molecularDynamics->dt_2)*gp;

	/* printf("gm = %f gp =%f\n",gm,gp);*/
	if(molecularDynamics->qmModel->molecule.constraints!=NOCONSTRAINTS)
	for (i = 0; i < n; i++)
		for ( j = 0; j < 3; j++)
				molecularDynamics->coordinatesOld[i][j]= molecularDynamics->qmModel->molecule.atoms[i].coordinates[j];

	for (i = 0; i < n; i++)
		if(molecularDynamics->qmModel->molecule.atoms[i].variable)
		for ( j = 0; j < 3; j++)
		{
			molecularDynamics->qmModel->molecule.atoms[i].coordinates[j] += 
			molecularDynamics->qmModel->molecule.atoms[i].velocity[j]*molecularDynamics->dt +
			(molecularDynamics->a[i][j]+molecularDynamics->theta[3*i+j]-molecularDynamics->qmModel->molecule.atoms[i].velocity[j]*molecularDynamics->friction)*molecularDynamics->dt2_2;	
		}
	for (i = 0; i < n; i++)
		if(molecularDynamics->qmModel->molecule.atoms[i].variable)
		for ( j = 0; j < 3; j++)
			molecularDynamics->qmModel->molecule.atoms[i].velocity[j] = 
			gm*molecularDynamics->qmModel->molecule.atoms[i].velocity[j] +
			gp*(molecularDynamics->a[i][j]+molecularDynamics->theta[3*i+j])*molecularDynamics->dt_2;
            
	if(molecularDynamics->qmModel->molecule.constraints!=NOCONSTRAINTS) applyRattleFirstPortion(molecularDynamics);

	newAccelaration(molecularDynamics);

	for (i = 0; i < n; i++)
		if(molecularDynamics->qmModel->molecule.atoms[i].variable)
		for ( j = 0; j < 3; j++)
			molecularDynamics->qmModel->molecule.atoms[i].velocity[j] += gp*(molecularDynamics->a[i][j]+molecularDynamics->theta[3*i+j])*molecularDynamics->dt_2;

	if(molecularDynamics->qmModel->molecule.constraints!=NOCONSTRAINTS) applyRattleSecondPortion(molecularDynamics);
	removeTranslationAndRotation(molecularDynamics);
	computeEnergies(molecularDynamics);
}
/*********************************************************************************/
File: ./cchemilib/src/QuantumMechanics/QuantumMechanicsDlg.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* QuantumMechanicsDlg.c */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>

#ifdef ENABLE_MPI
#include <mpi.h>
#endif

#include "../Utils/Utils.h"
#include "../Utils/AtomsProp.h"
#include "../Utils/Constants.h"
#include "../Utils/Types.h"
#include "../Molecule/Molecule.h"
#include "../QuantumMechanics/QuantumMechanicsModel.h"
#include "../QuantumMechanics/QuantumMechanics.h"
#include "../QuantumMechanics/QuantumMechanicsMD.h"
#include "../QuantumMechanics/QuantumMechanicsDlg.h"
#include "../QuantumMechanics/SteepestDescentQM.h"
#include "../QuantumMechanics/ConjugateGradientQM.h"
#include "../QuantumMechanics/QuasiNewtonQM.h"
#include "../EmpriricalCorrections/HydrogenBondCorrection.h"
#include "../EmpriricalCorrections/ShortRangeBasisSetCorrection.h"
#include "../EmpriricalCorrections/DispersionCorrection.h"
#include "../QuantumMechanics/GeneticAlgorithm.h"
#include "../QuantumMechanics/QuantumMechanicsDlg.h"

typedef enum
{
	TOLE = 0,
	TOLD = 1
} TOLptions;

#define NINTEGOPTIONS 3
#define NTHERMOPTIONS 3

#define NENTRYTOL 2

#define NCONSTRAINTS 3

static boolean saveGeometry(Molecule* molecule, double energy, char* fileNameGeom);
static boolean miminizeGeometriesUsingInternalOptimizer(int numberOfGeometries, QuantumMechanicsModel** geometries, double* energies, char* inputFileName);
/*****************************************************************************/
static void saveEnergies(double* energies, int n, char* inputFileName)
{
	FILE* file=NULL;
	int i;
	char* suff ;
	char* fileName ;

	if(!energies) return;

	suff = getSuffixNameFile(inputFileName);
	fileName = strdup_printf("%s%s",suff, "Energies.txt");
	free(suff);

	file=fopen(fileName,"w");
	if(!file) return;

	for(i=0;i<n;i++)
	{
		fprintf(file,"%lf %d\n", energies[i],i+1);
	}
	fclose(file);
	printf("----------------------------------------- \n");
	printf("Energies for all geometries saved in %s file\n",fileName);
	printf("----------------------------------------- \n");
	fflush(stdout);
	free(fileName);
}
static void checkWallCorrection(FILE* file, QuantumMechanicsModel* qmModel)
{
	char t[BSIZE];
	char* pos;
	rewind(file);
	qmModel->addWallCorrection=FALSE;
	while(!feof(file))
  	{
    		if(!fgets(t,BSIZE, file)) break;
		deleteFirstSpaces(t);
		if(t[0]=='#') continue;
		uppercase(t);
		pos = strstr(t,"WALL");
		if(pos && strstr(t,"="))
		{ 
			double E0;
			double rho;
			int nc;
			int n =0;
			pos = strstr(t,"=") + 1;
			n =sscanf(pos,"%lf %lf %d",&E0,&rho,&nc);
			//printf("t=%s\n",t);
			//printf("pos=%s\n",pos);
			if(n==3 && nc%2==0) { qmModel->addWallCorrection=TRUE; break;}
			else  { 
				fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
				fprintf(stderr,"Error during the reading of Wall parameters\n");
				fprintf(stderr,"You must give E0(au), rho (cutoff radius in angstrom) and nc(even integer)\n");
				fprintf(stderr,"Example : Wall=1000.0 10.0 6\n");
				fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
				exit(1);
			}
			break;
		}
	}
}
/*****************************************************************************/
static void printEnergyAndGradient(QuantumMechanicsModel* qmModel)
{
	char* str;
	double gradientNorm = 0;
	int i,j;

	qmModel->klass->calculateGradient(qmModel);

	gradientNorm = 0;
	for (  i = 0; i < qmModel->molecule.nAtoms; i++ )
		for(j=0;j<3;j++)
			gradientNorm += 
			qmModel->molecule.atoms[i].gradient[j]
			*qmModel->molecule.atoms[i].gradient[j]; 

	str = strdup_printf(("Gradient Norm  = %0.14f energy = %0.14f(kcal/mol) %0.14f(Hartree)\n"),
		sqrt(gradientNorm),qmModel->molecule.potentialEnergy, qmModel->molecule.potentialEnergy/(AUTOKCAL)); 

	printf("%s",str);
	free(str);
}
/*****************************************************************************/
static void printEnergy(QuantumMechanicsModel* qmModel)
{
	char* str;

	qmModel->klass->calculateEnergy(qmModel);
	str = strdup_printf(("energy = %0.14f(kcal/mol) %0.14f(Hartree)\n"),qmModel->molecule.potentialEnergy, qmModel->molecule.potentialEnergy/(AUTOKCAL)); 
	printf("%s",str);
	free(str);
}
/*********************************************************************************/
static void getMultiplicityName(int multiplicity, char* buffer)
{
	if(multiplicity==1) sprintf(buffer,"Singlet");
	else if(multiplicity==2) sprintf(buffer,"Doublet");
	else if(multiplicity==3) sprintf(buffer,"Triplet");
	else if(multiplicity==4) sprintf(buffer,"Quartet");
	else if(multiplicity==5) sprintf(buffer,"Quintet");
	else if(multiplicity==6) sprintf(buffer,"Sextet");
	else sprintf(buffer,"UNKNOWN");
}
/*****************************************************************************/
static boolean getEnergyMopac(char* fileNameOut, double* energy)
{
	FILE* file = NULL;
	char buffer[1024];
	char* pdest = NULL;

 	file = fopen(fileNameOut, "r");
	*energy=1e10;
	if(!file) return FALSE;
	 while(!feof(file))
	 {
		if(!fgets(buffer,BSIZE,file))break;
		pdest = strstr( buffer, " FINAL HEAT OF FORMATION");
		if(pdest) 
		{
			pdest = strstr( buffer, "=");
			if(pdest)
			{
				int l = strlen(pdest);
				int i;
				for(i=0;i<l;i++) if(pdest[i]=='D' || pdest[i]=='E') pdest[i] ='E';
				if(sscanf(pdest+1,"%lf",energy)==1)
				{
					fclose(file);
					return TRUE;
				}
			}
		}
	 }
	fclose(file);
	return FALSE;
}
/*************************************************************************************************************/
static boolean putMopacMoleculeInFile(Molecule* mol, FILE* file)
{
        char buffer[BSIZE];
	int i;
	int k1 = 0;
	int k2 = 0;
	int k3 = 0;

	if(mol->nAtoms<1) return FALSE;
      	for (i=0;i<mol->nAtoms;i++)
	{
		k1 = k2 = k3 = 0;
		if(mol->atoms[i].variable) k1 = k2 = k3 = 1;
		sprintf(buffer,"%s  %20.14f %d %20.14f %d %20.14f %d\n",mol->atoms[i].prop.symbol,
				mol->atoms[i].coordinates[0], k1,
				mol->atoms[i].coordinates[1], k2,
				mol->atoms[i].coordinates[2], k3
				);
       		fprintf(file, "%s",buffer);
	}
	return TRUE;
}
/*****************************************************************************/
static boolean runOneMopac(Molecule* mol, char* fileNamePrefix, char* keyWords, char* mopacCommand)
{
	FILE* file = NULL;
	FILE* fileSH = NULL;
	char* fileNameIn = NULL;
	char* fileNameOut = NULL;
	char* fileNameSH = NULL;
	char multiplicityStr[100];
	char buffer[1024];
	double energy = 0;
#ifdef OS_WIN32
	char c='%';
#endif

	if(!mol) return FALSE;
	if(mol->nAtoms<1) return FALSE;
#ifndef OS_WIN32
	fileNameSH = strdup_printf("%sMopacOne.sh",fileNamePrefix);
#else
	fileNameSH = strdup_printf("%sMopacOne.bat",fileNamePrefix);
#endif
 	fileSH = fopen(fileNameSH, "w");
	if(!fileSH) return FALSE;
#ifdef OS_WIN32
	fprintf(fileSH,"@echo off\n");
	fprintf(fileSH,"set PATH=%cPATH%c;\"%s\"\n",c,c,mopacDirectory);
#endif

	getMultiplicityName(mol->spinMultiplicity, multiplicityStr);

	fileNameIn = strdup_printf("%sOne.mop",fileNamePrefix);
 	file = fopen(fileNameIn, "w");
	if(!file) 
	{
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		return FALSE;
	}
	if(mol->spinMultiplicity>1)
	fprintf(file,"%s UHF CHARGE=%d %s\n",keyWords,mol->totalCharge,multiplicityStr);
	else
	fprintf(file,"%s CHARGE=%d %s\n",keyWords,mol->totalCharge,multiplicityStr);
	fprintf(file,"\n");
	fprintf(file,"Mopac file generated by Gabedit\n");

  	putMopacMoleculeInFile(mol, file);
	fclose(file);
	{
		char* str = NULL;
		if(!strstr(keyWords,"1SCF") && !strstr(keyWords,"ESP")) str = strdup_printf("Minimization by Mopac/%s ... Please wait",keyWords);
		else if(strstr(keyWords,"ESP")) str = strdup_printf("ESP charges from Mopac/%s ... Please wait",keyWords);
		else str = strdup_printf("Computing of energy by Mopac/%s ... Please wait",keyWords);
		printf("%s\n",str);
		if(str) free(str);
	}
#ifndef OS_WIN32
	fprintf(fileSH,"%s %s\n",mopacCommand,fileNameIn);
	fclose(fileSH);
	sprintf(buffer,"chmod u+x %s",fileNameSH);
	system(buffer);
	system(fileNameSH);
#else
	fprintf(fileSH,"\"%s\" \"%s\"\n",mopacCommand,fileNameIn);
	fclose(fileSH);
	sprintf(buffer,"\"%s\"",fileNameSH);
	system(buffer);
#endif

	fileNameOut = strdup_printf("%sOne.out",fileNamePrefix);
	if(getEnergyMopac(fileNameOut,&energy))
	{
		char* str = NULL;
		mol->klass->readGeomFromMopacOutputFile(mol, fileNameOut, -1);
		str = strdup_printf("Energy by Mopac = %f", energy);
		printf("%s\n",str);
		if(str) free(str);
		if(strstr(keyWords,"XYZ"))
		{
			str = strdup_printf("%s.gab",fileNamePrefix);
			saveGeometry(mol, energy, str);
			printf("----------------------------------------- \n");
			printf("Optimized geometry saved in %s file\n",str);
			printf("----------------------------------------- \n");
			if(str) free(str);
		}
		else
		{
			str = strdup_printf("%s.gab",fileNamePrefix);
			saveGeometry(mol, energy, str);
			printf("----------------------------------------- \n");
			printf("Geometry saved in %s file\n",str);
			printf("----------------------------------------- \n");
			if(str) free(str);
		}
	}
	else
	{
		char* str = NULL;
		str = strdup_printf(
				(
				"Sorry, I cannot read the output file : %s "
				" ; Check also the installation of Mopac..."
				),
				fileNameOut
				);
		printf("%s",str);
		if(str) free(str);
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		return FALSE;
	}

 	if(fileNameIn) free(fileNameIn);
 	if(fileNameOut) free(fileNameOut);
 	if(fileNameSH) free(fileNameSH);
	return TRUE;
}
/*****************************************************************************/
static boolean getEnergyFireFly(char* fileNameOut, double* energy)
{
	FILE* file = NULL;
	char buffer[1024];
	char* pdest = NULL;
	boolean OK = FALSE;

	*energy=1e10;
 	file = fopen(fileNameOut, "r");
	if(!file) return FALSE;
	 while(!feof(file))
	 {
		if(!fgets(buffer,BSIZE,file))break;
		pdest = strstr( buffer, "HEAT OF FORMATION IS");
		if(!pdest) pdest = strstr( buffer, "FINAL ENERGY IS");
		if(pdest) 
		{
			pdest = strstr( buffer, "S");
			if(pdest)
			{
				int l = strlen(pdest);
				int i;
				for(i=0;i<l;i++) if(pdest[i]=='D' || pdest[i]=='E') pdest[i] ='E';
				if(sscanf(pdest+1,"%lf",energy)==1) OK = TRUE;
				if(OK && strstr( buffer, "FINAL ENERGY IS")) *energy *= AUTOKCAL;
			}
		}
	 }
	fclose(file);
	return OK;
}
/*************************************************************************************************************/
static void putFireFlyMoleculeXYZFixed(Molecule* mol, FILE* file)
{
	int i,k,l;
	int nvar = 0;

        if(mol->nAtoms<2)return;
	nvar = 0;
        for(i=0;i<mol->nAtoms;i++)
		if(mol->atoms[i].variable) nvar+=3;
	/* printf("nvar = %d\n",nvar);*/
	if(nvar==3*mol->nAtoms) return;
	if(nvar==0) return;

        fprintf(file," ");
        fprintf(file, "$STATPT\n");
        fprintf (file,"   IFREEZ(1)=");

	l = 0;
        for(i=0;i<mol->nAtoms;i++)
	{
		if(!mol->atoms[i].variable)
		{
			l++;
			k = i*3+1;
			fprintf(file,"%d, %d, %d ",k,k+1,k+2);
			if(l%10==0) fprintf(file,"\n");
		}
	}
	fprintf(file,"\n ");
        fprintf (file, "$END\n");
}
/*****************************************************************************/
static boolean runOneFireFly(Molecule* mol, char* fileNamePrefix, char* keyWords, char* fireflyCommand)
{
	FILE* file = NULL;
	FILE* fileSH = NULL;
	int j;
	char* fileNameIn = NULL;
	char* fileNameOut = NULL;
	char* fileNameSH = NULL;
	char multiplicityStr[100];
	char buffer[1024];
	double energy = 0;
#ifdef OS_WIN32
	char c='%';
#endif

	if(!mol) return FALSE;
        if(mol->nAtoms<2)return FALSE;
#ifndef OS_WIN32
	fileNameSH = strdup_printf("%sPCGOne.sh",fileNamePrefix);
#else
	fileNameSH = strdup_printf("%sPCGOne.bat",fileNamePrefix);
#endif
 	fileSH = fopen(fileNameSH, "w");
	if(!fileSH) return FALSE;

	getMultiplicityName(mol->spinMultiplicity, multiplicityStr);

	fileNameIn = strdup_printf("%sOne.inp",fileNamePrefix);
 	file = fopen(fileNameIn, "w");
	if(!file) 
	{
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		return FALSE;
	}
	fprintf(file,"! ======================================================\n");
	fprintf(file,"!  Input file for FireFly\n"); 
	fprintf(file,"! ======================================================\n");
	if(strstr(keyWords,"RUNTYP"))
	{
		sscanf(strstr(keyWords,"RUNTYP"),"%s",buffer);
		fprintf(file," $CONTRL %s $END\n",buffer);
	}
	if(strstr(keyWords,"SCFTYP"))
	{
		sscanf(strstr(keyWords,"SCFTYP"),"%s",buffer);
		fprintf(file," $CONTRL %s $END\n",buffer);
	}
	else
	{
		if(mol->spinMultiplicity==1)
			fprintf(file," $CONTRL SCFTYP=RHF $END\n");
		else
			fprintf(file," $CONTRL SCFTYP=UHF $END\n");
	}

	fprintf(file," $CONTRL ICHARG=%d MULT=%d $END\n",mol->totalCharge,mol->spinMultiplicity);
	if(strstr(keyWords,"GBASIS"))
	{
		sscanf(strstr(keyWords,"GBASIS"),"%s",buffer);
		fprintf(file," $BASIS %s $END\n",buffer);
	}
	if(strstr(keyWords,"Optimize"))
	{
        	fprintf(file, " $STATPT OptTol=1e-4 NStep=500 $END\n");
	}
	if(strstr(keyWords,"Optimize"))
	{
		putFireFlyMoleculeXYZFixed(mol, file);
	}
	fprintf(file," $DATA\n");
	fprintf(file,"Molecule specification\n");
	fprintf(file,"C1\n");
	for(j=0;j<mol->nAtoms;j++)
	{
		char* symbol = mol->atoms[j].prop.symbol;
		SAtomsProp prop = propAtomGet(symbol);
		fprintf(file,"%s %f %f %f %f\n", 
			symbol,
			(double)prop.atomicNumber,
			mol->atoms[j].coordinates[0],
			mol->atoms[j].coordinates[1],
			mol->atoms[j].coordinates[2]
			);
	}
	fprintf(file," $END\n");
	fclose(file);
	fileNameOut = strdup_printf("%sOne.out",fileNamePrefix);
#ifndef OS_WIN32
	if(!strcmp(fireflyCommand,"pcgamess") || !strcmp(fireflyCommand,"nohup pcgamess")||
	!strcmp(fireflyCommand,"firefly") || !strcmp(fireflyCommand,"nohup firefly"))
	{
		fprintf(fileSH,"mkdir %stmp\n",fileNamePrefix);
		fprintf(fileSH,"cd %stmp\n",fileNamePrefix);
		fprintf(fileSH,"cp %s input\n",fileNameIn);
		fprintf(fileSH,"%s -p -o %s\n",fireflyCommand,fileNameOut);
		fprintf(fileSH,"cd ..\n");
		fprintf(fileSH,"rm PUNCH\n");
		fprintf(fileSH,"/bin/rm -r  %stmp\n",fileNamePrefix);
	}
	else
		fprintf(fileSH,"%s %s",fireflyCommand,fileNameIn);
#else
	 if(!strcmp(fireflyCommand,"pcgamess") ||
	 !strcmp(fireflyCommand,"firefly") )
	{
        	fprintf(fileSH,"mkdir \"%stmp\"\n",fileNamePrefix);
		addUnitDisk(fileSH, fileNamePrefix);
	 	fprintf(fileSH,"cd \"%stmp\"\n",fileNamePrefix);
         	fprintf(fileSH,"copy \"%s\" input\n",fileNameIn);
         	fprintf(fileSH,"%s -p -o \"%s\"\n",fireflyCommand,fileNameOut);
	 	fprintf(fileSH,"cd ..\n");
         	fprintf(fileSH,"del PUNCH 2> nul\n");
         	fprintf(fileSH,"del /Q  \"%stmp\"\n",fileNamePrefix);
         	fprintf(fileSH,"rmdir  \"%stmp\"\n",fileNamePrefix);
	}
	else
		fprintf(fileSH,"%s %s",fireflyCommand,fileNameIn);
#endif
	fclose(fileSH);
	{
		char* str = NULL;
		if(strstr(keyWords,"Optimiz")) str = strdup_printf("Minimization by FireFly/%s ... Please wait",keyWords);
		else str = strdup_printf("Computing of energy by FireFly/%s .... Please wait",keyWords);
		printf("%s\n",str);
		if(str) free(str);
	}
#ifndef OS_WIN32
	sprintf(buffer,"chmod u+x %s",fileNameSH);
	system(buffer);
	system(fileNameSH);
#else
	sprintf(buffer,"\"%s\"",fileNameSH);
	system(buffer);
#endif
	if(getEnergyFireFly(fileNameOut,&energy))
	{
		printf("Energy by FireFly = %f\n", energy);
		if(strstr(keyWords,"Optimiz")) mol->klass->readGeomFromGamessOutputFile(mol, fileNameOut, -1);
		else mol->klass->readGeomFromGamessOutputFile(mol, fileNameOut, 1);
		if(strstr(keyWords,"Optimiz"))
		{
			char* str = strdup_printf("%s.gab",fileNamePrefix);
			saveGeometry(mol, energy, str);
			printf("----------------------------------------- \n");
			printf("Optimized geometry saved in %s file\n",str);
			printf("----------------------------------------- \n");
			if(str) free(str);
		}
		else
		{
			char* str = strdup_printf("%s.gab",fileNamePrefix);
			saveGeometry(mol, energy, str);
			printf("----------------------------------------- \n");
			printf("Geometry saved in %s file\n",str);
			printf("----------------------------------------- \n");
			if(str) free(str);
		}
	}
	else
	{
		printf(
				(
				"Sorry, I cannot read the output file :  %s"
				" ; Check also the installation of FireFly...")
				,
				fileNameOut
				);
		exit(1);
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		return FALSE;
	}

 	if(fileNameIn) free(fileNameIn);
 	if(fileNameOut) free(fileNameOut);
 	if(fileNameSH) free(fileNameSH);
	return TRUE;
}
/*****************************************************************************/
static boolean getEnergyOrca(char* fileNameOut, double* energy)
{
	FILE* file = NULL;
	char buffer[1024];
	char* pdest = NULL;
	char* energyTag = "FINAL SINGLE POINT ENERGY";

	*energy=1e10;
 	file = fopen(fileNameOut, "r");
	if(!file) return FALSE;
	 while(!feof(file))
	 {
		if(!fgets(buffer,BSIZE,file))break;
		pdest = strstr( buffer, energyTag);
		if(pdest)
		{
			int l = strlen(pdest);
			int i;
			for(i=0;i<l;i++) if(pdest[i]=='D' || pdest[i]=='E') pdest[i] ='E';
		}
		if(pdest &&sscanf(pdest+strlen(energyTag)+1,"%lf",energy)==1)
		{
			fclose(file);
			*energy *= AUTOKCAL;
			return TRUE;
		}
	 }
	fclose(file);
	return FALSE;
}
/*****************************************************************************/
static boolean runOneOrca(Molecule* mol, char* fileNamePrefix, char* keyWords, char* NameCommandOrca)
{
	FILE* file = NULL;
	FILE* fileSH = NULL;
	char* fileNameIn = NULL;
	char* fileNameOut = NULL;
	char* fileNameSH = NULL;
	char multiplicityStr[100];
	char buffer[1024];
	double energy = 0;
	int i;
	int nV;

	if(!mol) return FALSE;
        if(mol->nAtoms<2)return FALSE;
#ifndef OS_WIN32
	fileNameSH = strdup_printf("%sOne.sh",fileNamePrefix);
#else
	fileNameSH = strdup_printf("%sOne.bat",fileNamePrefix);
#endif
 	fileSH = fopen(fileNameSH, "w");
	if(!fileSH) return FALSE;
#ifdef OS_WIN32
	fprintf(fileSH,"@echo off\n");
#endif

	getMultiplicityName(mol->spinMultiplicity, multiplicityStr);

	fileNameIn = strdup_printf("%sOne.inp",fileNamePrefix);
 	file = fopen(fileNameIn, "w");
	if(!file) 
	{
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		return FALSE;
	}
	fprintf(file,"# ======================================================\n");
	fprintf(file,"#  Orca input file made in Gabedit\n"); 
	fprintf(file,"# ======================================================\n");
	fprintf(file,"! %s\n",keyWords);
	{
		fprintf(file,"* xyz %d   %d\n",mol->totalCharge,mol->spinMultiplicity);
		nV = 0;
      		for (i=0;i<mol->nAtoms;i++)
		{
			char X[100];
			char Y[100];
			char Z[100];
			sprintf(X,"%20.14f",mol->atoms[i].coordinates[0]);
			sprintf(Y,"%20.14f",mol->atoms[i].coordinates[1]);
			sprintf(Z,"%20.14f",mol->atoms[i].coordinates[2]);

			fprintf(file," %s  %s %s %s\n",mol->atoms[i].prop.symbol, X,Y,Z);
			if(mol->atoms[i].variable) nV+=3;
		}
		fprintf(file,"*\n");
		if(nV>0&&nV!=3*mol->nAtoms) 
		{
			fprintf(file,"%cgeom Constraints\n",'%');
      			for (i=0;i<mol->nAtoms;i++)
			{
				if(mol->atoms[i].variable)
				{
					fprintf(file,"  {C %d C}\n",i);
				}
			}
			fprintf(file," end #Constraints\n");
			fprintf(file," invertConstraints true\n");
			fprintf(file," end #geom\n");
		}
	}

	fclose(file);
	fileNameOut = strdup_printf("%sOne.out",fileNamePrefix);
#ifndef OS_WIN32
	if(!strcmp(NameCommandOrca,"orca") || !strcmp(NameCommandOrca,"nohup orca"))
	{
		fprintf(fileSH,"%s %s > %s\n",NameCommandOrca,fileNameIn,fileNameOut);
		fprintf(fileSH,"exit\n");
	}
	else
		fprintf(fileSH,"%s %s",NameCommandOrca,fileNameIn);
#else
	 if(!strcmp(NameCommandOrca,"orca") )
	{
		if(strstr(orcaDirectory,"\"")) fprintf(fileSH,"set PATH=%s;%cPATH%c\n",orcaDirectory,'%','%');
		else fprintf(fileSH,"set PATH=\"%s\";%cPATH%c\n",orcaDirectory,'%','%');
		fprintf(fileSH,"%s %s > %s\n",NameCommandOrca,fileNameIn,fileNameOut);
		fprintf(fileSH,"exit\n");
	}
	else
		fprintf(fileSH,"%s %s",NameCommandOrca,fileNameIn);
#endif
	fclose(fileSH);
	{
		char* str = NULL;
		if(strstr(keyWords,"Opt")) str = strdup_printf("Minimization by Orca/%s ... Please wait",keyWords);
		else str = strdup_printf("Computing of energy by Orca/%s .... Please wait",keyWords);
		printf("%s\n",str);
		if(str) free(str);
	}
#ifndef OS_WIN32
	sprintf(buffer,"chmod u+x %s",fileNameSH);
	system(buffer);
	system(fileNameSH);
#else
	sprintf(buffer,"\"%s\"",fileNameSH);
	system(buffer);
#endif
	if(getEnergyOrca(fileNameOut,&energy))
	{
		printf("Energy by Orca = %f\n", energy);
		mol->klass->readGeomFromOrcaOutputFile(mol, fileNameOut, -1);
		if(strstr(keyWords,"Opt"))
		{
			char* str = strdup_printf("%s.gab",fileNamePrefix);
			saveGeometry(mol, energy, str);
			printf("----------------------------------------- \n");
			printf("Optimized geometry saved in %s file\n",str);
			printf("----------------------------------------- \n");
			if(str) free(str);
		}
		else
		{
			char* str = strdup_printf("%s.gab",fileNamePrefix);
			saveGeometry(mol, energy, str);
			printf("----------------------------------------- \n");
			printf("Geometry saved in %s file\n",str);
			printf("----------------------------------------- \n");
			if(str) free(str);
		}
	}
	else
	{
		printf(
				(
				"Sorry, I cannot read the output file :  %s"
				" ; Check also the installation of Orca..."
				),
				fileNameOut
				);
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		exit(1);
		return FALSE;
	}

 	if(fileNameIn) free(fileNameIn);
 	if(fileNameOut) free(fileNameOut);
 	if(fileNameSH) free(fileNameSH);
	return TRUE;
}
/*****************************************************************************/
static boolean getEnergyOpenBabel(char* fileNameOut, double* energy)
{
	FILE* file = NULL;
	char buffer[1024];
	char* pdest = NULL;
	//char* energyTag = "TOTAL ENERGY =";
	char* energyTag = "FINAL ENERGY:";

 	file = fopen(fileNameOut, "r");
	if(!file) return FALSE;
	 while(!feof(file))
	 {
		if(!fgets(buffer,BSIZE,file))break;
		pdest = strstr( buffer, energyTag);
		if(pdest &&sscanf(pdest+strlen(energyTag)+1,"%lf",energy)==1)
		{
			fclose(file);
			if(strstr(pdest,"kJ")) *energy /= KCALTOKJ;
			return TRUE;
		}
	 }
	fclose(file);
        return FALSE;
}
/*****************************************************************************/
static boolean runOneOpenBabel(Molecule* mol, char* fileNamePrefix, char* keyWords, char* NameCommandOpenBabel)
{
	FILE* fileSH = NULL;
	char* fileNameIn = NULL;
	char* fileNameOut = NULL;
	char* fileNameSH = NULL;
	char buffer[1024];
	double energy;
#ifdef OS_WIN32
	char c='%';
#endif

	if(mol->nAtoms<1) return FALSE;
#ifndef OS_WIN32
	fileNameSH = strdup_printf("%sOne.sh",fileNamePrefix);
#else
	fileNameSH = strdup_printf("%sOne.bat",fileNamePrefix);
#endif
 	fileSH = fopen(fileNameSH, "w");
	if(!fileSH) return FALSE;
#ifdef OS_WIN32
	fprintf(fileSH,"@echo off\n");
	fprintf(fileSH,"set PATH=%cPATH%c;\"%s\"\n",c,c,openBabelDirectory);
#endif

	fileNameIn = strdup_printf("%sOne.hin",fileNamePrefix);
	fileNameOut = strdup_printf("%sOne.out",fileNamePrefix);

	if(!mol->klass->saveHIN(mol,fileNameIn))
	{
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		return FALSE;
	}
#ifndef OS_WIN32
	if(!strcmp(NameCommandOpenBabel,"obgradient") || !strcmp(NameCommandOpenBabel,"obopt"))
	{
		if(strstr(keyWords,"Opt")) fprintf(fileSH,"%s -ff gaff %s > %s\n","obopt",fileNameIn,fileNameOut);
		else fprintf(fileSH,"%s -ff gaff %s > %s\n","obenergy",fileNameIn,fileNameOut);
		fprintf(fileSH,"exit\n");
	}
	else 
	{
		if(strstr(keyWords,"Opt") && !strstr( NameCommandOpenBabel,"obopt")) 
		{
			char** ssplit = NULL;
			int nA = 0;
			int i;
			ssplit = split(NameCommandOpenBabel);
			while(ssplit && ssplit[nA]!=NULL) nA++;
			fprintf(fileSH,"%s ", "obopt");
			for(i=1;i<nA;i++) fprintf(fileSH,"%s ",  ssplit[i]);
			fprintf(fileSH," %s > %s 2>/dev/null", fileNameIn, fileNameOut);
			strfreev(ssplit);
		}
		else fprintf(fileSH,"%s %s > %s 2>/dev/null", NameCommandOpenBabel, fileNameIn, fileNameOut);
	}
#else
	 if(!strcmp(NameCommandOpenBabel,"obabel") )
	{
		if(strstr(openBabelDirectory,"\"")) fprintf(fileSH,"set PATH=%s;%cPATH%c\n",openBabelDirectory,'%','%');
		else fprintf(fileSH,"set PATH=\"%s\";%cPATH%c\n",openBabelDirectory,'%','%');
		if(strstr(keyWords,"Opt")) fprintf(fileSH,"%s -ff gaff %s > %s\n","obminimize",fileNameIn,fileNameOut);
		else fprintf(fileSH,"%s -ff gaff %s > %s\n","obenergy",fileNameIn,fileNameOut);
		fprintf(fileSH,"exit\n");
	}
	else
	{
		if(strstr(keyWords,"Opt") && !strstr( NameCommandOpenBabel,"obopt")) 
		{
			char** ssplit = NULL;
			int nA = 0;
			int i;
			ssplit = split(NameCommandOpenBabel);
			while(ssplit && ssplit[nA]!=NULL) nA++;
			fprintf(fileSH,"%s ", "obopt");
			for(i=1;i<nA;i++) fprintf(fileSH,"%s ",  ssplit[i]);
			fprintf(fileSH," %s > %s 2>/dev/null", fileNameIn, fileNameOut);
			strfreev(ssplit);
		}
		else fprintf(fileSH,"%s %s > %s", NameCommandOpenBabel, fileNameIn, fileNameOut);
	}
#endif
	fclose(fileSH);
#ifndef OS_WIN32
	/*
	sprintf(buffer,"cat %s",fileNameSH);
	system(buffer);
	sprintf(buffer,"cat %s",fileNameIn);
	system(buffer);
	*/



	sprintf(buffer,"chmod u+x %s",fileNameSH);
	system(buffer);
	system(fileNameSH);
#else
	sprintf(buffer,"\"%s\"",fileNameSH);
	system(buffer);
#endif
	if(getEnergyOpenBabel(fileNameOut,&energy))
	{
		printf("Energy by OpenBabel = %f\n", energy);
		mol->klass->readGeomFromOpenBabelOutputFile(mol, fileNameOut, -1);
		if(strstr(keyWords,"Opt"))
		{
			char* str = strdup_printf("%s.gab",fileNamePrefix);
			saveGeometry(mol, energy, str);
			printf("----------------------------------------- \n");
			printf("Optimized geometry saved in %s file\n",str);
			printf("----------------------------------------- \n");
			if(str) free(str);
		}
		else
		{
			char* str = strdup_printf("%s.gab",fileNamePrefix);
			saveGeometry(mol, energy, str);
			printf("----------------------------------------- \n");
			printf("Geometry saved in %s file\n",str);
			printf("----------------------------------------- \n");
			if(str) free(str);
		}
	}
	else
	{
		printf(
				(
				"Sorry, I cannot read the output file :  %s"
				" ; Check also the installation of OpenBabel..."
				),
				fileNameOut
				);
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		exit(1);
		return FALSE;
	}

 	if(fileNameIn) free(fileNameIn);
 	if(fileNameOut) free(fileNameOut);
 	if(fileNameSH) free(fileNameSH);
	return TRUE;
}
/*************************************************************************************************************/
/*
static boolean getEnergyGaussian(char* fileNameOut, double* energy)
{
	FILE* file = NULL;
	char buffer[1024];
	char* pdest = NULL;
	boolean OK = FALSE;

	*energy=1e10;
 	file = fopen(fileNameOut, "r");
	if(!file) return FALSE;
	 while(!feof(file))
	 {
		if(!fgets(buffer,BSIZE,file))break;
		pdest = strstr( buffer, "SCF Done:  E(");
		if(!pdest) if(strstr( buffer, "Energy=") && !strstr( buffer, "hange") ) pdest = strstr( buffer, "Energy=");
		if(pdest) 
		{
			pdest = strstr( buffer, "=");
			if(pdest)
			{
				int l = strlen(pdest);
				int i;
				for(i=0;i<l;i++) if(pdest[i]=='D' || pdest[i]=='E') pdest[i] ='E';
				if(sscanf(pdest+1,"%lf",energy)==1)
				{
					OK = TRUE;
					break;
				}
			}
		}
	 }
	fclose(file);
	*energy *= AUTOKCAL;
	return OK;
}
*/
/**********************************************************************/
static boolean getEnergyGaussian(char* fileNameOut, double* energy)
{
	FILE* file = NULL;
	char buffer[1024];
	char* pdest = NULL;
	char* pos = NULL;
	boolean OK = FALSE;

 	file = fopen(fileNameOut, "r");
	if(!file) return FALSE;
	 while(!feof(file))
	 {
		if(!fgets(buffer,BSIZE,file))break;
		pdest = NULL;
		if(strstr( buffer, "SCF Done:  E(") && strstr( buffer, "=")) pdest = strstr( buffer, "=")+1;
		if(!pdest) if(strstr( buffer, "Energy=") && !strstr( buffer, "hange") ) pdest = strstr( buffer, "Energy=")+strlen("Energy=");
		if(!pdest) if(strstr( buffer, "UMP") && strstr( buffer, "=")) { pos = strstr( buffer, "UMP"); pdest = strstr(pos, "=")+1;};
		if(!pdest) if(strstr( buffer, " E(B2PLYP)") && strstr( buffer, "=")) { pos = strstr( buffer, " E(B2PLYP)"); pdest = strstr(pos, "=")+1;};
		if(!pdest) if(strstr( buffer, "E(CI") && strstr( buffer, "=")) { pos = strstr( buffer, "E(CI"); pdest = strstr(pos, "=")+1;};
		if(!pdest) if(strstr( buffer, " E(CORR)") && strstr( buffer, "=")) { pos = strstr( buffer, " E(CORR)"); pdest = strstr(pos, "=")+1;};
		if(!pdest) if(strstr( buffer, "CCSD(T)=")) { pos = strstr( buffer, "CCSD(T)="); pdest = strstr(pos, "=")+1;};
		if(pdest) 
		{
			int l = strlen(pdest);
			int i;
			for(i=0;i<l;i++) if(pdest[i]=='D' || pdest[i]=='E') pdest[i] ='E';
			if(sscanf(pdest+1,"%lf",energy)==1)
			{
				*energy *= AUTOKCAL;
				OK = TRUE;
				/* break;*/
			}
		}
	 }
	fclose(file);
	return OK;
}
/*************************************************************************************************************/
static boolean putGaussianMoleculeInFile(Molecule* mol, FILE* file)
{
        char buffer[BSIZE];
	int i;
	int k = 0;

	if(mol->nAtoms<1) return FALSE;
      	for (i=0;i<mol->nAtoms;i++)
	{
		k = -1;
		if(mol->atoms[i].variable) k = 0;
		sprintf(buffer,"%s %d %20.14f %20.14f %20.14f\n",mol->atoms[i].prop.symbol, k,
				mol->atoms[i].coordinates[0], 
				mol->atoms[i].coordinates[1],
				mol->atoms[i].coordinates[2]
				);
       		fprintf(file, "%s",buffer);
	}
       	fprintf(file, "\n");
	return TRUE;
}
/*****************************************************************************/
static boolean runOneGaussian(Molecule* mol, char* fileNamePrefix, char* keyWords, char* gaussianCommand)
{
	FILE* file = NULL;
	FILE* fileSH = NULL;
	char* fileNameIn = NULL;
	char* fileNameOut = NULL;
	char* fileNameSH = NULL;
	char multiplicityStr[100];
	char buffer[1024];
	double energy = 0;
#ifdef OS_WIN32
	char c='%';
#endif

	if(!mol) return FALSE;
	if(mol->nAtoms<1) return FALSE;
#ifndef OS_WIN32
	fileNameSH = strdup_printf("%sGaussianOne.sh",fileNamePrefix);
#else
	fileNameSH = strdup_printf("%sGaussianOne.bat",fileNamePrefix);
#endif
 	fileSH = fopen(fileNameSH, "w");
	if(!fileSH) return FALSE;
#ifdef OS_WIN32
	fprintf(fileSH,"@echo off\n");
	fprintf(fileSH,"set PATH=%cPATH%c;\"%s\"\n",c,c,gaussianDirectory);
#endif

	getMultiplicityName(mol->spinMultiplicity, multiplicityStr);

	fileNameIn = strdup_printf("%sOne.com",fileNamePrefix);
 	file = fopen(fileNameIn, "w");
	if(!file) 
	{
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		return FALSE;
	}
	fprintf(file,"# %s\n",keyWords);
	fprintf(file,"\n");
	fprintf(file,"Gaussian file generated by cchemi\n");
	fprintf(file,"\n");
	fprintf(file,"%d %d\n",mol->totalCharge,mol->spinMultiplicity);
  	putGaussianMoleculeInFile(mol, file);
	fclose(file);
	{
		char* str = NULL;
		if(strstr(keyWords,"Opt")) str = strdup_printf("Minimization by Gaussian/%s ... Please wait",keyWords);
		else str = strdup_printf("Energy by Gaussian/%s ... Please wait",keyWords);
		printf("%s\n",str);
		if(str) free(str);
	}
#ifndef OS_WIN32
	fprintf(fileSH,"%s %s\n",gaussianCommand,fileNameIn);
	fclose(fileSH);
	sprintf(buffer,"chmod u+x %s",fileNameSH);
	system(buffer);
	system(fileNameSH);
#else
	fprintf(fileSH,"\"%s\" \"%s\"\n",gaussianCommand,fileNameIn);
	fclose(fileSH);
	sprintf(buffer,"\"%s\"",fileNameSH);
	system(buffer);
#endif

	fileNameOut = strdup_printf("%sOne.log",fileNamePrefix);
	if(getEnergyGaussian(fileNameOut,&energy))
	{
		char* str = NULL;
		mol->klass->readGeomFromGaussianOutputFile(mol, fileNameOut, -1);
		str = strdup_printf("Energy by Gaussian = %f", energy);
		printf("%s\n",str);
		if(str) free(str);
		if(strstr(keyWords,"Opt"))
		{
			str = strdup_printf("%s.gab",fileNamePrefix);
			saveGeometry(mol, energy, str);
			printf("----------------------------------------- \n");
			printf("Optimized geometry saved in %s file\n",str);
			printf("----------------------------------------- \n");
			if(str) free(str);
		}
		else
		{
			str = strdup_printf("%s.gab",fileNamePrefix);
			saveGeometry(mol, energy, str);
			printf("----------------------------------------- \n");
			printf("Geometry saved in %s file\n",str);
			printf("----------------------------------------- \n");
			if(str) free(str);
		}
	}
	else
	{
		char* str = NULL;
		str = strdup_printf(
				(
				"Sorry, I cannot read the output file : %s "
				" ; Check also the installation of Gaussian..."
				),
				fileNameOut
				);
		printf("%s",str);
		if(str) free(str);
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		return FALSE;
	}

 	if(fileNameIn) free(fileNameIn);
 	if(fileNameOut) free(fileNameOut);
 	if(fileNameSH) free(fileNameSH);
	return TRUE;
}
/*****************************************************************************/
static boolean getEnergyGeneric(char* fileNameOut, double* energy)
{
	FILE* file = NULL;
	char buffer[1024];
	int i;
 	file = fopen(fileNameOut, "r");
	if(!file) return FALSE;
	if(!fgets(buffer,BSIZE,file)) { fclose(file); return FALSE;}/* first line for energy in Hartree*/

	for(i=0;i<strlen(buffer);i++) if(buffer[i]=='D' || buffer[i]=='d') buffer[i] ='E';
	if(sscanf(buffer,"%lf",energy)==1)
	{
		fclose(file);
		*energy *=AUTOKCAL;
		return TRUE;
	}
	fclose(file);
	return FALSE;
}
/*****************************************************************************/
static boolean runOneGeneric(Molecule* mol, char* fileNamePrefix, char* keyWords, char* genericCommand)
{
	FILE* file = NULL;
	FILE* fileSH = NULL;
	char* fileNameIn = NULL;
	char* fileNameOut = NULL;
	char* fileNameSH = NULL;
	char multiplicityStr[100];
	char buffer[1024];
	double energy = 0;
	int type = 0;
#ifdef OS_WIN32
	char c='%';
#endif

	if(!mol) return FALSE;
	if(mol->nAtoms<1) return FALSE;
#ifndef OS_WIN32
	fileNameSH = strdup_printf("%sGenericOne.sh",fileNamePrefix);
#else
	fileNameSH = strdup_printf("%sGenericOne.bat",fileNamePrefix);
#endif
 	fileSH = fopen(fileNameSH, "w");
	if(!fileSH) return FALSE;
#ifdef OS_WIN32
	fprintf(fileSH,"@echo off\n");
#endif

	getMultiplicityName(mol->spinMultiplicity, multiplicityStr);

	fileNameIn = strdup_printf("%sOne.inp",fileNamePrefix);
	fileNameOut = strdup_printf("%sOne.out",fileNamePrefix);

 	file = fopen(fileNameIn, "w");
	if(!file) 
	{
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		return FALSE;
	}
	if(strstr(keyWords,"Opt")) type = 2;
	if(strstr(keyWords,"ENGRAD")) type = 1;
	fprintf(file,"%d\n",type);
	mol->klass->addMolecule(mol,file);
	fclose(file);
	{
		char* str = NULL;
		if(type==2) str = strdup_printf("Minimization by Generic/%s ... Please wait",genericCommand);
		else str = strdup_printf("Energy by Generic/%s ... Please wait",genericCommand);
		printf("%s\n",str);
		if(str) free(str);
	}
#ifndef OS_WIN32
	fprintf(fileSH,"%s %s %s",genericCommand,fileNameIn,fileNameOut);
	fclose(fileSH);
	sprintf(buffer,"chmod u+x %s",fileNameSH);
	system(buffer);
	system(fileNameSH);
#else
	fprintf(fileSH,"\"%s\" \"%s\" \"%s\"",genericCommand,fileNameIn,fileNameOut);
	fclose(fileSH);
	sprintf(buffer,"\"%s\"",fileNameSH);
	system(buffer);
#endif

	if(getEnergyGeneric(fileNameOut,&energy))
	{
		char* str = NULL;
		mol->klass->readGeometry(mol,fileNameOut);
		str = strdup_printf("Energy by %s = %f", genericCommand,energy);
		printf("%s\n",str);
		if(str) free(str);
		if(strstr(keyWords,"Opt"))
		{
			str = strdup_printf("%s.gab",fileNamePrefix);
			saveGeometry(mol, energy, str);
			printf("----------------------------------------- \n");
			printf("Optimized geometry saved in %s file\n",str);
			printf("----------------------------------------- \n");
			if(str) free(str);
		}
		else
		{
			str = strdup_printf("%s.gab",fileNamePrefix);
			saveGeometry(mol, energy, str);
			printf("----------------------------------------- \n");
			printf("Geometry saved in %s file\n",str);
			printf("----------------------------------------- \n");
			if(str) free(str);
		}
	}
	else
	{
		char* str = NULL;
		str = strdup_printf(
				(
				"Sorry, I cannot read the output file : %s "
				" ; Check also the installation of Generic..."
				),
				fileNameOut
				);
		printf("%s",str);
		if(str) free(str);
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		return FALSE;
	}

 	if(fileNameIn) free(fileNameIn);
 	if(fileNameOut) free(fileNameOut);
 	if(fileNameSH) free(fileNameSH);
	return TRUE;
}
/*****************************************************************************/
static void runMopac(Molecule* mol, char* fileName, char* keys, char* mopacCommand)
{
	if(mopacCommand&& keys)
	{
		char* fileNamePrefix = getSuffixNameFile(fileName);
		printf("keys = %s\n",keys);
		if(runOneMopac(mol, fileNamePrefix, keys,mopacCommand))
		{
		}
		if(fileNamePrefix) free(fileNamePrefix);
	}
}
/*****************************************************************************/
static void runOrca(Molecule* mol, char* fileName, char* keys, char* NameCommandOrca)
{
	if(NameCommandOrca && keys)
	{
		char* fileNamePrefix = getSuffixNameFile(fileName);
		if(runOneOrca(mol, fileNamePrefix, keys,NameCommandOrca))
		{
			char* fileOut = strdup_printf("%sOne.out",fileNamePrefix);
			mol->klass->readGeomFromOrcaOutputFile(mol, fileOut, -1);
			if(fileOut) free(fileOut);
		}
		if(fileNamePrefix) free(fileNamePrefix);
	}
}
/*****************************************************************************/
static void runOpenBabel(Molecule* mol, char* fileName, char* keys, char* NameCommandOpenBabel)
{
	if(NameCommandOpenBabel && keys)
	{
		char* fileNamePrefix = getSuffixNameFile(fileName);
		if(runOneOpenBabel(mol, fileNamePrefix, keys,NameCommandOpenBabel))
		{
			char* fileOut = strdup_printf("%sOne.out",fileNamePrefix);
			mol->klass->readGeomFromOpenBabelOutputFile(mol, fileOut, -1);
			if(fileOut) free(fileOut);
		}
		if(fileNamePrefix) free(fileNamePrefix);
	}
}
/*****************************************************************************/
static void runFireFly(Molecule* mol, char* fileName, char* keys, char* fireflyCommand)
{
	if(keys && fireflyCommand)
	{
		char* fileNamePrefix = getSuffixNameFile(fileName);
		if(runOneFireFly(mol, fileNamePrefix, keys,fireflyCommand))
		{
		}
		if(fileNamePrefix) free(fileNamePrefix);
	}
}
/*****************************************************************************/
static void runGaussian(Molecule* mol, char* fileName, char* keys, char* gaussianCommand)
{
	if(keys && gaussianCommand)
	{
		char* fileNamePrefix = getSuffixNameFile(fileName);
		if(runOneGaussian(mol, fileNamePrefix, keys,gaussianCommand))
		{
		}
		if(fileNamePrefix) free(fileNamePrefix);
	}
}
/*****************************************************************************/
static void runGeneric(Molecule* mol, char* fileName, char* keys, char* genericCommand)
{
	if(keys && genericCommand)
	{
		char* fileNamePrefix = getSuffixNameFile(fileName);
		if(runOneGeneric(mol, fileNamePrefix, keys, genericCommand))
		{
		}
		if(fileNamePrefix) free(fileNamePrefix);
	}
}
/*****************************************************************************/
void quantumMechanicsDlg(char* inputFileName)
{
	Molecule mol = *(readMolecule(inputFileName, TRUE));
	char* fileName = NULL;
	char* mopacCommand = strdup("/opt/mopac/MOPAC2012");
	char* fireflyCommand = strdup("firefly");
	char* orcaCommand = strdup("orca");
	char* openBabelCommand = strdup("obgradient");
	char* gaussianCommand = strdup("g09");
	char* genericCommand = strdup("runGeneric");
	char* N2P2Dir=strdup(getenv("PWD"));
	char* tmModule=strdup_printf("%s/%s",getenv("PWD"),"CChemITMModule");
	FILE* file = NULL;
	char* runType = NULL;
	char* model = NULL;
	char* QMKeys = NULL;
	if(!inputFileName)
	{
		printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		printf("Usage : cchemi inputFileName.inp\n");
		printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		exit(1);
	}
	file = fopen(inputFileName, "r");
	if(!file)
	{
		printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		printf("Sorry, I cannot open the input file : %s\n",inputFileName);
		printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		exit(1);
	}
	if(!readOneString(file,"RunType",&runType)) runType = strdup("ENERGY");
	if(!readOneString(file,"Model",&model)) model = strdup("MOPAC");
	uppercase(model);
	if(!readOneString(file,"QMKeys",&QMKeys)) 
	{
		if(!strcmp(model,"MOPAC")) QMKeys = strdup("PM6-DH+");
		else if(!strcmp(model,"ORCA")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"GAUSSIAN")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"FIREFLY")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"OPENBABEL")) QMKeys = strdup("mmff94");
		else QMKeys = strdup("SCC-DFTB");
	}
	if(!strcmp(model,"OPENBABEL")) mol.klass->buildMMTypes(&mol, file);

	uppercase(runType);
	readOneString(file,"mopacCommand",&mopacCommand);
	readOneString(file,"orcaCommand",&orcaCommand);
	readOneString(file,"openBabelCommand",&openBabelCommand);
	readOneString(file,"HDNNDir",&N2P2Dir);
	readOneString(file,"N2P2Dir",&N2P2Dir);
	readOneString(file,"tmModule",&tmModule);
	readOneString(file,"fireflyCommand",&fireflyCommand);
	readOneString(file,"gaussianCommand",&gaussianCommand);
	readOneString(file,"genericCommand",&genericCommand);
	if(!strcmp(model,"FIREFLY")) QMKeys = strdup("GBASIS=AM1");
	printf("QMKeys = %s\n",QMKeys);
	printf("Model = %s\n",model);
	printf("openBabelCommand = %s\n",openBabelCommand);
	if(!strcmp(model,"MOPAC") && (!strcmp(runType,"ENERGY")|| strstr(QMKeys,"ESP") ||  strstr(QMKeys,"POINT")))
	{
		char* keys = strdup_printf("1SCF %s",QMKeys);
		printf("keys = %s\n",keys);
		printf("mopacCommand = %s\n",mopacCommand);
		fileName = strdup_printf("cchemiMopac.inp");
		runMopac(&mol, fileName, keys, mopacCommand);
		free(keys);
	}
	else if(!strcmp(model,"MOPAC") && strstr(runType,"GRADIENT"))
	{
		char* keys = strdup_printf("1SCF GRAD %s",QMKeys);
		printf("keys = %s\n",keys);
		printf("mopacCommand = %s\n",mopacCommand);
		fileName = strdup_printf("cchemiMopac.inp");
		runMopac(&mol, fileName, keys, mopacCommand);
		free(keys);
	}
	else if(!strcmp(model,"MOPAC") && strstr(runType,"OPTIMIZATION"))
	{
		char* keys = strdup_printf("XYZ %s",QMKeys);
		printf("keys = %s\n",keys);
		printf("mopacCommand = %s\n",mopacCommand);
		fileName = strdup_printf("cchemiMopac.inp");
		runMopac(&mol, fileName, keys, mopacCommand);
		free(keys);
	}
	else if(!strcmp(model,"ORCA") && strstr(runType,"ENERGY"))
	{
		char* keys = strdup_printf("%s",QMKeys);
		fileName = strdup_printf("cchemiOrca.inp");
		runOrca(&mol, fileName, keys, orcaCommand);
		free(keys);
	}
	else if(!strcmp(model,"ORCA") && strstr(runType,"GRADIENT"))
	{
		char* keys = strdup_printf("%s ENGRAD",QMKeys);
		fileName = strdup_printf("cchemiOrca.inp");
		runOrca(&mol, fileName, keys, orcaCommand);
		free(keys);
	}
	else if(!strcmp(model,"ORCA") && strstr(runType,"OPTIMIZATION"))
	{
		char* keys = strdup_printf("%s Opt",QMKeys);
		fileName = strdup_printf("cchemiOrca.inp");
		runOrca(&mol, fileName, keys, orcaCommand);
		free(keys);
	}
	else if(!strcmp(model,"FIREFLY") && strstr(runType,"ENERGY"))
	{
		char* keys = strdup_printf("RUNTYP=Energy %s",QMKeys);
		fileName = strdup_printf("cchemiFF.inp");
		runFireFly(&mol, fileName, keys, fireflyCommand);
		free(keys);
	}
	else if(!strcmp(model,"FIREFLY") && strstr(runType,"GRADIENT"))
	{
		char* keys = strdup_printf("RUNTYP=GRADIENT %s",QMKeys);
		printf("keys=%s\n",QMKeys);
		fileName = strdup_printf("cchemiFF.inp");
		runFireFly(&mol, fileName, keys, fireflyCommand);
		free(keys);
	}
	else if(!strcmp(model,"FIREFLY") && strstr(runType,"OPTIMIZATION"))
	{
		char* keys = strdup_printf("RUNTYP=Optimize %s",QMKeys);
		printf("keys=%s\n",QMKeys);
		fileName = strdup_printf("cchemiFF.inp");
		runFireFly(&mol, fileName, keys, fireflyCommand);
		free(keys);
	}
	else if(!strcmp(model,"GAUSSIAN") && strstr(runType,"ENERGY"))
	{
		char* keys = strdup_printf("%s",QMKeys);
		fileName = strdup_printf("cchemiGauss.com");
		runGaussian(&mol, fileName, keys, gaussianCommand);
		free(keys);
	}
	else if(!strcmp(model,"GAUSSIAN") && strstr(runType,"GRADIENT"))
	{
		char* keys = strdup_printf("%s Force ",QMKeys);
		printf("keys=%s\n",QMKeys);
		fileName = strdup_printf("cchemiGauss.com");
		runGaussian(&mol, fileName, keys, gaussianCommand);
		free(keys);
	}
	else if(!strcmp(model,"GAUSSIAN") && strstr(runType,"OPTIMIZATION"))
	{
		char* keys = strdup_printf("%s Opt",QMKeys);
		printf("keys=%s\n",QMKeys);
		fileName = strdup_printf("cchemiGauss.com");
		runGaussian(&mol, fileName, keys, gaussianCommand);
		free(keys);
	}
	else if(!strcmp(model,"GENERIC") && strstr(runType,"ENERGY"))
	{
		char* keys = strdup_printf("%s",QMKeys);
		fileName = strdup_printf("cchemiGen.com");
		runGeneric(&mol, fileName, keys, genericCommand);
		free(keys);
	}
	else if(!strcmp(model,"GENERIC") && strstr(runType,"GRADIENT"))
	{
		char* keys = strdup_printf("%s ENGRAD",QMKeys);
		fileName = strdup_printf("cchemiGen.com");
		runGeneric(&mol, fileName, keys, genericCommand);
		free(keys);
	}
	else if(!strcmp(model,"GENERIC") && strstr(runType,"OPTIMIZATION"))
	{
		char* keys = strdup_printf("%s Opt",QMKeys);
		fileName = strdup_printf("cchemiGauss.com");
		runGeneric(&mol, fileName, keys, genericCommand);
		free(keys);
	}
	else if(!strcmp(model,"OPENBABEL") && strstr(runType,"ENERGY"))
	{
		char* keys = strdup_printf("%s",QMKeys);
		fileName = strdup_printf("cchemiOB.hin");
		runOpenBabel(&mol, fileName, keys, openBabelCommand);
		free(keys);
	}
	else if(!strcmp(model,"OPENBABEL") && strstr(runType,"GRADIENT"))
	{
		char* keys = strdup_printf("%s ENGRAD",QMKeys);
		fileName = strdup_printf("cchemiOB.hin");
		runOpenBabel(&mol, fileName, keys, openBabelCommand);
		free(keys);
	}
	else if(!strcmp(model,"OPENBABEL") && strstr(runType,"OPTIMIZATION"))
	{
		char* keys = strdup_printf("%s Opt",QMKeys);
		fileName = strdup_printf("cchemiOB.hin");
		runOpenBabel(&mol, fileName, keys, openBabelCommand);
		free(keys);
	}
	else if(!strcmp(model,"N2P2") || !strcmp(model,"HDNN"))
	{
		
		double cfenergy = 1.0/(AUTOKCAL);
        	double cflength = ANGTOBOHR;
		// compute energy using N2P2 potential with data in N2P2Dir
		runN2P2(&mol, N2P2Dir, cflength, cfenergy, 0, 0);
	}
	else if(!strcmp(model,"TENSORMOL") || !strcmp(model,"TM"))
	{
		
		runTM(&mol, tmModule,TRUE);
	}
	printf("fileName = %s\n",fileName);
	fclose(file);
	if(fileName) free(fileName);
}
/*****************************************************************************/
static boolean saveGeometry(Molecule* molecule, double energy, char* fileNameGeom)
{
	boolean Ok = FALSE;
	double oldEnergy = molecule->potentialEnergy;
	molecule->potentialEnergy = energy;
	Ok = molecule->klass->save(molecule,fileNameGeom);
	molecule->potentialEnergy = oldEnergy;
	return Ok;
}
/*****************************************************************************/
static boolean saveConfoGeometries(int numberOfGeometries, QuantumMechanicsModel** geometries, double* energies, char* fileNameGeom)
{
	FILE* file = NULL;
	int i;
	int j;
	int nG = 0;
	int k;
	int form = 1;

	if(numberOfGeometries<1) return FALSE;
	if(!geometries) return FALSE;
	if(!energies) return FALSE;
	for(i=0;i<numberOfGeometries;i++) if(geometries[i]) nG++;
	if(nG<1) return FALSE;

 	file = fopen(fileNameGeom, "w");

	if(!file) return FALSE;

	fprintf(file,"[Gabedit Format]\n");
	fprintf(file,"[GEOCONV]\n");
	fprintf(file,"energy\n");
	for(i=0;i<numberOfGeometries;i++)
		if(geometries[i]) fprintf(file,"%f\n",energies[i]);
	fprintf(file,"max-force\n");
	for(i=0;i<numberOfGeometries;i++)
		if(geometries[i]) fprintf(file,"0.0\n");
	fprintf(file,"rms-force\n");
	for(i=0;i<numberOfGeometries;i++)
		if(geometries[i]) fprintf(file,"0.0\n");

	fprintf(file,"\n");
	fprintf(file,"[GEOMETRIES]\n");
	for(i=0;i<numberOfGeometries;i++)
	{
		if(!geometries[i]) continue;
		fprintf(file,"%d\n",geometries[i]->molecule.nAtoms);
		fprintf(file,"\n");
		for(j=0;j<geometries[i]->molecule.nAtoms;j++)
		fprintf(file," %s %0.8f %0.8f %0.8f\n", 
				geometries[i]->molecule.atoms[j].prop.symbol,
				geometries[i]->molecule.atoms[j].coordinates[0],
				geometries[i]->molecule.atoms[j].coordinates[1],
				geometries[i]->molecule.atoms[j].coordinates[2]
				);
	}
	fprintf(file,"\n");
	fprintf(file,"[GEOMS] %d\n",form);
	fprintf(file,"%d 2\n",nG);
	fprintf(file,"energy kcal/mol 1\n");
	fprintf(file,"deltaE eV 1\n");
	k = -1;
	for(i=0;i<numberOfGeometries;i++)
	{
		if(!geometries[i]) continue;
		if(k<0) k = i;
		fprintf(file,"%f\n",energies[i]);
		//if(k>=0) fprintf(file,"%f\n",(energies[i]-energies[k])*503.21892494); // in K
		if(k>=0) fprintf(file,"%f\n",(energies[i]-energies[k])/AUTOKCAL*AUTOEV); // in eV
		else fprintf(file,"0\n");

		Molecule* mol=&geometries[i]->molecule;
		double oldEnergy = mol->potentialEnergy;
		mol->potentialEnergy = energies[i];
		geometries[i]->molecule.klass->addGeometryToGabedit(&geometries[i]->molecule, file);
		mol->potentialEnergy = oldEnergy;
	}
	fclose(file);
	return TRUE;

}
/*****************************************************************************/
static boolean runOneOptMopac(QuantumMechanicsModel* geom, double* energy, char* fileNamePrefix, char* keyWords, char* mopacCommand)
{
	FILE* file = NULL;
	FILE* fileSH = NULL;
	int j;
	char* fileNameIn = NULL;
	char* fileNameOut = NULL;
	char* fileNameSH = NULL;
	char multiplicityStr[100];
	char buffer[1024];
	*energy = 0;
	Molecule* mol = &geom->molecule;
#ifdef OS_WIN32
	char c='%';
#endif

	if(!geom) return FALSE;
	if(geom->molecule.nAtoms<1) return FALSE;
#ifndef OS_WIN32
	fileNameSH = strdup_printf("%sMopacOne.sh",fileNamePrefix);
#else
	fileNameSH = strdup_printf("%sMopacOne.bat",fileNamePrefix);
#endif
 	fileSH = fopen(fileNameSH, "w");
	if(!fileSH) return FALSE;
#ifdef OS_WIN32
	fprintf(fileSH,"set PATH=%cPATH%c;\"%s\"\n",c,c,mopacDirectory);
#endif

	getMultiplicityName(mol->spinMultiplicity, multiplicityStr);

	fileNameIn = strdup_printf("%sOne.mop",fileNamePrefix);
 	file = fopen(fileNameIn, "w");
	if(!file) 
	{
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		return FALSE;
	}
	if(mol->spinMultiplicity>1)
	fprintf(file,"%s UHF CHARGE=%d %s\n",keyWords,mol->totalCharge,multiplicityStr);
	else
	fprintf(file,"%s CHARGE=%d %s\n",keyWords,mol->totalCharge,multiplicityStr);
	fprintf(file,"\n");
	fprintf(file,"Mopac file generated by Gabedit\n");

	for(j=0;j<geom->molecule.nAtoms;j++)
	{
	fprintf(file," %s %f %d %f %d %f %d\n", 
			geom->molecule.atoms[j].prop.symbol,
			geom->molecule.atoms[j].coordinates[0],
			1,
			geom->molecule.atoms[j].coordinates[1],
			1,
			geom->molecule.atoms[j].coordinates[2],
			1
			);
	}
	fclose(file);
	{
		char* str = NULL;
		if(!strstr(keyWords,"1SCF") && !strstr(keyWords,"ESP")) str = strdup_printf("Minimization by Mopac/%s ... Please wait",keyWords);
		else if(strstr(keyWords,"ESP")) str = strdup_printf("ESP charges from Mopac/%s ... Please wait",keyWords);
		else str = strdup_printf("Computing of energy by Mopac/%s .... Please wait",keyWords);
		printf("%s\n",str);
		if(str) free(str);
	}
#ifndef OS_WIN32
	fprintf(fileSH,"%s %s\n",mopacCommand,fileNameIn);
	fclose(fileSH);
	sprintf(buffer,"chmod u+x %s",fileNameSH);
	system(buffer);
	system(fileNameSH);
#else
	fprintf(fileSH,"\"%s\" \"%s\"\n",mopacCommand,fileNameIn);
	fclose(fileSH);
	sprintf(buffer,"\"%s\"",fileNameSH);
	system(buffer);
#endif

	fileNameOut = strdup_printf("%sOne.out",fileNamePrefix);
	if(getEnergyMopac(fileNameOut,energy))
	{
		printf("Energy by Mopac = %f\n", *energy);
		mol->klass->readGeomFromMopacOutputFile(mol, fileNameOut, -1);
	}
	else
	{
		printf("I cannot read energy = from %s file\n",fileNameOut);
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		return FALSE;
	}

 	if(fileNameIn) free(fileNameIn);
 	if(fileNameOut) free(fileNameOut);
 	if(fileNameSH) free(fileNameSH);
	return TRUE;
}
/*****************************************************************************/
static boolean runMopacFiles(int numberOfGeometries, QuantumMechanicsModel** geometries, double* energies, char* fileNamePrefix, char* keyWords, char* mopacCommand)
{
	int i;
	int nG = 0;
	int nM = 0;
	FILE* logfile = stdout;
	for(i=0;i<numberOfGeometries;i++)
	{
		if(!geometries[i]) continue;
		nG++;
		fprintf(logfile,"Minimization by Mopac of geometry n = %d... Please wait\n", i+1);
		if(runOneOptMopac(geometries[i], &energies[i], fileNamePrefix, keyWords, mopacCommand)) 
		{
			nM++;
		}
		else
		{
			geometries[i]->klass->free(geometries[i]);
			geometries[i] =NULL;
		}
		fflush(logfile);

	}
	/*
	if(nM==nG) return TRUE;
	return FALSE;
	*/
	fprintf(logfile,"Number of Mopac runs with errors = %d\n", nG-nM); fflush(logfile);
	fprintf(logfile,"-------------------------------------------\n"); fflush(logfile);
	return (nM>0);


}
/*****************************************************************************/
static boolean runOneOptGeneric(QuantumMechanicsModel* geom, double* energy, char* fileNamePrefix, char* keyWords, char* genericCommand)
{
	FILE* file = NULL;
	FILE* fileSH = NULL;
	char* fileNameIn = NULL;
	char* fileNameOut = NULL;
	char* fileNameSH = NULL;
	char buffer[1024];
	int type = 0;
	Molecule* mol = &geom->molecule;
	*energy = 0;
#ifdef OS_WIN32
	char c='%';
#endif

	if(!geom) return FALSE;
	if(geom->molecule.nAtoms<1) return FALSE;
#ifndef OS_WIN32
	fileNameSH = strdup_printf("%sGeneOne.sh",fileNamePrefix);
#else
	fileNameSH = strdup_printf("%sGeneOne.bat",fileNamePrefix);
#endif
 	fileSH = fopen(fileNameSH, "w");
	if(!fileSH) return FALSE;

	fileNameIn = strdup_printf("%sOne.inp",fileNamePrefix);
	fileNameOut = strdup_printf("%sOne.out",fileNamePrefix);

 	file = fopen(fileNameIn, "w");
	if(!file) 
	{
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		return FALSE;
	}

	if(strstr(keyWords,"Opt")) type = 2;
	if(strstr(keyWords,"ENGRAD")) type = 1;
	fprintf(file,"%d\n",type);
	mol->klass->addMolecule(mol,file);
	fclose(file);
	{
		char* str = NULL;
		if(strstr(keyWords,"OPT")) str = strdup_printf("Minimization by Generic/%s ... Please wait",genericCommand);
		else str = strdup_printf("Computing of energy by Generic/%s .... Please wait ",genericCommand);
		printf("%s",str);
	}
#ifndef OS_WIN32
	fprintf(fileSH,"%s %s %s",genericCommand,fileNameIn,fileNameOut);
	fclose(fileSH);
	sprintf(buffer,"chmod u+x %s",fileNameSH);
	system(buffer);
	system(fileNameSH);
#else
	fprintf(fileSH,"\"%s\" \"%s\" \"%s\"",genericCommand,fileNameIn,fileNameOut);
	fclose(fileSH);
	sprintf(buffer,"\"%s\"",fileNameSH);
	system(buffer);
#endif
	if(getEnergyGeneric(fileNameOut,energy))
	{
		printf("Energy by Generic = %f\n", *energy);
		mol->klass->readGeometry(mol,fileNameOut);
	}
	else
	{
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		return FALSE;
	}

 	if(fileNameIn) free(fileNameIn);
 	if(fileNameOut) free(fileNameOut);
 	if(fileNameSH) free(fileNameSH);
	return TRUE;
}
/*****************************************************************************/
static boolean runGenericFiles(int numberOfGeometries, QuantumMechanicsModel** geometries, double* energies, char* fileNamePrefix, char* keyWords, char* genericCommand)
{
	int i;
	int nG = 0;
	int nM = 0;
	FILE* logfile = stdout;
	for(i=0;i<numberOfGeometries;i++)
	{
		if(!geometries[i]) continue;
		nG++;
		fprintf(logfile,"Minimization by Generic of geometry n = %d... Please wait\n", i+1);
		if(runOneOptGeneric(geometries[i], &energies[i], fileNamePrefix, keyWords, genericCommand)) 
		{
			nM++;
		}
		else
		{
			geometries[i]->klass->free(geometries[i]);
			geometries[i] =NULL;
		}
		fflush(logfile);

	}
	/*
	if(nM==nG) return TRUE;
	return FALSE;
	*/
	fprintf(logfile,"Number of generic runs with errors = %d\n", nG-nM); fflush(logfile);
	fprintf(logfile,"-------------------------------------------\n"); fflush(logfile);
	return (nM>0);

}
/*****************************************************************************/
static boolean runOneOptFireFly(QuantumMechanicsModel* geom, double* energy, char* fileNamePrefix, char* keyWords, char* fireflyCommand)
{
	FILE* file = NULL;
	FILE* fileSH = NULL;
	int j;
	char* fileNameIn = NULL;
	char* fileNameOut = NULL;
	char* fileNameSH = NULL;
	char multiplicityStr[100];
	char buffer[1024];
	Molecule* mol = &geom->molecule;
	*energy = 0;
#ifdef OS_WIN32
	char c='%';
#endif

	if(!geom) return FALSE;
	if(geom->molecule.nAtoms<1) return FALSE;
#ifndef OS_WIN32
	fileNameSH = strdup_printf("%sPCGOne.sh",fileNamePrefix);
#else
	fileNameSH = strdup_printf("%sPCGOne.bat",fileNamePrefix);
#endif
 	fileSH = fopen(fileNameSH, "w");
	if(!fileSH) return FALSE;
#ifdef OS_WIN32
	fprintf(fileSH,"set PATH=%cPATH%c;\"%s\"\n",c,c,fireflyDirectory);
#endif

	getMultiplicityName(mol->spinMultiplicity, multiplicityStr);

	fileNameIn = strdup_printf("%sOne.inp",fileNamePrefix);
 	file = fopen(fileNameIn, "w");
	if(!file) 
	{
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		return FALSE;
	}
	fprintf(file,"! ======================================================\n");
	fprintf(file,"!  Input file for FireFly\n"); 
	fprintf(file,"! ======================================================\n");
	if(strstr(keyWords,"RUNTYP"))
	{
		sscanf(strstr(keyWords,"RUNTYP"),"%s",buffer);
		fprintf(file," $CONTRL %s $END\n",buffer);
	}
	if(strstr(keyWords,"SCFTYP"))
	{
		sscanf(strstr(keyWords,"SCFTYP"),"%s",buffer);
		fprintf(file," $CONTRL %s $END\n",buffer);
	}
	else
	{
		if(mol->spinMultiplicity==1)
			fprintf(file," $CONTRL SCFTYP=RHF $END\n");
		else
			fprintf(file," $CONTRL SCFTYP=UHF $END\n");
	}

	fprintf(file," $CONTRL ICHARG=%d MULT=%d $END\n",mol->totalCharge,mol->spinMultiplicity);
	if(strstr(keyWords,"GBASIS"))
	{
		sscanf(strstr(keyWords,"GBASIS"),"%s",buffer);
		fprintf(file," $BASIS %s $END\n",buffer);
	}
	fprintf(file," $DATA\n");
	fprintf(file,"Molecule specification\n");
	fprintf(file,"C1\n");
	for(j=0;j<geom->molecule.nAtoms;j++)
	{
		char* symbol = geom->molecule.atoms[j].prop.symbol;
		SAtomsProp prop = propAtomGet(symbol);
		fprintf(file,"%s %f %f %f %f\n", 
			symbol,
			(double)prop.atomicNumber,
			geom->molecule.atoms[j].coordinates[0],
			geom->molecule.atoms[j].coordinates[1],
			geom->molecule.atoms[j].coordinates[2]
			);
	}
	fprintf(file," $END\n");
	fclose(file);
	fileNameOut = strdup_printf("%sOne.out",fileNamePrefix);
#ifndef OS_WIN32
	if(!strcmp(fireflyCommand,"pcgamess") || !strcmp(fireflyCommand,"nohup pcgamess")||
	!strcmp(fireflyCommand,"firefly") || !strcmp(fireflyCommand,"nohup firefly"))
	{
		fprintf(fileSH,"mkdir %stmp\n",fileNamePrefix);
		fprintf(fileSH,"cd %stmp\n",fileNamePrefix);
		fprintf(fileSH,"cp %s input\n",fileNameIn);
		fprintf(fileSH,"%s -p -o %s\n",fireflyCommand,fileNameOut);
		fprintf(fileSH,"cd ..\n");
		fprintf(fileSH,"rm PUNCH\n");
		fprintf(fileSH,"/bin/rm -r  %stmp\n",fileNamePrefix);
	}
	else
		fprintf(fileSH,"%s %s",fireflyCommand,fileNameIn);
#else
	 if(!strcmp(fireflyCommand,"pcgamess") ||
	 !strcmp(fireflyCommand,"firefly") )
	{
        	fprintf(fileSH,"mkdir \"%stmp\"\n",fileNamePrefix);
		addUnitDisk(fileSH, fileNamePrefix);
	 	fprintf(fileSH,"cd \"%stmp\"\n",fileNamePrefix);
         	fprintf(fileSH,"copy \"%s\" input\n",fileNameIn);
         	fprintf(fileSH,"%s -p -o \"%s\"\n",fireflyCommand,fileNameOut);
	 	fprintf(fileSH,"cd ..\n");
         	fprintf(fileSH,"del PUNCH\n");
         	fprintf(fileSH,"del /Q  \"%stmp\"\n",fileNamePrefix);
         	fprintf(fileSH,"rmdir  \"%stmp\"\n",fileNamePrefix);
	}
	else
		fprintf(fileSH,"%s %s",fireflyCommand,fileNameIn);
#endif
	fclose(fileSH);
	{
		char* str = NULL;
		if(strstr(keyWords,"OPTIMIZE")) str = strdup_printf("Minimization by FireFly/%s ... Please wait",keyWords);
		else str = strdup_printf("Computing of energy by FireFly/%s .... Please wait",keyWords);
		printf("%s",str);
	}
#ifndef OS_WIN32
	sprintf(buffer,"chmod u+x %s",fileNameSH);
	system(buffer);
	system(fileNameSH);
#else
	sprintf(buffer,"\"%s\"",fileNameSH);
	system(buffer);
#endif
	if(getEnergyFireFly(fileNameOut,energy))
	{
		printf("Energy by FireFly = %f\n", *energy);
		mol->klass->readGeomFromGamessOutputFile(mol, fileNameOut, -1);
	}
	else
	{
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		return FALSE;
	}

 	if(fileNameIn) free(fileNameIn);
 	if(fileNameOut) free(fileNameOut);
 	if(fileNameSH) free(fileNameSH);
	return TRUE;
}
/*****************************************************************************/
static boolean runFireFlyFiles(int numberOfGeometries, QuantumMechanicsModel** geometries, double* energies, char* fileNamePrefix, char* keyWords, char* fireflyCommand)
{
	int i;
	int nG = 0;
	int nM = 0;
	FILE* logfile = stdout;
	for(i=0;i<numberOfGeometries;i++)
	{
		if(!geometries[i]) continue;
		nG++;
		fprintf(logfile,"Minimization by FireFly of geometry n = %d... Please wait\n", i+1);
		if(runOneOptFireFly(geometries[i], &energies[i], fileNamePrefix, keyWords,fireflyCommand)) 
		{
			nM++;
		}
		else
		{
			geometries[i]->klass->free(geometries[i]);
			geometries[i] =NULL;
		}
		fflush(logfile);

	}
	/*
	if(nM==nG) return TRUE;
	return FALSE;
	*/
	fprintf(logfile,"Number of FireFly generic runs with errors = %d\n", nG-nM); fflush(logfile);
	fprintf(logfile,"-------------------------------------------\n"); fflush(logfile);
	return (nM>0);


}
/*****************************************************************************/
static boolean runOneOptGaussian(QuantumMechanicsModel* geom, double* energy, char* fileNamePrefix, char* keyWords, char* gaussianCommand)
{
	FILE* file = NULL;
	FILE* fileSH = NULL;
	int j;
	char* fileNameIn = NULL;
	char* fileNameOut = NULL;
	char* fileNameSH = NULL;
	char buffer[1024];
	Molecule* mol = &geom->molecule;
	*energy = 0;
#ifdef OS_WIN32
	char c='%';
#endif

	if(!geom) return FALSE;
	if(geom->molecule.nAtoms<1) return FALSE;
#ifndef OS_WIN32
	fileNameSH = strdup_printf("%sGaussOne.sh",fileNamePrefix);
#else
	fileNameSH = strdup_printf("%sGaussOne.bat",fileNamePrefix);
#endif
 	fileSH = fopen(fileNameSH, "w");
	if(!fileSH) return FALSE;
#ifdef OS_WIN32
	fprintf(fileSH,"set PATH=%cPATH%c;\"%s\"\n",c,c,gaussianDirectory);
#endif

	fileNameIn = strdup_printf("%sOne.inp",fileNamePrefix);
 	file = fopen(fileNameIn, "w");
	if(!file) 
	{
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		return FALSE;
	}
	fprintf(file,"# %s\n",keyWords);
	fprintf(file,"\n");
	fprintf(file,"! ======================================================\n");
	fprintf(file,"!  Input file for Gaussian\n"); 
	fprintf(file,"! ======================================================\n");
	fprintf(file,"\n");

	fprintf(file,"%d %d\n",mol->totalCharge,mol->spinMultiplicity);
	for(j=0;j<mol->nAtoms;j++)
	{
		char* symbol = mol->atoms[j].prop.symbol;
		fprintf(file,"%s %f %f %f\n", 
			symbol,
			mol->atoms[j].coordinates[0],
			mol->atoms[j].coordinates[1],
			mol->atoms[j].coordinates[2]
			);
	}
	fprintf(file,"\n");
	fclose(file);
	fileNameOut = strdup_printf("%sOne.out",fileNamePrefix);
#ifndef OS_WIN32
	fprintf(fileSH,"%s %s",gaussianCommand,fileNameIn);
#else
	fprintf(fileSH,"%s %s",gaussianCommand,fileNameIn);
#endif
	fclose(fileSH);
	{
		char* str = NULL;
		if(strstr(keyWords,"OPT")) str = strdup_printf("Minimization by Gaussian/%s ... Please wait",keyWords);
		else str = strdup_printf("Computing of energy by Gaussian/%s .... Please wait",keyWords);
		printf("%s",str);
	}
#ifndef OS_WIN32
	sprintf(buffer,"chmod u+x %s",fileNameSH);
	system(buffer);
	system(fileNameSH);
#else
	sprintf(buffer,"\"%s\"",fileNameSH);
	system(buffer);
#endif
	if(getEnergyGaussian(fileNameOut,energy))
	{
		printf("Energy by Gaussian = %f\n", *energy);
		mol->klass->readGeomFromGaussianOutputFile(mol, fileNameOut, -1);
	}
	else
	{
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		return FALSE;
	}

 	if(fileNameIn) free(fileNameIn);
 	if(fileNameOut) free(fileNameOut);
 	if(fileNameSH) free(fileNameSH);
	return TRUE;
}
/*****************************************************************************/
static boolean runGaussianFiles(int numberOfGeometries, QuantumMechanicsModel** geometries, double* energies, char* fileNamePrefix, char* keyWords, char* gaussianCommand)
{
	int i;
	int nG = 0;
	int nM = 0;
	FILE* logfile = stdout;
	for(i=0;i<numberOfGeometries;i++)
	{
		if(!geometries[i]) continue;
		nG++;
		fprintf(logfile,"Minimization by Gaussian of geometry n = %d... Please wait\n", i+1);
		if(runOneOptGaussian(geometries[i], &energies[i], fileNamePrefix, keyWords,gaussianCommand)) 
		{
			nM++;
		}
		else
		{
			geometries[i]->klass->free(geometries[i]);
			geometries[i] =NULL;
		}
		fflush(logfile);

	}
	/*
	if(nM==nG) return TRUE;
	return FALSE;
	*/
	fprintf(logfile,"Number of Gaussian runs with errors = %d\n", nG-nM); fflush(logfile);
	fprintf(logfile,"-------------------------------------------\n"); fflush(logfile);
	return (nM>0);


}
/*****************************************************************************/
static boolean runOneOptOrca(QuantumMechanicsModel* geom, double* energy, char* fileNamePrefix, char* keyWords, char* orcaCommand)
{
	FILE* file = NULL;
	FILE* fileSH = NULL;
	char* fileNameIn = NULL;
	char* fileNameOut = NULL;
	char* fileNameSH = NULL;
	char multiplicityStr[100];
	char buffer[1024];
	int i;
	int nV;
	Molecule* mol = &geom->molecule;

	if(!mol) return FALSE;
        if(mol->nAtoms<2)return FALSE;
#ifndef OS_WIN32
	fileNameSH = strdup_printf("%sOne.sh",fileNamePrefix);
#else
	fileNameSH = strdup_printf("%sOne.bat",fileNamePrefix);
#endif
 	fileSH = fopen(fileNameSH, "w");
	if(!fileSH) return FALSE;
#ifdef OS_WIN32
	fprintf(fileSH,"@echo off\n");
#endif

	getMultiplicityName(mol->spinMultiplicity, multiplicityStr);

	fileNameIn = strdup_printf("%sOne.inp",fileNamePrefix);
 	file = fopen(fileNameIn, "w");
	if(!file) 
	{
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		return FALSE;
	}
	fprintf(file,"# ======================================================\n");
	fprintf(file,"#  Orca input file made in Gabedit\n"); 
	fprintf(file,"# ======================================================\n");
	fprintf(file,"! %s\n",keyWords);
	{
		fprintf(file,"* xyz %d   %d\n",mol->totalCharge,mol->spinMultiplicity);
		nV = 0;
      		for (i=0;i<mol->nAtoms;i++)
		{
			char X[100];
			char Y[100];
			char Z[100];
			sprintf(X,"%20.14f",mol->atoms[i].coordinates[0]);
			sprintf(Y,"%20.14f",mol->atoms[i].coordinates[1]);
			sprintf(Z,"%20.14f",mol->atoms[i].coordinates[2]);

			fprintf(file," %s  %s %s %s\n",mol->atoms[i].prop.symbol, X,Y,Z);
			if(mol->atoms[i].variable) nV+=3;
		}
		fprintf(file,"*\n");
		if(nV>0&&nV!=3*mol->nAtoms) 
		{
			fprintf(file,"%cgeom Constraints\n",'%');
      			for (i=0;i<mol->nAtoms;i++)
			{
				if(mol->atoms[i].variable)
				{
					fprintf(file,"  {C %d C}\n",i);
				}
			}
			fprintf(file," end #Constraints\n");
			fprintf(file," invertConstraints true\n");
			fprintf(file," end #geom\n");
		}
	}

	fclose(file);
	fileNameOut = strdup_printf("%sOne.out",fileNamePrefix);
#ifndef OS_WIN32
	if(!strcmp(orcaCommand,"orca") || !strcmp(orcaCommand,"nohup orca"))
	{
		fprintf(fileSH,"%s %s > %s\n",orcaCommand,fileNameIn,fileNameOut);
		fprintf(fileSH,"exit\n");
	}
	else
		fprintf(fileSH,"%s %s",orcaCommand,fileNameIn);
#else
	 if(!strcmp(orcaCommand,"orca") )
	{
		if(strstr(orcaDirectory,"\"")) fprintf(fileSH,"set PATH=%s;%cPATH%c\n",orcaDirectory,'%','%');
		else fprintf(fileSH,"set PATH=\"%s\";%cPATH%c\n",orcaDirectory,'%','%');
		fprintf(fileSH,"%s %s > %s\n",orcaCommand,fileNameIn,fileNameOut);
		fprintf(fileSH,"exit\n");
	}
	else
		fprintf(fileSH,"%s %s",orcaCommand,fileNameIn);
#endif
	fclose(fileSH);
	{
		char* str = NULL;
		if(strstr(keyWords,"Opt")) str = strdup_printf("Minimization by Orca/%s ... Please wait",keyWords);
		else str = strdup_printf("Computing of energy by Orca/%s .... Please wait",keyWords);
		printf("%s\n",str);
		if(str) free(str);
	}
#ifndef OS_WIN32
	sprintf(buffer,"chmod u+x %s",fileNameSH);
	system(buffer);
	system(fileNameSH);
#else
	sprintf(buffer,"\"%s\"",fileNameSH);
	system(buffer);
#endif
	if(getEnergyOrca(fileNameOut,energy))
	{
		printf("Energy by Orca = %f\n", *energy);
		mol->klass->readGeomFromOrcaOutputFile(mol, fileNameOut, -1);
	}
	else
	{
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		return FALSE;
	}

 	if(fileNameIn) free(fileNameIn);
 	if(fileNameOut) free(fileNameOut);
 	if(fileNameSH) free(fileNameSH);
	return TRUE;
}
/*****************************************************************************/
static boolean runOrcaFiles(int numberOfGeometries, QuantumMechanicsModel** geometries, double* energies, char* fileNamePrefix, char* keyWords, char* orcaCommand)
{
	int i;
	int nG = 0;
	int nM = 0;
	FILE* logfile = stdout;
	for(i=0;i<numberOfGeometries;i++)
	{
		if(!geometries[i]) continue;
		nG++;
		fprintf(logfile,"Minimization by Orca of geometry n = %d... Please wait\n", i+1);
		if(runOneOptOrca(geometries[i], &energies[i], fileNamePrefix, keyWords,orcaCommand)) 
		{
			nM++;
		}
		else
		{
			geometries[i]->klass->free(geometries[i]);
			geometries[i] =NULL;
		}
		fflush(logfile);

	}
	/*
	if(nM==nG) return TRUE;
	return FALSE;
	*/
	fprintf(logfile,"Number of Orca runs with errors = %d\n", nG-nM); fflush(logfile);
	fprintf(logfile,"-------------------------------------------\n"); fflush(logfile);
	return (nM>0);


}
/*****************************************************************************/
static boolean runOpenBabelFiles(int numberOfGeometries, QuantumMechanicsModel** geometries, double* energies, char* fileNamePrefix, char* keyWords, char* openBabelCommand)
{
	int i;
	int nG = 0;
	int nM = 0;
	FILE* logfile = stdout;
	if(!geometries) return FALSE;
	for(i=0;i<numberOfGeometries;i++)
	{
		if(!geometries[i]) continue;
		nG++;
		fprintf(logfile,"Minimization by OpenBabel of geometry n = %d... Please wait\n", i+1);
		if(runOneOpenBabel(&geometries[i]->molecule, fileNamePrefix, "Opt",openBabelCommand)) 
		{
			energies[i] = geometries[i]->molecule.potentialEnergy;
			nM++;
		}
		else
		{
			geometries[i]->klass->free(geometries[i]);
			geometries[i] =NULL;
		}
		fflush(logfile);

	}
	/*
	if(nM==nG) return TRUE;
	return FALSE;
	*/
	fprintf(logfile,"Number of OpenBabel runs with errors = %d\n", nG-nM); fflush(logfile);
	fprintf(logfile,"-------------------------------------------\n"); fflush(logfile);
	return (nM>0);


}
/*****************************************************************************/
static boolean testEqualDistances(double* distancesI, double* distancesJ, int n, double tol)
{
	int k;
	if(!distancesI) return FALSE;
	if(!distancesJ) return FALSE;
	if(n<1) return FALSE;
	for (  k = 0; k < n; k++ )
		if(fabs(distancesI[k]-distancesJ[k])>tol) return FALSE;
	return TRUE;
}
/*****************************************************************************/
static double* getDistancesBetweenAtoms(QuantumMechanicsModel* qmModel)
{
	double* distances = NULL;
	int i;
	int j;
	int n;
	int k;
	if(qmModel->molecule.nAtoms<1) return distances;
	n = qmModel->molecule.nAtoms*(qmModel->molecule.nAtoms-1)/2;
	distances = malloc(n*sizeof(double));
	n = 0;
	for (  i = 0; i < qmModel->molecule.nAtoms-1; i++ )
	for (  j = i+1; j < qmModel->molecule.nAtoms; j++ )
	{
		double x = qmModel->molecule.atoms[i].coordinates[0]-qmModel->molecule.atoms[j].coordinates[0];
		double y = qmModel->molecule.atoms[i].coordinates[1]-qmModel->molecule.atoms[j].coordinates[1];
		double z = qmModel->molecule.atoms[i].coordinates[2]-qmModel->molecule.atoms[j].coordinates[2];
		distances[n++] = x*x + y*y + z*z;
	}
	for(i=0;i<n-1;i++)
	{
		k = i;
		for(j=i+1;j<n;j++)
			if(distances[j]<distances[k]) k= j;
		if(k!=i)
		{
			double d = distances[i];
			distances[i] = distances[k];
			distances[k] = d;
		}
	}
	return distances;
}
/*****************************************************************************/
static void removedsToEnd(int numberOfGeometries, QuantumMechanicsModel** geometries, double* energies, boolean* removeds)
{
	if(geometries && energies && removeds)
	{
		int i;
		int j;
		int k;
		for(i=0;i<numberOfGeometries-1;i++)
		{
			if(!removeds[i]) continue;
			k = i;
			for(j=i+1;j<numberOfGeometries;j++)
				if(!removeds[j]) { k= j; break;}
			if(k!=i)
			{
				double energy = energies[i];
				boolean r = removeds[i];
				QuantumMechanicsModel* g = geometries[i];

				energies[i] = energies[k];
				energies[k] = energy;
				geometries[i] = geometries[k];
				geometries[k] = g;
				removeds[i] = removeds[k];
				removeds[k] = r;
			}
		}
	}
}
/*****************************************************************************/
static void computeRemoveds(int numberOfGeometries, QuantumMechanicsModel** geometries, double* energies, boolean *removeds, 
		double tolEnergy, double tolDistance)
{
	int i;
	int j;
	double* distancesI = NULL;
	double* distancesJ = NULL;
	if(tolDistance<=0 && tolEnergy<=0) return;
	if(!geometries || !energies) return;
	if(numberOfGeometries<1) return;
	i = numberOfGeometries-1;
	if(!geometries[i]) removeds[i] = TRUE;
	for(i=0;i<numberOfGeometries-1;i++)
	{
		int n;
		if(!geometries[i]) removeds[i] = TRUE;
		if(removeds[i]) continue;
		if(tolDistance>0) distancesI =  getDistancesBetweenAtoms(geometries[i]);
		n = geometries[i]->molecule.nAtoms*(geometries[i]->molecule.nAtoms-1)/2;
		for(j=i+1;j<numberOfGeometries;j++)
		{
			if(!geometries[j]) removeds[j] = TRUE;
			if(removeds[j]) continue;
			if(tolEnergy>0 && fabs(energies[j]-energies[i])<tolEnergy && geometries[i]->molecule.nAtoms==geometries[j]->molecule.nAtoms)
			{
				if(tolDistance>0) 
				{
					distancesJ =  getDistancesBetweenAtoms(geometries[j]);
					if(testEqualDistances(distancesI, distancesJ, n, tolDistance))
						removeds[j] = TRUE;
					if(distancesJ) free(distancesJ);
					distancesJ = NULL;
				}
				else
					removeds[j] = TRUE;
			}
			if(tolEnergy<0 && tolDistance>0 && geometries[i]->molecule.nAtoms==geometries[j]->molecule.nAtoms)
			{
				distancesJ =  getDistancesBetweenAtoms(geometries[j]);
				if(testEqualDistances(distancesI, distancesJ, n, tolDistance))
					removeds[j] = TRUE;
				if(distancesJ) free(distancesJ);
				distancesJ = NULL;
			}
		}
		if(distancesI) free(distancesI);
		distancesI = NULL;
	}

}
/*****************************************************************************/
static void removeIdenticalGeometries(int* nG, QuantumMechanicsModel*** geoms, double** eners, double tolEnergy, double tolDistance)
{
	int i;
	int numberOfGeometries =*nG;
	QuantumMechanicsModel** geometries = *geoms; 
	double* energies = *eners;
	boolean* removeds = NULL;
	int newN = 0;
	if(numberOfGeometries<1) return;
	removeds = malloc(numberOfGeometries*sizeof(boolean));
	for(i=0;i<numberOfGeometries;i++) removeds[i] = FALSE;
	computeRemoveds(numberOfGeometries, geometries, energies, removeds, tolEnergy, tolDistance);
	removedsToEnd(numberOfGeometries, geometries, energies, removeds);

	for(i=0;i<numberOfGeometries;i++) 
	{
		if(removeds[i]) 
		{
			if(geometries[i]) geometries[i]->klass->free(geometries[i]);
		}
		else newN++;
	}
	free(removeds);
	if(newN==0) { *nG = newN; return;}
	if(newN==numberOfGeometries) return;
	*nG = newN;
	*eners = realloc(*eners,newN*sizeof(double));
	*geoms = realloc(*geoms,newN*sizeof(QuantumMechanicsModel**));

}
/*****************************************************************************/
/*
static int removeIdenticalGeometriesNULL(int numberOfGeometries, QuantumMechanicsModel** geometries, double* energies, double tolEnergy, double tolDistance)
{
	int i;
	boolean* removeds = NULL;
	int newN = 0;
	if(numberOfGeometries<1) return numberOfGeometries;
	removeds = malloc(numberOfGeometries*sizeof(boolean));
	for(i=0;i<numberOfGeometries;i++) removeds[i] = FALSE;
	computeRemoveds(numberOfGeometries, geometries, energies, removeds, tolEnergy, tolDistance);
	removedsToEnd(numberOfGeometries, geometries, energies, removeds);
	for(i=0;i<numberOfGeometries;i++) 
	{
		if(removeds[i]) 
		{
			if(geometries[i]) geometries[i]->klass->free(geometries[i]);
			geometries[i] = NULL;
			energies[i] = 1e30;
		}
		else newN++;
	}
	free(removeds);
	return newN;
}
*/
/*****************************************************************************/
static void sortGeometries(int numberOfGeometries, QuantumMechanicsModel** geometries, double* energies)
{
	if(geometries && energies)
	{
		int i;
		int j;
		int k;
		for(i=0;i<numberOfGeometries-1;i++)
		{
			k = i;
			for(j=i+1;j<numberOfGeometries;j++)
				if(energies[j]<energies[k]) k= j;
			if(k!=i)
			{
				double energy = energies[i];
				QuantumMechanicsModel* g = geometries[i];

				energies[i] = energies[k];
				energies[k] = energy;
				geometries[i] = geometries[k];
				geometries[k] = g;
			}
		}
	}
}
/*****************************************************************************/
static boolean createCChemIFiles(int numberOfGeometries, QuantumMechanicsModel** geometries, double* energies, char* fileNamePrefix, char* keyWords,char* cchemiCommand)
{
	FILE* file = NULL;
	FILE* fileSH = NULL;
	int i;
	int j;
	int nG = 0;
	char* fileName = NULL;
	char* fileNameSH = NULL;

	if(numberOfGeometries<1) return FALSE;
	if(!geometries) return FALSE;
	if(!energies) return FALSE;
	for(i=0;i<numberOfGeometries;i++) if(geometries[i]) nG++;
	if(nG<1) return FALSE;
	fileNameSH = strdup_printf("%scchemi.sh",fileNamePrefix);
#ifndef OS_WIN32
	fileNameSH = strdup_printf("%scchemi.sh",fileNamePrefix);
#else
	fileNameSH = strdup_printf("%sCChemI.bat",fileNamePrefix);
#endif
 	fileSH = fopen(fileNameSH, "w");
	if(!fileSH) return FALSE;


	for(i=0;i<numberOfGeometries;i++)
	{
		if(!geometries[i]) continue;
 		if(fileName) free(fileName);
		fileName = strdup_printf("%sCCHEMI_%d.inp",fileNamePrefix,i+1);
 		file = fopen(fileName, "w");
		if(!file) return FALSE;
		fprintf(file,"# RunType = Energy, Optimization, MD, MDConfo, REMDConfo\n");
		fprintf(file,"RunType=Optimization\n");
		fprintf(file,"OptimizerType=External\n");
		fprintf(file,"Model=Mopac\n");
		fprintf(file,"QMKeys=AM1\n");
		fprintf(file,"mopacCommand=/home/allouche/Softwares/MOPAC2012/MOPAC2012.exe\n");
		fprintf(file,"orcaCommand=orca\n");
		fprintf(file,"fireflyCommand=firefly\n");
		fprintf(file,"gaussianCommand=g09\n");
		fprintf(file,"#gaussianKeywordsPost=B3LYP/aug-cc-pvdz\n");
		fprintf(file,"#QuasiNewton\n");
		fprintf(file,"useQuasiNewton = TRUE\n");
		fprintf(file,"Geometry\n");
		fprintf(file,"%d %d %d\n",geometries[i]->molecule.nAtoms, geometries[i]->molecule.totalCharge, geometries[i]->molecule.spinMultiplicity);
		for(j=0;j<geometries[i]->molecule.nAtoms;j++)
		{
			int nc = 0;
			int k;
			for(k=0;k<geometries[i]->molecule.nAtoms;k++) 
				if(geometries[i]->molecule.atoms[j].typeConnections&&geometries[i]->molecule.atoms[j].typeConnections[k]>0) nc++;

			fprintf(file," %s %s %s %s %d %f %d %d %f %f %f %d ", 
				geometries[i]->molecule.atoms[j].prop.symbol,
				geometries[i]->molecule.atoms[j].mmType,
				geometries[i]->molecule.atoms[j].pdbType,
				geometries[i]->molecule.atoms[j].residueName,
				geometries[i]->molecule.atoms[j].residueNumber,
				geometries[i]->molecule.atoms[j].charge,
				geometries[i]->molecule.atoms[j].layer,
				geometries[i]->molecule.atoms[j].variable,
				geometries[i]->molecule.atoms[j].coordinates[0],
				geometries[i]->molecule.atoms[j].coordinates[1],
				geometries[i]->molecule.atoms[j].coordinates[2],
				nc
				);
			for(k=0;k< geometries[i]->molecule.nAtoms;k++) 
			{
		 		int nk =  geometries[i]->molecule.atoms[k].N-1;
				if(geometries[i]->molecule.atoms[j].typeConnections && geometries[i]->molecule.atoms[j].typeConnections[nk]>0) 
					fprintf(file," %d %d", nk+1, geometries[i]->molecule.atoms[j].typeConnections[nk]);
			}
			fprintf(file,"\n");
		}
		fprintf(file,"Velocities\n");
		for(j=0;j<geometries[i]->molecule.nAtoms;j++)
		{
			fprintf(file,"%f %f %f", 
				geometries[i]->molecule.atoms[j].velocity[0],
				geometries[i]->molecule.atoms[j].velocity[1],
				geometries[i]->molecule.atoms[j].velocity[2]
				);
			fprintf(file,"\n");
		}
		fprintf(file,"Masses\n");
		for(j=0;j<geometries[i]->molecule.nAtoms;j++)
		{
			fprintf(file,"%f", geometries[i]->molecule.atoms[j].mass);
			fprintf(file,"\n");
		}
		fclose(file);
		fprintf(fileSH,"%s %s\n",cchemiCommand,fileName);
	}
	fclose(fileSH);
#ifndef OS_WIN32
	{
		char buffer[1024];
  		sprintf(buffer,"chmod u+x %s",fileNameSH);
		system(buffer);
	}
#endif
 	if(fileName) free(fileName);
 	if(fileNameSH) free(fileNameSH);
	return TRUE;

}
/*****************************************************************************/
static boolean createMopacFiles(int numberOfGeometries, QuantumMechanicsModel** geometries, double* energies, char* fileNamePrefix, char* keyWords, char* mopacCommand)
{
	FILE* file = NULL;
	FILE* fileSH = NULL;
	int i;
	int j;
	int nG = 0;
	char* fileName = NULL;
	char* fileNameSH = NULL;
	char multiplicityStr[100];
#ifdef OS_WIN32
	char c='%';
#endif

	if(numberOfGeometries<1) return FALSE;
	if(!geometries) return FALSE;
	if(!energies) return FALSE;
	for(i=0;i<numberOfGeometries;i++) if(geometries[i]) nG++;
	if(nG<1) return FALSE;
#ifndef OS_WIN32
	fileNameSH = strdup_printf("%sMopac.sh",fileNamePrefix);
#else
	fileNameSH = strdup_printf("%sMopac.bat",fileNamePrefix);
#endif
 	fileSH = fopen(fileNameSH, "w");
	if(!fileSH) return FALSE;
#ifdef OS_WIN32
	fprintf(fileSH,"set PATH=%cPATH%c;\"%s\"\n",c,c,mopacDirectory);
#endif


	for(i=0;i<numberOfGeometries;i++)
	{
		if(!geometries[i]) continue;
 		if(fileName) free(fileName);
		getMultiplicityName(geometries[i]->molecule.spinMultiplicity, multiplicityStr);
		fileName = strdup_printf("%s_%d.mop",fileNamePrefix,i+1);
 		file = fopen(fileName, "w");
		if(!file) return FALSE;
		if(geometries[i]->molecule.spinMultiplicity>1)
		fprintf(file,"%s UHF CHARGE=%d %s\n",keyWords,geometries[i]->molecule.totalCharge,multiplicityStr);
		else
		fprintf(file,"%s CHARGE=%d %s\n",keyWords,geometries[i]->molecule.totalCharge,multiplicityStr);
		fprintf(file,"\n");
		fprintf(file," Quantum Mechanics Energy(kCal/mol) =%f\n",energies[i]);

		for(j=0;j<geometries[i]->molecule.nAtoms;j++)
		{
		fprintf(file," %s %f %d %f %d %f %d\n", 
				geometries[i]->molecule.atoms[j].prop.symbol,
				geometries[i]->molecule.atoms[j].coordinates[0],
				1,
				geometries[i]->molecule.atoms[j].coordinates[1],
				1,
				geometries[i]->molecule.atoms[j].coordinates[2],
				1
				);
		}
		fclose(file);
		fprintf(fileSH,"%s %s\n",mopacCommand,fileName);
	}
	fclose(fileSH);
#ifndef OS_WIN32
	{
		char buffer[1024];
  		sprintf(buffer,"chmod u+x %s",fileNameSH);
		system(buffer);
	}
#endif
 	if(fileName) free(fileName);
 	if(fileNameSH) free(fileNameSH);
	return TRUE;

}
/*****************************************************************************/
static boolean createGaussianFiles(int numberOfGeometries, QuantumMechanicsModel** geometries, double* energies, char* fileNamePrefix, char* keyWords, char* gaussianCommand)
{
	FILE* file = NULL;
	FILE* fileSH = NULL;
	int i;
	int j;
	int nG = 0;
	char* fileName = NULL;
	char* fileNameSH = NULL;

	if(numberOfGeometries<1) return FALSE;
	if(!geometries) return FALSE;
	if(!energies) return FALSE;
	for(i=0;i<numberOfGeometries;i++) if(geometries[i]) nG++;
	if(nG<1) return FALSE;
	fileNameSH = strdup_printf("%sGauss.sh",fileNamePrefix);
#ifndef OS_WIN32
	fileNameSH = strdup_printf("%sGauss.sh",fileNamePrefix);
#else
	fileNameSH = strdup_printf("%sGauss.bat",fileNamePrefix);
#endif
 	fileSH = fopen(fileNameSH, "w");
	if(!fileSH) return FALSE;


	for(i=0;i<numberOfGeometries;i++)
	{
		if(!geometries[i]) continue;
 		if(fileName) free(fileName);
		fileName = strdup_printf("%s_%d.com",fileNamePrefix,i+1);
 		file = fopen(fileName, "w");
		if(!file) return FALSE;
		fprintf(file,"#P %s\n",keyWords);
		fprintf(file,"#  Units(Ang,Deg)\n");
		fprintf(file,"\n");
		fprintf(file,"File generated by Gabedit\n");
		fprintf(file,"Quantum Mechanics Energy(kCal/mol) = %f\n",energies[i]);
		fprintf(file,"\n");
		fprintf(file,"%d %d\n",geometries[i]->molecule.totalCharge,geometries[i]->molecule.spinMultiplicity);
		for(j=0;j<geometries[i]->molecule.nAtoms;j++)
		{
		fprintf(file,"%s %f %f %f\n", 
				geometries[i]->molecule.atoms[j].prop.symbol,
				geometries[i]->molecule.atoms[j].coordinates[0],
				geometries[i]->molecule.atoms[j].coordinates[1],
				geometries[i]->molecule.atoms[j].coordinates[2]
				);
		}
		fprintf(file,"\n");
		fclose(file);
		fprintf(fileSH,"%s %s\n",gaussianCommand,fileName);
	}
	fclose(fileSH);
#ifndef OS_WIN32
	{
		char buffer[1024];
  		sprintf(buffer,"chmod u+x %s",fileNameSH);
		system(buffer);
	}
#endif
 	if(fileName) free(fileName);
 	if(fileNameSH) free(fileNameSH);
	return TRUE;

}
/*****************************************************************************/
static boolean createFireFlyFiles(int numberOfGeometries, QuantumMechanicsModel** geometries, double* energies, char* fileNamePrefix, char* keyWords, char* fireflyCommand)
{
	FILE* file = NULL;
	FILE* fileSH = NULL;
	int i;
	int j;
	int nG = 0;
	char* fileName = NULL;
	char* fileNameSH = NULL;
	char buffer[1024];
#ifdef OS_WIN32
	char c='%';
#endif

	if(numberOfGeometries<1) return FALSE;
	if(!geometries) return FALSE;
	if(!energies) return FALSE;
	for(i=0;i<numberOfGeometries;i++) if(geometries[i]) nG++;
	if(nG<1) return FALSE;
#ifndef OS_WIN32
	fileNameSH = strdup_printf("%sPCGam.sh",fileNamePrefix);
#else
	fileNameSH = strdup_printf("%sPCGam.bat",fileNamePrefix);
#endif
 	fileSH = fopen(fileNameSH, "w");
	if(!fileSH) return FALSE;
#ifdef OS_WIN32
	fprintf(fileSH,"set PATH=%cPATH%c;\"%s\"\n",c,c,fireflyDirectory);
#endif


	uppercase(keyWords);
	for(i=0;i<numberOfGeometries;i++)
	{
		if(!geometries[i]) continue;
 		if(fileName) free(fileName);
		fileName = strdup_printf("%sFF_%d.inp",fileNamePrefix,i+1);
 		file = fopen(fileName, "w");
		if(!file) return FALSE;
		fprintf(file,"! ======================================================\n");
		fprintf(file,"!  Input file for FireFly\n"); 
		fprintf(file,"! ======================================================\n");
		if(strstr(keyWords,"RUNTYP"))
		{
			sscanf(strstr(keyWords,"RUNTYP"),"%s",buffer);
			fprintf(file," $CONTRL %s $END\n",buffer);
		}
		if(strstr(keyWords,"SCFTYP"))
		{
			sscanf(strstr(keyWords,"SCFTYP"),"%s",buffer);
			fprintf(file," $CONTRL %s $END\n",buffer);
		}
		else
		{
			if(geometries[i]->molecule.spinMultiplicity==1)
				fprintf(file," $CONTRL SCFTYP=RHF $END\n");
			else
				fprintf(file," $CONTRL SCFTYP=UHF $END\n");
		}

		fprintf(file," $CONTRL ICHARG=%d MULT=%d $END\n",geometries[i]->molecule.totalCharge,geometries[i]->molecule.spinMultiplicity);
		if(strstr(keyWords,"GBASIS"))
		{
			sscanf(strstr(keyWords,"GBASIS"),"%s",buffer);
			fprintf(file," $BASIS %s $END\n",buffer);
		}
		fprintf(file," $DATA\n");
		fprintf(file,"Molecule specification\n");
		fprintf(file,"C1\n");
		for(j=0;j<geometries[i]->molecule.nAtoms;j++)
		{
			char* symbol = geometries[i]->molecule.atoms[j].prop.symbol;
			SAtomsProp prop = propAtomGet(symbol);
			fprintf(file,"%s %f %f %f %f\n", 
				symbol,
				(double)prop.atomicNumber,
				geometries[i]->molecule.atoms[j].coordinates[0],
				geometries[i]->molecule.atoms[j].coordinates[1],
				geometries[i]->molecule.atoms[j].coordinates[2]
				);
		}
		fprintf(file," $END\n");
		fclose(file);

#ifndef OS_WIN32
		if(!strcmp(fireflyCommand,"pcgamess") || !strcmp(fireflyCommand,"nohup pcgamess")||
		!strcmp(fireflyCommand,"firefly") || !strcmp(fireflyCommand,"nohup firefly"))
		{
			fprintf(fileSH,"mkdir %stmp%d\n",fileNamePrefix,i+1);
			fprintf(fileSH,"cd %stmp%d\n",fileNamePrefix,i+1);
			fprintf(fileSH,"cp %s input\n",fileName);
			fprintf(fileSH,"%s -p -o %sFF_%d.log\n",fireflyCommand,fileNamePrefix,i+1);
			fprintf(fileSH,"cd ..\n");
			fprintf(fileSH,"mv PUNCH  %sFF_%d.pun\n",fileNamePrefix,i+1);
			fprintf(fileSH,"/bin/rm -r  %stmp%d\n",fileNamePrefix,i+1);
		}
		else
			fprintf(fileSH,"%s %s",fireflyCommand,fileName);
#else
	 	if(!strcmp(fireflyCommand,"pcgamess") ||
	 	!strcmp(fireflyCommand,"firefly") )
		{
         		fprintf(fileSH,"mkdir %stmp%d\n",fileNamePrefix,i+1);
			addUnitDisk(fileSH, fileNamePrefix);
	 		fprintf(fileSH,"cd %stmp%d\n",fileNamePrefix,i+1);
         		fprintf(fileSH,"copy %s input\n",fileName);
         		fprintf(fileSH,"%s -p -o %sFF_%d.log\n",fireflyCommand,fileNamePrefix,i+1);
	 		fprintf(fileSH,"cd ..\n");
         		fprintf(fileSH,"move PUNCH  %sFF_%d.pun\n",fileNamePrefix,i+1);
         		fprintf(fileSH,"del /Q  %stmp%d\n",fileNamePrefix,i+1);
         		fprintf(fileSH,"rmdir  %stmp%d\n",fileNamePrefix,i+1);
		}
		else
			fprintf(fileSH,"%s %s",fireflyCommand,fileName);
#endif
	}
	fclose(fileSH);
#ifndef OS_WIN32
	{
		char buffer[1024];
  		sprintf(buffer,"chmod u+x %s",fileNameSH);
		system(buffer);
	}
#endif
 	if(fileName) free(fileName);
 	if(fileNameSH) free(fileNameSH);
	return TRUE;

}
/*****************************************************************************/
static boolean createOrcaFiles(int numberOfGeometries, QuantumMechanicsModel** geometries, double* energies, char* fileNamePrefix, char* keyWords,char* orcaCommand)
{
	FILE* file = NULL;
	FILE* fileSH = NULL;
	int i,j;
	int nG = 0;
	int nV = 0;
	char* fileName = NULL;
	char* fileOut = NULL;
	char* fileNameSH = NULL;
	Molecule* mol = NULL;

	if(numberOfGeometries<1) return FALSE;
	if(!geometries) return FALSE;
	if(!energies) return FALSE;
	for(i=0;i<numberOfGeometries;i++) if(geometries[i]) nG++;
	if(nG<1) return FALSE;
	fileNameSH = strdup_printf("%sOrca.sh",fileNamePrefix);
#ifndef OS_WIN32
	fileNameSH = strdup_printf("%sOrca.sh",fileNamePrefix);
#else
	fileNameSH = strdup_printf("%sOrca.bat",fileNamePrefix);
#endif
 	fileSH = fopen(fileNameSH, "w");
	if(!fileSH) return FALSE;


	for(j=0;j<numberOfGeometries;j++)
	{
		if(!geometries[j]) continue;
 		if(fileName) free(fileName);
 		if(fileOut) free(fileOut);
		fileOut = strdup_printf("%sORCA_%d.out",fileNamePrefix,j+1);
		fileName = strdup_printf("%sORCA_%d.inp",fileNamePrefix,j+1);
 		file = fopen(fileName, "w");
		if(!file) return FALSE;
		mol = &geometries[j]->molecule;
		fprintf(file,"! %s\n",keyWords);
		fprintf(file,"* xyz %d   %d\n",mol->totalCharge,mol->spinMultiplicity);
		nV = 0;
      		for (i=0;i<mol->nAtoms;i++)
		{
			char X[100];
			char Y[100];
			char Z[100];
			sprintf(X,"%20.14f",mol->atoms[i].coordinates[0]);
			sprintf(Y,"%20.14f",mol->atoms[i].coordinates[1]);
			sprintf(Z,"%20.14f",mol->atoms[i].coordinates[2]);

			fprintf(file," %s  %s %s %s\n",mol->atoms[i].prop.symbol, X,Y,Z);
			if(mol->atoms[i].variable) nV+=3;
		}
		fprintf(file,"*\n");
		if(nV>0&&nV!=3*mol->nAtoms) 
		{
			fprintf(file,"%cgeom Constraints\n",'%');
      			for (i=0;i<mol->nAtoms;i++)
			{
				if(mol->atoms[i].variable)
				{
					fprintf(file,"  {C %d C}\n",i);
				}
			}
			fprintf(file," end #Constraints\n");
			fprintf(file," invertConstraints true\n");
			fprintf(file," end #geom\n");
		}
		fprintf(file,"\n");
		fclose(file);
		fprintf(fileSH,"%s %s > %s\n",orcaCommand,fileName, fileOut);
	}
	fclose(fileSH);
#ifndef OS_WIN32
	{
		char buffer[1024];
  		sprintf(buffer,"chmod u+x %s",fileNameSH);
		system(buffer);
	}
#endif
 	if(fileName) free(fileName);
 	if(fileOut) free(fileOut);
 	if(fileNameSH) free(fileNameSH);
	return TRUE;
}
/*****************************************************************************/
/*****************************************************************************/
static void createPostProcessingFiles(int numberOfGeometries, QuantumMechanicsModel** geometries,double* energies,char* fileNameGeom, char* mopacKeywords, char* gaussianKeywords, char* fireflyKeywords, char* orcaKeywords,  char* cchemiKeywords, char* message, char* mopacCommand, char* gaussianCommand, char* fireflyCommand, char* orcaCommand, char* cchemiCommand)
{
	if(mopacKeywords)
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		createMopacFiles(numberOfGeometries, geometries, energies, fileNamePrefix, mopacKeywords,mopacCommand);
		strcat(message,fileNamePrefix);
		strcat(message,("_*.mop\n\tFiles for a post processing by Mopac\n\n"));
		if(fileNamePrefix) free(fileNamePrefix);
	}
	if(gaussianKeywords)
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		createGaussianFiles(numberOfGeometries, geometries, energies, fileNamePrefix, gaussianKeywords,gaussianCommand);
		strcat(message,fileNamePrefix);
		strcat(message,("_*.com\n\tFiles for a post processing by Gaussian\n\n"));
		if(fileNamePrefix) free(fileNamePrefix);
	}
	if(fireflyKeywords)
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		createFireFlyFiles(numberOfGeometries, geometries, energies, fileNamePrefix, fireflyKeywords,fireflyCommand);
		strcat(message,fileNamePrefix);
		strcat(message,("FF_*.inp\n\tFiles for a post processing by FireFly\n\n"));
		if(fileNamePrefix) free(fileNamePrefix);
	}
	if(orcaKeywords)
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		createOrcaFiles(numberOfGeometries, geometries, energies, fileNamePrefix, orcaKeywords,orcaCommand);
		strcat(message,fileNamePrefix);
		strcat(message,("ORCA_*.inp\n\tFiles for a post processing by Orca\n\n"));
		if(fileNamePrefix) free(fileNamePrefix);
	}
	if(cchemiKeywords)
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		createCChemIFiles(numberOfGeometries, geometries, energies, fileNamePrefix, cchemiKeywords,cchemiCommand);
		strcat(message,fileNamePrefix);
		strcat(message,("CCHEMI_*.inp\n\tFiles for a post processing by CChemI\n\n"));
		if(fileNamePrefix) free(fileNamePrefix);
	}
}
/*****************************************************************************/
static int collectGeometriesFromProcessors(int nproc, QuantumMechanicsModel** geometriesAll, int numberOfGeometriesMax, double* energiesAll, QuantumMechanicsModel** geometries, int numberOfGeometries, double* energies,  double* coords,  double* enerDum, QuantumMechanicsModel* qmModel, double tolEnergy, double tolDistance)
{
		int numberOfGeometriesAll = 0;
#ifdef ENABLE_MPI
#ifdef DEBUG
		printf("Begin collectGeometriesFromProcessors\n");
#endif
		int j;
		int i;
		int code,tag;
		for(i=0;i<numberOfGeometriesMax;i++) 
		{
			energiesAll[i] = 1e30;
			if(geometriesAll[i]) geometries[i]->klass->free(geometriesAll[i]);
			geometriesAll[i] = NULL;
		}
		for(i=0;i<numberOfGeometries;i++) 
		{
			if(geometries[i])
			{
				geometriesAll[i] = malloc(sizeof(QuantumMechanicsModel));
               			*geometriesAll[i] = geometries[i]->klass->copy(geometries[i]);
				energiesAll[i] = energies[i];
			}
		}
		numberOfGeometriesAll = numberOfGeometries;
		// get geometries from other proc
		for(j=1;j<nproc;j++)
		{
			int nG = 0;
			tag = 1000;
			MPI_Status status ;
//#ifdef DEBUG
			printf("get nGeometries from proc n %d\n", j);
//#endif
			code = MPI_Recv(&nG,1,MPI_INT,j,tag,MPI_COMM_WORLD,&status) ;
//#ifdef DEBUG
			printf("nGeometries=%d from proc n %d\n",nG, j);
//#endif
			if(nG>0) 
			{
				int k;
				int a,b;
				tag = 2000;
				code = MPI_Recv(enerDum,nG,MPI_DOUBLE,j,tag,MPI_COMM_WORLD,&status) ;
				for(k=0;k<nG;k++)
				{
					int nA = qmModel->molecule.nAtoms;
					energiesAll[i+k] = enerDum[k];
					tag = 3000+k;
					code = MPI_Recv(coords,nA*3,MPI_DOUBLE,j,tag,MPI_COMM_WORLD,&status) ;
					geometriesAll[i+k] = malloc(sizeof(QuantumMechanicsModel));
               				*geometriesAll[i+k] = qmModel->klass->copy(qmModel);
					b = 0;
					for(a=0;a<nA;a++)
					{
//#ifdef DEBUG
						printf(" atoms %d C = %f %f %f\n",a,coords[b], coords[b+1], coords[b+2]);
//#endif
						geometriesAll[i+k]->molecule.atoms[a].coordinates[0] = coords[b++];
						geometriesAll[i+k]->molecule.atoms[a].coordinates[1] = coords[b++];
						geometriesAll[i+k]->molecule.atoms[a].coordinates[2] = coords[b++];
					}
				}
				i += nG;
				numberOfGeometriesAll += nG;
			}
		}
		sortGeometries(numberOfGeometriesAll, geometriesAll, energiesAll);
		numberOfGeometriesAll = removeIdenticalGeometriesNULL(numberOfGeometriesAll, geometriesAll, energiesAll, tolEnergy, tolDistance);
//#ifdef DEBUG
		printf("End collectGeometriesFromProcessors\n");
//#endif

#endif /* ENABLE_MPI */
		return numberOfGeometriesAll;
}
/*********************************************************************************************************************************/
static void sendGeometriesToMaster(int rank, QuantumMechanicsModel** geometries, int numberOfGeometries, double* energies,  double* coords, int nAtoms)
{
#ifdef ENABLE_MPI
	int j;
	int code,tag;
	j = 0;
	tag = 1000;
#ifdef DEBUG
	printf("Begin sendGeometriesToMaster from proc n %d\n",rank);
#endif
	code = MPI_Send(&numberOfGeometries,1,MPI_INT,j,tag,MPI_COMM_WORLD) ;
	if(numberOfGeometries>0)
	{
		int k;
		int a,b;
		tag = 2000;
		code = MPI_Send(energies,numberOfGeometries,MPI_DOUBLE,j,tag,MPI_COMM_WORLD) ;
		for(k=0;k<numberOfGeometries;k++)
		{
			tag = 3000+k;
			b = 0;
			for(a=0;a<nAtoms;a++)
			{
				coords[b++] = geometries[k]->molecule.atoms[a].coordinates[0];
				coords[b++] = geometries[k]->molecule.atoms[a].coordinates[1];
				coords[b++] = geometries[k]->molecule.atoms[a].coordinates[2];
			}
			code = MPI_Send(coords,nAtoms*3,MPI_DOUBLE,j,tag,MPI_COMM_WORLD);
		}
	}
#ifdef DEBUG
	printf("End sendGeometriesToMaster from proc n %d\n",rank);
#endif
#endif /* ENABLE_MPI */
}
/***********************************************************************************************************************/
static void optAndSortGeometries(
	QuantumMechanicsModel* qmModel, 
	char* inputFileName,
	QuantumMechanicsModel*** geometries,
	int* numberOfGeometries,
	char* mopacCommand,
	char* gaussianCommand,
	char* N2P2Dir,
	char* tmModule,
	char* fireflyCommand,
	char* cchemiCommand,
	char* orcaCommand,
	char* openBabelCommand,
	char* genericCommand,
	char* optMopacMethod,
	char* optGaussianMethod,
	char* optFireFlyMethod,
	char* optOrcaMethod,
	char* optGenericMethod,
	double** energies,
	boolean optMopac,
	boolean optGaussian,
	boolean optGeneric,
	boolean optFireFly,
	boolean optOrca,
	boolean optOpenBabel,
	boolean optN2P2,
	boolean optTM,
	double tolEnergy,
	double tolDistance,
	char* fileNameGeom,
	boolean removeSimilarInertia,
	boolean removeFragmented,
	boolean removeSmallDistance,
	boolean removeSimilarBonds,
	double inertiaTol,
	double sTol,
	double distMaxTol,
	FILE* logfile,
	char* message
)
{
	/* minimazation by mopac PM6*/
	if(optMopac )
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		char* keys = strdup_printf("%s XYZ",optMopacMethod);
		runMopacFiles(*numberOfGeometries, *geometries, *energies, fileNamePrefix, keys, mopacCommand);
		{
			char* fileNameGeomMop = strdup_printf("%sMop.gab",fileNamePrefix);
			sortGeometries(*numberOfGeometries, *geometries, *energies);
			saveEnergies(*energies, *numberOfGeometries, inputFileName);
			removeIdenticalGeometries(numberOfGeometries, geometries, energies, tolEnergy, tolDistance);
			if(removeSimilarInertia) qmModel->klass->removeSimilarInertiaGeometries(*geometries, numberOfGeometries,*energies,logfile,inertiaTol);
			if(removeSimilarBonds) qmModel->klass->removeSimilarBondsGeometries(*geometries, numberOfGeometries, *energies,logfile,sTol, distMaxTol);
			if(removeFragmented) qmModel->klass->removeFragmentedMolecules(*geometries, numberOfGeometries, *energies, logfile);
			if(removeSmallDistance) qmModel->klass->removeSmallDistanceMolecules(*geometries, numberOfGeometries, *energies, logfile);
			if(saveConfoGeometries(*numberOfGeometries, *geometries, *energies, fileNameGeom))
			{
				strcat(message,fileNameGeom);
				strcat(message,("\n\tGeometries after minimization by Mopac/"));
				strcat(message,optMopacMethod);
				strcat(message,("\n\tTo read this file through Gabedit : 'Read/CChemI file'\n\n"));
			}
			free(fileNameGeomMop);
		}
		if(fileNamePrefix) free(fileNamePrefix);
		if(keys)free(keys);
	}
	/* minimazation by gaussian PM6*/
	if(optGaussian )
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		char* keys = strdup_printf("%s Opt",optGaussianMethod);
		if(runGaussianFiles(*numberOfGeometries, *geometries, *energies, fileNamePrefix, keys, gaussianCommand))
		{
			char* fileNameGeomGauss = strdup_printf("%sGauss.gab",fileNamePrefix);
			sortGeometries(*numberOfGeometries, *geometries, *energies);
			saveEnergies(*energies, *numberOfGeometries, inputFileName);
			removeIdenticalGeometries(numberOfGeometries, geometries, energies, tolEnergy, tolDistance);
			if(removeSimilarInertia) qmModel->klass->removeSimilarInertiaGeometries(*geometries, numberOfGeometries,*energies,logfile,inertiaTol);
			if(removeSimilarBonds) qmModel->klass->removeSimilarBondsGeometries(*geometries, numberOfGeometries, *energies,logfile,sTol, distMaxTol);
			if(removeFragmented) qmModel->klass->removeFragmentedMolecules(*geometries, numberOfGeometries, *energies, logfile);
			if(removeSmallDistance) qmModel->klass->removeSmallDistanceMolecules(*geometries, numberOfGeometries, *energies, logfile);
			if(saveConfoGeometries(*numberOfGeometries, *geometries, *energies, fileNameGeom))
			{
				strcat(message,fileNameGeom);
				strcat(message,("\n\tGeometries after minimization by Gaussian/"));
				strcat(message,optGaussianMethod);
				strcat(message,("\n\tTo read this file through Gabedit : 'Read/CChemI file'\n\n"));
			}
			free(fileNameGeomGauss);
		}
		if(fileNamePrefix) free(fileNamePrefix);
		if(keys)free(keys);
	}
	/* minimazation by FireFly*/
	if(optFireFly )
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		char* keys=strdup_printf("RUNTYP=Optimize GBASIS=%s",optFireFlyMethod);
		if(runFireFlyFiles(*numberOfGeometries, *geometries, *energies, fileNamePrefix, keys,fireflyCommand))
		{
			char* fileNameGeomFireFly = strdup_printf("%sFireFly.gab",fileNamePrefix);
			sortGeometries(*numberOfGeometries, *geometries, *energies);
			saveEnergies(*energies, *numberOfGeometries, inputFileName);
			removeIdenticalGeometries(numberOfGeometries, geometries, energies, tolEnergy, tolDistance);
			if(removeSimilarInertia) qmModel->klass->removeSimilarInertiaGeometries(*geometries, numberOfGeometries,*energies,logfile,inertiaTol);
			if(removeSimilarBonds) qmModel->klass->removeSimilarBondsGeometries(*geometries, numberOfGeometries, *energies,logfile,sTol, distMaxTol);
			if(removeFragmented) qmModel->klass->removeFragmentedMolecules(*geometries, numberOfGeometries, *energies, logfile);
			if(removeSmallDistance) qmModel->klass->removeSmallDistanceMolecules(*geometries, numberOfGeometries, *energies, logfile);
			if(saveConfoGeometries(*numberOfGeometries, *geometries, *energies, fileNameGeom))
			{
				strcat(message,fileNameGeom);
				strcat(message,("\n\tGeometries after minimization by FireFly"));
				strcat(message,("\n\tTo read this file through Gabedit : 'Read/Gabedit file'\n\n"));
			}
			free(fileNameGeomFireFly);

		}
		if(fileNamePrefix) free(fileNamePrefix);
		if(keys)free(keys);
	}
	/* minimazation by OpenBabel*/
	if(optOpenBabel )
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		char* keys=strdup_printf("opt");
		if(runOpenBabelFiles(*numberOfGeometries, *geometries, *energies, fileNamePrefix, keys,openBabelCommand))
		{
			char* fileNameGeomOpenBabel = strdup_printf("%sOpenBabel.gab",fileNamePrefix);
			sortGeometries(*numberOfGeometries, *geometries, *energies);
			saveEnergies(*energies, *numberOfGeometries, inputFileName);
			removeIdenticalGeometries(numberOfGeometries, geometries, energies, tolEnergy, tolDistance);
			if(removeSimilarInertia) qmModel->klass->removeSimilarInertiaGeometries(*geometries, numberOfGeometries,*energies,logfile,inertiaTol);
			if(removeSimilarBonds) qmModel->klass->removeSimilarBondsGeometries(*geometries, numberOfGeometries, *energies,logfile,sTol, distMaxTol);
			if(removeFragmented) qmModel->klass->removeFragmentedMolecules(*geometries, numberOfGeometries, *energies, logfile);
			if(removeSmallDistance) qmModel->klass->removeSmallDistanceMolecules(*geometries, numberOfGeometries, *energies, logfile);
			if(saveConfoGeometries(*numberOfGeometries, *geometries, *energies, fileNameGeom))
			{
				strcat(message,fileNameGeom);
				strcat(message,("\n\tGeometries after minimization by OpenBabel"));
				strcat(message,("\n\tTo read this file through Gabedit : 'Read/Gabedit file'\n\n"));
			}
			free(fileNameGeomOpenBabel);

		}
		if(fileNamePrefix) free(fileNamePrefix);
		if(keys)free(keys);
	}
	/* minimazation by Orca*/
	if(optOrca )
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		char* keys=strdup_printf("%s opt",optOrcaMethod);
		if(runOrcaFiles(*numberOfGeometries, *geometries, *energies, fileNamePrefix, keys,orcaCommand))
		{
			char* fileNameGeomOrca = strdup_printf("%sOrca.gab",fileNamePrefix);
			sortGeometries(*numberOfGeometries, *geometries, *energies);
			saveEnergies(*energies, *numberOfGeometries, inputFileName);
			removeIdenticalGeometries(numberOfGeometries, geometries, energies, tolEnergy, tolDistance);
			if(removeSimilarInertia) qmModel->klass->removeSimilarInertiaGeometries(*geometries, numberOfGeometries,*energies,logfile,inertiaTol);
			if(removeSimilarBonds) qmModel->klass->removeSimilarBondsGeometries(*geometries, numberOfGeometries, *energies,logfile,sTol, distMaxTol);
			if(removeFragmented) qmModel->klass->removeFragmentedMolecules(*geometries, numberOfGeometries, *energies, logfile);
			if(removeSmallDistance) qmModel->klass->removeSmallDistanceMolecules(*geometries, numberOfGeometries, *energies, logfile);
			if(saveConfoGeometries(*numberOfGeometries, *geometries, *energies, fileNameGeom))
			{
				strcat(message,fileNameGeom);
				strcat(message,("\n\tGeometries after minimization by Orca"));
				strcat(message,("\n\tTo read this file through Gabedit : 'Read/Gabedit file'\n\n"));
			}
			free(fileNameGeomOrca);

		}
		if(fileNamePrefix) free(fileNamePrefix);
		if(keys)free(keys);
	}
	/* minimazation by generic*/
	if(optGeneric )
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		char* keys = strdup_printf(" Opt");
		if(runGenericFiles(*numberOfGeometries, *geometries, *energies, fileNamePrefix, keys, optGenericMethod))
		{
			char* fileNameGeomGene = strdup_printf("%sGene.gab",fileNamePrefix);
			sortGeometries(*numberOfGeometries, *geometries, *energies);
			saveEnergies(*energies, *numberOfGeometries, inputFileName);
			removeIdenticalGeometries(numberOfGeometries, geometries, energies, tolEnergy, tolDistance);
			if(removeSimilarInertia) qmModel->klass->removeSimilarInertiaGeometries(*geometries, numberOfGeometries,*energies,logfile,inertiaTol);
			if(removeSimilarBonds) qmModel->klass->removeSimilarBondsGeometries(*geometries, numberOfGeometries, *energies,logfile,sTol, distMaxTol);
			if(removeFragmented) qmModel->klass->removeFragmentedMolecules(*geometries, numberOfGeometries, *energies, logfile);
			if(removeSmallDistance) qmModel->klass->removeSmallDistanceMolecules(*geometries, numberOfGeometries, *energies, logfile);
			if(saveConfoGeometries(*numberOfGeometries, *geometries, *energies, fileNameGeom))
			{
				strcat(message,fileNameGeom);
				strcat(message,("\n\tGeometries after minimization by Generic/"));
				strcat(message,optGenericMethod);
				strcat(message,("\n\tTo read this file through Gabedit : 'Read/CChemI file'\n\n"));
			}
			free(fileNameGeomGene);
		}
		if(fileNamePrefix) free(fileNamePrefix);
		if(keys)free(keys);
	}
	/* minimazation with N2P2  */
	//fprintf(stderr,"optN2P2=%d\n",optN2P2);
	if(optN2P2 )
	{
		fprintf(stderr,"optimisation using HDDN potentials\n");
		if(miminizeGeometriesUsingInternalOptimizer(*numberOfGeometries, *geometries, *energies, inputFileName))
		{
			sortGeometries(*numberOfGeometries, *geometries, *energies);
			saveEnergies(*energies, *numberOfGeometries, inputFileName);
			removeIdenticalGeometries(numberOfGeometries, geometries, energies, tolEnergy, tolDistance);
			if(removeSimilarInertia) qmModel->klass->removeSimilarInertiaGeometries(*geometries, numberOfGeometries,*energies,logfile,inertiaTol);
			if(removeSimilarBonds) qmModel->klass->removeSimilarBondsGeometries(*geometries, numberOfGeometries, *energies,logfile,sTol, distMaxTol);
			if(removeFragmented) qmModel->klass->removeFragmentedMolecules(*geometries, numberOfGeometries, *energies, logfile);
			if(removeSmallDistance) qmModel->klass->removeSmallDistanceMolecules(*geometries, numberOfGeometries, *energies, logfile);
			if(saveConfoGeometries(*numberOfGeometries, *geometries, *energies, fileNameGeom))
			{
				strcat(message,fileNameGeom);
				strcat(message,("\n\tGeometries after minimization by N2P2 potential"));
				strcat(message,("\n\tTo read this file through Gabedit : 'Read/Gabedit file'\n\n"));
			}

		}
	}
	/* minimazation with TM  */
	//fprintf(stderr,"optTM=%d\n",optTM);
	if(optTM )
	{
		fprintf(stderr,"optimisation using TM potential\n");
		if(miminizeGeometriesUsingInternalOptimizer(*numberOfGeometries, *geometries, *energies, inputFileName))
		{
			sortGeometries(*numberOfGeometries, *geometries, *energies);
			saveEnergies(*energies, *numberOfGeometries, inputFileName);
			removeIdenticalGeometries(numberOfGeometries, geometries, energies, tolEnergy, tolDistance);
			if(removeSimilarInertia) qmModel->klass->removeSimilarInertiaGeometries(*geometries, numberOfGeometries,*energies,logfile,inertiaTol);
			if(removeSimilarBonds) qmModel->klass->removeSimilarBondsGeometries(*geometries, numberOfGeometries, *energies,logfile,sTol, distMaxTol);
			if(removeFragmented) qmModel->klass->removeFragmentedMolecules(*geometries, numberOfGeometries, *energies, logfile);
			if(removeSmallDistance) qmModel->klass->removeSmallDistanceMolecules(*geometries, numberOfGeometries, *energies, logfile);
			if(saveConfoGeometries(*numberOfGeometries, *geometries, *energies, fileNameGeom))
			{
				strcat(message,fileNameGeom);
				strcat(message,("\n\tGeometries after minimization by TM potential"));
				strcat(message,("\n\tTo read this file through Gabedit : 'Read/Gabedit file'\n\n"));
			}

		}
	}
	if(!optMopac && !optFireFly && !optGaussian && !optGeneric && !optOpenBabel && !optN2P2 && !optTM)
	//if(!optMopac && !optFireFly && !optGaussian && !optGeneric )
	{
		/*  sort by energies */
		sortGeometries(*numberOfGeometries, *geometries, *energies);
		saveEnergies(*energies, *numberOfGeometries, inputFileName);
		removeIdenticalGeometries(numberOfGeometries, geometries, energies, tolEnergy, tolDistance);
		if(removeSimilarInertia) qmModel->klass->removeSimilarInertiaGeometries(*geometries, numberOfGeometries,*energies,logfile,inertiaTol);
		if(removeSimilarBonds) qmModel->klass->removeSimilarBondsGeometries(*geometries, numberOfGeometries, *energies,logfile,sTol, distMaxTol);
		if(removeFragmented) qmModel->klass->removeFragmentedMolecules(*geometries, numberOfGeometries, *energies, logfile);
		if(removeSmallDistance) qmModel->klass->removeSmallDistanceMolecules(*geometries, numberOfGeometries, *energies, logfile);
		/* printf("fileNameGeom = %s\n",fileNameGeom);*/
		if(saveConfoGeometries(*numberOfGeometries, *geometries, *energies, fileNameGeom))
		{
			strcat(message,fileNameGeom);
			strcat(message,("\n\tGeometries selected and optimized using your Quantum Mechanics potentials"));
			strcat(message,("\n\tTo read this file through Gabedit : 'Read/Gabedit file'\n\n"));
		}
	}
}
/***********************************************************************************************************************/
static void quantumMechanicsRemoveSimilarConfo(char* inputFileName)
{
	QuantumMechanicsModel qmModel; 
	QuantumMechanicsModel** geometries = NULL;
	int i;
	char message[BSIZE]="Created files :\n";
	char* dirName = NULL;
	int numberOfGeometries = 0;
	Molecule** mols = readMolecules(inputFileName,FALSE);
	char* mopacCommand = strdup("mopac");
	char* gaussianCommand=strdup("g09"); 
	char* N2P2Dir=strdup(getenv("PWD"));
	char* tmModule=strdup_printf("%s/%s",getenv("PWD"),"CChemITMModule");
	char* fireflyCommand=strdup("firefly");
	char* cchemiCommand=strdup("cchemi");
	char* orcaCommand = strdup("orca");
	char* openBabelCommand = strdup("obgradient");
	char* genericCommand=strdup("runGeneric");
	FILE* file = fopen(inputFileName,"rb");
	char* mopacKeywordsPost = NULL;
	char* gaussianKeywordsPost = NULL;
	char* fireflyKeywordsPost = NULL;
	char* orcaKeywordsPost = NULL;
	char* cchemiKeywordsPost = NULL;
	char* optMopacMethod=strdup("PM6");
	char* optGaussianMethod=strdup("AM1");
	char* optFireFlyMethod=strdup("AM1");
	char* optOrcaMethod=strdup("AM1");
	char* optGenericMethod=strdup("runGeneric");
	char* model = NULL;
	char* QMKeys = NULL;
	int cnt;
	char* optimizerType = NULL;

	double* energies = NULL;
	boolean optMopac = FALSE;
	boolean optGaussian = FALSE;
	boolean optGeneric = FALSE;
	boolean optFireFly = FALSE;
	boolean optOrca = FALSE;
	boolean optOpenBabel = FALSE;
	boolean optN2P2 = FALSE;
	boolean optTM = FALSE;
	double tolEnergy = 0.01;
	double tolDistance = 0.01;
	char* fileNameGeom = NULL;
	Constraints constraints = NOCONSTRAINTS;
	boolean chain=FALSE;
	boolean fragments=FALSE;
	boolean saveFirstGeom=FALSE;
	boolean removeSimilarInertia = FALSE;
	boolean removeFragmented = FALSE;
	boolean removeSmallDistance = FALSE;
	int nTimesGeoms=1;
	double inertiaTol = 0.04; // recomended byjun Zhao et al (2016)
       	//Comprehensive genetic algorithm for ab initio global optimisation of clusters, Molecular Simulation,
	// 42:10, 809-819, DOI: 10.1080/08927022.2015.1121386	     

	boolean removeSimilarBonds = FALSE;
	double sTol=0.02;
	double distMaxTol=0.7;
	// sTol = 0.02 , distMaxTol = 0.7 Ang, recommanded in Jorgensen et al JCTC, 2017
//Mathias S. Jrgensen , Michael N. Groves, and Bjrk Hammer
//J. Chem. Theory Comput., 2017, 13 (3), pp 14861493
//DOI: 10.1021/acs.jctc.6b01119
	FILE* logfile = stdout;

	numberOfGeometries = 0;
	while(mols && mols[numberOfGeometries]) numberOfGeometries++;

	readOneString(file,"mopacCommand",&mopacCommand);
	readOneString(file,"gaussianCommand",&gaussianCommand);
	readOneString(file,"genericCommand",&genericCommand);
	readOneString(file,"orcaCommand",&orcaCommand);
	readOneString(file,"openBabelCommand",&openBabelCommand);
	readOneString(file,"HDNNDir",&N2P2Dir);
	readOneString(file,"N2P2Dir",&N2P2Dir);
	readOneString(file,"tmModule",&tmModule);
	readOneString(file,"fireflyCommand",&fireflyCommand);
	readOneString(file,"cchemiCommand",&cchemiCommand);
	readOneReal(file,"tolEnergy",&tolEnergy);
	readOneReal(file,"tolDistance",&tolDistance);
	readOneBoolean(file,"ConfoOptMopac",&optMopac);
	readOneString(file,"ConfoOptMopacMethod",&optMopacMethod);
	readOneBoolean(file,"ConfoOptGaussian",&optGaussian);
	readOneString(file,"ConfoOptGaussianMethod",&optGaussianMethod);
	readOneBoolean(file,"ConfoOptFireFly",&optFireFly);
	readOneString(file,"ConfoOptFireFlyMethod",&optFireFlyMethod);
	readOneBoolean(file,"ConfoOptOrca",&optOrca);
	readOneString(file,"ConfoOptOrcaMethod",&optOrcaMethod);
	readOneBoolean(file,"ConfoOptOpenBabel",&optOpenBabel);
	readOneBoolean(file,"ConfoOptGeneric",&optGeneric);
	readOneString(file,"ConfoOptGenericMethod",&optGenericMethod);
	readOneBoolean(file,"ConfoOptN2P2",&optN2P2);
	readOneBoolean(file,"ConfoOptTM",&optTM);
	readOneBoolean(file,"RDChain",&chain);
	readOneBoolean(file,"RDFragments",&fragments);
	readOneBoolean(file,"RDSaveFirstGeom",&saveFirstGeom);
	readOneInt(file,"nTimesGeoms",&nTimesGeoms);

	if(readOneInt(file,"Constraints",&cnt)) constraints = cnt;

	readOneString(file,"mopacKeywordsPost",&mopacKeywordsPost);
	readOneString(file,"gaussianKeywordsPost",&gaussianKeywordsPost);
	readOneString(file,"fireflyKeywordsPost",&fireflyKeywordsPost);
	readOneString(file,"orcaKeywordsPost",&orcaKeywordsPost);
	readOneString(file,"cchemiKeywordsPost",&cchemiKeywordsPost);
	readOneString(file,"OptimizerType",&optimizerType);
	if(!optimizerType) optimizerType = strdup("External");
	if(!strstr(optimizerType,"External") && (optMopac||optFireFly))
	{
		printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		printf("Sorry, The optimization using the internal optimizer with a RD conformational search is not yes implemented in this software\n");
		printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		exit(1);
	}
	if(!readOneString(file,"Model",&model)) model = strdup("MOPAC");
	uppercase(model);
	if(!readOneString(file,"QMKeys",&QMKeys)) 
	{
		if(!strcmp(model,"MOPAC")) QMKeys = strdup("PM6-DH+");
		else if(!strcmp(model,"ORCA")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"GAUSSIAN")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"FIREFLY")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"OPENBABEL")) QMKeys = strdup("mmff94");
		else QMKeys = strdup("SCC-DFTB");
	}
	if(!strcmp(model,"OPENBABEL")) 
	{
		int i; for(i=0;i<numberOfGeometries;i++) mols[i]->klass->buildMMTypes(mols[i], file);
	}

	/* fileName for geometries */
	{
		char* suff = getSuffixNameFile(inputFileName);
		dirName = strdup(getenv("PWD"));
		fileNameGeom = strdup_printf("%s%s",suff, "Geoms.gab");
		free(suff);
	}
	if(readOneBoolean(file,"removeSimilarInertia",&removeSimilarInertia) && removeSimilarInertia) readOneReal(file,"InertiaTol",&inertiaTol);
	readOneBoolean(file,"removeFragmented",&removeFragmented);
	readOneBoolean(file,"removeDissociated",&removeFragmented);
	readOneBoolean(file,"removeSmallDistance",&removeSmallDistance);
	if(readOneBoolean(file,"removeSimilarBonds",&removeSimilarBonds) && removeSimilarBonds)
	{
		readOneReal(file,"sTol",&sTol);
		readOneReal(file,"distMaxTol",&distMaxTol);
	}


	printf("Model = %s\n",model);
	printf("QMKeys = %s\n",QMKeys);

	{
		int i; 
		boolean addD3Correction;
		readOneBoolean(file,"addD3Correction",&addD3Correction);
		geometries = malloc(numberOfGeometries*sizeof(QuantumMechanicsModel*));
		for(i=0;i<numberOfGeometries;i++) 
		{
			geometries[i] = malloc(sizeof(QuantumMechanicsModel));
			QuantumMechanicsModel qmModel;
			qmModel = createGenericModel(mols[i], QMKeys, dirName, genericCommand, constraints, stdout);
                	*geometries[i] = qmModel.klass->copy(&qmModel);
			setH4Correction(file,geometries[i]);
			setSRBCorrection(file,geometries[i]);
			geometries[i]->addD3Correction=addD3Correction;
			checkWallCorrection(file, geometries[i]);
		}
	}



	int nOld = numberOfGeometries*nTimesGeoms;
	if(nTimesGeoms>1) numberOfGeometries = nOld;
	qmModel = *geometries[0];

	if(removeSimilarInertia) qmModel.klass->removeSimilarInertiaGeometries(geometries, &numberOfGeometries, energies,stdout,inertiaTol);
	if(removeFragmented) qmModel.klass->removeFragmentedMolecules(geometries, &numberOfGeometries, energies, stdout);
	if(removeSmallDistance) qmModel.klass->removeSmallDistanceMolecules(geometries, &numberOfGeometries, energies, stdout);
	if(removeSimilarBonds) qmModel.klass->removeSimilarBondsGeometries(geometries, &numberOfGeometries, energies,stdout,sTol, distMaxTol);

	if(nTimesGeoms>1) qmModel.klass->cutByInertia(geometries, &numberOfGeometries, energies,nOld/nTimesGeoms,stdout);

	if(geometries && numberOfGeometries>0)
	{
		int i;
		energies = malloc(numberOfGeometries*sizeof(double));
		for(i=0;i<numberOfGeometries;i++)
			energies[i] = geometries[i]->molecule.potentialEnergy;
	}

	optAndSortGeometries(&qmModel, inputFileName, &geometries, &numberOfGeometries, mopacCommand, gaussianCommand, N2P2Dir, tmModule, fireflyCommand, cchemiCommand,
	orcaCommand, openBabelCommand, genericCommand, optMopacMethod, optGaussianMethod, optFireFlyMethod, optOrcaMethod, optGenericMethod, &energies,
	optMopac, optGaussian, optGeneric, optFireFly, optOrca, optOpenBabel, optN2P2, optTM, tolEnergy, tolDistance, fileNameGeom, removeSimilarInertia,
	removeFragmented, removeSmallDistance, removeSimilarBonds, inertiaTol, sTol, distMaxTol, logfile, message);

	if(numberOfGeometries>0 && geometries )
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		createPostProcessingFiles(numberOfGeometries, geometries, energies,fileNamePrefix, mopacKeywordsPost, gaussianKeywordsPost, fireflyKeywordsPost, orcaKeywordsPost, cchemiKeywordsPost, message, mopacCommand, gaussianCommand, fireflyCommand, orcaCommand, cchemiCommand);
		if(fileNamePrefix) free(fileNamePrefix);
	}
	if(geometries)
	{
		for(i=0;i<numberOfGeometries;i++)
			if(geometries[i]) geometries[i]->klass->free(geometries[i]);
		free(geometries);
	}
	if(energies) free(energies);
	if(strlen(message)>20) printf("%s",message);
	if(fileNameGeom)free(fileNameGeom);
	fclose(file);

}
/*****************************************************************************/
static void quantumMechanicsREMDConfo(char* inputFileName)
{
	QuantumMechanicsModel qmModel; 
	QuantumMechanicsMD molecularDynamics;
	int updateFrequency = 1;
	double heatTime;
	double equiTime;
	double runTime;
	double coolTime;
	double heatTemp; 
	double equiTemp; 
	double runTemp; 
	double coolTemp; 
	double stepSize;
	MDIntegratorType integrator = VERLET;
	char* fileNameGeom = NULL;
	char* fileNameTraj = NULL;
	char* fileNameProp = NULL;
	double friction=-1;
	double omegaMax = 4000;
	int Nf = 50;
	double collide = 20;
	double qNH = 20;
	MDThermostatType thermostat = NONE;
	int numberOfGeometries = 2;
	QuantumMechanicsModel** geometries = NULL; 
	double* energies = NULL;
	boolean optMopac = FALSE;
	boolean optGaussian = FALSE;
	boolean optGeneric = FALSE;
	boolean optFireFly = FALSE;
	boolean optOrca = FALSE;
	boolean optOpenBabel = FALSE;
	boolean optN2P2 = FALSE;
	boolean optTM = FALSE;
	double tolEnergy = 0.01;
	double tolDistance = 0.01;
	Constraints constraints = NOCONSTRAINTS;
	int i;
	char message[BSIZE]="Created files :\n";
	char* dirName = NULL;
	Molecule mol = *(readMolecule(inputFileName,TRUE));
	char* mopacCommand = strdup("mopac");
	char* gaussianCommand=strdup("g09"); 
	char* N2P2Dir=strdup(getenv("PWD"));
	char* tmModule=strdup_printf("%s/%s",getenv("PWD"),"CChemITMModule");
	char* genericCommand=strdup("runGeneric"); 
	char* fireflyCommand=strdup("firefly");
	char* cchemiCommand=strdup("cchemi");
	char* orcaCommand = strdup("orca");
	char* openBabelCommand = strdup("obgradient");
	FILE* file = fopen(inputFileName,"rb");
	char* mopacKeywordsPost = NULL;
	char* gaussianKeywordsPost = NULL;
	char* fireflyKeywordsPost = NULL;
	char* orcaKeywordsPost = NULL;
	char* cchemiKeywordsPost = NULL;
	char* optMopacMethod=strdup("PM6");
	char* optGaussianMethod=strdup("AM1");
	char* optFireFlyMethod=strdup("AM1");
	char* optOrcaMethod=strdup("AM1");
	char* optGenericMethod=strdup("runGeneric");
	char* model = NULL;
	char* QMKeys = NULL;
	double runTempMax = 700;
	int nTemperatures = 10;
	int numberOfExchanges = 10;
	double timeExchange = 1;
	int nproc;
	int rank;
	QuantumMechanicsModel** geometriesAll = NULL; 
	int numberOfGeometriesAll = 2;
	int numberOfGeometriesMax = 2;
	double* energiesAll = NULL;
	double* coords = NULL;
	double* enerDum = NULL;
	FILE* logfile = NULL;
	int cnt = 0;
	char* optimizerType = NULL;
	boolean removeSimilarInertia = FALSE;
	boolean removeFragmented = FALSE;
	boolean removeSmallDistance = FALSE;
	double inertiaTol = 0.04; // recomended byjun Zhao et al (2016)
       	//Comprehensive genetic algorithm for ab initio global optimisation of clusters, Molecular Simulation,
	// 42:10, 809-819, DOI: 10.1080/08927022.2015.1121386	     

	boolean removeSimilarBonds = FALSE;
	double sTol=0.02;
	double distMaxTol=0.7;
	// sTol = 0.02 , distMaxTol = 0.7 Ang, recommanded in Jorgensen et al JCTC, 2017
//Mathias S. Jrgensen , Michael N. Groves, and Bjrk Hammer
//J. Chem. Theory Comput., 2017, 13 (3), pp 14861493
//DOI: 10.1021/acs.jctc.6b01119

#ifdef ENABLE_MPI
	MPI_Comm_rank( MPI_COMM_WORLD,&rank);
	MPI_Comm_size( MPI_COMM_WORLD,&nproc );
#else
	rank = 0;
	nproc = 1;
#endif

	logfile = stdout;
	if(rank!=0)
	{
		char* tmp = strdup_printf("cchemi_%d.log",rank);
		logfile = fopen(tmp,"w");
		free(tmp);
	}
	fprintf(logfile, "MolecularMechanicsDynamicsREMDConfoDlg Rank#=%d  nproc = %d\n", rank, nproc );
#ifdef DEBUG
	fprintf(logfile, "MolecularMechanicsDynamicsREMDConfoDlg Rank#=%d  nproc = %d\n", rank, nproc );
#endif

	setMDOptions(file, &updateFrequency, 
		&heatTime, &equiTime, &runTime, &coolTime,
		&heatTemp, &runTemp, &equiTemp, &coolTemp, &stepSize, 
		&integrator, &thermostat, &friction, &omegaMax, &Nf, &collide,&qNH);
	if(thermostat == NONE) 
	{
		fprintf(logfile, "Warning....................\n");
		fprintf(logfile, " A thermostat is required for a REMD calculation\n");
		fprintf(logfile, " I set it to Berendsen\n");
		thermostat = BERENDSEN;
	}
	if(readOneBoolean(file,"removeSimilarInertia",&removeSimilarInertia) && removeSimilarInertia) readOneReal(file,"InertiaTol",&inertiaTol);
	readOneBoolean(file,"removeFragmented",&removeFragmented);
	readOneBoolean(file,"removeDissociated",&removeFragmented);
	readOneBoolean(file,"removeSmallDistance",&removeSmallDistance);
	if(readOneBoolean(file,"removeSimilarBonds",&removeSimilarBonds) && removeSimilarBonds)
	{
		readOneReal(file,"sTol",&sTol);
		readOneReal(file,"distMaxTol",&distMaxTol);
	}


	readOneString(file,"mopacCommand",&mopacCommand);
	readOneString(file,"orcaCommand",&orcaCommand);
	readOneString(file,"openBabelCommand",&openBabelCommand);
	readOneString(file,"HDNNDir",&N2P2Dir);
	readOneString(file,"N2P2Dir",&N2P2Dir);
	readOneString(file,"tmModule",&tmModule);
	readOneString(file,"gaussianCommand",&gaussianCommand);
	readOneString(file,"fireflyCommand",&fireflyCommand);
	readOneString(file,"genericCommand",&genericCommand);
	readOneString(file,"cchemiCommand",&cchemiCommand);
	readOneReal(file,"tolEnergy",&tolEnergy);
	readOneReal(file,"tolDistance",&tolDistance);
	readOneBoolean(file,"ConfoOptMopac",&optMopac);
	readOneString(file,"ConfoOptMopacMethod",&optMopacMethod);
	readOneBoolean(file,"ConfoOptGaussian",&optGaussian);
	readOneString(file,"ConfoOptGaussianMethod",&optGaussianMethod);
	readOneBoolean(file,"ConfoOptGeneric",&optGeneric);
	readOneString(file,"ConfoOptGenericMethod",&optGenericMethod);
	readOneBoolean(file,"ConfoOptFireFly",&optFireFly);
	readOneString(file,"ConfoOptFireFlyMethod",&optFireFlyMethod);
	readOneBoolean(file,"ConfoOptOrca",&optOrca);
	readOneString(file,"ConfoOptOrcaMethod",&optOrcaMethod);
	readOneBoolean(file,"ConfoOptOpenBabel",&optOpenBabel);
	readOneBoolean(file,"ConfoOptN2P2",&optN2P2);
	readOneBoolean(file,"ConfoOptTM",&optTM);

	if(readOneInt(file,"Constraints",&cnt)) constraints = cnt;

	readOneString(file,"mopacKeywordsPost",&mopacKeywordsPost);
	readOneString(file,"gaussianKeywordsPost",&gaussianKeywordsPost);
	readOneString(file,"fireflyKeywordsPost",&fireflyKeywordsPost);
	readOneString(file,"orcaKeywordsPost",&orcaKeywordsPost);
	readOneString(file,"cchemiKeywordsPost",&cchemiKeywordsPost);
	readOneString(file,"OptimizerType",&optimizerType);
	if(!optimizerType) optimizerType = strdup("External");
	if(!strstr(optimizerType,"External")  && (optMopac||optFireFly))
	{
		printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		printf("Sorry, The optimization using the internal optimizer after a MD conformational search is not yes implemented in this software\n");
		printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		exit(1);
	}

	readOneReal(file,"runTempMax",&runTempMax);
	if(runTempMax<=runTemp) runTempMax=10*runTemp;
	readOneInt(file,"nTemperatures",&nTemperatures);
	if(nTemperatures<1) nTemperatures=10;

	if(readOneReal(file,"timeExchange",&timeExchange))
	{
		if(timeExchange>=runTime)
		{
			fprintf(logfile, "Error : time of exchange cannot be larger than run time \n");
			fprintf(logfile, "      : check your input file\n");
			exit(1);
		}
	}
	else timeExchange = runTime/10;

	numberOfExchanges = (int)(runTime/timeExchange+0.5);


	if(numberOfExchanges<1) numberOfExchanges=2;
	/* number for geometries */
	{
		numberOfGeometries = 10;
		readOneInt(file,"numberOfGeometries",&numberOfGeometries);
		if(numberOfGeometries<2) numberOfGeometries = 2;
		fprintf(logfile, "numerOfGeometries = %d\n",numberOfGeometries);
	}
	if(!readOneString(file,"Model",&model)) model = strdup("MOPAC");
	uppercase(model);
	if(!readOneString(file,"QMKeys",&QMKeys)) 
	{
		if(!strcmp(model,"MOPAC")) QMKeys = strdup("PM6-DH+");
		else if(!strcmp(model,"ORCA")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"GAUSSIAN")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"FIREFLY")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"OPENBABEL")) QMKeys = strdup("mmff94");
		else QMKeys = strdup("SCC-DFTB");
	}
	if(!strcmp(model,"OPENBABEL")) mol.klass->buildMMTypes(&mol, file);

	/* fileName for geometries */
	{
		char* suff = getSuffixNameFile(inputFileName);
		dirName = strdup(getenv("PWD"));
		fileNameGeom = strdup_printf("%s%s",suff, "Geoms.gab");
		fileNameTraj = strdup_printf("%s%s",suff, "Traj.gab");
		fileNameProp = strdup_printf("%s%s",suff, "Prop.txt");
		free(suff);
	}


	fprintf(logfile, "Model = %s\n",model);
	fprintf(logfile, "QMKeys = %s\n",QMKeys);
	if(!strcmp(model,"MOPAC")) qmModel = createMopacModel(&mol, QMKeys, dirName, mopacCommand, constraints, logfile);
	else if(!strcmp(model,"FIREFLY")) qmModel = createFireFlyModel(&mol, QMKeys, dirName, fireflyCommand, constraints, logfile);
	else if(!strcmp(model,"ORCA")) qmModel = createOrcaModel(&mol, QMKeys, dirName, orcaCommand, constraints, logfile);
	else if(!strcmp(model,"OPENBABEL")) qmModel = createOpenBabelModel(&mol, QMKeys, dirName, openBabelCommand, constraints, logfile);
	else if(!strcmp(model,"GAUSSIAN")) qmModel = createGaussianModel(&mol, QMKeys, dirName, gaussianCommand, constraints, logfile);
	else if(!strcmp(model,"N2P2") || !strcmp(model,"HDNN")) qmModel = createN2P2Model(&mol, N2P2Dir, constraints, logfile);
	else if(!strcmp(model,"TM") || !strcmp(model,"TensorModel")) qmModel = createTMModel(&mol, tmModule, constraints, logfile);
	else qmModel = createGenericModel(&mol, QMKeys, dirName, genericCommand, constraints, logfile);

	setH4Correction(file,&qmModel);
	setSRBCorrection(file,&qmModel);
	readOneBoolean(file,"addD3Correction",&qmModel.addD3Correction);
	checkWallCorrection(file, &qmModel);

	geometries = runQuantumMechanicsREMDConfo(&molecularDynamics, &qmModel,
		updateFrequency, heatTime, equiTime, runTime, heatTemp, runTemp, runTempMax, stepSize, 
		integrator, thermostat, friction, omegaMax, Nf, collide, qNH, numberOfGeometries, nTemperatures, numberOfExchanges, fileNameTraj, fileNameProp);

	if(geometries) 
	{
		int k = 0;
		int i = 0;
#ifdef DEBUG
		fprintf(logfile, "number max of Geometries in rank n %d = %d\n",rank,numberOfGeometries );
#endif
		for(i=0;i<numberOfGeometries;i++) if(geometries[i])k++;
		fprintf(logfile, "number of selected geometries on rank n %d = %d\n",rank, k);
		if(k>0) fprintf(logfile, "fileNameGeom = %s\n",fileNameGeom);
	}
	else fprintf(logfile, "No selected geometriy in rank n %d\n",rank);
	fflush(logfile);

	if(geometries && numberOfGeometries>0) energies = malloc(numberOfGeometries*sizeof(double));
	numberOfGeometriesAll = numberOfGeometries+1;
	numberOfGeometriesMax = numberOfGeometries+1;
	fprintf(logfile, "Alloc energiesAll rank= %d\n",rank);
	fflush(logfile);
	if(nproc>1)
	{
		coords =  malloc(qmModel.molecule.nAtoms*3*sizeof(double));
		enerDum =  malloc(numberOfGeometriesMax*sizeof(double));
		if(geometries && numberOfGeometries>0) energiesAll = malloc(numberOfGeometriesMax*sizeof(double));
		if(geometries && numberOfGeometries>0) 
		{
			geometriesAll = malloc(numberOfGeometriesMax*sizeof(QuantumMechanicsModel*));
			for(i=0;i<numberOfGeometriesMax;i++) 
			{
				geometriesAll[i] = NULL;
			}
		}
	}

	fprintf(logfile, "Alloc energies rank= %d\n",rank);
	fflush(logfile);
	if(geometries && numberOfGeometries>0)
	{
		int i;
		energies = malloc(numberOfGeometries*sizeof(double));
		for(i=0;i<numberOfGeometries;i++) energies[i] = 1e30;
		for(i=0;i<numberOfGeometries;i++) 
			if(geometries[i]) energies[i] = geometries[i]->molecule.potentialEnergy;
	}
	fprintf(logfile, "End Alloc energies rank= %d\n",rank);
	fflush(logfile);

	/* minimazation by mopac PM6*/
	if(optMopac )
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		char* keys = strdup_printf("%s XYZ",optMopacMethod);
		runMopacFiles(numberOfGeometries, geometries, energies, fileNamePrefix, keys, mopacCommand);
		{
			char* fileNameGeomMop = strdup_printf("%sMop.gab",fileNamePrefix);
			sortGeometries(numberOfGeometries, geometries, energies);
			removeIdenticalGeometries(&numberOfGeometries, &geometries, &energies, tolEnergy, tolDistance);
			if(removeSimilarInertia) qmModel.klass->removeSimilarInertiaGeometries(geometries, &numberOfGeometries,energies,stdout,inertiaTol);
			if(removeSimilarBonds) qmModel.klass->removeSimilarBondsGeometries(geometries, &numberOfGeometries, energies,stdout,sTol, distMaxTol);
			if(removeFragmented) qmModel.klass->removeFragmentedMolecules(geometries, &numberOfGeometries, energies, stdout);
			if(removeSmallDistance) qmModel.klass->removeSmallDistanceMolecules(geometries, &numberOfGeometries, energies, stdout);
			if(nproc==1)
			{
				numberOfGeometriesAll = numberOfGeometries;
				geometriesAll = geometries;
				energiesAll = energies;
			}
			else
			{
//#ifdef DEBUG
				fprintf(logfile, "MolecularMechanicsDynamicsREMDConfoDlg Rank#=%d  nproc = %d\n", rank, nproc );
//#endif
				if(rank==0) 
					numberOfGeometriesAll = collectGeometriesFromProcessors(nproc, geometriesAll, numberOfGeometriesMax, energiesAll, geometries, numberOfGeometries, energies,  coords,  enerDum, &qmModel,tolEnergy,tolDistance);
				else sendGeometriesToMaster(rank, geometries, numberOfGeometries, energies,  coords, qmModel.molecule.nAtoms);
				fprintf(logfile, "End collect&send nGeoms = %d\n", numberOfGeometriesAll );
				fflush(logfile);
			}
			if(rank==0 && saveConfoGeometries(numberOfGeometriesAll, geometriesAll, energiesAll, fileNameGeom))
			{
				strcat(message,fileNameGeom);
				strcat(message,("\n\tGeometries after minimization by Mopac/"));
				strcat(message,optMopacMethod);
				strcat(message,("\n\tTo read this file through Gabedit : 'Read/CChemI file'\n\n"));
			}
			free(fileNameGeomMop);
		}
		if(fileNamePrefix) free(fileNamePrefix);
		if(keys)free(keys);
	}
	/* minimazation by Gaussian PM6*/
	if(optGaussian )
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		char* keys = strdup_printf("%s Opt",optGaussianMethod);
		if(runGaussianFiles(numberOfGeometries, geometries, energies, fileNamePrefix, keys, gaussianCommand))
		{
			char* fileNameGeomGauss = strdup_printf("%sGauss.gab",fileNamePrefix);
			sortGeometries(numberOfGeometries, geometries, energies);
			removeIdenticalGeometries(&numberOfGeometries, &geometries, &energies, tolEnergy, tolDistance);
			if(removeSimilarInertia) qmModel.klass->removeSimilarInertiaGeometries(geometries, &numberOfGeometries,energies,stdout,inertiaTol);
			if(removeSimilarBonds) qmModel.klass->removeSimilarBondsGeometries(geometries, &numberOfGeometries, energies,stdout,sTol, distMaxTol);
			if(removeFragmented) qmModel.klass->removeFragmentedMolecules(geometries, &numberOfGeometries, energies, stdout);
			if(removeSmallDistance) qmModel.klass->removeSmallDistanceMolecules(geometries, &numberOfGeometries, energies, stdout);
			if(nproc==1)
			{
				numberOfGeometriesAll = numberOfGeometries;
				geometriesAll = geometries;
				energiesAll = energies;
			}
			else
			{
//#ifdef DEBUG
				fprintf(logfile, "MolecularMechanicsDynamicsREMDConfoDlg Rank#=%d  nproc = %d\n", rank, nproc );
//#endif
				if(rank==0) 
					numberOfGeometriesAll = collectGeometriesFromProcessors(nproc, geometriesAll, numberOfGeometriesMax, energiesAll, geometries, numberOfGeometries, energies,  coords,  enerDum, &qmModel,tolEnergy,tolDistance);
				else sendGeometriesToMaster(rank, geometries, numberOfGeometries, energies,  coords, qmModel.molecule.nAtoms);
				fprintf(logfile, "End collect&send nGeoms = %d\n", numberOfGeometriesAll );
				fflush(logfile);
			}
			if(rank==0 && saveConfoGeometries(numberOfGeometriesAll, geometriesAll, energiesAll, fileNameGeom))
			{
				strcat(message,fileNameGeom);
				strcat(message,("\n\tGeometries after minimization by Gaussian/"));
				strcat(message,optGaussianMethod);
				strcat(message,("\n\tTo read this file through Gabedit : 'Read/CChemI file'\n\n"));
			}
			free(fileNameGeomGauss);
		}
		if(fileNamePrefix) free(fileNamePrefix);
		if(keys)free(keys);
	}
	/* minimazation by FireFly*/
	if(optFireFly )
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		char* keys=strdup_printf("RUNTYP=Optimize GBASIS=%s",optFireFlyMethod);
		if(runFireFlyFiles(numberOfGeometries, geometries, energies, fileNamePrefix, keys,fireflyCommand))
		{
			char* fileNameGeomFireFly = strdup_printf("%sFireFly.gab",fileNamePrefix);
			sortGeometries(numberOfGeometries, geometries, energies);
			removeIdenticalGeometries(&numberOfGeometries, &geometries, &energies, tolEnergy, tolDistance);
			if(removeSimilarInertia) qmModel.klass->removeSimilarInertiaGeometries(geometries, &numberOfGeometries,energies,stdout,inertiaTol);
			if(removeSimilarBonds) qmModel.klass->removeSimilarBondsGeometries(geometries, &numberOfGeometries, energies,stdout,sTol, distMaxTol);
			if(removeFragmented) qmModel.klass->removeFragmentedMolecules(geometries, &numberOfGeometries, energies, stdout);
			if(removeSmallDistance) qmModel.klass->removeSmallDistanceMolecules(geometries, &numberOfGeometries, energies, stdout);
			if(nproc==1)
			{
				numberOfGeometriesAll = numberOfGeometries;
				geometriesAll = geometries;
				energiesAll = energies;
			}
			else
			{
//#ifdef DEBUG
				fprintf(logfile, "MolecularMechanicsDynamicsREMDConfoDlg Rank#=%d  nproc = %d\n", rank, nproc );
//#endif
				if(rank==0) 
					numberOfGeometriesAll = collectGeometriesFromProcessors(nproc, geometriesAll, numberOfGeometriesMax, energiesAll, geometries, numberOfGeometries, energies,  coords,  enerDum, &qmModel,tolEnergy,tolDistance);
				else sendGeometriesToMaster(rank, geometries, numberOfGeometries, energies,  coords, qmModel.molecule.nAtoms);
				fprintf(logfile, "End collect&send nGeoms = %d\n", numberOfGeometriesAll );
				fflush(logfile);
			}
			if(rank==0 && saveConfoGeometries(numberOfGeometriesAll, geometriesAll, energiesAll, fileNameGeom))
			{
				strcat(message,fileNameGeom);
				strcat(message,("\n\tGeometries after minimization by FireFly"));
				strcat(message,("\n\tTo read this file through Gabedit : 'Read/Gabedit file'\n\n"));
			}
			free(fileNameGeomFireFly);

		}
		if(fileNamePrefix) free(fileNamePrefix);
		if(keys)free(keys);
	}
	/* minimazation by generic*/
	if(optGeneric )
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		char* keys = strdup_printf(" Opt");
		runGenericFiles(numberOfGeometries, geometries, energies, fileNamePrefix, keys, optGenericMethod);
		{
			char* fileNameGeomGen = strdup_printf("%sGen.gab",fileNamePrefix);
			sortGeometries(numberOfGeometries, geometries, energies);
			removeIdenticalGeometries(&numberOfGeometries, &geometries, &energies, tolEnergy, tolDistance);
			if(removeSimilarInertia) qmModel.klass->removeSimilarInertiaGeometries(geometries, &numberOfGeometries,energies,stdout,inertiaTol);
			if(removeSimilarBonds) qmModel.klass->removeSimilarBondsGeometries(geometries, &numberOfGeometries, energies,stdout,sTol, distMaxTol);
			if(removeFragmented) qmModel.klass->removeFragmentedMolecules(geometries, &numberOfGeometries, energies, stdout);
			if(removeSmallDistance) qmModel.klass->removeSmallDistanceMolecules(geometries, &numberOfGeometries, energies, stdout);
			if(nproc==1)
			{
				numberOfGeometriesAll = numberOfGeometries;
				geometriesAll = geometries;
				energiesAll = energies;
			}
			else
			{
//#ifdef DEBUG
				fprintf(logfile, "MolecularMechanicsDynamicsREMDConfoDlg Rank#=%d  nproc = %d\n", rank, nproc );
//#endif
				if(rank==0) 
					numberOfGeometriesAll = collectGeometriesFromProcessors(nproc, geometriesAll, numberOfGeometriesMax, energiesAll, geometries, numberOfGeometries, energies,  coords,  enerDum, &qmModel,tolEnergy,tolDistance);
				else sendGeometriesToMaster(rank, geometries, numberOfGeometries, energies,  coords, qmModel.molecule.nAtoms);
				fprintf(logfile, "End collect&send nGeoms = %d\n", numberOfGeometriesAll );
				fflush(logfile);
			}
			if(rank==0 && saveConfoGeometries(numberOfGeometriesAll, geometriesAll, energiesAll, fileNameGeom))
			{
				strcat(message,fileNameGeom);
				strcat(message,("\n\tGeometries after minimization by Generic/"));
				strcat(message,optGenericMethod);
				strcat(message,("\n\tTo read this file through Gabedit : 'Read/CChemI file'\n\n"));
			}
			free(fileNameGeomGen);
		}
		if(fileNamePrefix) free(fileNamePrefix);
		if(keys)free(keys);
	}
	/* minimazation by OpenBabel*/
	if(optOpenBabel )
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		char* keys=strdup_printf("opt");
		if(runOpenBabelFiles(numberOfGeometries, geometries, energies, fileNamePrefix, keys,openBabelCommand))
		{
			char* fileNameGeomOpenBabel = strdup_printf("%sOpenBabel.gab",fileNamePrefix);
			sortGeometries(numberOfGeometries, geometries, energies);
			removeIdenticalGeometries(&numberOfGeometries, &geometries, &energies, tolEnergy, tolDistance);
			if(removeSimilarInertia) qmModel.klass->removeSimilarInertiaGeometries(geometries, &numberOfGeometries,energies,stdout,inertiaTol);
			if(removeSimilarBonds) qmModel.klass->removeSimilarBondsGeometries(geometries, &numberOfGeometries, energies,stdout,sTol, distMaxTol);
			if(removeFragmented) qmModel.klass->removeFragmentedMolecules(geometries, &numberOfGeometries, energies, stdout);
			if(removeSmallDistance) qmModel.klass->removeSmallDistanceMolecules(geometries, &numberOfGeometries, energies, stdout);
			if(saveConfoGeometries(numberOfGeometries, geometries, energies, fileNameGeom))
			{
				strcat(message,fileNameGeom);
				strcat(message,("\n\tGeometries after minimization by OpenBabel"));
				strcat(message,("\n\tTo read this file through Gabedit : 'Read/Gabedit file'\n\n"));
			}
			free(fileNameGeomOpenBabel);

		}
		if(fileNamePrefix) free(fileNamePrefix);
		if(keys)free(keys);
	}
	/* minimazation by Orca*/
	if(optOrca )
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		char* keys=strdup_printf("%s opt",optOrcaMethod);
		if(runOrcaFiles(numberOfGeometries, geometries, energies, fileNamePrefix, keys,orcaCommand))
		{
			char* fileNameGeomOrca = strdup_printf("%sOrca.gab",fileNamePrefix);
			sortGeometries(numberOfGeometries, geometries, energies);
			removeIdenticalGeometries(&numberOfGeometries, &geometries, &energies, tolEnergy, tolDistance);
			if(removeSimilarInertia) qmModel.klass->removeSimilarInertiaGeometries(geometries, &numberOfGeometries,energies,stdout,inertiaTol);
			if(removeSimilarBonds) qmModel.klass->removeSimilarBondsGeometries(geometries, &numberOfGeometries, energies,stdout,sTol, distMaxTol);
			if(removeFragmented) qmModel.klass->removeFragmentedMolecules(geometries, &numberOfGeometries, energies, stdout);
			if(removeSmallDistance) qmModel.klass->removeSmallDistanceMolecules(geometries, &numberOfGeometries, energies, stdout);
			if(saveConfoGeometries(numberOfGeometries, geometries, energies, fileNameGeom))
			{
				strcat(message,fileNameGeom);
				strcat(message,("\n\tGeometries after minimization by Orca"));
				strcat(message,("\n\tTo read this file through Gabedit : 'Read/Gabedit file'\n\n"));
			}
			free(fileNameGeomOrca);

		}
		if(fileNamePrefix) free(fileNamePrefix);
		if(keys)free(keys);
	}
	/* minimazation with N2P2  */
	//fprintf(stderr,"optN2P2=%d\n",optN2P2);
	if(optN2P2 )
	{
		fprintf(stderr,"optimisation using HDDN potentials\n");
		if(miminizeGeometriesUsingInternalOptimizer(numberOfGeometries, geometries, energies, inputFileName))
		{
			sortGeometries(numberOfGeometries, geometries, energies);
			saveEnergies(energies, numberOfGeometries, inputFileName);
			removeIdenticalGeometries(&numberOfGeometries, &geometries, &energies, tolEnergy, tolDistance);
			if(removeSimilarInertia) qmModel.klass->removeSimilarInertiaGeometries(geometries, &numberOfGeometries,energies,stdout,inertiaTol);
			if(removeSimilarBonds) qmModel.klass->removeSimilarBondsGeometries(geometries, &numberOfGeometries, energies,stdout,sTol, distMaxTol);
			if(removeFragmented) qmModel.klass->removeFragmentedMolecules(geometries, &numberOfGeometries, energies, stdout);
			if(removeSmallDistance) qmModel.klass->removeSmallDistanceMolecules(geometries, &numberOfGeometries, energies, stdout);
			if(saveConfoGeometries(numberOfGeometries, geometries, energies, fileNameGeom))
			{
				strcat(message,fileNameGeom);
				strcat(message,("\n\tGeometries after minimization by N2P2 potential"));
				strcat(message,("\n\tTo read this file through Gabedit : 'Read/Gabedit file'\n\n"));
			}

		}
	}
	/* minimazation with TM  */
	//fprintf(stderr,"optTM=%d\n",optTM);
	if(optTM )
	{
		fprintf(stderr,"optimisation using TM potential\n");
		if(miminizeGeometriesUsingInternalOptimizer(numberOfGeometries, geometries, energies, inputFileName))
		{
			sortGeometries(numberOfGeometries, geometries, energies);
			saveEnergies(energies, numberOfGeometries, inputFileName);
			removeIdenticalGeometries(&numberOfGeometries, &geometries, &energies, tolEnergy, tolDistance);
			if(removeSimilarInertia) qmModel.klass->removeSimilarInertiaGeometries(geometries, &numberOfGeometries,energies,stdout,inertiaTol);
			if(removeSimilarBonds) qmModel.klass->removeSimilarBondsGeometries(geometries, &numberOfGeometries, energies,stdout,sTol, distMaxTol);
			if(removeFragmented) qmModel.klass->removeFragmentedMolecules(geometries, &numberOfGeometries, energies, stdout);
			if(removeSmallDistance) qmModel.klass->removeSmallDistanceMolecules(geometries, &numberOfGeometries, energies, stdout);
			if(saveConfoGeometries(numberOfGeometries, geometries, energies, fileNameGeom))
			{
				strcat(message,fileNameGeom);
				strcat(message,("\n\tGeometries after minimization by TM potential"));
				strcat(message,("\n\tTo read this file through Gabedit : 'Read/Gabedit file'\n\n"));
			}

		}
	}
	if(!optMopac && !optFireFly && !optGaussian && !optGeneric && !optOpenBabel && !optN2P2 && !optTM)
	{
		/*  sort by energies */
		fprintf(logfile, "Begin sortGeom\n");
		fflush(logfile);
		sortGeometries(numberOfGeometries, geometries, energies);
		fprintf(logfile, "End sortGeom\n");
		fflush(logfile);
		removeIdenticalGeometries(&numberOfGeometries, &geometries, &energies, tolEnergy, tolDistance);
		if(removeSimilarInertia) qmModel.klass->removeSimilarInertiaGeometries(geometries, &numberOfGeometries,energies,stdout,inertiaTol);
		if(removeSimilarBonds) qmModel.klass->removeSimilarBondsGeometries(geometries, &numberOfGeometries, energies,stdout,sTol, distMaxTol);
		if(removeFragmented) qmModel.klass->removeFragmentedMolecules(geometries, &numberOfGeometries, energies, stdout);
		if(removeSmallDistance) qmModel.klass->removeSmallDistanceMolecules(geometries, &numberOfGeometries, energies, stdout);
		fprintf(logfile, "End removeId\n");
		fflush(logfile);
		/* printf("fileNameGeom = %s\n",fileNameGeom);*/
		if(nproc==1)
		{
			numberOfGeometriesAll = numberOfGeometries;
			geometriesAll = geometries;
			energiesAll = energies;
		}
		else
		{
//#ifdef DEBUG
			fprintf(logfile, "MolecularMechanicsDynamicsREMDConfoDlg Rank#=%d  nproc = %d\n", rank, nproc );
			fflush(logfile);
//#endif
			if(rank==0) 
				numberOfGeometriesAll = collectGeometriesFromProcessors(nproc, geometriesAll, numberOfGeometriesMax, energiesAll, geometries, numberOfGeometries, energies,  coords,  enerDum, &qmModel,tolEnergy,tolDistance);
			else sendGeometriesToMaster(rank, geometries, numberOfGeometries, energies,  coords, qmModel.molecule.nAtoms);
			fprintf(logfile, "End collect&send nGeoms = %d\n", numberOfGeometriesAll );
			fflush(logfile);
		}
		if(rank==0 && saveConfoGeometries(numberOfGeometriesAll, geometriesAll, energiesAll, fileNameGeom))
		{
			strcat(message,fileNameGeom);
			strcat(message,("\n\tGeometries selected and optimized using your Quantum Mechanics potentials"));
			strcat(message,("\n\tTo read this file through Gabedit : 'Read/Gabedit file'\n\n"));
		}
	}
	if(rank==0 && numberOfGeometriesAll>0 && geometriesAll )
	{
		createPostProcessingFiles(numberOfGeometriesAll, geometriesAll, energiesAll,fileNameGeom, mopacKeywordsPost, gaussianKeywordsPost, fireflyKeywordsPost, orcaKeywordsPost, cchemiKeywordsPost, message, mopacCommand, gaussianCommand, fireflyCommand, orcaCommand, cchemiCommand);
/*
		if(mopacKeywordsPost)
		{
			char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
			createMopacFiles(numberOfGeometriesAll, geometriesAll, energiesAll, fileNamePrefix, mopacKeywordsPost,mopacCommand);
			strcat(message,fileNamePrefix);
			strcat(message,("_*.mop\n\tFiles for a post processing by Mopac\n\n"));
			if(fileNamePrefix) free(fileNamePrefix);
		}
		if(gaussianKeywordsPost)
		{
			char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
			createGaussianFiles(numberOfGeometriesAll, geometriesAll, energiesAll, fileNamePrefix, gaussianKeywordsPost, gaussianCommand);
			strcat(message,fileNamePrefix);
			strcat(message,("_*.com\n\tFiles for a post processing by Gaussian\n\n"));
			if(fileNamePrefix) free(fileNamePrefix);
		}
		if(fireflyKeywordsPost)
		{
			char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
			createFireFlyFiles(numberOfGeometriesAll, geometriesAll, energiesAll, fileNamePrefix, fireflyKeywordsPost,fireflyCommand);
			strcat(message,fileNamePrefix);
			strcat(message,("FF_*.inp\n\tFiles for a post processing by FireFly\n\n"));
			if(fileNamePrefix) free(fileNamePrefix);
		}
*/
	}
	fprintf(logfile, "Begin freegeometriesAll\n" );
	fflush(logfile);
	if(geometriesAll && geometriesAll!=geometries)
	{
		for(i=0;i<numberOfGeometriesAll;i++)
			if(geometriesAll[i]) geometries[i]->klass->free(geometriesAll[i]);
		free(geometriesAll);
	}
	fprintf(logfile, "End freegeometriesAll\n" );
	fflush(logfile);
	if(energiesAll && energiesAll!= energies)
	{
		free(energiesAll);
	}
	fprintf(logfile, "End free energiesAll\n" );
	fflush(logfile);

	if(geometries)
	{
		for(i=0;i<numberOfGeometries;i++)
			if(geometries[i]) geometries[i]->klass->free(geometries[i]);
		free(geometries);
	}
	if(energies) free(energies);
	if(strlen(message)>20) printf("%s",message);
	if(fileNameGeom)free(fileNameGeom);
	qmModel.klass->free(&qmModel);
	fclose(file);

}
/*****************************************************************************/
static void quantumMechanicsMDConfo(char* inputFileName)
{
	QuantumMechanicsModel qmModel; 
	QuantumMechanicsMD molecularDynamics;
	int updateFrequency = 1;
	double heatTime;
	double equiTime;
	double runTime;
	double coolTime;
	double heatTemp; 
	double equiTemp; 
	double runTemp; 
	double coolTemp; 
	double stepSize;
	MDIntegratorType integrator = VERLET;
	char* fileNameGeom = NULL;
	char* fileNameTraj = NULL;
	char* fileNameProp = NULL;
	double friction=-1;
	double collide = 20;
	double qNH = 20;
	MDThermostatType thermostat = NONE;
	int numberOfGeometries = 2;
	QuantumMechanicsModel** geometries = NULL; 
	double* energies = NULL;
	boolean optMopac = FALSE;
	boolean optGaussian = FALSE;
	boolean optGeneric = FALSE;
	boolean optFireFly = FALSE;
	boolean optOrca = FALSE;
	boolean optOpenBabel = FALSE;
	boolean optN2P2 = FALSE;
	boolean optTM = FALSE;
	double tolEnergy = 0.01;
	double tolDistance = 0.01;
	double omegaMax = 4000;
	int Nf = 50;
	Constraints constraints = NOCONSTRAINTS;
	int i;
	char message[BSIZE]="Created files :\n";
	char* dirName = NULL;
	Molecule mol = *(readMolecule(inputFileName,TRUE));
	char* mopacCommand = strdup("mopac");
	char* gaussianCommand=strdup("g09"); 
	char* N2P2Dir=strdup(getenv("PWD"));
	char* tmModule=strdup_printf("%s/%s",getenv("PWD"),"CChemITMModule");
	char* fireflyCommand=strdup("firefly");
	char* cchemiCommand=strdup("cchemi");
	char* orcaCommand = strdup("orca");
	char* openBabelCommand = strdup("obgradient");
	char* genericCommand=strdup("runGeneric");
	FILE* file = fopen(inputFileName,"rb");
	char* mopacKeywordsPost = NULL;
	char* gaussianKeywordsPost = NULL;
	char* fireflyKeywordsPost = NULL;
	char* orcaKeywordsPost = NULL;
	char* cchemiKeywordsPost = NULL;
	char* optMopacMethod=strdup("PM6");
	char* optGaussianMethod=strdup("AM1");
	char* optFireFlyMethod=strdup("AM1");
	char* optOrcaMethod=strdup("AM1");
	char* optGenericMethod=strdup("runGeneric");
	char* model = NULL;
	char* QMKeys = NULL;
	FILE* logfile = stdout;
	int cnt;
	char* optimizerType = NULL;
	boolean removeSimilarInertia = FALSE;
	boolean removeFragmented = FALSE;
	boolean removeSmallDistance = FALSE;
	double inertiaTol = 0.04; // recomended byjun Zhao et al (2016)
       	//Comprehensive genetic algorithm for ab initio global optimisation of clusters, Molecular Simulation,
	// 42:10, 809-819, DOI: 10.1080/08927022.2015.1121386	     

	boolean removeSimilarBonds = FALSE;
	double sTol=0.02;
	double distMaxTol=0.7;
	// sTol = 0.02 , distMaxTol = 0.7 Ang, recommanded in Jorgensen et al JCTC, 2017
//Mathias S. Jrgensen , Michael N. Groves, and Bjrk Hammer
//J. Chem. Theory Comput., 2017, 13 (3), pp 14861493
//DOI: 10.1021/acs.jctc.6b01119


	printf("MDConfo begin\n");
	setMDOptions(file, &updateFrequency, 
		&heatTime, &equiTime, &runTime, &coolTime,
		&heatTemp, &runTemp, &equiTemp, &coolTemp, &stepSize, 
		&integrator, &thermostat, &friction, &omegaMax, &Nf, &collide,&qNH);
	if(readOneBoolean(file,"removeSimilarInertia",&removeSimilarInertia) && removeSimilarInertia) readOneReal(file,"InertiaTol",&inertiaTol);
	readOneBoolean(file,"removeFragmented",&removeFragmented);
	readOneBoolean(file,"removeDissociated",&removeFragmented);
	readOneBoolean(file,"removeSmallDistance",&removeSmallDistance);
	if(readOneBoolean(file,"removeSimilarBonds",&removeSimilarBonds) && removeSimilarBonds)
	{
		readOneReal(file,"sTol",&sTol);
		readOneReal(file,"distMaxTol",&distMaxTol);
	}

	readOneString(file,"mopacCommand",&mopacCommand);
	readOneString(file,"gaussianCommand",&gaussianCommand);
	readOneString(file,"genericCommand",&genericCommand);
	readOneString(file,"orcaCommand",&orcaCommand);
	readOneString(file,"openBabelCommand",&openBabelCommand);
	readOneString(file,"HDNNDir",&N2P2Dir);
	readOneString(file,"N2P2Dir",&N2P2Dir);
	readOneString(file,"tmModule",&tmModule);
	readOneString(file,"fireflyCommand",&fireflyCommand);
	readOneString(file,"cchemiCommand",&cchemiCommand);
	readOneReal(file,"tolEnergy",&tolEnergy);
	readOneReal(file,"tolDistance",&tolDistance);
	readOneBoolean(file,"ConfoOptMopac",&optMopac);
	readOneString(file,"ConfoOptMopacMethod",&optMopacMethod);
	readOneBoolean(file,"ConfoOptGaussian",&optGaussian);
	readOneString(file,"ConfoOptGaussianMethod",&optGaussianMethod);
	readOneBoolean(file,"ConfoOptFireFly",&optFireFly);
	readOneString(file,"ConfoOptFireFlyMethod",&optFireFlyMethod);
	readOneBoolean(file,"ConfoOptOrca",&optOrca);
	readOneString(file,"ConfoOptOrcaMethod",&optOrcaMethod);
	readOneBoolean(file,"ConfoOptOpenBabel",&optOpenBabel);
	readOneBoolean(file,"ConfoOptGeneric",&optGeneric);
	readOneString(file,"ConfoOptGenericMethod",&optGenericMethod);
	readOneBoolean(file,"ConfoOptN2P2",&optN2P2);
	readOneBoolean(file,"ConfoOptTM",&optTM);

	if(readOneInt(file,"Constraints",&cnt)) constraints = cnt;

	readOneString(file,"mopacKeywordsPost",&mopacKeywordsPost);
	readOneString(file,"gaussianKeywordsPost",&gaussianKeywordsPost);
	readOneString(file,"fireflyKeywordsPost",&fireflyKeywordsPost);
	readOneString(file,"orcaKeywordsPost",&orcaKeywordsPost);
	readOneString(file,"cchemiKeywordsPost",&cchemiKeywordsPost);
	readOneString(file,"OptimizerType",&optimizerType);
	if(!optimizerType) optimizerType = strdup("External");
	if(!strstr(optimizerType,"External") && (optMopac||optFireFly))
	{
		printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		printf("Sorry, The optimization using the internal optimizer after a MD conformational search is not yes implemented in this software\n");
		printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		exit(1);
	}
	/* number for geometries */
	{
		numberOfGeometries = 10;
		readOneInt(file,"numberOfGeometries",&numberOfGeometries);
		if(numberOfGeometries<2) numberOfGeometries = 2;
	}
	if(!readOneString(file,"Model",&model)) model = strdup("MOPAC");
	uppercase(model);
	if(!readOneString(file,"QMKeys",&QMKeys)) 
	{
		if(!strcmp(model,"MOPAC")) QMKeys = strdup("PM6-DH+");
		else if(!strcmp(model,"ORCA")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"GAUSSIAN")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"FIREFLY")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"OPENBABEL")) QMKeys = strdup("mmff94");
		else QMKeys = strdup("SCC-DFTB");
	}
	if(!strcmp(model,"OPENBABEL")) mol.klass->buildMMTypes(&mol, file);

	/* fileName for geometries */
	{
		char* suff = getSuffixNameFile(inputFileName);
		dirName = strdup(getenv("PWD"));
		fileNameGeom = strdup_printf("%s%s",suff, "Geoms.gab");
		fileNameTraj = strdup_printf("%s%s",suff, "Traj.gab");
		fileNameProp = strdup_printf("%s%s",suff, "Prop.txt");
		free(suff);
	}


	printf("Model = %s\n",model);
	printf("QMKeys = %s\n",QMKeys);
	if(!strcmp(model,"MOPAC")) qmModel = createMopacModel(&mol, QMKeys, dirName, mopacCommand, constraints, stdout);
	else  if(!strcmp(model,"FIREFLY")) qmModel = createFireFlyModel(&mol, QMKeys, dirName, fireflyCommand, constraints, stdout);
	else if(!strcmp(model,"ORCA")) qmModel = createOrcaModel(&mol, QMKeys, dirName, orcaCommand, constraints, stdout);
	else if(!strcmp(model,"OPENBABEL")) qmModel = createOpenBabelModel(&mol, QMKeys, dirName, openBabelCommand, constraints, stdout);
	else if(!strcmp(model,"GAUSSIAN")) qmModel = createGaussianModel(&mol, QMKeys, dirName, gaussianCommand, constraints, stdout);
	else if(!strcmp(model,"N2P2") || !strcmp(model,"HDNN")) qmModel = createN2P2Model(&mol, N2P2Dir, constraints, stdout);
	else if(!strcmp(model,"TM") || !strcmp(model,"TensorModel")) qmModel = createTMModel(&mol, tmModule, constraints, logfile);
	else qmModel = createGenericModel(&mol, QMKeys, dirName, genericCommand, constraints, stdout);
	setH4Correction(file,&qmModel);
	setSRBCorrection(file,&qmModel);
	readOneBoolean(file,"addD3Correction",&qmModel.addD3Correction);
	checkWallCorrection(file, &qmModel);

	geometries = runQuantumMechanicsMDConfo(&molecularDynamics, &qmModel,
		updateFrequency, heatTime, equiTime, runTime, heatTemp, equiTemp, runTemp, stepSize, 
		integrator, thermostat, friction, omegaMax, Nf, collide, qNH, numberOfGeometries, fileNameTraj, fileNameProp);
	if(geometries && numberOfGeometries>0)
	{
		int i;
		energies = malloc(numberOfGeometries*sizeof(double));
		for(i=0;i<numberOfGeometries;i++)
			energies[i] = geometries[i]->molecule.potentialEnergy;
	}
	optAndSortGeometries(&qmModel, inputFileName, &geometries, &numberOfGeometries, mopacCommand, gaussianCommand, N2P2Dir, tmModule, fireflyCommand, cchemiCommand,
	orcaCommand, openBabelCommand, genericCommand, optMopacMethod, optGaussianMethod, optFireFlyMethod, optOrcaMethod, optGenericMethod, &energies,
	optMopac, optGaussian, optGeneric, optFireFly, optOrca, optOpenBabel, optN2P2, optTM, tolEnergy, tolDistance, fileNameGeom, removeSimilarInertia,
	removeFragmented, removeSmallDistance, removeSimilarBonds, inertiaTol, sTol, distMaxTol, logfile, message);

	if(numberOfGeometries>0 && geometries )
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		createPostProcessingFiles(numberOfGeometries, geometries, energies,fileNamePrefix, mopacKeywordsPost, gaussianKeywordsPost, fireflyKeywordsPost, orcaKeywordsPost, cchemiKeywordsPost, message, mopacCommand, gaussianCommand, fireflyCommand, orcaCommand, cchemiCommand);
		if(fileNamePrefix) free(fileNamePrefix);
/*
		if(mopacKeywordsPost)
		{
			char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
			createMopacFiles(numberOfGeometries, geometries, energies, fileNamePrefix, mopacKeywordsPost,mopacCommand);
			strcat(message,fileNamePrefix);
			strcat(message,("_*.mop\n\tFiles for a post processing by Mopac\n\n"));
			if(fileNamePrefix) free(fileNamePrefix);
		}
		if(gaussianKeywordsPost)
		{
			char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
			createGaussianFiles(numberOfGeometries, geometries, energies, fileNamePrefix, gaussianKeywordsPost, gaussianCommand);
			strcat(message,fileNamePrefix);
			strcat(message,("_*.com\n\tFiles for a post processing by Gaussian\n\n"));
			if(fileNamePrefix) free(fileNamePrefix);
		}
		if(fireflyKeywordsPost)
		{
			char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
			createFireFlyFiles(numberOfGeometries, geometries, energies, fileNamePrefix, fireflyKeywordsPost,fireflyCommand);
			strcat(message,fileNamePrefix);
			strcat(message,("FF_*.inp\n\tFiles for a post processing by FireFly\n\n"));
			if(fileNamePrefix) free(fileNamePrefix);
		}
*/
	}
	if(geometries)
	{
		for(i=0;i<numberOfGeometries;i++)
			if(geometries[i]) geometries[i]->klass->free(geometries[i]);
		free(geometries);
	}
	if(energies) free(energies);
	if(strlen(message)>20) printf("%s",message);
	if(fileNameGeom)free(fileNameGeom);
	fclose(file);
	qmModel.klass->free(&qmModel);

}
/*****************************************************************************/
static void quantumMechanicsMD(char* inputFileName)
{
	QuantumMechanicsModel qmModel; 
	QuantumMechanicsMD molecularDynamics;
	int updateFrequency = 1;
	double heatTime;
	double equiTime;
	double runTime;
	double coolTime; 
	double heatTemp; 
	double equiTemp; 
	double runTemp; 
	double coolTemp; 
	double stepSize;
	MDIntegratorType integrator = VERLET;
	char* fileNameTraj = NULL;
	char* fileNameProp = NULL;
	double friction=-1;
	double omegaMax = 4000;
	int Nf = 50;
	double collide = 20;
	double qNH = 20;
	MDThermostatType thermostat = NONE;
	char* dirName = NULL;
	Constraints constraints = NOCONSTRAINTS;
	Molecule mol = *(readMolecule(inputFileName,TRUE));
	char* mopacCommand = strdup("/opt/mopac/MOPAC2012");
	char* fireflyCommand = strdup("firefly");
	char* orcaCommand = strdup("orca");
	char* N2P2Dir=strdup(getenv("PWD"));
	char* tmModule=strdup_printf("%s/%s",getenv("PWD"),"CChemITMModule");
	char* openBabelCommand = strdup("obgradient");
	char* gaussianCommand = strdup("g09");
	char* genericCommand = strdup("runGeneric");
	FILE* file = fopen(inputFileName,"rb");
	char* model = NULL;
	char* QMKeys = NULL;
	int cnt;
	FILE* logfile = stdout;

	setMDOptions(file, &updateFrequency, 
		&heatTime, &equiTime, &runTime, &coolTime,
		&heatTemp, &runTemp, &equiTemp, &coolTemp, &stepSize, 
		&integrator, &thermostat, &friction, &omegaMax, &Nf, &collide,&qNH);
	if(!readOneString(file,"Model",&model)) model = strdup("MOPAC");
	uppercase(model);
	if(!readOneString(file,"QMKeys",&QMKeys)) 
	{
		if(!strcmp(model,"MOPAC")) QMKeys = strdup("PM6-DH+");
		else if(!strcmp(model,"ORCA")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"GAUSSIAN")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"FIREFLY")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"OPENBABEL")) QMKeys = strdup("mmff94");
		else QMKeys = strdup("SCC-DFTB");
	}
	if(!strcmp(model,"OPENBABEL")) mol.klass->buildMMTypes(&mol, file);

	readOneString(file,"mopacCommand",&mopacCommand);
	readOneString(file,"fireflyCommand",&fireflyCommand);
	readOneString(file,"orcaCommand",&orcaCommand);
	readOneString(file,"openBabelCommand",&openBabelCommand);
	readOneString(file,"HDNNDir",&N2P2Dir);
	readOneString(file,"N2P2Dir",&N2P2Dir);
	readOneString(file,"tmModule",&tmModule);
	readOneString(file,"gaussianCommand",&gaussianCommand);
	readOneString(file,"genericCommand",&genericCommand);

	if(readOneInt(file,"Constraints",&cnt)) constraints = cnt;


	{
		char* suff = getSuffixNameFile(inputFileName);
		dirName = strdup(getenv("PWD"));
		fileNameTraj = strdup_printf("%s%s",suff, "Traj.gab");
		fileNameProp = strdup_printf("%s%s",suff, "Prop.txt");
		free(suff);
	}

	if(!strcmp(model,"MOPAC")) qmModel = createMopacModel(&mol, QMKeys, dirName, mopacCommand, constraints,logfile);
	else if(!strcmp(model,"FIREFLY")) qmModel = createFireFlyModel(&mol, QMKeys,dirName, fireflyCommand, constraints,logfile);
	else if(!strcmp(model,"ORCA")) qmModel = createOrcaModel(&mol, QMKeys, dirName, orcaCommand, constraints, logfile);
	else if(!strcmp(model,"OPENBABEL")) qmModel = createOpenBabelModel(&mol, QMKeys, dirName, openBabelCommand, constraints, logfile);
	else if(!strcmp(model,"GAUSSIAN")) qmModel = createGaussianModel(&mol, QMKeys,dirName, gaussianCommand, constraints,logfile);
	else if(!strcmp(model,"N2P2") || !strcmp(model,"HDNN")) qmModel = createN2P2Model(&mol, N2P2Dir, constraints, logfile);
	else if(!strcmp(model,"TM") || !strcmp(model,"TensorModel")) qmModel = createTMModel(&mol, tmModule, constraints, logfile);
	else qmModel = createGenericModel(&mol, QMKeys,dirName, genericCommand, constraints,logfile);
	setSRBCorrection(file,&qmModel);
	readOneBoolean(file,"addD3Correction",&qmModel.addD3Correction);
	checkWallCorrection(file, &qmModel);

	runQuantumMechanicsMD(&molecularDynamics, &qmModel,
		updateFrequency, heatTime, equiTime, runTime, coolTime, heatTemp, equiTemp, runTemp, coolTemp, stepSize, 
		integrator, thermostat, friction, omegaMax, Nf, collide, qNH, fileNameTraj, fileNameProp);

	qmModel.klass->free(&qmModel);
	free(dirName);
	fclose(file);
}
/***********************************************************************************************************************/
static void quantumMechanicsRDConfo(char* inputFileName)
{
	QuantumMechanicsModel qmModel; 
	QuantumMechanicsModel** geometries = NULL;
	int i;
	char message[BSIZE]="Created files :\n";
	char* dirName = NULL;
	Molecule mol = *(readMolecule(inputFileName,TRUE));
	char* mopacCommand = strdup("mopac");
	char* gaussianCommand=strdup("g09"); 
	char* N2P2Dir=strdup(getenv("PWD"));
	char* tmModule=strdup_printf("%s/%s",getenv("PWD"),"CChemITMModule");
	char* fireflyCommand=strdup("firefly");
	char* cchemiCommand=strdup("cchemi");
	char* orcaCommand = strdup("orca");
	char* openBabelCommand = strdup("obgradient");
	char* genericCommand=strdup("runGeneric");
	FILE* file = fopen(inputFileName,"rb");
	char* mopacKeywordsPost = NULL;
	char* gaussianKeywordsPost = NULL;
	char* fireflyKeywordsPost = NULL;
	char* orcaKeywordsPost = NULL;
	char* cchemiKeywordsPost = NULL;
	char* optMopacMethod=strdup("PM6");
	char* optGaussianMethod=strdup("AM1");
	char* optFireFlyMethod=strdup("AM1");
	char* optOrcaMethod=strdup("AM1");
	char* optGenericMethod=strdup("runGeneric");
	char* model = NULL;
	char* QMKeys = NULL;
	int cnt;
	char* optimizerType = NULL;

	double* energies = NULL;
	boolean optMopac = FALSE;
	boolean optGaussian = FALSE;
	boolean optGeneric = FALSE;
	boolean optFireFly = FALSE;
	boolean optOrca = FALSE;
	boolean optOpenBabel = FALSE;
	boolean optN2P2 = FALSE;
	boolean optTM = FALSE;
	double tolEnergy = 0.01;
	double tolDistance = 0.01;
	int numberOfGeometries = 2;
	char* fileNameGeom = NULL;
	Constraints constraints = NOCONSTRAINTS;
	boolean chain=FALSE;
	boolean fragments=FALSE;
	boolean saveFirstGeom=FALSE;
	boolean removeSimilarInertia = FALSE;
	boolean removeFragmented = FALSE;
	boolean removeSmallDistance = FALSE;
	FILE* logfile = stdout;
	int nTimesGeoms=1;
	double inertiaTol = 0.04; // recomended byjun Zhao et al (2016)
       	//Comprehensive genetic algorithm for ab initio global optimisation of clusters, Molecular Simulation,
	// 42:10, 809-819, DOI: 10.1080/08927022.2015.1121386	     

	boolean removeSimilarBonds = FALSE;
	double sTol=0.02;
	double distMaxTol=0.7;
	// sTol = 0.02 , distMaxTol = 0.7 Ang, recommanded in Jorgensen et al JCTC, 2017
//Mathias S. Jrgensen , Michael N. Groves, and Bjrk Hammer
//J. Chem. Theory Comput., 2017, 13 (3), pp 14861493
//DOI: 10.1021/acs.jctc.6b01119

	readOneString(file,"mopacCommand",&mopacCommand);
	readOneString(file,"gaussianCommand",&gaussianCommand);
	readOneString(file,"genericCommand",&genericCommand);
	readOneString(file,"orcaCommand",&orcaCommand);
	readOneString(file,"openBabelCommand",&openBabelCommand);
	readOneString(file,"HDNNDir",&N2P2Dir);
	readOneString(file,"N2P2Dir",&N2P2Dir);
	readOneString(file,"tmModule",&tmModule);
	readOneString(file,"fireflyCommand",&fireflyCommand);
	readOneString(file,"cchemiCommand",&cchemiCommand);
	readOneReal(file,"tolEnergy",&tolEnergy);
	readOneReal(file,"tolDistance",&tolDistance);
	readOneBoolean(file,"ConfoOptMopac",&optMopac);
	readOneString(file,"ConfoOptMopacMethod",&optMopacMethod);
	readOneBoolean(file,"ConfoOptGaussian",&optGaussian);
	readOneString(file,"ConfoOptGaussianMethod",&optGaussianMethod);
	readOneBoolean(file,"ConfoOptFireFly",&optFireFly);
	readOneString(file,"ConfoOptFireFlyMethod",&optFireFlyMethod);
	readOneBoolean(file,"ConfoOptOrca",&optOrca);
	readOneString(file,"ConfoOptOrcaMethod",&optOrcaMethod);
	readOneBoolean(file,"ConfoOptOpenBabel",&optOpenBabel);
	readOneBoolean(file,"ConfoOptGeneric",&optGeneric);
	readOneString(file,"ConfoOptGenericMethod",&optGenericMethod);
	readOneBoolean(file,"ConfoOptN2P2",&optN2P2);
	readOneBoolean(file,"ConfoOptTM",&optTM);
	readOneBoolean(file,"RDChain",&chain);
	readOneBoolean(file,"RDFragments",&fragments);
	readOneBoolean(file,"RDSaveFirstGeom",&saveFirstGeom);
	readOneInt(file,"nTimesGeoms",&nTimesGeoms);

	if(readOneInt(file,"Constraints",&cnt)) constraints = cnt;

	readOneString(file,"mopacKeywordsPost",&mopacKeywordsPost);
	readOneString(file,"gaussianKeywordsPost",&gaussianKeywordsPost);
	readOneString(file,"fireflyKeywordsPost",&fireflyKeywordsPost);
	readOneString(file,"orcaKeywordsPost",&orcaKeywordsPost);
	readOneString(file,"cchemiKeywordsPost",&cchemiKeywordsPost);
	readOneString(file,"OptimizerType",&optimizerType);
	if(!optimizerType) optimizerType = strdup("External");
	if(!strstr(optimizerType,"External") && (optMopac||optFireFly))
	{
		printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		printf("Sorry, The optimization using the internal optimizer with a RD conformational search is not yes implemented in this software\n");
		printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		exit(1);
	}
	/* number for geometries */
	{
		numberOfGeometries = 10;
		readOneInt(file,"numberOfGeometries",&numberOfGeometries);
		if(numberOfGeometries<2) numberOfGeometries = 2;
	}
	if(!readOneString(file,"Model",&model)) model = strdup("MOPAC");
	uppercase(model);
	if(!readOneString(file,"QMKeys",&QMKeys)) 
	{
		if(!strcmp(model,"MOPAC")) QMKeys = strdup("PM6-DH+");
		else if(!strcmp(model,"ORCA")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"GAUSSIAN")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"FIREFLY")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"OPENBABEL")) QMKeys = strdup("mmff94");
		else QMKeys = strdup("SCC-DFTB");
	}
	if(!strcmp(model,"OPENBABEL")) mol.klass->buildMMTypes(&mol, file);

	/* fileName for geometries */
	{
		char* suff = getSuffixNameFile(inputFileName);
		dirName = strdup(getenv("PWD"));
		fileNameGeom = strdup_printf("%s%s",suff, "Geoms.gab");
		free(suff);
	}
	if(readOneBoolean(file,"removeSimilarInertia",&removeSimilarInertia) && removeSimilarInertia) readOneReal(file,"InertiaTol",&inertiaTol);
	readOneBoolean(file,"removeFragmented",&removeFragmented);
	readOneBoolean(file,"removeDissociated",&removeFragmented);
	readOneBoolean(file,"removeSmallDistance",&removeSmallDistance);
	if(readOneBoolean(file,"removeSimilarBonds",&removeSimilarBonds) && removeSimilarBonds)
	{
		readOneReal(file,"sTol",&sTol);
		readOneReal(file,"distMaxTol",&distMaxTol);
	}


	printf("Model = %s\n",model);
	printf("QMKeys = %s\n",QMKeys);
	if(!strcmp(model,"MOPAC")) qmModel = createMopacModel(&mol, QMKeys, dirName, mopacCommand, constraints, logfile);
	else  if(!strcmp(model,"FIREFLY")) qmModel = createFireFlyModel(&mol, QMKeys, dirName, fireflyCommand, constraints, logfile);
	else if(!strcmp(model,"ORCA")) qmModel = createOrcaModel(&mol, QMKeys, dirName, orcaCommand, constraints, logfile);
	else if(!strcmp(model,"OPENBABEL")) qmModel = createOpenBabelModel(&mol, QMKeys, dirName, openBabelCommand, constraints, logfile);
	else if(!strcmp(model,"GAUSSIAN")) qmModel = createGaussianModel(&mol, QMKeys, dirName, gaussianCommand, constraints, logfile);
	else if(!strcmp(model,"N2P2") || !strcmp(model,"HDNN")) qmModel = createN2P2Model(&mol, N2P2Dir, constraints, logfile);
	else if(!strcmp(model,"TM") || !strcmp(model,"TensorModel")) qmModel = createTMModel(&mol, tmModule, constraints, logfile);
	else qmModel = createGenericModel(&mol, QMKeys, dirName, genericCommand, constraints, logfile);

	setH4Correction(file,&qmModel);
	setSRBCorrection(file,&qmModel);
	readOneBoolean(file,"addD3Correction",&qmModel.addD3Correction);
	checkWallCorrection(file, &qmModel);


	int nOld = numberOfGeometries*nTimesGeoms;
	if(nTimesGeoms>1) numberOfGeometries = nOld;
	if(fragments)
	geometries = qmModel.klass->getQuantumMechanicsRDFConfo(&qmModel, numberOfGeometries, saveFirstGeom);
	else
	geometries = qmModel.klass->getQuantumMechanicsRDConfo(&qmModel, numberOfGeometries, chain, saveFirstGeom);


	if(removeSimilarInertia) qmModel.klass->removeSimilarInertiaGeometries(geometries, &numberOfGeometries, energies,logfile,inertiaTol);
	if(removeFragmented) qmModel.klass->removeFragmentedMolecules(geometries, &numberOfGeometries, energies, logfile);
	if(removeSmallDistance) qmModel.klass->removeSmallDistanceMolecules(geometries, &numberOfGeometries, energies, logfile);
	if(removeSimilarBonds) qmModel.klass->removeSimilarBondsGeometries(geometries, &numberOfGeometries, energies,logfile,sTol, distMaxTol);

	if(nTimesGeoms>1) qmModel.klass->cutByInertia(geometries, &numberOfGeometries, energies,nOld/nTimesGeoms,logfile);

	if(geometries && numberOfGeometries>0)
	{
		int i;
		energies = malloc(numberOfGeometries*sizeof(double));
		for(i=0;i<numberOfGeometries;i++)
			energies[i] = geometries[i]->molecule.potentialEnergy;
	}

	optAndSortGeometries(&qmModel, inputFileName, &geometries, &numberOfGeometries, mopacCommand, gaussianCommand, N2P2Dir, tmModule, fireflyCommand, cchemiCommand,
	orcaCommand, openBabelCommand, genericCommand, optMopacMethod, optGaussianMethod, optFireFlyMethod, optOrcaMethod, optGenericMethod, &energies,
	optMopac, optGaussian, optGeneric, optFireFly, optOrca, optOpenBabel, optN2P2, optTM, tolEnergy, tolDistance, fileNameGeom, removeSimilarInertia,
	removeFragmented, removeSmallDistance, removeSimilarBonds, inertiaTol, sTol, distMaxTol, logfile, message);

	if(numberOfGeometries>0 && geometries )
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		createPostProcessingFiles(numberOfGeometries, geometries, energies,fileNamePrefix, mopacKeywordsPost, gaussianKeywordsPost, fireflyKeywordsPost, orcaKeywordsPost, cchemiKeywordsPost, message, mopacCommand, gaussianCommand, fireflyCommand, orcaCommand, cchemiCommand);
		if(fileNamePrefix) free(fileNamePrefix);
	}
	if(geometries)
	{
		for(i=0;i<numberOfGeometries;i++)
			if(geometries[i]) geometries[i]->klass->free(geometries[i]);
		free(geometries);
	}
	qmModel.klass->free(&qmModel);
	if(energies) free(energies);
	if(strlen(message)>20) printf("%s",message);
	if(fileNameGeom)free(fileNameGeom);
	fclose(file);

}
/***********************************************************************************************************************/
static void quantumMechanicsGAConfo(char* inputFileName)
{
	GeneticAlgorithm* ga; 
	ga = newGeneticAlgorithm(inputFileName);
	if(ga) ga->klass->run(ga);
}
/********************************************************************************/
void quantumMechanicsMolecularDynamicsDlg(char* inputFileName)
{
	quantumMechanicsMD(inputFileName);
}
/***********************************************************************/
void quantumMechanicsMolecularDynamicsConfoDlg(char* inputFileName)
{
	quantumMechanicsMDConfo(inputFileName);
}
/***********************************************************************/
void quantumMechanicsREMDConfoDlg(char* inputFileName)
{
	quantumMechanicsREMDConfo(inputFileName);
}
/***********************************************************************/
void quantumMechanicsRandomConfoDlg(char* inputFileName)
{
	quantumMechanicsRDConfo(inputFileName);
}
/***********************************************************************/
void quantumMechanicsGAConfoDlg(char* inputFileName)
{
	quantumMechanicsGAConfo(inputFileName);
}
/***********************************************************************/
void quantumMechanicsRemoveSimilarConfoDlg(char* inputFileName)
{
	quantumMechanicsRemoveSimilarConfo(inputFileName);
}
/*****************************************************************************/
static char*  setOptOptions(FILE* file, ConjugateGradientQMOptions* conjugateGradientQMOptions, QuasiNewtonQM* quasiNewtonQM)
{
	char* optimizerType = strdup("External");
	readOneString(file,"OptimizerType",&optimizerType);
	if(strstr(optimizerType,"Gradient")) setCGQMOptions(file, conjugateGradientQMOptions);
	else if(strstr(optimizerType,"Quasi")) setQNQMOptions(file, quasiNewtonQM);
	else if(strstr(optimizerType,"Steep")) setCGQMOptions(file, conjugateGradientQMOptions);
	return optimizerType;
}
/*****************************************************************************/
void quantumMechanicsMinimizeExternalDlg(char* inputFileName)
{
	Molecule mol = *(readMolecule(inputFileName, TRUE));
	char* mopacCommand = strdup("/opt/mopac/MOPAC2012");
	char* fireflyCommand = strdup("firefly");
	char* orcaCommand = strdup("orca");
	char* openBabelCommand = strdup("obgradient");
	char* gaussianCommand = strdup("g09");
	char* genericCommand = strdup("runGeneric");
	char* N2P2Dir=strdup(getenv("PWD"));
	FILE* file = NULL;
	char* runType = NULL;
	char* model = NULL;
	char* QMKeys = NULL;
	char* fileName = strdup_printf("%sOpt.gab",getSuffixNameFile(inputFileName));
	if(!inputFileName)
	{
		printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		printf("Usage : cchemi inputFileName.inp\n");
		printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		exit(1);
	}
	file = fopen(inputFileName, "r");
	if(!file)
	{
		printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		printf("Sorry, I cannot open the input file : %s\n",inputFileName);
		printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		exit(1);
	}
	if(!readOneString(file,"RunType",&runType)) runType = strdup("ENERGY");
	if(!readOneString(file,"Model",&model)) model = strdup("MOPAC");
	uppercase(model);
	if(!readOneString(file,"QMKeys",&QMKeys)) 
	{
		if(!strcmp(model,"MOPAC")) QMKeys = strdup("PM6-DH+");
		else if(!strcmp(model,"ORCA")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"GAUSSIAN")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"FIREFLY")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"OPENBABEL")) QMKeys = strdup("mmff94");
		else QMKeys = strdup("SCC-DFTB");
	}
	if(!strcmp(model,"OPENBABEL")) mol.klass->buildMMTypes(&mol, file);
	uppercase(runType);
	readOneString(file,"mopacCommand",&mopacCommand);
	readOneString(file,"orcaCommand",&orcaCommand);
	readOneString(file,"openBabelCommand",&openBabelCommand);
	readOneString(file,"HDNNDir",&N2P2Dir);
	readOneString(file,"N2P2Dir",&N2P2Dir);
	readOneString(file,"fireflyCommand",&fireflyCommand);
	readOneString(file,"gaussianCommand",&gaussianCommand);
	readOneString(file,"genericCommand",&genericCommand);
	if(!strcmp(model,"FIREFLY")) QMKeys = strdup("GBASIS=AM1");
	printf("QMKeys = %s\n",QMKeys);
	printf("Model = %s\n",model);
	if(!strcmp(model,"MOPAC"))
	{
		char* keys = strdup_printf("XYZ %s",QMKeys);
		printf("keys = %s\n",keys);
		printf("mopacCommand = %s\n",mopacCommand);
		runMopac(&mol, fileName, keys, mopacCommand);
		free(keys);
	}
	else if(!strcmp(model,"ORCA"))
	{
		char* keys = strdup_printf("%s Opt",QMKeys);
		runOrca(&mol, fileName, keys, orcaCommand);
		free(keys);
	}
	else if(!strcmp(model,"FIREFLY"))
	{
		char* keys = strdup_printf("RUNTYP=Optimize %s",QMKeys);
		printf("keys=%s\n",QMKeys);
		runFireFly(&mol, fileName, keys, fireflyCommand);
		free(keys);
	}
	else if(!strcmp(model,"GAUSSIAN"))
	{
		char* keys = strdup_printf("%s Opt",QMKeys);
		printf("keys=%s\n",QMKeys);
		runGaussian(&mol, fileName, keys, gaussianCommand);
		free(keys);
	}
	else if(!strcmp(model,"GENERIC"))
	{
		char* keys = strdup_printf("%s Opt",QMKeys);
		runGeneric(&mol, fileName, keys, genericCommand);
		free(keys);
	}
	else if(!strcmp(model,"OPENBABEL"))
	{
		char* keys = strdup_printf("%s Opt",QMKeys);
		runOpenBabel(&mol, fileName, keys, openBabelCommand);
		free(keys);
	}
	else if(!strcmp(model,"N2P2") || !strcmp(model,"HDNN"))
	{
		fprintf(stderr,"Optimization by a external minimizer for N2P2 not yet implemented\n");
	}
	else if(!strcmp(model,"TM") || !strcmp(model,"TensorMol"))
	{
		char* tmModule=strdup_printf("%s","CChemITMModule");
		int err = 0;
		readOneString(file,"tmModule",&tmModule);
		readOneString(file,"TensorMolModule",&tmModule);
		if(tmModule) err = runOptTensorMol(&mol, tmModule);
		if(err)
		{
			fprintf(stderr," You must compile cchemi with enable_python = 1 in CONFIG file\n");
		}
		else{
			char* fileNameOut = strdup_printf("%sOpt.gab",getSuffixNameFile(inputFileName));
			printf("Optimized geometry saved in %s file\n",fileNameOut);
			mol.klass->save(&mol,fileNameOut);
			free(fileNameOut);
		}
	}
	fclose(file);
	if(fileName) free(fileName);
}
/*****************************************************************************/
static boolean minimizeGeometry(QuantumMechanicsModel* qmModel, 
	char* optimizerType, SteepestDescentQM steepestDescentQM, 
	QuasiNewtonQM quasiNewtonQM, ConjugateGradientQM conjugateGradientQM,
	ConjugateGradientQMOptions conjugateGradientQMOptions
	)
{
	if(strstr(optimizerType,"Grad"))
	{
		//printf("Minimization by Conjugate Gradient method\n");
		conjugateGradientQM.logfile= stdout;
		runConjugateGradientQM(&conjugateGradientQM, qmModel, conjugateGradientQMOptions); 
	}
	else if(strstr(optimizerType,"Quasi"))
	{
		//printf("Minimization by QuasiNewton method\n");
		quasiNewtonQM.qmModel = qmModel; 
               	quasiNewtonQM.logfile = stdout;
                runQuasiNewtonQM(&quasiNewtonQM);
	}
	else
	{
		//printf("Minimization by steepest descent method\n");
		steepestDescentQM.logfile= stdout;
		runSteepestDescentQM(&steepestDescentQM, qmModel,
			       	conjugateGradientQMOptions.updateFrequency,
			       conjugateGradientQMOptions.maxIterations,
			       conjugateGradientQMOptions.gradientNorm,
			       conjugateGradientQMOptions.maxLines);
	}
	//printEnergyAndGradient(qmModel);
	return TRUE;
}
/*****************************************************************************/
static boolean miminizeGeometriesUsingInternalOptimizer(int numberOfGeometries, QuantumMechanicsModel** geometries, double* energies, char* inputFileName)
{
	SteepestDescentQM steepestDescentQM;
	ConjugateGradientQM conjugateGradientQM;
	QuasiNewtonQM quasiNewtonQM;
	char* optimizerType = NULL;
	ConjugateGradientQMOptions conjugateGradientQMOptions;
	FILE* file = NULL;
	int i;
	int nG = 0;
	int nM = 0;
	if(!geometries) return FALSE;

	file = fopen(inputFileName,"rb");
	optimizerType = setOptOptions(file, &conjugateGradientQMOptions, &quasiNewtonQM);
	fclose(file);

	for(i=0;i<numberOfGeometries;i++)
	{
		if(!geometries[i]) continue;
		nG++;
		fprintf(stdout,"Optimization of geometry # %d / %d\n",i+1, numberOfGeometries);
		if(minimizeGeometry(geometries[i], optimizerType, steepestDescentQM, quasiNewtonQM, conjugateGradientQM,conjugateGradientQMOptions))
		{
			energies[i] = geometries[i]->molecule.potentialEnergy;
			nM++;
		}
		else
		{
			fprintf(stderr,"============>Free geom number %d\n",i+1);
			geometries[i]->klass->free(geometries[i]);
			geometries[i] =NULL;
		}

	}
	return (nM>0);
}
/***********************************************************************/
void quantumMechanicsMinimizeInternalDlg(char* inputFileName)
{
	QuantumMechanicsModel qmModel; 
	SteepestDescentQM steepestDescentQM;
	ConjugateGradientQM conjugateGradientQM;
	QuasiNewtonQM quasiNewtonQM;
	char* optimizerType = NULL;
	ConjugateGradientQMOptions conjugateGradientQMOptions;
	Molecule* mol = readMolecule(inputFileName,TRUE);
	FILE* file = fopen(inputFileName,"rb");
	char* fileNameOut = strdup_printf("%sOpt.gab",getSuffixNameFile(inputFileName));
	char* model = NULL;
	char* QMKeys = strdup("AM1");
	char* dirName = NULL;
	char* mopacCommand = strdup("/opt/mopac/MOPAC2012");
	char* fireflyCommand = strdup("firefly");
	char* orcaCommand = strdup("orca");
	char* N2P2Dir=strdup(getenv("PWD"));
	char* tmModule=strdup_printf("%s/%s",getenv("PWD"),"CChemITMModule");
	char* openBabelCommand = strdup("obgradient");
	char* gaussianCommand = strdup("g09");
	char* genericCommand = strdup("runGeneric");
	Constraints constraints = NOCONSTRAINTS;
	FILE* logfile = stdout;


	optimizerType = setOptOptions(file, &conjugateGradientQMOptions, &quasiNewtonQM);

	if(!readOneString(file,"Model",&model)) model = strdup("MOPAC");
	uppercase(model);
	if(!readOneString(file,"QMKeys",&QMKeys)) 
	{
		if(!strcmp(model,"MOPAC")) QMKeys = strdup("PM6-DH+");
		else if(!strcmp(model,"ORCA")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"GAUSSIAN")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"FIREFLY")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"OPENBABEL")) QMKeys = strdup("mmff94");
		else QMKeys = strdup("SCC-DFTB");
	}
	if(!strcmp(model,"OPENBABEL")) mol->klass->buildMMTypes(mol, file);

	dirName = strdup(getenv("PWD"));
	readOneString(file,"mopacCommand",&mopacCommand);
	readOneString(file,"orcaCommand",&orcaCommand);
	readOneString(file,"openBabelCommand",&openBabelCommand);
	readOneString(file,"HDNNDir",&N2P2Dir);
	readOneString(file,"N2P2Dir",&N2P2Dir);
	readOneString(file,"tmModule",&tmModule);
	readOneString(file,"fireflyCommand",&fireflyCommand);
	readOneString(file,"gaussianCommand",&gaussianCommand);
	readOneString(file,"genericCommand",&genericCommand);

	if(!strcmp(model,"MOPAC")) qmModel = createMopacModel(mol, QMKeys, dirName, mopacCommand, constraints, logfile);
	else if(!strcmp(model,"FIREFLY")) qmModel = createFireFlyModel(mol, QMKeys, dirName, fireflyCommand, constraints, logfile);
	else if(!strcmp(model,"ORCA")) qmModel = createOrcaModel(mol, QMKeys, dirName, orcaCommand, constraints, logfile);
	else if(!strcmp(model,"OPENBABEL")) qmModel = createOpenBabelModel(mol, QMKeys, dirName, openBabelCommand, constraints, logfile);
	else if(!strcmp(model,"GAUSSIAN")) qmModel = createGaussianModel(mol, QMKeys, dirName, gaussianCommand, constraints, logfile);
	else if(!strcmp(model,"N2P2") || !strcmp(model,"HDNN")) qmModel = createN2P2Model(mol, N2P2Dir, constraints, logfile);
	else if(!strcmp(model,"TM") || !strcmp(model,"TensorModel")) qmModel = createTMModel(mol, tmModule, constraints, logfile);
	else qmModel = createGenericModel(mol, QMKeys, dirName, genericCommand, constraints, logfile);
	setH4Correction(file,&qmModel);
	setSRBCorrection(file,&qmModel);
	readOneBoolean(file,"addD3Correction",&qmModel.addD3Correction);
	checkWallCorrection(file, &qmModel);



	if(strstr(optimizerType,"Grad"))
	{
		printf("Minimization by Conjugate Gradient method\n");
		conjugateGradientQM.logfile= stdout;
		runConjugateGradientQM(&conjugateGradientQM, &qmModel, conjugateGradientQMOptions); 
		printf("Optimized geometry saved in %s file\n",fileNameOut);
		qmModel.molecule.klass->save(&qmModel.molecule,fileNameOut);

		freeConjugateGradientQM(&conjugateGradientQM);
	}
	else if(strstr(optimizerType,"Quasi"))
	{
		printf("Minimization by QuasiNewton method\n");
		quasiNewtonQM.qmModel = &qmModel; 
               	quasiNewtonQM.logfile = stdout;
                runQuasiNewtonQM(&quasiNewtonQM);
		printf("Optimized geometry saved in %s file\n",fileNameOut);
		qmModel.molecule.klass->save(&qmModel.molecule,fileNameOut);
		freeQuasiNewtonQM(&quasiNewtonQM);
	}
	else
	{
		printf("Minimization by steepest descent method\n");
		steepestDescentQM.logfile= stdout;
		runSteepestDescentQM(&steepestDescentQM, &qmModel,
			       	conjugateGradientQMOptions.updateFrequency,
			       conjugateGradientQMOptions.maxIterations,
			       conjugateGradientQMOptions.gradientNorm,
			       conjugateGradientQMOptions.maxLines);
		printf("Optimized geometry saved in %s file\n",fileNameOut);
		qmModel.molecule.klass->save(&qmModel.molecule,fileNameOut);
		freeSteepestDescentQM(&steepestDescentQM);
	}
	printEnergyAndGradient(&qmModel);
	qmModel.klass->free(&qmModel);
	fclose(file);
}
/***********************************************************************/
void quantumMechanicsMinimizeDlg(char* inputFileName)
{
	
	char* optimizerType = NULL;
	char* fileName = NULL;
	boolean addH4Correction = FALSE;
	boolean addSRBCorrection = FALSE;
	boolean addD3Correction = FALSE;
	FILE* file = fopen(inputFileName,"rb");
	readOneBoolean(file,"addD3Correction",&addD3Correction);
	readOneString(file,"OptimizerType",&optimizerType);
	if(readOneString(file,"H4FileName",&fileName)) addH4Correction = TRUE;
	if(readOneString(file,"SRBFileName",&fileName)) addSRBCorrection = TRUE;
	fclose(file);
	if(!optimizerType) optimizerType = strdup("External");
	if(strstr(optimizerType,"External") && (addH4Correction || addD3Correction || addSRBCorrection))
	{
		printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		printf("I cannot use a External optimizer with H4 or D3 Correction\n");
		printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		exit(1);
	}
	if(strstr(optimizerType,"External")) printf("optimization using the Computational chemistry optimizer\n");
	else  printf("We use the internal optimizer\n");
	if(strstr(optimizerType,"External")) quantumMechanicsMinimizeExternalDlg(inputFileName);
	else quantumMechanicsMinimizeInternalDlg(inputFileName);
}
/*****************************************************************************/
void quantumMechanicsEnergyDlg(char* inputFileName)
{
	QuantumMechanicsModel qmModel;
	Molecule* mol = readMolecule(inputFileName,TRUE);
	FILE* file = fopen(inputFileName,"rb");
	char* fileNameOut = strdup_printf("%s.gab",getSuffixNameFile(inputFileName));
	char* model = NULL;
	char* QMKeys = NULL;
	char* dirName = NULL;
	char* mopacCommand = strdup("/opt/mopac/MOPAC2012");
	char* fireflyCommand = strdup("firefly");
	char* orcaCommand = strdup("orca");
	char* N2P2Dir=strdup(getenv("PWD"));
	char* tmModule=strdup_printf("%s/%s",getenv("PWD"),"CChemITMModule");
	char* openBabelCommand = strdup("orca");
	char* gaussianCommand = strdup("g09");
	char* genericCommand = strdup("runGeneric");
	Constraints constraints = NOCONSTRAINTS;
	FILE* logfile = stdout;


	if(!readOneString(file,"Model",&model)) model = strdup("MOPAC");
	uppercase(model);
	if(!readOneString(file,"QMKeys",&QMKeys)) 
	{
		if(!strcmp(model,"MOPAC")) QMKeys = strdup("PM6-DH+");
		else if(!strcmp(model,"ORCA")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"GAUSSIAN")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"FIREFLY")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"OPENBABEL")) QMKeys = strdup("mmff94");
		else QMKeys = strdup("SCC-DFTB");
	}
	if(!strcmp(model,"OPENBABEL")) mol->klass->buildMMTypes(mol, file);

	dirName = strdup(getenv("PWD"));
	readOneString(file,"mopacCommand",&mopacCommand);
	readOneString(file,"orcaCommand",&orcaCommand);
	readOneString(file,"openBabelCommand",&openBabelCommand);
	readOneString(file,"HDNNDir",&N2P2Dir);
	readOneString(file,"N2P2Dir",&N2P2Dir);
	readOneString(file,"tmModule",&tmModule);
	readOneString(file,"fireflyCommand",&fireflyCommand);
	readOneString(file,"gaussianCommand",&gaussianCommand);
	readOneString(file,"genericCommand",&genericCommand);

	if(!strcmp(model,"MOPAC")) qmModel = createMopacModel(mol, QMKeys, dirName, mopacCommand, constraints, logfile);
	else if(!strcmp(model,"FIREFLY")) qmModel = createFireFlyModel(mol, QMKeys, dirName, fireflyCommand, constraints, logfile);
	else if(!strcmp(model,"ORCA")) qmModel = createOrcaModel(mol, QMKeys, dirName, orcaCommand, constraints, logfile);
	else if(!strcmp(model,"OPENBABEL")) qmModel = createOpenBabelModel(mol, QMKeys, dirName, openBabelCommand, constraints, logfile);
	else if(!strcmp(model,"GAUSSIAN")) qmModel = createGaussianModel(mol, QMKeys, dirName, gaussianCommand, constraints, logfile);
	else if(!strcmp(model,"N2P2") || !strcmp(model,"HDNN")) qmModel = createN2P2Model(mol, N2P2Dir, constraints, logfile);
	else if(!strcmp(model,"TM") || !strcmp(model,"TensorModel")) qmModel = createTMModel(mol, tmModule, constraints, logfile);
	else qmModel = createGenericModel(mol, QMKeys, dirName, genericCommand, constraints, logfile);
	setH4Correction(file,&qmModel);
	setSRBCorrection(file,&qmModel);
	readOneBoolean(file,"addD3Correction",&qmModel.addD3Correction);
	checkWallCorrection(file, &qmModel);

	printEnergy(&qmModel);
	printf("Geometry saved in %s file\n",fileNameOut);
	qmModel.molecule.klass->save(&qmModel.molecule,fileNameOut);
	if(qmModel.H4Parameters)
	{
		int i,j;
		printf("H4 Correction\n");
		printf("Gradient(analytic) in kcal/Ang\n");
		for (  i = 0; i < qmModel.molecule.nAtoms; i++ )
			for(j=0;j<3;j++) qmModel.molecule.atoms[i].gradient[j] = 0;
		qmModel.molecule.potentialEnergy = getH4Correction(&qmModel.molecule, qmModel.H4Parameters, TRUE);
		for (  i = 0; i < qmModel.molecule.nAtoms; i++ )
		{
			printf("%-6s ",qmModel.molecule.atoms[i].prop.symbol);
			for(j=0;j<3;j++) printf("%14.8f ",qmModel.molecule.atoms[i].gradient[j]); 
			printf("\n");
		}

		printf("energy = %f(kcal/mol)\n",qmModel.molecule.potentialEnergy);
	}
	if(qmModel.SRBParameters)
	{
		int i,j;
		printf("SRB Correction\n");
		printf("Gradient(analytic) in kcal/Ang\n");
		for (  i = 0; i < qmModel.molecule.nAtoms; i++ )
			for(j=0;j<3;j++) qmModel.molecule.atoms[i].gradient[j] = 0;
		qmModel.molecule.potentialEnergy = getSRBCorrection(&qmModel.molecule, qmModel.SRBParameters, TRUE);
		for (  i = 0; i < qmModel.molecule.nAtoms; i++ )
		{
			printf("%-6s ",qmModel.molecule.atoms[i].prop.symbol);
			for(j=0;j<3;j++) printf("%14.8f ",qmModel.molecule.atoms[i].gradient[j]); 
			printf("\n");
		}

		printf("energy = %f(kcal/mol)\n",qmModel.molecule.potentialEnergy);
	}
	if(qmModel.addD3Correction)
	{
		int i,j;
		printf("Geometry\n");
		for (  i = 0; i < qmModel.molecule.nAtoms; i++ )
		{
			printf("%-6s ",qmModel.molecule.atoms[i].prop.symbol);
			for(j=0;j<3;j++) printf("%14.8f ",qmModel.molecule.atoms[i].coordinates[j]); 
			printf("\n");
		}
		printf("D3 Correction\n");
		printf("Gradient(numeric) in kcal/Ang\n");
		for (  i = 0; i < qmModel.molecule.nAtoms; i++ )
			for(j=0;j<3;j++) qmModel.molecule.atoms[i].gradient[j] = 0;
		qmModel.molecule.potentialEnergy = getD3Correction(&qmModel.molecule, qmModel.method, TRUE);
		for (  i = 0; i < qmModel.molecule.nAtoms; i++ )
		{
			printf("%-6s ",qmModel.molecule.atoms[i].prop.symbol);
			for(j=0;j<3;j++) printf("%14.8f ",qmModel.molecule.atoms[i].gradient[j]); 
			printf("\n");
		}

		printf("energy = %f(kcal/mol)\n",qmModel.molecule.potentialEnergy);
	}

	qmModel.klass->free(&qmModel);
	fclose(file);
}
/*****************************************************************************/
void quantumMechanicsGradientDlg(char* inputFileName)
{
	QuantumMechanicsModel qmModel;
	Molecule* mol = readMolecule(inputFileName,TRUE);
	FILE* file = fopen(inputFileName,"rb");
	char* fileNameOut = strdup_printf("%s.gab",getSuffixNameFile(inputFileName));
	char* model = NULL;
	char* QMKeys = NULL;
	char* dirName = NULL;
	char* mopacCommand = strdup("/opt/mopac/MOPAC2012");
	char* fireflyCommand = strdup("firefly");
	char* orcaCommand = strdup("orca");
	char* N2P2Dir=strdup(getenv("PWD"));
	char* tmModule=strdup_printf("%s/%s",getenv("PWD"),"CChemITMModule");
	char* openBabelCommand = strdup("orca");
	char* gaussianCommand = strdup("g09");
	char* genericCommand = strdup("runGeneric");
	Constraints constraints = NOCONSTRAINTS;
	FILE* logfile = stdout;


	if(!readOneString(file,"Model",&model)) model = strdup("MOPAC");
	uppercase(model);
	if(!readOneString(file,"QMKeys",&QMKeys)) 
	{
		if(!strcmp(model,"MOPAC")) QMKeys = strdup("PM6-DH+");
		else if(!strcmp(model,"ORCA")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"GAUSSIAN")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"FIREFLY")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"OPENBABEL")) QMKeys = strdup("mmff94");
		else QMKeys = strdup("SCC-DFTB");
	}
	if(!strcmp(model,"OPENBABEL")) mol->klass->buildMMTypes(mol, file);

	dirName = strdup(getenv("PWD"));
	readOneString(file,"mopacCommand",&mopacCommand);
	readOneString(file,"orcaCommand",&orcaCommand);
	readOneString(file,"openBabelCommand",&openBabelCommand);
	readOneString(file,"HDNNDir",&N2P2Dir);
	readOneString(file,"N2P2Dir",&N2P2Dir);
	readOneString(file,"tmModule",&tmModule);
	readOneString(file,"fireflyCommand",&fireflyCommand);
	readOneString(file,"gaussianCommand",&gaussianCommand);
	readOneString(file,"genericCommand",&genericCommand);

	if(!strcmp(model,"MOPAC")) qmModel = createMopacModel(mol, QMKeys, dirName, mopacCommand, constraints, logfile);
	else if(!strcmp(model,"FIREFLY")) qmModel = createFireFlyModel(mol, QMKeys, dirName, fireflyCommand, constraints, logfile);
	else if(!strcmp(model,"ORCA")) qmModel = createOrcaModel(mol, QMKeys, dirName, orcaCommand, constraints, logfile);
	else if(!strcmp(model,"OPENBABEL")) qmModel = createOpenBabelModel(mol, QMKeys, dirName, openBabelCommand, constraints, logfile);
	else if(!strcmp(model,"GAUSSIAN")) qmModel = createGaussianModel(mol, QMKeys, dirName, gaussianCommand, constraints, logfile);
	else if(!strcmp(model,"N2P2") || !strcmp(model,"HDNN")) qmModel = createN2P2Model(mol, N2P2Dir, constraints, logfile);
	else if(!strcmp(model,"TM") || !strcmp(model,"TensorModel")) qmModel = createTMModel(mol, tmModule, constraints, logfile);
	else qmModel = createGenericModel(mol, QMKeys, dirName, genericCommand, constraints, logfile);
	setH4Correction(file,&qmModel);
	setSRBCorrection(file,&qmModel);
	readOneBoolean(file,"addD3Correction",&qmModel.addD3Correction);
	checkWallCorrection(file, &qmModel);

	printEnergyAndGradient(&qmModel);
	printf("Geometry saved in %s file\n",fileNameOut);
	qmModel.molecule.klass->save(&qmModel.molecule,fileNameOut);
	if(qmModel.H4Parameters)
	{
		int i,j;
		printf("H4 Correction\n");
		printf("Gradient(analytic) in kcal/Ang\n");
		for (  i = 0; i < qmModel.molecule.nAtoms; i++ )
			for(j=0;j<3;j++) qmModel.molecule.atoms[i].gradient[j] = 0;
		qmModel.molecule.potentialEnergy = getH4Correction(&qmModel.molecule, qmModel.H4Parameters, TRUE);
		for (  i = 0; i < qmModel.molecule.nAtoms; i++ )
		{
			printf("%-6s ",qmModel.molecule.atoms[i].prop.symbol);
			for(j=0;j<3;j++) printf("%14.8f ",qmModel.molecule.atoms[i].gradient[j]); 
			printf("\n");
		}

		printf("energy = %f(kcal/mol)\n",qmModel.molecule.potentialEnergy);
	}
	if(qmModel.SRBParameters)
	{
		int i,j;
		printf("SRB Correction\n");
		printf("Gradient(analytic) in kcal/Ang\n");
		for (  i = 0; i < qmModel.molecule.nAtoms; i++ )
			for(j=0;j<3;j++) qmModel.molecule.atoms[i].gradient[j] = 0;
		qmModel.molecule.potentialEnergy = getSRBCorrection(&qmModel.molecule, qmModel.SRBParameters, TRUE);
		for (  i = 0; i < qmModel.molecule.nAtoms; i++ )
		{
			printf("%-6s ",qmModel.molecule.atoms[i].prop.symbol);
			for(j=0;j<3;j++) printf("%14.8f ",qmModel.molecule.atoms[i].gradient[j]); 
			printf("\n");
		}

		printf("energy = %f(kcal/mol)\n",qmModel.molecule.potentialEnergy);
	}
	if(qmModel.addD3Correction)
	{
		int i,j;
		printf("Geometry\n");
		for (  i = 0; i < qmModel.molecule.nAtoms; i++ )
		{
			printf("%-6s ",qmModel.molecule.atoms[i].prop.symbol);
			for(j=0;j<3;j++) printf("%14.8f ",qmModel.molecule.atoms[i].coordinates[j]); 
			printf("\n");
		}
		printf("D3 Correction\n");
		printf("Gradient(numeric) in kcal/Ang\n");
		for (  i = 0; i < qmModel.molecule.nAtoms; i++ )
			for(j=0;j<3;j++) qmModel.molecule.atoms[i].gradient[j] = 0;
		qmModel.molecule.potentialEnergy = getD3Correction(&qmModel.molecule, qmModel.method, TRUE);
		for (  i = 0; i < qmModel.molecule.nAtoms; i++ )
		{
			printf("%-6s ",qmModel.molecule.atoms[i].prop.symbol);
			for(j=0;j<3;j++) printf("%14.8f ",qmModel.molecule.atoms[i].gradient[j]); 
			printf("\n");
		}

		printf("energy = %f(kcal/mol)\n",qmModel.molecule.potentialEnergy);
	}

	qmModel.klass->free(&qmModel);
	fclose(file);
}
/********************************************************************************/
void quantumMechanicsFrequenciesDlg(char* inputFileName)
{
	double* frequencies = NULL;
	double* reducedMasses = NULL;
	double* IRIntensities = NULL;
	double** modes = NULL;
	int nModes = 0;
	int i;

	QuantumMechanicsModel qmModel;
	Molecule* mol = readMolecule(inputFileName,TRUE);
	FILE* file = fopen(inputFileName,"rb");
	char* fileNameOut = strdup_printf("%sFreq.gab",getSuffixNameFile(inputFileName));
	char* model = NULL;
	char* QMKeys = NULL;
	char* dirName = NULL;
	char* mopacCommand = strdup("/opt/mopac/MOPAC2012");
	char* fireflyCommand = strdup("firefly");
	char* orcaCommand = strdup("orca");
	char* N2P2Dir=strdup(getenv("PWD"));
	char* tmModule=strdup_printf("%s/%s",getenv("PWD"),"CChemITMModule");
	char* openBabelCommand = strdup("orca");
	char* gaussianCommand = strdup("g09");
	char* genericCommand = strdup("runGeneric");
	Constraints constraints = NOCONSTRAINTS;
	FILE* logfile = stdout;
	double dx = -1.0;


	readOneReal(file,"dx",&dx);
	if(!readOneString(file,"Model",&model)) model = strdup("MOPAC");
	uppercase(model);
	if(!readOneString(file,"QMKeys",&QMKeys)) 
	{
		if(!strcmp(model,"MOPAC")) QMKeys = strdup("PM6-DH+");
		else if(!strcmp(model,"ORCA")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"GAUSSIAN")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"FIREFLY")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"OPENBABEL")) QMKeys = strdup("mmff94");
		else QMKeys = strdup("SCC-DFTB");
	}
	if(!strcmp(model,"OPENBABEL")) mol->klass->buildMMTypes(mol, file);

	dirName = strdup(getenv("PWD"));
	readOneString(file,"mopacCommand",&mopacCommand);
	readOneString(file,"orcaCommand",&orcaCommand);
	readOneString(file,"openBabelCommand",&openBabelCommand);
	readOneString(file,"HDNNDir",&N2P2Dir);
	readOneString(file,"N2P2Dir",&N2P2Dir);
	readOneString(file,"tmModule",&tmModule);
	readOneString(file,"fireflyCommand",&fireflyCommand);
	readOneString(file,"gaussianCommand",&gaussianCommand);
	readOneString(file,"genericCommand",&genericCommand);

	if(!strcmp(model,"MOPAC")) qmModel = createMopacModel(mol, QMKeys, dirName, mopacCommand, constraints, logfile);
	else if(!strcmp(model,"FIREFLY")) qmModel = createFireFlyModel(mol, QMKeys, dirName, fireflyCommand, constraints, logfile);
	else if(!strcmp(model,"ORCA")) qmModel = createOrcaModel(mol, QMKeys, dirName, orcaCommand, constraints, logfile);
	else if(!strcmp(model,"OPENBABEL")) qmModel = createOpenBabelModel(mol, QMKeys, dirName, openBabelCommand, constraints, logfile);
	else if(!strcmp(model,"GAUSSIAN")) qmModel = createGaussianModel(mol, QMKeys, dirName, gaussianCommand, constraints, logfile);
	else if(!strcmp(model,"N2P2") || !strcmp(model,"HDNN")) qmModel = createN2P2Model(mol, N2P2Dir, constraints, logfile);
	else if(!strcmp(model,"TM") || !strcmp(model,"TensorModel")) qmModel = createTMModel(mol, tmModule, constraints, logfile);
	else qmModel = createGenericModel(mol, QMKeys, dirName, genericCommand, constraints, logfile);
	setH4Correction(file,&qmModel);
	setSRBCorrection(file,&qmModel);
	readOneBoolean(file,"addD3Correction",&qmModel.addD3Correction);
	checkWallCorrection(file, &qmModel);
	fclose(file);

	printf("Computing of IR spectra... Please wait\n");
	if(dx>0)
	{
		/* use numerical method */
		qmModel.dx = dx;
		nModes = qmModel.klass->computeQMFrequenciesNumeric(&qmModel, &frequencies, &modes, &reducedMasses, &IRIntensities);
	}
	else
	{
		/* use analytical method if available */
		qmModel.dx = 1e-3;
		nModes = qmModel.klass->computeQMFrequencies(&qmModel, &frequencies, &modes, &reducedMasses, &IRIntensities);
	}

	printEnergyAndGradient(&qmModel);
	printf("Frequencies and modes in the %s file\n",fileNameOut);
	mol->klass->saveFrequencies(mol, fileNameOut, nModes, frequencies, modes, reducedMasses, IRIntensities);
	addHarmonicVelocities(inputFileName, nModes, frequencies, modes, reducedMasses, IRIntensities);
	printHarmonicVelocities(inputFileName, nModes, frequencies, modes, reducedMasses);
	if(frequencies) free(frequencies);
	if(reducedMasses) free(reducedMasses);
	for(i=0;i<nModes;i++) free(modes[i]);
	if(modes) free(modes);
	qmModel.klass->free(&qmModel);
	free(fileNameOut);
}
/********************************************************************************/
void quantumMechanicsOptFrequenciesDlg(char* inputFileName)
{
	double* frequencies = NULL;
	double* reducedMasses = NULL;
	double* IRIntensities = NULL;
	double** modes = NULL;
	int nModes = 0;
	int i;

	QuantumMechanicsModel qmModel;
	Molecule* mol = readMolecule(inputFileName,TRUE);
	FILE* file = NULL;
	char* fileNameOut = strdup_printf("%sFreq.gab",getSuffixNameFile(inputFileName));
	char* fileNameOpt = strdup_printf("%sOpt.gab",getSuffixNameFile(inputFileName));
	char* model = NULL;
	char* QMKeys = NULL;
	char* dirName = NULL;
	char* mopacCommand = strdup("/opt/mopac/MOPAC2012");
	char* fireflyCommand = strdup("firefly");
	char* orcaCommand = strdup("orca");
	char* N2P2Dir=strdup(getenv("PWD"));
	char* tmModule=strdup_printf("%s/%s",getenv("PWD"),"CChemITMModule");
	char* openBabelCommand = strdup("obgradient");
	char* gaussianCommand = strdup("g09");
	char* genericCommand = strdup("runGeneric");
	Constraints constraints = NOCONSTRAINTS;
	FILE* logfile = stdout;
	double dx = -1.0;

	quantumMechanicsMinimizeDlg(inputFileName);
	mol = readMoleculeFromGabeditFile(fileNameOpt);
	/* mol->klass->print(mol, logfile);*/

	file = fopen(inputFileName,"rb");

	readOneReal(file,"dx",&dx);

	if(!readOneString(file,"Model",&model)) model = strdup("MOPAC");
	uppercase(model);
	if(!readOneString(file,"QMKeys",&QMKeys)) 
	{
		if(!strcmp(model,"MOPAC")) QMKeys = strdup("PM6-DH+");
		else if(!strcmp(model,"ORCA")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"GAUSSIAN")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"FIREFLY")) QMKeys = strdup("AM1");
		else if(!strcmp(model,"OPENBABEL")) QMKeys = strdup("mmff94");
		else QMKeys = strdup("SCC-DFTB");
	}
	if(!strcmp(model,"OPENBABEL")) mol->klass->buildMMTypes(mol, file);

	dirName = strdup(getenv("PWD"));
	readOneString(file,"mopacCommand",&mopacCommand);
	readOneString(file,"orcaCommand",&orcaCommand);
	readOneString(file,"openBabelCommand",&openBabelCommand);
	readOneString(file,"HDNNDir",&N2P2Dir);
	readOneString(file,"N2P2Dir",&N2P2Dir);
	readOneString(file,"tmModule",&tmModule);
	readOneString(file,"fireflyCommand",&fireflyCommand);
	readOneString(file,"gaussianCommand",&gaussianCommand);
	readOneString(file,"genericCommand",&genericCommand);

	if(!strcmp(model,"MOPAC")) qmModel = createMopacModel(mol, QMKeys, dirName, mopacCommand, constraints, logfile);
	else if(!strcmp(model,"FIREFLY")) qmModel = createFireFlyModel(mol, QMKeys, dirName, fireflyCommand, constraints, logfile);
	else if(!strcmp(model,"ORCA")) qmModel = createOrcaModel(mol, QMKeys, dirName, orcaCommand, constraints, logfile);
	else if(!strcmp(model,"OPENBABEL")) qmModel = createOpenBabelModel(mol, QMKeys, dirName, openBabelCommand, constraints, logfile);
	else if(!strcmp(model,"GAUSSIAN")) qmModel = createGaussianModel(mol, QMKeys, dirName, gaussianCommand, constraints, logfile);
	else if(!strcmp(model,"N2P2") || !strcmp(model,"HDNN")) qmModel = createN2P2Model(mol, N2P2Dir, constraints, logfile);
	else if(!strcmp(model,"TM") || !strcmp(model,"TensorModel")) qmModel = createTMModel(mol, tmModule, constraints, logfile);
	else qmModel = createGenericModel(mol, QMKeys, dirName, genericCommand, constraints, logfile);
	setH4Correction(file,&qmModel);
	setSRBCorrection(file,&qmModel);
	readOneBoolean(file,"addD3Correction",&qmModel.addD3Correction);
	checkWallCorrection(file, &qmModel);
	fclose(file);

	printf("Computing of IR spectra... Please wait\n");
	if(dx>0)
	{
		/* use numerical method */
		qmModel.dx = dx;
		nModes = qmModel.klass->computeQMFrequenciesNumeric(&qmModel, &frequencies, &modes, &reducedMasses, &IRIntensities);
	}
	else
	{
		/* use analytical method if available */
		qmModel.dx = 1e-3;
		nModes = qmModel.klass->computeQMFrequencies(&qmModel, &frequencies, &modes, &reducedMasses, &IRIntensities);
	}

	printEnergyAndGradient(&qmModel);
	printf("Frequencies and modes in the %s file\n",fileNameOut);
	mol->klass->saveFrequencies(mol, fileNameOut, nModes, frequencies, modes, reducedMasses, IRIntensities);
	addHarmonicVelocities(inputFileName, nModes, frequencies, modes, reducedMasses, IRIntensities);
	printHarmonicVelocities(inputFileName, nModes, frequencies, modes, reducedMasses);
	if(frequencies) free(frequencies);
	if(reducedMasses) free(reducedMasses);
	for(i=0;i<nModes;i++) free(modes[i]);
	if(modes) free(modes);
	qmModel.klass->free(&qmModel);
	free(fileNameOut);
	free(fileNameOpt);
}
/********************************************************************************/
File: ./cchemilib/src/Utils/SList.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

#include <stdlib.h>
#include "SList.h"

static void slistDestroy(SList *SList);
static int slistPushFront(SList *SList, void *data);
static int slistPushBack(SList *SList, void *data);
static void* slistPopFront(SList *SList);
static void* slistPopBack(SList *SList);
static int slistStep(SList *SList);
static void* slistReadIndex(SList *SList, int index);
static int slistInsertAfter(SList *SList, int index, void *data);
static void* slistExtractAfter(SList *SList, int index);
static LNode* slistLast (SList *slist);
static int slistRemove(SList *slist, void* data);
/*************************************************************************************************************/
SList* newSList()
{
        SList *slist;
        slist = malloc(sizeof(SList));
        if (slist != NULL) {
                slist->head = NULL;
                slist->tail = NULL;
                slist->current = NULL;
                slist->size = 0;

                slist->klass = malloc(sizeof(SListClass));
                slist->klass->destroy = slistDestroy;
                slist->klass->pushFront =slistPushFront;
                slist->klass->pushBack = slistPushBack;
                slist->klass->append = slistPushBack;
                slist->klass->popFront = slistPopFront;
                slist->klass->popBack = slistPopBack;
                slist->klass->remove = slistRemove;
                slist->klass->step = slistStep;
                slist->klass->last = slistLast;
                slist->klass->readIndex = slistReadIndex;
                slist->klass->insertAfter = slistInsertAfter;
                slist->klass->extractAfter = slistExtractAfter;
        }
        return slist;
}
/*************************************************************************************************************/
static void slistDestroy(SList *slist)
{
        LNode *save_next;
        slist->current = slist->head;
        while(slist->current != NULL) {
                save_next = slist->current->next;
                free(slist->current->data);
                free(slist->current);
                slist->current = save_next;
        }
        free(slist);
}
/*************************************************************************************************************/
static int slistPushFront(SList *slist, void *data)
{
	LNode *node;
	node = malloc(sizeof(LNode));
	if (node == NULL) return -1;
	node->data = data;
	node->next = slist->head;
	slist->head = node;
	if (slist->size == 0) slist->tail = node;
	slist->size++;
	return 0;
}
/*************************************************************************************************************/
static int slistPushBack(SList *slist, void *data)
{
	LNode *node;
	node = malloc(sizeof(LNode));
	if (node ==NULL) return -1;
	node->data = data;
	node->next = NULL;
	if (slist->size == 0) { slist->head = node; slist->tail = node; } 
	else { slist->tail->next = node; slist->tail = node; }
	slist->size++;
	return 0;
}
/*************************************************************************************************************/
static void* slistPopFront(SList *slist)
{
	if (slist->size == 0) return NULL;
	void* data = slist->head->data;
	LNode *save_head = slist->head;
	if (slist->size == 1)
	{
		slist->head = NULL;
		slist->tail = NULL;
		slist->current = NULL;
	}
	else
	{
		slist->head = slist->head->next;
	}
	free(save_head);
	slist->size--;
	return data;
}
/*************************************************************************************************************/
static void* slistPopBack(SList *slist)
{
	if (slist->size == 0) return NULL;
	void *data = slist->tail->data;
	LNode *save_tail = slist->tail;
	if (slist->size == 1)
	{
		slist->head = NULL;
		slist->tail = NULL;
		slist->current = NULL;
	}
	else
	{
		LNode *new_tail = slist->head;
		while(new_tail->next->next != NULL) new_tail = new_tail->next;
		slist->tail = new_tail;
		slist->tail->next = NULL;
	}
	free(save_tail);
	slist->size--;
	return data;
}
/*************************************************************************************************************/
static int slistStep(SList *slist)
{
	if (slist->current == NULL) return 1;
        else
	{
		slist->current = slist->current->next;
		return 0;
	}
}
/*************************************************************************************************************/
static LNode* slistLast (SList *slist)
{
	if(!slist) return NULL;
	return slist->tail;
}
/*************************************************************************************************************/
static void* slistReadIndex(SList *slist, int index)
{
	LNode *target;
	int i;
	if ( ((slist->size - index - 1) < 0 ) || (index < 0) ) return NULL;
	target = slist->head;
	for(i = 0; i < index; i++) target = target->next;
	return (target->data);
}
/*************************************************************************************************************/
static int slistRemove(SList *slist, void* data)
{
	LNode *current;
	LNode *prev;
	if(!slist) return 1;
	if(!data) return 2;
	if(data==slist->head->data)
	{ 
		if (slist->size == 1)
		{
			slist->head = NULL;
			slist->tail = NULL;
			slist->current = NULL;
		}
		else
		{
			slist->head = slist->head->next;
		}
		slist->size--;
		return 0;
	}
	if(data==slist->tail->data)
	{ 
		if (slist->size == 1)
		{
			slist->head = NULL;
			slist->tail = NULL;
			slist->current = NULL;
		}
		else
		{
			LNode *new_tail = slist->head;
			while(new_tail->next->next != NULL) new_tail = new_tail->next;
			slist->tail = new_tail;
			slist->tail->next = NULL;
		}
		slist->size--;
		return 0;
	}
	
	prev = slist->head;
	current = prev->next;
        while(current)
        {
                void* cdata = current->data;
		if(cdata==data)
		{
			prev->next = current->next;
			slist->size--;
			return 0;
		}
		prev = current;
		current = prev->next;
	}
	return 1;
}
/*************************************************************************************************************/
static int slistInsertAfter(SList *slist, int index, void *data)
{
	LNode *target;
	LNode *node;
	int i;
	if ( ((slist->size - index - 1) < 0 ) || (index < 0) ) return 1;
	target = slist->head;
	for(i = 0; i < index; i++) target = target->next;
	node = malloc(sizeof(LNode));
	if (node == NULL) return -1;
	node->data = data;
	node->next = target->next;
	target->next = node;
	if (index == slist->size - 1) slist->tail = node;
	slist->size++;
	return 0;
}
/*************************************************************************************************************/
static void* slistExtractAfter(SList *slist, int index)
{
	LNode *target;
	void *data;
	LNode *saveObsolete;
	int i;
	if ( ((slist->size - index - 2) < 0 ) || (index < 0) ) return NULL;
	target = slist->head;
	for(i = 0; i < index; i++) target = target->next;
	if (index == slist->size - 1) slist->tail = target;
	data = target->next->data;
	saveObsolete = target->next;
	target->next = target->next->next;
	free(saveObsolete);
	slist->size--;
	return data;
}
/*************************************************************************************************************/
File: ./cchemilib/src/Utils/Jacobi.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* Jacobi.c */
#include <math.h>
#include <stdlib.h>
#define ROTATE(a,i,j,k,l) g=a[i][j];h=a[k][l];a[i][j]=g-s*(h+g*tau);\
	a[k][l]=h+s*(g-h*tau);
#define EPS 1e-10

int jacobi(double *M, int n, double d[], double **v, int *nrot)
{
	int j,iq,ip,i;
	double tresh,theta,tau,t,sm,s,h,g,c,*b,*z;
        double **a;
        int k,ki,imin;

	a=malloc(n*sizeof(double*));
        for(i=0;i<n;i++)
           a[i]=malloc(n*sizeof(double));
        iq = -1;
        for(i=0;i<n;i++)
         for(j=i;j<n;j++)
         {
          iq++;
          a[i][j] = M[iq];
         }
        for(i=0;i<n;i++)
         for(j=0;j<i;j++)
          a[i][j] = a[j][i];

	b=malloc(n*sizeof(double));
	z=malloc(n*sizeof(double));
	for (ip=0;ip<n;ip++) {
		for (iq=0;iq<n;iq++) v[ip][iq]=0.0;
		v[ip][ip]=1.0;
	}
	for (ip=0;ip<n;ip++) {
		b[ip]=d[ip]=a[ip][ip];
		z[ip]=0.0;
	}
	*nrot=0;
	for (i=0;i<50;i++) {
		sm=0.0;
		for (ip=0;ip<n-1;ip++) {
			for (iq=ip+1;iq<n;iq++)
				sm += fabs(a[ip][iq]);
		}
		if (fabs(sm)<=EPS) {
			free(z);
			free(b);
		        for(i=0;i<n;i++)
           			free(a[i]);
			free(a);

                        for(k=0;k<n-1;k++)
                        {
			  imin = k;
                          for(ki=k+1;ki<n;ki++)
				if(d[ki]<d[imin])
				   imin = ki;
                          if(imin != k)
			  {
			    sm = d[k];
                            d[k] = d[imin];
			    d[imin] = sm;

                            for(ki=0;ki<n;ki++)
                            {
				sm = v[ki][k];
				v[ki][k] = v[ki][imin];
				v[ki][imin] = sm ;
                            }

			  }
                        }

			return 0;
		}
		if (i < 4)
			tresh=0.2*sm/(n*n);
		else
			tresh=0.0;
		for (ip=0;ip<n-1;ip++) {
			for (iq=ip+1;iq<n;iq++) {
				g=100.0*fabs(a[ip][iq]);
				if (i > 4 && (double)(fabs(d[ip])+g) == (double)fabs(d[ip])
					&& (double)(fabs(d[iq])+g) == (double)fabs(d[iq]))
					a[ip][iq]=0.0;
				else if (fabs(a[ip][iq]) > tresh) {
					h=d[iq]-d[ip];
					if ((double)(fabs(h)+g) == (double)fabs(h))
						t=(a[ip][iq])/h;
					else {
						theta=0.5*h/(a[ip][iq]);
						t=1.0/(fabs(theta)+sqrt(1.0+theta*theta));
						if (theta < 0.0) t = -t;
					}
					c=1.0/sqrt(1+t*t);
					s=t*c;
					tau=s/(1.0+c);
					h=t*a[ip][iq];
					z[ip] -= h;
					z[iq] += h;
					d[ip] -= h;
					d[iq] += h;
					a[ip][iq]=0.0;
					for (j=0;j<=ip-1;j++) {
						ROTATE(a,j,ip,j,iq)
					}
					for (j=ip+1;j<=iq-1;j++) {
						ROTATE(a,ip,j,j,iq)
					}
					for (j=iq+1;j<n;j++) {
						ROTATE(a,ip,j,iq,j)
					}
					for (j=0;j<n;j++) {
						ROTATE(v,j,ip,j,iq)
					}
					++(*nrot);
				}
			}
		}
		for (ip=0;ip<n;ip++) {
			b[ip] += z[ip];
			d[ip]=b[ip];
			z[ip]=0.0;
		}
	}
	/*	Debug("Too many iterations in routine jacobi\n");*/
        free(z);
        free(b);
        for(i=0;i<n;i++)
        	free(a[i]);
	free(a);
        return 1;
}
#undef ROTATE
#undef EPS
File: ./cchemilib/src/Utils/LoadPDBTemplate.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* LoadPDBTemplate.c */
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>

#include "../Utils/Types.h"
#include "../Utils/PDBTemplate.h"
#include "../Utils/Utils.h"
#include "../Utils/Constants.h"
/**********************************************************************/
char** getResiduesList(FILE* file,int* nResidue)
{
	char** t = (char**)malloc(sizeof(char*));
	
	char dump[BSIZE];
	int len = BSIZE;
	int n;
	boolean Ok = FALSE;

	*nResidue = 0;
	fseek(file, 0L, SEEK_SET);
    	if(fgets(dump,len,file))
	while(!feof(file))
	{
		if(fgets(dump,len,file))
		{
			if(strstr(dump,"Begin Residue List"))
			{
				Ok = TRUE;
				break;
			}
		}
	}
	if(!Ok)
		return NULL;
	n = 0;
	while(!feof(file))
	{
		if(fgets(dump,len,file))
		{
			if(strstr(dump,"End"))
				break;
		}
		t = realloc(t,(n+1)*sizeof(char*));
		t[n] = (char*)malloc(BSIZE*sizeof(char));
		sscanf(dump,"%s",t[n]);
		n++;
	}
	if(n==0)
	{
		free(t);
		return NULL;
	}
	*nResidue = n;

	return t;
}
/**********************************************************************/
void setResiduesList(PDBTemplate* pdbTemplate, FILE* file)
{
	int nResidue;
	char** t = getResiduesList(file,&nResidue);

	pdbTemplate->numberOfResidues = nResidue;
	pdbTemplate->residueTemplates = NULL;
	if(nResidue>0 && t)
	{
		int i;
		pdbTemplate->residueTemplates = malloc(nResidue*sizeof(PDBResidueTemplate));
		for(i=0;i<nResidue;i++)
		{
			pdbTemplate->residueTemplates[i].residueName = strdup(t[i]);
			pdbTemplate->residueTemplates[i].numberOfTypes = 0;
			pdbTemplate->residueTemplates[i].typeTemplates = NULL;
			free(t[i]);
		}
		free(t);
	}
}
/**********************************************************************/
void setOneResidue(PDBTemplate* pdbTemplate, FILE* file,int residueNumber)
{
	char title[BSIZE];
	char pdbType[BSIZE];
	char mmType[BSIZE];
	char charge[BSIZE];
	char dump[BSIZE];
	int len = BSIZE;
	int n = 0;
	PDBTypeTemplate *typeTemplates = NULL;
	boolean Ok = FALSE;

	sprintf(title,"Begin %s Residue",pdbTemplate->residueTemplates[residueNumber].residueName);
	fseek(file, 0L, SEEK_SET);
	while(!feof(file))
	{
		if(fgets(dump,len,file))
		{
			if(strstr(dump,title))
			{
				Ok = TRUE;
				break;
			}
		}
	}
	if(!Ok)
		return;
	n = 0;
	typeTemplates = malloc(sizeof(PDBTypeTemplate));
	while(!feof(file))
	{
		if(fgets(dump,len,file))
		{
			if(strstr(dump,"End"))
				break;
		}
		sscanf(dump,"%s %s %s",pdbType, mmType, charge);
		/*printf("pdbType = %s mmType = %s charge = %s\n",pdbType, mmType, charge);*/
		typeTemplates[n].pdbType = strdup(pdbType);
		typeTemplates[n].mmType = strdup(mmType);
		typeTemplates[n].charge = atof(charge);

		n++;
		typeTemplates = realloc(typeTemplates,(n+1)*sizeof(PDBTypeTemplate));
	}
	if(n==0)
	{
		free(typeTemplates);
		pdbTemplate->residueTemplates[residueNumber].numberOfTypes = 0;
		pdbTemplate->residueTemplates[residueNumber].typeTemplates = NULL;
		return;
	}
	typeTemplates = realloc(typeTemplates,n*sizeof(PDBTypeTemplate));

	pdbTemplate->residueTemplates[residueNumber].numberOfTypes = n;
	pdbTemplate->residueTemplates[residueNumber].typeTemplates = typeTemplates;
}
/**********************************************************************/
void setAllResidues(PDBTemplate* pdbTemplate, FILE* file)
{
	int i;
	int n = pdbTemplate->numberOfResidues;
	/* printf("numberOfResidues = %d\n",pdbTemplate->numberOfResidues);*/
	for(i=0;i<n;i++)
	{
		/* printf("i = %d\n",i);*/
		setOneResidue(pdbTemplate,file,i);
	}
}
/**********************************************************************/
boolean readPDBTemplate(PDBTemplate* pdbTemplate,char* filename)
{
	FILE* file;
	file = fopen(filename,"rb");

	/* printf("Read Default TPL file %s \n",filename);*/
	if(file == NULL)
		return FALSE;
	else
	{
		/* printf("Read List Of residue\n");*/
		setResiduesList(pdbTemplate,file);
		/* printf("End Read List Of residue\n");*/
		setAllResidues(pdbTemplate,file);
		/* printf("End Set All Residue\n");*/
		fclose(file);
	}
	return TRUE;
}
/**********************************************************************/
File: ./cchemilib/src/Utils/SavePDBTemplate.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* SavePDBTemplate.c */
#include <stdlib.h>
#include <stdio.h>
#include <math.h>

#include "../Utils/Types.h"
#include "../Utils/PDBTemplate.h"
#include "../Utils/Utils.h"
/************************************************************/
static void saveTitleResidueTpl(FILE* file)
{
	fprintf(file,"Begin Title\n");
	fprintf(file,"	Residue        : PDB type atom  Amber type atom  charge of atom\n");
	fprintf(file,"End\n");
}
/**********************************************************************/
static void saveResiduesList(PDBTemplate* pdbTemplate, FILE* file)
{
	int i;

	fprintf(file,"Begin Residue List\n");

	for(i=0;i<pdbTemplate->numberOfResidues;i++)
		fprintf(file,"%s\n",pdbTemplate->residueTemplates[i].residueName);

	fprintf(file,"End\n");
}
/**********************************************************************/
static void saveOneResidue(PDBTemplate* pdbTemplate, FILE* file,int residueNumber)
{
	int i;
	int numberOfTypes = pdbTemplate->residueTemplates[residueNumber].numberOfTypes;
	PDBTypeTemplate *typeTemplates = pdbTemplate->residueTemplates[residueNumber].typeTemplates;

	fprintf(file,"Begin %s Residue\n",pdbTemplate->residueTemplates[residueNumber].residueName);
	for(i=0;i<numberOfTypes;i++)
		fprintf(file,"%s %s %f\n",
				typeTemplates[i].pdbType,
				typeTemplates[i].mmType,
				typeTemplates[i].charge
				);
	fprintf(file,"End\n");
}
/**********************************************************************/
static void saveAllResidues(PDBTemplate* pdbTemplate, FILE* file)
{
	int i;
	int n = pdbTemplate->numberOfResidues;
	for(i=0;i<n;i++)
		saveOneResidue(pdbTemplate,file,i);
}
/**********************************************************************/
boolean savePDBTemplate(PDBTemplate* pdbTemplate,char* filename)
{
	FILE* file;
	file = fopen(filename,"w");

	if(file == NULL)
		return FALSE;
	else
	{
		saveTitleResidueTpl(file);
		saveResiduesList(pdbTemplate,file);
		saveAllResidues(pdbTemplate,file);
		fclose(file);
	}
	return TRUE;
}
/**********************************************************************/
File: ./cchemilib/src/Utils/QL.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* QL.c */
/* To determine the eigenvalues and eigenvectors of a real, symmetric matrix A using the 
 * QL algorithm to determine after tridiagonalisation */

#include <math.h>
#include <stdlib.h>
#include <stdio.h>

/********************************************************************************/
static void reductionToTridiagonal(double **A, int n, double *D, double *E);
static int diagonalisationOfATridiagonalMatrix(double *D, double *E, int n, double **V);
/********************************************************************************/
static void swap2d(double* a, double* b)
{
        double c = *a;
        *a = *b;
        *b = c;
}
/********************************************************************************/
static void sort(int n, double *EVals, double** V)
{
        int i,j,k;

        for(i=0;i<n;i++)
        {
                k = i;
                for(j=i+1;j<n;j++) if(EVals[j]<EVals[k]) k = j;
                if(k==i) continue;
                swap2d(&EVals[i],&EVals[k]);
                for(j=0;j<n;j++) swap2d(&V[j][i],&V[j][k]);
        }
}
/********************************************************************************/
int eigen(double **M, int n, double *EVals, double** V)
{
	double** A;
	double* E;
	int success = 0;
	int i;
	int j;

	if(n<1) return 0;
	A = malloc(n*sizeof(double*));
	for(i=0;i<n;i++) A[i]=malloc(n*sizeof(double));

	for(i=0;i<n;i++)
  	for(j=i;j<n;j++)
    		A[i][j] = A[j][i] = M[i][j];

	E=malloc(n*sizeof(double));
	reductionToTridiagonal(A, n, EVals, E);
	/*
	for(i=0;i<n;i++) printf("EVals[%d]=%f\n",i,EVals[i]);
	*/
	success = diagonalisationOfATridiagonalMatrix(EVals, E, n, A);
	for(i=0;i<n;i++)
	for(j=0;j<n;j++)
		V[i][j] = A[i][j];

	free(E);
	for(i=0;i<n;i++) free(A[i]);
	free(A);
	sort(n, EVals, V);

	return success;
}
/********************************************************************************/
int eigenQL(int n, double *M, double *EVals, double** V)
{
	double** A;
	double* E;
	int ii;
	int success = 0;
	int i;
	int j;

	if(n<1) return 0;
	A = malloc(n*sizeof(double*));
	for(i=0;i<n;i++) A[i]=malloc(n*sizeof(double));

	/* M is an inf symmetric matrix */
	ii = -1;
	for(i=0;i<n;i++)
	for(j=0;j<=i;j++)
	{
		ii++;
		A[i][j] = M[ii];
	}
	for(i=0;i<n;i++)
  	for(j=i+1;j<n;j++)
    		A[i][j] = A[j][i];

	E=malloc(n*sizeof(double));
	reductionToTridiagonal(A, n, EVals, E);
	/*
	for(i=0;i<n;i++) printf("EVals[%d]=%f\n",i,EVals[i]);
	*/
	success = diagonalisationOfATridiagonalMatrix(EVals, E, n, A);
	for(i=0;i<n;i++)
	for(j=0;j<n;j++)
		V[i][j] = A[i][j];

	free(E);
	for(i=0;i<n;i++) free(A[i]);
	free(A);

	return success;
}
/* procedure to reduce a real symmetric matrix to the tridiagonal form that is suitable for input to 
 * diagonalisationOfATridiagonalMatrix.*/
/********************************************************************************/
static void reductionToTridiagonal(double **A, int n, double *D, double *E)
{
	int	l, k, j, i;
	double  scale, hh, h, g, f;
 
	for (i = n-1; i >= 1; i--)
	{
	    l = i - 1;
	    h = scale = 0.0;
	    if (l > 0)
	    {
		   for (k = 0; k <= l; k++) scale += fabs(A[i][k]);
		   if (scale == 0.0) E[i] = A[i][l];
		   else
		   {
			  for (k = 0; k <= l; k++)
			  {
				 A[i][k] /= scale;
				 h += A[i][k] * A[i][k];
			  }
			  f = A[i][l];
			  g = f > 0 ? -sqrt(h) : sqrt(h);
			  E[i] = scale * g;
			  h -= f * g;
			  A[i][l] = f - g;
			  f = 0.0;
			  for (j = 0; j <= l; j++)
			  {
				 A[j][i] = A[i][j] / h;
				 g = 0.0;
				 for (k = 0; k <= j; k++) g += A[j][k] * A[i][k];
				 for (k = j + 1; k <= l; k++) g += A[k][j] * A[i][k];
				 E[j] = g / h;
				 f += E[j] * A[i][j];
			  }
			  hh = f / (h + h);
			  for (j = 0; j <= l; j++)
			  {
				 f = A[i][j];
				 E[j] = g = E[j] - hh * f;
				 for (k = 0; k <= j; k++) A[j][k] -= (f * E[k] + g * A[i][k]);
			  }
		   }
	    } else E[i] = A[i][l];
	    D[i] = h;
	}
	D[0] = 0.0;
	E[0] = 0.0;
	for (i = 0; i < n; i++)
	{
	    l = i - 1;
	    if (D[i])
	    {
		   for (j = 0; j <= l; j++)
		   {
			  g = 0.0;
			  for (k = 0; k <= l; k++) g += A[i][k] * A[k][j];
			  for (k = 0; k <= l; k++) A[k][j] -= g * A[k][i];
		   }
	    }
	    D[i] = A[i][i];
	    A[i][i] = 1.0;
	    for (j = 0; j <= l; j++) A[j][i] = A[i][j] = 0.0;
	}
}
#undef SIGN
#define SIGN(A,B) ((B)<0 ? -fabs(A) : fabs(A))
/* QL algorithm to determine 
 * the eigenvalues and eigenvectors of a real, symmetric, tridiagonal matrix.*/
/********************************************************************************/
static int diagonalisationOfATridiagonalMatrix(double *D, double *E, int n, double **V)
{
	int	m, l, iter, i, k;
	double  s, r, p, g, f, dd, c, b;
 
	for (i = 1; i < n; i++) E[i - 1] = E[i];
	E[n-1] = 0.0;
	for (l = 0; l < n; l++)
	{
	    iter = 0;
	    do
	    {
		   for (m = l; m < n - 1; m++)
		   {
			  dd = fabs(D[m]) + fabs(D[m + 1]);
			  if (fabs(E[m]) + dd == dd) break;
		   }
		   if (m != l)
		   {
			  if (iter++ == 30) return 0;
			  g = (D[l + 1] - D[l]) / (2.0 * E[l]);
			  r = sqrt((g*g) + 1.0);
			  g = D[m] - D[l] + E[l] / (g + SIGN(r, g));
			  s = c = 1.0;
			  p = 0.0;
			  for (i = m - 1; i >= l; i--)
			  {
				 f = s * E[i];
				 b = c * E[i];
				 if (fabs(f) >= fabs(g))
				 {
					c = g / f;
					r = sqrt((c*c) + 1.0);
					E[i + 1] = f * r;
					c *= (s = 1.0 / r);
				 } else
				 {
					s = f / g;
					r = sqrt((s*s) + 1.0);
					E[i + 1] = g * r;
					s *= (c = 1.0 / r);
				 }
				 g = D[i + 1] - p;
				 r = (D[i] - g) * s + 2.0 * c * b;
				 p = s * r;
				 D[i + 1] = g + p;
				 g = c * r - b;
				 for (k = 0; k < n; k++)
				 {
					f = V[k][i + 1];
					V[k][i + 1] = s * V[k][i] + c * f;
					V[k][i] = c * V[k][i] - s * f;
				 }
			  }
			  D[l] = D[l] - p;
			  E[l] = g;
			  E[m] = 0.0;
		   }
	    } while (m != l);
	}
 
	return 1;
}
/*******************************************************************/
/* Given a matrix
a[0..n-1][0..n-1] , this routine replaces it by the LU decomposition of a rowwise
permutation of itself.  a and n are  input.  a is  output,
indx[0..n-1] is  an  output  vector  that  records  the  row  permutation  ected  by  the  partial pivoting;
d is  output  as  1 depending  on  whether  the  number  of  row  interchanges was  even
or odd, respectively.  This routine is used in combination with
lubksb to solve linear equations or  invert  a  matrix
*/
void ludcmp(double **a, int n, int *indx, double *d)
{
	int i,imax=0,j,k;
	double big,dum,sum,temp;
	double *vv;

	vv= malloc(n*sizeof(double));
	*d=1.0;
	for (i=0;i<n;i++) {
		big=0.0;
		for (j=0;j<n;j++)
			if ((temp=fabs(a[i][j])) > big) big=temp;
		if (big == 0.0) fprintf(stderr,"Singular matrix in routine ludcmp");
		vv[i]=1.0/big;
	}
	for (j=0;j<n;j++) {
		for (i=0;i<j;i++) {
			sum=a[i][j];
			for (k=0;k<i;k++) sum -= a[i][k]*a[k][j];
			a[i][j]=sum;
		}
		big=0.0;
		for (i=j;i<n;i++) {
			sum=a[i][j];
			for (k=0;k<j;k++)
				sum -= a[i][k]*a[k][j];
			a[i][j]=sum;
			if ( (dum=vv[i]*fabs(sum)) >= big) {
				big=dum;
				imax=i;
			}
		}
		if (j != imax) {
			for (k=0;k<n;k++) {
				dum=a[imax][k];
				a[imax][k]=a[j][k];
				a[j][k]=dum;
			}
			*d = -(*d);
			vv[imax]=vv[j];
		}
		indx[j]=imax;
		if (a[j][j] == 0.0) a[j][j]=1e-20;
		if (j != n-1) {
			dum=1.0/(a[j][j]);
			for (i=j+1;i<n;i++) a[i][j] *= dum;
		}
	}
	free(vv);

}
/******************************************************/
/* Solves the set of n linear equations A X = B .Here a[0..n-1][0..n-1]
is input, not as the matrix A but rather as its LU decomposition, determined by the routine
ludcmp .  indx[0..n-1] is input as the permutation vector returned by ludcmp.
b[0..n-1] is input as the right-hand side vector B ,  and  returns  with  the  solution  vector
X .  a , n ,and indx are  not  modied  by  this  routine and can be left in place for 
successive calls with different right-hand sides b .  This routine takes into  account the  possibility  that
 b will  begin with  many zero  elements, so it  is  elsecient for use in  matrix  inversion */
void lubksb(double **a, int n, int *indx, double b[])
{
	int i,ii=-1,ip,j;
	double sum;

	for (i=0;i<n;i++) {
		ip=indx[i];
		sum=b[ip];
		b[ip]=b[i];
		if (ii!=-1) for (j=ii;j<=i-1;j++) sum -= a[i][j]*b[j];
		else if (sum) ii=i;
		b[i]=sum;
	}
	for (i=n-1;i>=0;i--) {
		sum=b[i];
		for (j=i+1;j<n;j++) sum -= a[i][j]*b[j];
		b[i]=sum/a[i][i];
	}
}
/********************************************************************************/
int solveSymEqQL(int n, double **A, double* B, double* values)
{
	double** V;
	int *indx;
	int i,j;
	int success = 0;
	double d;
	V = malloc(n*sizeof(double*));
	for(i=0;i<n;i++) V[i]=malloc(n*sizeof(double));

	for(i=0;i<n;i++)
	for(j=0;j<=i;j++)
	{
		V[i][j] = V[j][i] = A[i][j];
	}
	indx = malloc(n*sizeof(int));
	for(i=0;i<n;i++) values[i] = B[i]; 
	/*
	printf("A\n");
	for(i=0;i<n;i++) 
	{
		for(j=0;j<n;j++) printf("%f ",V[i][j]);
		printf("\n");
	}
	printf("B\n");
	for(i=0;i<n;i++) printf("%f ",B[i]);
	printf("\n");
	*/

	ludcmp(V,n,indx,&d);
	lubksb(V,n,indx,values);

	/*
	printf("values\n");
	for(i=0;i<n;i++) printf("%f ",values[i]);
	printf("\n");
	*/
	for(i=0;i<n;i++) free(V[i]);
	free(V);
	free(indx);
	return success;
}
File: ./cchemilib/src/Utils/AtomsProp.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* AtomsProp.c */

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <math.h>
#include "../Utils/Types.h"
#include "../Utils/Constants.h"
#include "../Utils/AtomsProp.h"
#include "../Utils/Utils.h"

#define NATOMS 112
/********************************************************************************/
enum 
{
	DISPLAY_RADII = 0,
	COVALENT_RADII,
	VANDERWALS_RADII,
	MAXIMUM_BOND_VALENCE,
	MASSE,
	ELECTRONEGATIVITY,
	NUMBER_OF_ENTRYS,
};
/********************************************************************************/
static SAtomsProp AtomsProp[NATOMS];
/********************************************************************************/
void saveAtomsProp()
{
 int i;
 int j;
 char *atomspropfile;
 FILE *fd;

 atomspropfile = strdup_printf("%s%satomsprop.txt",cchemiDirectory(),DIR_SEPARATOR_S);
 fd = fopen(atomspropfile, "w");

 if(fd==NULL)
 {
	printf("I cannot open %s file to save the atoms properties\n",atomspropfile);
	return;
 }

 for(i=0;i<NATOMS;i++)
 {
  	fprintf(fd,"%s %s %d %f %f %f %f %d %f %f %d %d %d %d\n",
	AtomsProp[i].name,
	AtomsProp[i].symbol,
	AtomsProp[i].atomicNumber,
	AtomsProp[i].covalentRadii,
	AtomsProp[i].bondOrderRadii,
	AtomsProp[i].vanDerWaalsRadii,
	AtomsProp[i].radii,
	AtomsProp[i].maximumBondValence,
	AtomsProp[i].mass,
	AtomsProp[i].electronegativity,
	AtomsProp[i].color[0],
	AtomsProp[i].color[1],
	AtomsProp[i].color[2],
	AtomsProp[i].nIsotopes
	);
 	for(j=0;j<AtomsProp[i].nIsotopes;j++)
  		fprintf(fd,"%d %f %f\n", AtomsProp[i].iMass[j], AtomsProp[i].rMass[j], AtomsProp[i].abundances[j]);
  }
  fclose(fd);
}
/********************************************************************************/
boolean readAtomsProp()
{
 
 int i;
 int j;
 char *t;
 boolean OK=TRUE;
 char *atomspropfile;
 FILE *fd;
 
 atomspropfile = strdup_printf("%s%satomsprop.txt",cchemiDirectory(),DIR_SEPARATOR_S);
 fd = fopen(atomspropfile, "r");  

 t=malloc(BSIZE*sizeof(char));

 i=-1;
 if(fd!=NULL)
 {
  while(!feof(fd) && (i<NATOMS-1))
  {
    i++;
    fgets(t,BSIZE,fd);
    AtomsProp[i].name= malloc(30);
    AtomsProp[i].symbol= malloc(3);
    sscanf(t,"%s %s %d %lf %lf %lf %lf %d %lf %lf %d %d %d %d",
	AtomsProp[i].name,
	AtomsProp[i].symbol,
	&AtomsProp[i].atomicNumber,
	&AtomsProp[i].covalentRadii,
	&AtomsProp[i].bondOrderRadii,
	&AtomsProp[i].vanDerWaalsRadii,
	&AtomsProp[i].radii,
	&AtomsProp[i].maximumBondValence,
	&AtomsProp[i].mass,
	&AtomsProp[i].electronegativity,
	&AtomsProp[i].color[0],
	&AtomsProp[i].color[1],
	&AtomsProp[i].color[2],
	&AtomsProp[i].nIsotopes
        );
 	for(j=0;j<AtomsProp[i].nIsotopes;j++)
	{
    		fgets(t,BSIZE,fd);
    		sscanf(t,"%d %lf %lf", &AtomsProp[i].iMass[j], &AtomsProp[i].rMass[j], &AtomsProp[i].abundances[j]);
	}
  }
 }
 else
    OK  = FALSE;
 free(t);
 return OK;
}
/********************************************************************************/
double getMassFromSymbol(char* symbol)
{
	int i;
	for(i=0;i<NATOMS;i++)
	{
		if (!strcmp(symbol,AtomsProp[i].symbol))
			return AtomsProp[i].mass;
	}
	return 1.0;
}
/******************************************************************/
double getAtomicNumberFromSymbol(char* symbol)
{
	int i;
        static char symb[5];
	int l;

	if(!symbol) return 0.0;
	l = strlen(symbol);
	symb[0] = toupper(symbol[0]);
	if(l>1) symb[1]=tolower(symbol[1]);
	if(l>2) symb[2]=tolower(symbol[1]);
	symb[l] = '\0';
	
	for(i=0;i<NATOMS;i++)
	{
		if (!strcmp(symb,AtomsProp[i].symbol))
		{
			return AtomsProp[i].atomicNumber;
		}
	}
	return -1.0;
}
/********************************************************************************/
char* getSymbolUsingZ(int z)
{
	int i;
	
	for(i=0;i<NATOMS;i++)
	{
		if(z == (int)AtomsProp[i].atomicNumber)
		{
			return strdup(AtomsProp[i].symbol);
		}
	}
	return strdup("X");
}
/********************************************************************************/
boolean testAtomDefine(char *Symb)
{
	int i;
	
	for(i=0;i<NATOMS;i++)
	{
		if (!strcmp(Symb,AtomsProp[i].symbol))
 		{
			return TRUE;
		}

	}
	return FALSE;
}
/********************************************************************************/
void propAtomFree(SAtomsProp* prop)
{
	if(prop->name) free(prop->name);
	if(prop->symbol) free(prop->symbol);
}
/********************************************************************************/
SAtomsProp propAtomGet(const char *Symb)
{
	int i;
	int j;
        SAtomsProp temp;
	int c;
	
	for(i=0;i<NATOMS;i++)
	{
		if (!strcmp(Symb,AtomsProp[i].symbol))
 		{
			temp.name   = strdup(AtomsProp[i].name);
			temp.symbol   = strdup(AtomsProp[i].symbol);
			temp.atomicNumber      = AtomsProp[i].atomicNumber;
			temp.covalentRadii    = AtomsProp[i].covalentRadii;
			temp.bondOrderRadii    = AtomsProp[i].bondOrderRadii;
			temp.vanDerWaalsRadii   = AtomsProp[i].vanDerWaalsRadii;
			temp.radii = AtomsProp[i].radii;
			temp.maximumBondValence = AtomsProp[i].maximumBondValence;
			temp.mass    = AtomsProp[i].mass;
			temp.electronegativity    = AtomsProp[i].electronegativity;
			for(c=0;c<3;c++) temp.color[c]  = AtomsProp[i].color[c];
			temp.nIsotopes  = AtomsProp[i].nIsotopes;
			for(j=0;j<temp.nIsotopes;j++) temp.iMass[j] = AtomsProp[i].iMass[j];
			for(j=0;j<temp.nIsotopes;j++) temp.rMass[j] = AtomsProp[i].rMass[j];
			for(j=0;j<temp.nIsotopes;j++) temp.abundances[j] = AtomsProp[i].abundances[j];

			return temp;
		}

	}
	printf(("Warning : Sorry , Your atom %s is not defined\n"),Symb);
        i=0;
	temp.name   = strdup(AtomsProp[i].name);
	temp.symbol   = strdup(AtomsProp[i].symbol);
	temp.atomicNumber      = AtomsProp[i].atomicNumber;
	temp.covalentRadii    = AtomsProp[i].covalentRadii;
	temp.bondOrderRadii    = AtomsProp[i].bondOrderRadii;
	temp.vanDerWaalsRadii   = AtomsProp[i].vanDerWaalsRadii;
	temp.maximumBondValence = AtomsProp[i].maximumBondValence;
	temp.radii = AtomsProp[i].radii;
	temp.mass = AtomsProp[i].mass;
	temp.electronegativity = AtomsProp[i].electronegativity;
	for(c=0;c<3;c++) temp.color[c]  = AtomsProp[i].color[c];
	temp.nIsotopes = AtomsProp[i].nIsotopes;
	for(j=0;j<temp.nIsotopes;j++) temp.iMass[j] = AtomsProp[i].iMass[j];
	for(j=0;j<temp.nIsotopes;j++) temp.rMass[j] = AtomsProp[i].rMass[j];
	for(j=0;j<temp.nIsotopes;j++) temp.abundances[j] = AtomsProp[i].abundances[j];
	return temp;
}
/******************************************************************/
char *symbAtomGet(int Z)
{
	int i;
        char *symb;
       
        symb = strdup("X");
	
	for(i=0;i<NATOMS;i++)
	{
		if (Z==AtomsProp[i].atomicNumber)
 		{
		symb =strdup(AtomsProp[i].symbol);
 		break;
		}

	}
	return symb;
}
/******************************************************************/
void addIsotopeToAtom(char* symbol, int atomicNumber, int iMass, double rMass, double abundance)
{
	int i = (int)atomicNumber-1;
	int j = 0;
	if(i>=NATOMS) return;
	if(i<0) return;
	if(strcmp(symbol,"Xx")==0) return;
	if(strcmp(symbol,"X")==0) return;
	if(i>=109) return;
	if(AtomsProp[i].nIsotopes>= MAXISOTOP) return;

	j = AtomsProp[i].nIsotopes;
	AtomsProp[i].nIsotopes++;
	AtomsProp[i].iMass[j] = iMass;
	AtomsProp[i].rMass[j] = rMass;
	AtomsProp[i].abundances[j] = abundance;
	if(j==0) AtomsProp[i].mass = rMass;
}
/******************************************************************/
void setPropForOneAtom(char* name, char* symbol, int atomicNumber, 
		double covalentRadii, double bondOrderRadii, double vanDerWaalsRadii, 
		int maximumBondValence, double mass, double electronegativity, double red, double green, double blue)
{
	int i = (int)atomicNumber-1;
	if(strcmp(symbol,"Xx")==0) i = 109;
	if(strcmp(symbol,"X")==0) i = 110;

	AtomsProp[i].name = strdup(name);
	AtomsProp[i].symbol = strdup(symbol);
	AtomsProp[i].atomicNumber = atomicNumber;
	AtomsProp[i].covalentRadii = (covalentRadii+0.2)*ANGTOBOHR;
	AtomsProp[i].bondOrderRadii = bondOrderRadii*ANGTOBOHR;
	AtomsProp[i].vanDerWaalsRadii = vanDerWaalsRadii*ANGTOBOHR;
	/*AtomsProp[i].radii = covalentRadii/1.5*ANG_TO_BOHR;*/
	AtomsProp[i].radii = vanDerWaalsRadii*0.2*ANGTOBOHR;
	AtomsProp[i].maximumBondValence = maximumBondValence;
	AtomsProp[i].mass = mass;
	AtomsProp[i].electronegativity = electronegativity/27.21;
	AtomsProp[i].color[0] = (red*65535);
	AtomsProp[i].color[1] = (green*65535);
	AtomsProp[i].color[2] = (blue*65535);
	AtomsProp[i].nIsotopes =  0;
}
/******************************************************************/
void defineDefaultAtomsProp()
{
	setPropForOneAtom("Hydrogen", "H", 1, 0.230000, 0.330000, 1.200000, 1, 1.007940, 2.100000, 1.000000, 1.000000, 1.000000);
	setPropForOneAtom("Helium", "He", 2, 0.930000, 0.700000, 1.400000, 0, 4.002602, 0.000000, 0.850000, 1.000000, 1.000000);
	setPropForOneAtom("Lithium", "Li", 3, 0.680000, 1.230000, 1.820000, 1, 6.941000, 0.980000, 0.800000, 0.500000, 1.000000);
	setPropForOneAtom("Beryllium", "Be", 4, 0.350000, 0.900000, 1.700000, 2, 9.012182, 1.570000, 0.760000, 1.000000, 0.000000);
	setPropForOneAtom("Boron", "B", 5, 0.830000, 0.820000, 2.080000, 3, 10.811000, 2.040000, 1.000000, 0.710000, 0.710000);
	setPropForOneAtom("Carbon", "C", 6, 0.680000, 0.770000, 1.950000, 4, 12.010700, 2.550000, 0.500000, 0.500000, 0.500000);
	setPropForOneAtom("Nitrogen", "N", 7, 0.680000, 0.700000, 1.850000, 3, 14.006700, 3.040000, 0.050000, 0.050000, 1.000000);
	setPropForOneAtom("Oxygen", "O", 8, 0.680000, 0.660000, 1.700000, 2, 15.999400, 3.440000, 1.000000, 0.050000, 0.050000);
	setPropForOneAtom("Fluorine", "F", 9, 0.640000, 0.611000, 1.730000, 1, 18.998404, 3.980000, 0.700000, 1.000000, 1.000000);
	setPropForOneAtom("Neon", "Ne", 10, 1.120000, 0.700000, 1.540000, 0, 20.179701, 0.000000, 0.700000, 0.890000, 0.960000);
	/*
	setPropForOneAtom("Sodium", "Na", 11, 0.970000, 1.540000, 2.270000, 1, 22.989771, 0.930000, 0.670000, 0.360000, 0.950000);
	*/
	setPropForOneAtom("Sodium", "Na", 11, 1.9, 3.06, 2.270000, 1, 22.989771, 0.930000, 0.670000, 0.360000, 0.950000);
	AtomsProp[10].radii /= 2;

	setPropForOneAtom("Magnesium", "Mg", 12, 1.100000, 1.360000, 1.730000, 2, 24.305000, 1.310000, 0.540000, 1.000000, 0.000000);
	setPropForOneAtom("Aluminium", "Al", 13, 1.350000, 1.180000, 2.050000, 6, 26.981539, 1.610000, 0.750000, 0.650000, 0.650000);
	setPropForOneAtom("Silicon", "Si", 14, 1.200000, 0.937000, 2.100000, 6, 28.085501, 1.900000, 0.500000, 0.600000, 0.600000);
	setPropForOneAtom("Phosphorus", "P", 15, 1.100000, 0.890000, 2.080000, 5, 30.973761, 2.190000, 1.000000, 0.500000, 0.000000);
	setPropForOneAtom("Sulphur", "S", 16, 1.020000, 1.040000, 2.000000, 6, 32.064999, 2.580000, 1.000000, 1.000000, 0.190000);
	setPropForOneAtom("Chlorine", "Cl", 17, 0.990000, 0.997000, 1.970000, 1, 35.452999, 3.160000, 0.120000, 0.940000, 0.120000);
	setPropForOneAtom("Argon", "Ar", 18, 1.570000, 1.740000, 1.880000, 0, 39.948002, 0.000000, 0.500000, 0.820000, 0.890000);
	setPropForOneAtom("Potassium", "K", 19, 1.330000, 2.030000, 2.750000, 1, 39.098301, 0.820000, 0.560000, 0.250000, 0.830000);
	setPropForOneAtom("Calcium", "Ca", 20, 0.990000, 1.740000, 1.973000, 2, 40.077999, 1.000000, 0.240000, 1.000000, 0.000000);
	setPropForOneAtom("Scandium", "Sc", 21, 1.440000, 1.440000, 1.700000, 6, 44.955910, 1.360000, 0.900000, 0.900000, 0.900000);
	setPropForOneAtom("Titanium", "Ti", 22, 1.470000, 1.320000, 1.700000, 6, 47.867001, 1.540000, 0.750000, 0.760000, 0.780000);
	setPropForOneAtom("Vanadium", "V", 23, 1.330000, 1.220000, 1.700000, 6, 50.941502, 1.630000, 0.650000, 0.650000, 0.670000);
	setPropForOneAtom("Chromium", "Cr", 24, 1.350000, 1.180000, 1.700000, 6, 51.996101, 1.660000, 0.540000, 0.600000, 0.780000);
	setPropForOneAtom("Manganese", "Mn", 25, 1.350000, 1.170000, 1.700000, 8, 54.938049, 1.550000, 0.610000, 0.480000, 0.780000);
	setPropForOneAtom("Iron", "Fe", 26, 1.340000, 1.170000, 1.700000, 6, 55.845001, 1.830000, 0.500000, 0.480000, 0.780000);
	setPropForOneAtom("Cobalt", "Co", 27, 1.330000, 1.160000, 1.700000, 6, 58.933201, 1.880000, 0.440000, 0.480000, 0.780000);
	setPropForOneAtom("Nickel", "Ni", 28, 1.500000, 1.150000, 1.630000, 6, 58.693401, 1.910000, 0.360000, 0.480000, 0.760000);
	setPropForOneAtom("Copper", "Cu", 29, 1.520000, 1.170000, 1.400000, 6, 63.546001, 1.900000, 1.000000, 0.480000, 0.380000);
	setPropForOneAtom("Zinc", "Zn", 30, 1.450000, 1.250000, 1.390000, 6, 65.408997, 1.650000, 0.490000, 0.500000, 0.690000);
	setPropForOneAtom("Gallium", "Ga", 31, 1.220000, 1.260000, 1.870000, 3, 69.723000, 1.810000, 0.760000, 0.560000, 0.560000);
	setPropForOneAtom("Germanium", "Ge", 32, 1.170000, 1.188000, 1.700000, 4, 72.639999, 2.010000, 0.400000, 0.560000, 0.560000);
	setPropForOneAtom("Arsenic", "As", 33, 1.210000, 1.200000, 1.850000, 3, 74.921600, 2.180000, 0.740000, 0.500000, 0.890000);
	setPropForOneAtom("Selenium", "Se", 34, 1.220000, 1.170000, 1.900000, 2, 78.959999, 2.550000, 1.000000, 0.630000, 0.000000);
	setPropForOneAtom("Bromine", "Br", 35, 1.210000, 1.167000, 2.100000, 1, 79.903999, 2.960000, 0.650000, 0.160000, 0.160000);
	setPropForOneAtom("Krypton", "Kr", 36, 1.910000, 1.910000, 2.020000, 0, 83.797997, 0.000000, 0.360000, 0.720000, 0.820000);
	setPropForOneAtom("Rubidium", "Rb", 37, 1.470000, 2.160000, 1.700000, 1, 85.467796, 0.820000, 0.440000, 0.180000, 0.690000);
	setPropForOneAtom("Strontium", "Sr", 38, 1.120000, 1.910000, 1.700000, 2, 87.620003, 0.950000, 0.000000, 1.000000, 0.000000);
	setPropForOneAtom("Yttrium", "Y", 39, 1.780000, 1.620000, 1.700000, 6, 88.905853, 1.220000, 0.580000, 1.000000, 1.000000);
	setPropForOneAtom("Zirconium", "Zr", 40, 1.560000, 1.450000, 1.700000, 6, 91.223999, 1.330000, 0.580000, 0.880000, 0.880000);
	setPropForOneAtom("Niobium", "Nb", 41, 1.480000, 1.340000, 1.700000, 6, 92.906380, 1.600000, 0.450000, 0.760000, 0.790000);
	setPropForOneAtom("Molybdenum", "Mo", 42, 1.470000, 1.300000, 1.700000, 6, 95.940002, 2.160000, 0.330000, 0.710000, 0.710000);
	setPropForOneAtom("Technetium", "Tc", 43, 1.350000, 1.270000, 1.700000, 6, 98.000000, 1.900000, 0.230000, 0.620000, 0.620000);
	setPropForOneAtom("Ruthenium", "Ru", 44, 1.400000, 1.250000, 1.700000, 6, 101.070000, 2.200000, 0.140000, 0.560000, 0.560000);
	setPropForOneAtom("Rhodium", "Rh", 45, 1.450000, 1.250000, 1.700000, 6, 102.905502, 2.280000, 0.040000, 0.490000, 0.550000);
	setPropForOneAtom("Palladium", "Pd", 46, 1.500000, 1.280000, 1.630000, 6, 106.419998, 2.200000, 0.000000, 0.410000, 0.520000);
	setPropForOneAtom("Silver", "Ag", 47, 1.590000, 1.340000, 1.720000, 6, 107.868202, 1.930000, 0.880000, 0.880000, 1.000000);
	setPropForOneAtom("Cadmium", "Cd", 48, 1.690000, 1.480000, 1.580000, 6, 112.411003, 1.690000, 1.000000, 0.850000, 0.560000);
	setPropForOneAtom("Indium", "In", 49, 1.630000, 1.440000, 1.930000, 3, 114.818001, 1.780000, 0.650000, 0.460000, 0.450000);
	setPropForOneAtom("Tin", "Sn", 50, 1.460000, 1.385000, 2.170000, 4, 118.709999, 1.960000, 0.400000, 0.500000, 0.500000);
	setPropForOneAtom("Antimony", "Sb", 51, 1.460000, 1.400000, 2.200000, 3, 121.760002, 2.050000, 0.620000, 0.390000, 0.710000);
	setPropForOneAtom("Tellurium", "Te", 52, 1.470000, 1.378000, 2.060000, 2, 127.599998, 2.100000, 0.830000, 0.480000, 0.000000);
	setPropForOneAtom("Iodine", "I", 53, 1.400000, 1.387000, 2.150000, 1, 126.904472, 2.660000, 0.580000, 0.000000, 0.580000);
	setPropForOneAtom("Xenon", "Xe", 54, 1.980000, 1.980000, 2.160000, 0, 131.292999, 2.600000, 0.260000, 0.620000, 0.690000);
	setPropForOneAtom("Cesium", "Cs", 55, 1.670000, 2.350000, 1.700000, 1, 132.905457, 0.790000, 0.340000, 0.090000, 0.560000);
	setPropForOneAtom("Barium", "Ba", 56, 1.340000, 1.980000, 1.700000, 2, 137.326996, 0.890000, 0.000000, 0.790000, 0.000000);
	setPropForOneAtom("Lanthanum", "La", 57, 1.870000, 1.690000, 1.700000, 12, 138.905502, 1.100000, 0.440000, 0.830000, 1.000000);
	setPropForOneAtom("Cerium", "Ce", 58, 1.830000, 1.830000, 1.700000, 6, 140.115997, 1.120000, 1.000000, 1.000000, 0.780000);
	setPropForOneAtom("Praseodymium", "Pr", 59, 1.820000, 1.820000, 1.700000, 6, 140.907654, 1.130000, 0.850000, 1.000000, 0.780000);
	setPropForOneAtom("Neodymium", "Nd", 60, 1.810000, 1.810000, 1.700000, 6, 144.240005, 1.140000, 0.780000, 1.000000, 0.780000);
	setPropForOneAtom("Promethium", "Pm", 61, 1.800000, 1.800000, 1.700000, 6, 145.000000, 1.130000, 0.640000, 1.000000, 0.780000);
	setPropForOneAtom("Samarium", "Sm", 62, 1.800000, 1.800000, 1.700000, 6, 150.360001, 1.170000, 0.560000, 1.000000, 0.780000);
	setPropForOneAtom("Europium", "Eu", 63, 1.990000, 1.990000, 1.700000, 6, 151.964005, 1.200000, 0.380000, 1.000000, 0.780000);
	setPropForOneAtom("Gadolinium", "Gd", 64, 1.790000, 1.790000, 1.700000, 6, 157.250000, 1.200000, 0.270000, 1.000000, 0.780000);
	setPropForOneAtom("Terbium", "Tb", 65, 1.760000, 1.760000, 1.700000, 6, 158.925339, 1.100000, 0.190000, 1.000000, 0.780000);
	setPropForOneAtom("Dysprosium", "Dy", 66, 1.750000, 1.750000, 1.700000, 6, 162.500000, 1.220000, 0.120000, 1.000000, 0.780000);
	setPropForOneAtom("Holmium", "Ho", 67, 1.740000, 1.740000, 1.700000, 6, 164.930313, 1.230000, 0.000000, 1.000000, 0.610000);
	setPropForOneAtom("Erbium", "Er", 68, 1.730000, 1.730000, 1.700000, 6, 167.259003, 1.240000, 0.000000, 0.900000, 0.460000);
	setPropForOneAtom("Thulium", "Tm", 69, 1.720000, 1.720000, 1.700000, 6, 168.934204, 1.250000, 0.000000, 0.830000, 0.320000);
	setPropForOneAtom("Ytterbium", "Yb", 70, 1.940000, 1.940000, 1.700000, 6, 173.039993, 1.100000, 0.000000, 0.750000, 0.220000);
	setPropForOneAtom("Lutetium", "Lu", 71, 1.720000, 1.720000, 1.700000, 6, 174.966995, 1.270000, 0.000000, 0.670000, 0.140000);
	setPropForOneAtom("Hafnium", "Hf", 72, 1.570000, 1.440000, 1.700000, 6, 178.490005, 1.300000, 0.300000, 0.760000, 1.000000);
	setPropForOneAtom("Tantalum", "Ta", 73, 1.430000, 1.340000, 1.700000, 6, 180.947906, 1.500000, 0.300000, 0.650000, 1.000000);
	setPropForOneAtom("Tungsten", "W", 74, 1.370000, 1.300000, 1.700000, 6, 183.839996, 2.360000, 0.130000, 0.580000, 0.840000);
	setPropForOneAtom("Rhenium", "Re", 75, 1.350000, 1.280000, 1.700000, 6, 186.207001, 1.900000, 0.150000, 0.490000, 0.670000);
	setPropForOneAtom("Osmium", "Os", 76, 1.370000, 1.260000, 1.700000, 6, 190.229996, 2.200000, 0.150000, 0.400000, 0.590000);
	setPropForOneAtom("Iridium", "Ir", 77, 1.320000, 1.270000, 1.700000, 6, 192.216995, 2.200000, 0.090000, 0.330000, 0.530000);
	setPropForOneAtom("Platinum", "Pt", 78, 1.500000, 1.300000, 1.720000, 6, 195.078003, 2.280000, 0.960000, 0.930000, 0.820000);
	setPropForOneAtom("Gold", "Au", 79, 1.500000, 1.340000, 1.660000, 6, 196.966553, 2.540000, 0.800000, 0.820000, 0.120000);
	setPropForOneAtom("Mercury", "Hg", 80, 1.700000, 1.490000, 1.550000, 6, 200.589996, 2.000000, 0.710000, 0.710000, 0.760000);
	setPropForOneAtom("Thallium", "Tl", 81, 1.550000, 1.480000, 1.960000, 3, 204.383301, 2.040000, 0.650000, 0.330000, 0.300000);
	setPropForOneAtom("Lead", "Pb", 82, 1.540000, 1.480000, 2.020000, 4, 207.199997, 2.330000, 0.340000, 0.350000, 0.380000);
	setPropForOneAtom("Bismuth", "Bi", 83, 1.540000, 1.450000, 1.700000, 3, 208.980377, 2.020000, 0.620000, 0.310000, 0.710000);
	setPropForOneAtom("Polonium", "Po", 84, 1.680000, 1.460000, 1.700000, 2, 209.000000, 2.000000, 0.670000, 0.360000, 0.000000);
	setPropForOneAtom("Astatine", "At", 85, 1.700000, 1.450000, 1.700000, 1, 210.000000, 2.200000, 0.460000, 0.310000, 0.270000);
	setPropForOneAtom("Radon", "Rn", 86, 2.400000, 2.400000, 1.700000, 0, 222.000000, 0.000000, 0.260000, 0.510000, 0.590000);
	setPropForOneAtom("Francium", "Fr", 87, 2.000000, 2.000000, 1.700000, 1, 223.000000, 0.700000, 0.260000, 0.000000, 0.400000);
	setPropForOneAtom(" radium", "Ra", 88, 1.900000, 1.900000, 1.700000, 2, 226.000000, 0.890000, 0.000000, 0.490000, 0.000000);
	setPropForOneAtom("Actinium", "Ac", 89, 1.880000, 1.880000, 1.700000, 6, 227.000000, 1.100000, 0.440000, 0.670000, 0.980000);
	setPropForOneAtom("Thorium", "Th", 90, 1.790000, 1.790000, 1.700000, 6, 232.038101, 1.300000, 0.000000, 0.730000, 1.000000);
	setPropForOneAtom("Protactinium", "Pa", 91, 1.610000, 1.610000, 1.700000, 6, 231.035873, 1.500000, 0.000000, 0.630000, 1.000000);
	setPropForOneAtom("Uranium", "U", 92, 1.580000, 1.580000, 1.860000, 6, 238.028915, 1.380000, 0.000000, 0.560000, 1.000000);
	setPropForOneAtom("Neptunium", "Np", 93, 1.550000, 1.550000, 1.700000, 6, 237.000000, 1.360000, 0.000000, 0.500000, 1.000000);
	setPropForOneAtom("Plutionium", "Pu", 94, 1.530000, 1.530000, 1.700000, 6, 244.000000, 1.280000, 0.000000, 0.420000, 1.000000);
	setPropForOneAtom("Americium", "Am", 95, 1.510000, 1.070000, 1.700000, 6, 243.000000, 1.300000, 0.330000, 0.360000, 0.950000);
	setPropForOneAtom("Curium", "Cm", 96, 1.500000, 0.000000, 1.700000, 6, 247.000000, 1.300000, 0.470000, 0.360000, 0.890000);
	setPropForOneAtom("Berkelium", "Bk", 97, 1.500000, 0.000000, 1.700000, 6, 247.000000, 1.300000, 0.540000, 0.310000, 0.890000);
	setPropForOneAtom("Californium", "Cf", 98, 1.500000, 0.000000, 1.700000, 6, 251.000000, 1.300000, 0.630000, 0.210000, 0.830000);
	setPropForOneAtom("Einsteinium", "Es", 99, 1.500000, 0.000000, 1.700000, 6, 252.000000, 1.300000, 0.700000, 0.120000, 0.830000);
	setPropForOneAtom("Fermium", "Fm", 100, 1.500000, 0.000000, 1.700000, 6, 257.000000, 1.300000, 0.700000, 0.120000, 0.730000);
	setPropForOneAtom("Mendelevium", "Md", 101, 1.500000, 0.000000, 1.700000, 6, 258.000000, 1.300000, 0.700000, 0.050000, 0.650000);
	setPropForOneAtom("Nobelium", "No", 102, 1.500000, 0.000000, 1.700000, 6, 259.000000, 1.300000, 0.740000, 0.050000, 0.530000);
	setPropForOneAtom("Lawrencium", "Lr", 103, 1.500000, 0.000000, 1.700000, 6, 262.000000, 1.300000, 0.780000, 0.000000, 0.400000);
	setPropForOneAtom("Rutherfordium", "Rf", 104, 1.600000, 0.000000, 1.700000, 6, 261.000000, 0.000000, 0.800000, 0.000000, 0.350000);
	setPropForOneAtom("Dubnium", "Db", 105, 1.600000, 0.000000, 1.700000, 6, 262.000000, 0.000000, 0.820000, 0.000000, 0.310000);
	setPropForOneAtom("Seaborgium", "Sg", 106, 1.600000, 0.000000, 1.700000, 6, 263.000000, 0.000000, 0.850000, 0.000000, 0.270000);
	setPropForOneAtom("Bohrium", "Bh", 107, 1.600000, 0.000000, 1.700000, 6, 264.000000, 0.000000, 0.880000, 0.000000, 0.220000);
	setPropForOneAtom("Hassium", "Hs", 108, 1.600000, 0.000000, 1.700000, 6, 265.000000, 0.000000, 0.900000, 0.000000, 0.180000);
	setPropForOneAtom("Meitnerium", "Mt", 109, 1.600000, 0.000000, 1.700000, 6, 268.000000, 0.000000, 0.920000, 0.000000, 0.150000);
	setPropForOneAtom("Dummy", "Xx", 0, 0.000000, 0.000000, 0.000000, 0, 1.000000, 0.000000, 0.070000, 0.500000, 0.700000);
	setPropForOneAtom("Dummy", "X", 0, 0.000000, 0.000000, 0.000000, 0, 1.000000, 0.000000, 0.070000, 0.500000, 0.700000);
	setPropForOneAtom("Tv", "Tv", 110, 0.000000, 0.000000, 0.000000, 0, 1.000000, 0.000000, 0.070000, 0.500000, 0.700000);
	addIsotopeToAtom("H", 1, 1,     1.007825032100,    99.98850000);
	addIsotopeToAtom("H", 1, 2,     2.014101778000,     0.01150000);
	addIsotopeToAtom("H", 1, 3,     3.016049267500,     0.00000000);
	addIsotopeToAtom("He", 2, 4,     4.002603249700,    99.99986300);
	addIsotopeToAtom("He", 2, 3,     3.016029309700,     0.00013700);
	addIsotopeToAtom("Li", 3, 7,     7.016004000000,    92.41000000);
	addIsotopeToAtom("Li", 3, 6,     6.015122300000,     7.59000000);
	addIsotopeToAtom("Be", 4, 9,     9.012182100000,   100.00000000);
	addIsotopeToAtom("B", 5, 11,    11.009305500000,    80.10000000);
	addIsotopeToAtom("B", 5, 10,    10.012937000000,    19.90000000);
	addIsotopeToAtom("C", 6, 12,    12.000000000000,    98.93000000);
	addIsotopeToAtom("C", 6, 13,    13.003354837800,     1.07000000);
	addIsotopeToAtom("C", 6, 14,    14.003241988000,     0.00000000);
	addIsotopeToAtom("N", 7, 14,    14.003074005200,    99.63200000);
	addIsotopeToAtom("N", 7, 15,    15.000108898400,     0.36800000);
	addIsotopeToAtom("O", 8, 16,    15.994914622100,    99.75700000);
	addIsotopeToAtom("O", 8, 18,    17.999160400000,     0.20500000);
	addIsotopeToAtom("O", 8, 17,    16.999131500000,     0.03800000);
	addIsotopeToAtom("F", 9, 19,    18.998403200000,   100.00000000);
	addIsotopeToAtom("Ne", 10, 20,    19.992440175900,    90.48000000);
	addIsotopeToAtom("Ne", 10, 22,    21.991385510000,     9.25000000);
	addIsotopeToAtom("Ne", 10, 21,    20.993846740000,     0.27000000);
	addIsotopeToAtom("Na", 11, 23,    22.989769670000,   100.00000000);
	addIsotopeToAtom("Mg", 12, 24,    23.985041900000,    78.99000000);
	addIsotopeToAtom("Mg", 12, 26,    25.982593040000,    11.01000000);
	addIsotopeToAtom("Mg", 12, 25,    24.985837020000,    10.00000000);
	addIsotopeToAtom("Al", 13, 27,    26.981538440000,   100.00000000);
	addIsotopeToAtom("Si", 14, 28,    27.976926532700,    92.22970000);
	addIsotopeToAtom("Si", 14, 29,    28.976494720000,     4.68320000);
	addIsotopeToAtom("Si", 14, 30,    29.973770220000,     3.08720000);
	addIsotopeToAtom("P", 15, 31,    30.973761510000,   100.00000000);
	addIsotopeToAtom("S", 16, 32,    31.972070690000,    94.93000000);
	addIsotopeToAtom("S", 16, 34,    33.967866830000,     4.29000000);
	addIsotopeToAtom("S", 16, 33,    32.971458500000,     0.76000000);
	addIsotopeToAtom("S", 16, 36,    35.967080880000,     0.02000000);
	addIsotopeToAtom("Cl", 17, 35,    34.968852710000,    75.78000000);
	addIsotopeToAtom("Cl", 17, 37,    36.965902600000,    24.22000000);
	addIsotopeToAtom("Ar", 18, 40,    39.962383123000,    99.60030000);
	addIsotopeToAtom("Ar", 18, 36,    35.967546280000,     0.33650000);
	addIsotopeToAtom("Ar", 18, 38,    37.962732200000,     0.06320000);
	addIsotopeToAtom("K", 19, 39,    38.963706900000,    93.25810000);
	addIsotopeToAtom("K", 19, 41,    40.961825970000,     6.73020000);
	addIsotopeToAtom("K", 19, 40,    39.963998670000,     0.01170000);
	addIsotopeToAtom("Ca", 20, 40,    39.962591200000,    96.94100000);
	addIsotopeToAtom("Ca", 20, 44,    43.955481100000,     2.08600000);
	addIsotopeToAtom("Ca", 20, 42,    41.958618300000,     0.64700000);
	addIsotopeToAtom("Ca", 20, 48,    47.952534000000,     0.18700000);
	addIsotopeToAtom("Ca", 20, 43,    42.958766800000,     0.13500000);
	addIsotopeToAtom("Ca", 20, 46,    45.953692800000,     0.00400000);
	addIsotopeToAtom("Sc", 21, 45,    44.955910200000,   100.00000000);
	addIsotopeToAtom("Ti", 22, 48,    47.947947100000,    73.72000000);
	addIsotopeToAtom("Ti", 22, 46,    45.952629500000,     8.25000000);
	addIsotopeToAtom("Ti", 22, 47,    46.951763800000,     7.44000000);
	addIsotopeToAtom("Ti", 22, 49,    48.947870800000,     5.41000000);
	addIsotopeToAtom("Ti", 22, 50,    49.944792100000,     5.18000000);
	addIsotopeToAtom("V", 23, 51,    50.943963700000,    99.75000000);
	addIsotopeToAtom("V", 23, 50,    49.947162800000,     0.25000000);
	addIsotopeToAtom("Cr", 24, 52,    51.940511900000,    83.78900000);
	addIsotopeToAtom("Cr", 24, 53,    52.940653800000,     9.50100000);
	addIsotopeToAtom("Cr", 24, 50,    49.946049600000,     4.34500000);
	addIsotopeToAtom("Cr", 24, 54,    53.938884900000,     2.36500000);
	addIsotopeToAtom("Mn", 25, 55,    54.938049600000,   100.00000000);
	addIsotopeToAtom("Fe", 26, 56,    55.934942100000,    91.75400000);
	addIsotopeToAtom("Fe", 26, 54,    53.939614800000,     5.84500000);
	addIsotopeToAtom("Fe", 26, 57,    56.935398700000,     2.11900000);
	addIsotopeToAtom("Fe", 26, 58,    57.933280500000,     0.28200000);
	addIsotopeToAtom("Co", 27, 59,    58.933200200000,   100.00000000);
	addIsotopeToAtom("Ni", 28, 58,    57.935347900000,    68.07690000);
	addIsotopeToAtom("Ni", 28, 60,    59.930790600000,    26.22310000);
	addIsotopeToAtom("Ni", 28, 62,    61.928348800000,     3.63450000);
	addIsotopeToAtom("Ni", 28, 61,    60.931060400000,     1.13990000);
	addIsotopeToAtom("Ni", 28, 64,    63.927969600000,     0.92560000);
	addIsotopeToAtom("Cu", 29, 63,    62.929601100000,    69.17000000);
	addIsotopeToAtom("Cu", 29, 65,    64.927793700000,    30.83000000);
	addIsotopeToAtom("Zn", 30, 64,    63.929146600000,    48.63000000);
	addIsotopeToAtom("Zn", 30, 66,    65.926036800000,    27.90000000);
	addIsotopeToAtom("Zn", 30, 68,    67.924847600000,    18.75000000);
	addIsotopeToAtom("Zn", 30, 67,    66.927130900000,     4.10000000);
	addIsotopeToAtom("Zn", 30, 70,    69.925325000000,     0.62000000);
	addIsotopeToAtom("Ga", 31, 69,    68.925581000000,    60.10800000);
	addIsotopeToAtom("Ga", 31, 71,    70.924705000000,    39.89200000);
	addIsotopeToAtom("Ge", 32, 74,    73.921178200000,    36.28000000);
	addIsotopeToAtom("Ge", 32, 72,    71.922076200000,    27.54000000);
	addIsotopeToAtom("Ge", 32, 70,    69.924250400000,    20.84000000);
	addIsotopeToAtom("Ge", 32, 73,    72.923459400000,     7.73000000);
	addIsotopeToAtom("Ge", 32, 76,    75.921402700000,     7.61000000);
	addIsotopeToAtom("As", 33, 75,    74.921596400000,   100.00000000);
	addIsotopeToAtom("Se", 34, 80,    79.916521800000,    49.61000000);
	addIsotopeToAtom("Se", 34, 78,    77.917309500000,    23.77000000);
	addIsotopeToAtom("Se", 34, 76,    75.919214100000,     9.37000000);
	addIsotopeToAtom("Se", 34, 82,    81.916700000000,     8.73000000);
	addIsotopeToAtom("Se", 34, 77,    76.919914600000,     7.63000000);
	addIsotopeToAtom("Se", 34, 74,    73.922476600000,     0.89000000);
	addIsotopeToAtom("Br", 35, 79,    78.918337600000,    50.69000000);
	addIsotopeToAtom("Br", 35, 81,    80.916291000000,    49.31000000);
	addIsotopeToAtom("Kr", 36, 84,    83.911507000000,    57.00000000);
	addIsotopeToAtom("Kr", 36, 86,    85.910610300000,    17.30000000);
	addIsotopeToAtom("Kr", 36, 82,    81.913484600000,    11.58000000);
	addIsotopeToAtom("Kr", 36, 83,    82.914136000000,    11.49000000);
	addIsotopeToAtom("Kr", 36, 80,    79.916378000000,     2.28000000);
	addIsotopeToAtom("Kr", 36, 78,    77.920386000000,     0.35000000);
	addIsotopeToAtom("Rb", 37, 85,    84.911789300000,    72.17000000);
	addIsotopeToAtom("Rb", 37, 87,    86.909183500000,    27.83000000);
	addIsotopeToAtom("Sr", 38, 88,    87.905614300000,    82.58000000);
	addIsotopeToAtom("Sr", 38, 86,    85.909262400000,     9.86000000);
	addIsotopeToAtom("Sr", 38, 87,    86.908879300000,     7.00000000);
	addIsotopeToAtom("Sr", 38, 84,    83.913425000000,     0.56000000);
	addIsotopeToAtom("Y", 39, 89,    88.905847900000,   100.00000000);
	addIsotopeToAtom("Zr", 40, 90,    89.904703700000,    51.45000000);
	addIsotopeToAtom("Zr", 40, 94,    93.906315800000,    17.38000000);
	addIsotopeToAtom("Zr", 40, 92,    91.905040100000,    17.15000000);
	addIsotopeToAtom("Zr", 40, 91,    90.905645000000,    11.22000000);
	addIsotopeToAtom("Zr", 40, 96,    95.908276000000,     2.80000000);
	addIsotopeToAtom("Nb", 41, 93,    92.906377500000,   100.00000000);
	addIsotopeToAtom("Mo", 42, 98,    97.905407800000,    24.13000000);
	addIsotopeToAtom("Mo", 42, 96,    95.904678900000,    16.68000000);
	addIsotopeToAtom("Mo", 42, 95,    94.905841500000,    15.92000000);
	addIsotopeToAtom("Mo", 42, 92,    91.906810000000,    14.84000000);
	addIsotopeToAtom("Mo", 42, 100,    99.907477000000,     9.63000000);
	addIsotopeToAtom("Mo", 42, 97,    96.906021000000,     9.55000000);
	addIsotopeToAtom("Mo", 42, 94,    93.905087600000,     9.25000000);
	addIsotopeToAtom("Tc", 43, 97,    96.906365000000,    33.33333333);
	addIsotopeToAtom("Tc", 43, 98,    97.907216000000,    33.33333333);
	addIsotopeToAtom("Tc", 43, 99,    98.906254600000,    33.33333333);
	addIsotopeToAtom("Ru", 44, 102,   101.904349500000,    31.55000000);
	addIsotopeToAtom("Ru", 44, 104,   103.905430000000,    18.62000000);
	addIsotopeToAtom("Ru", 44, 101,   100.905582200000,    17.06000000);
	addIsotopeToAtom("Ru", 44, 99,    98.905939300000,    12.76000000);
	addIsotopeToAtom("Ru", 44, 100,    99.904219700000,    12.60000000);
	addIsotopeToAtom("Ru", 44, 96,    95.907598000000,     5.54000000);
	addIsotopeToAtom("Ru", 44, 98,    97.905287000000,     1.87000000);
	addIsotopeToAtom("Rh", 45, 103,   102.905504000000,   100.00000000);
	addIsotopeToAtom("Pd", 46, 106,   105.903483000000,    27.33000000);
	addIsotopeToAtom("Pd", 46, 108,   107.903894000000,    26.46000000);
	addIsotopeToAtom("Pd", 46, 105,   104.905084000000,    22.33000000);
	addIsotopeToAtom("Pd", 46, 110,   109.905152000000,    11.72000000);
	addIsotopeToAtom("Pd", 46, 104,   103.904035000000,    11.14000000);
	addIsotopeToAtom("Pd", 46, 102,   101.905608000000,     1.02000000);
	addIsotopeToAtom("Ag", 47, 107,   106.905093000000,    51.83900000);
	addIsotopeToAtom("Ag", 47, 109,   108.904756000000,    48.16100000);
	addIsotopeToAtom("Cd", 48, 114,   113.903358100000,    28.73000000);
	addIsotopeToAtom("Cd", 48, 112,   111.902757200000,    24.13000000);
	addIsotopeToAtom("Cd", 48, 111,   110.904182000000,    12.80000000);
	addIsotopeToAtom("Cd", 48, 110,   109.903006000000,    12.49000000);
	addIsotopeToAtom("Cd", 48, 113,   112.904400900000,    12.22000000);
	addIsotopeToAtom("Cd", 48, 116,   115.904755000000,     7.49000000);
	addIsotopeToAtom("Cd", 48, 106,   105.906458000000,     1.25000000);
	addIsotopeToAtom("Cd", 48, 108,   107.904183000000,     0.89000000);
	addIsotopeToAtom("In", 49, 115,   114.903878000000,    95.71000000);
	addIsotopeToAtom("In", 49, 113,   112.904061000000,     4.29000000);
	addIsotopeToAtom("Sn", 50, 120,   119.902196600000,    32.58000000);
	addIsotopeToAtom("Sn", 50, 118,   117.901606000000,    24.22000000);
	addIsotopeToAtom("Sn", 50, 116,   115.901744000000,    14.54000000);
	addIsotopeToAtom("Sn", 50, 119,   118.903309000000,     8.59000000);
	addIsotopeToAtom("Sn", 50, 117,   116.902954000000,     7.68000000);
	addIsotopeToAtom("Sn", 50, 124,   123.905274600000,     5.79000000);
	addIsotopeToAtom("Sn", 50, 122,   121.903440100000,     4.63000000);
	addIsotopeToAtom("Sn", 50, 112,   111.904821000000,     0.97000000);
	addIsotopeToAtom("Sn", 50, 114,   113.902782000000,     0.66000000);
	addIsotopeToAtom("Sn", 50, 115,   114.903346000000,     0.34000000);
	addIsotopeToAtom("Sb", 51, 121,   120.903818000000,    57.21000000);
	addIsotopeToAtom("Sb", 51, 123,   122.904215700000,    42.79000000);
	addIsotopeToAtom("Te", 52, 130,   129.906222800000,    34.08000000);
	addIsotopeToAtom("Te", 52, 128,   127.904461400000,    31.74000000);
	addIsotopeToAtom("Te", 52, 126,   125.903305500000,    18.84000000);
	addIsotopeToAtom("Te", 52, 125,   124.904424700000,     7.07000000);
	addIsotopeToAtom("Te", 52, 124,   123.902819500000,     4.74000000);
	addIsotopeToAtom("Te", 52, 122,   121.903047100000,     2.55000000);
	addIsotopeToAtom("Te", 52, 123,   122.904273000000,     0.89000000);
	addIsotopeToAtom("Te", 52, 120,   119.904020000000,     0.09000000);
	addIsotopeToAtom("I", 53, 127,   126.904468000000,   100.00000000);
	addIsotopeToAtom("Xe", 54, 132,   131.904154500000,    26.89000000);
	addIsotopeToAtom("Xe", 54, 129,   128.904779500000,    26.44000000);
	addIsotopeToAtom("Xe", 54, 131,   130.905081900000,    21.18000000);
	addIsotopeToAtom("Xe", 54, 134,   133.905394500000,    10.44000000);
	addIsotopeToAtom("Xe", 54, 136,   135.907220000000,     8.87000000);
	addIsotopeToAtom("Xe", 54, 130,   129.903507900000,     4.08000000);
	addIsotopeToAtom("Xe", 54, 128,   127.903530400000,     1.92000000);
	addIsotopeToAtom("Xe", 54, 126,   125.904269000000,     0.09000000);
	addIsotopeToAtom("Xe", 54, 124,   123.905895800000,     0.09000000);
	addIsotopeToAtom("Cs", 55, 133,   132.905447000000,   100.00000000);
	addIsotopeToAtom("Ba", 56, 138,   137.905241000000,    71.69800000);
	addIsotopeToAtom("Ba", 56, 137,   136.905821000000,    11.23200000);
	addIsotopeToAtom("Ba", 56, 136,   135.904570000000,     7.85400000);
	addIsotopeToAtom("Ba", 56, 135,   134.905683000000,     6.59200000);
	addIsotopeToAtom("Ba", 56, 134,   133.904503000000,     2.41700000);
	addIsotopeToAtom("Ba", 56, 130,   129.906310000000,     0.10600000);
	addIsotopeToAtom("Ba", 56, 132,   131.905056000000,     0.10100000);
	addIsotopeToAtom("La", 57, 139,   138.906348000000,    99.91000000);
	addIsotopeToAtom("La", 57, 138,   137.907107000000,     0.09000000);
	addIsotopeToAtom("Ce", 58, 140,   139.905434000000,    88.45000000);
	addIsotopeToAtom("Ce", 58, 142,   141.909240000000,    11.11400000);
	addIsotopeToAtom("Ce", 58, 138,   137.905986000000,     0.25100000);
	addIsotopeToAtom("Ce", 58, 136,   135.907140000000,     0.18500000);
	addIsotopeToAtom("Pr", 59, 141,   140.907648000000,   100.00000000);
	addIsotopeToAtom("Nd", 60, 142,   141.907719000000,    27.20000000);
	addIsotopeToAtom("Nd", 60, 144,   143.910083000000,    23.80000000);
	addIsotopeToAtom("Nd", 60, 146,   145.913112000000,    17.20000000);
	addIsotopeToAtom("Nd", 60, 143,   142.909810000000,    12.20000000);
	addIsotopeToAtom("Nd", 60, 145,   144.912569000000,     8.30000000);
	addIsotopeToAtom("Nd", 60, 148,   147.916889000000,     5.70000000);
	addIsotopeToAtom("Nd", 60, 150,   149.920887000000,     5.60000000);
	addIsotopeToAtom("Pm", 61, 145,   144.912744000000,    50.00000000);
	addIsotopeToAtom("Pm", 61, 147,   146.915134000000,    50.00000000);
	addIsotopeToAtom("Sm", 62, 152,   151.919728000000,    26.75000000);
	addIsotopeToAtom("Sm", 62, 154,   153.922205000000,    22.75000000);
	addIsotopeToAtom("Sm", 62, 147,   146.914893000000,    14.99000000);
	addIsotopeToAtom("Sm", 62, 149,   148.917180000000,    13.82000000);
	addIsotopeToAtom("Sm", 62, 148,   147.914818000000,    11.24000000);
	addIsotopeToAtom("Sm", 62, 150,   149.917271000000,     7.38000000);
	addIsotopeToAtom("Sm", 62, 144,   143.911995000000,     3.07000000);
	addIsotopeToAtom("Eu", 63, 153,   152.921226000000,    52.19000000);
	addIsotopeToAtom("Eu", 63, 151,   150.919846000000,    47.81000000);
	addIsotopeToAtom("Gd", 64, 158,   157.924101000000,    24.84000000);
	addIsotopeToAtom("Gd", 64, 160,   159.927051000000,    21.86000000);
	addIsotopeToAtom("Gd", 64, 156,   155.922120000000,    20.47000000);
	addIsotopeToAtom("Gd", 64, 157,   156.923957000000,    15.65000000);
	addIsotopeToAtom("Gd", 64, 155,   154.922619000000,    14.80000000);
	addIsotopeToAtom("Gd", 64, 154,   153.920862000000,     2.18000000);
	addIsotopeToAtom("Gd", 64, 152,   151.919788000000,     0.20000000);
	addIsotopeToAtom("Tb", 65, 159,   158.925343000000,   100.00000000);
	addIsotopeToAtom("Dy", 66, 164,   163.929171000000,    28.18000000);
	addIsotopeToAtom("Dy", 66, 162,   161.926795000000,    25.51000000);
	addIsotopeToAtom("Dy", 66, 163,   162.928728000000,    24.90000000);
	addIsotopeToAtom("Dy", 66, 161,   160.926930000000,    18.91000000);
	addIsotopeToAtom("Dy", 66, 160,   159.925194000000,     2.34000000);
	addIsotopeToAtom("Dy", 66, 158,   157.924405000000,     0.10000000);
	addIsotopeToAtom("Dy", 66, 156,   155.924278000000,     0.06000000);
	addIsotopeToAtom("Ho", 67, 165,   164.930319000000,   100.00000000);
	addIsotopeToAtom("Er", 68, 166,   165.930290000000,    33.61000000);
	addIsotopeToAtom("Er", 68, 168,   167.932368000000,    26.78000000);
	addIsotopeToAtom("Er", 68, 167,   166.932045000000,    22.93000000);
	addIsotopeToAtom("Er", 68, 170,   169.935460000000,    14.93000000);
	addIsotopeToAtom("Er", 68, 164,   163.929197000000,     1.61000000);
	addIsotopeToAtom("Er", 68, 162,   161.928775000000,     0.14000000);
	addIsotopeToAtom("Tm", 69, 169,   168.934211000000,   100.00000000);
	addIsotopeToAtom("Yb", 70, 174,   173.938858100000,    31.83000000);
	addIsotopeToAtom("Yb", 70, 172,   171.936377700000,    21.83000000);
	addIsotopeToAtom("Yb", 70, 173,   172.938206800000,    16.13000000);
	addIsotopeToAtom("Yb", 70, 171,   170.936322000000,    14.28000000);
	addIsotopeToAtom("Yb", 70, 176,   175.942568000000,    12.76000000);
	addIsotopeToAtom("Yb", 70, 170,   169.934759000000,     3.04000000);
	addIsotopeToAtom("Yb", 70, 168,   167.933894000000,     0.13000000);
	addIsotopeToAtom("Lu", 71, 175,   174.940767900000,    97.41000000);
	addIsotopeToAtom("Lu", 71, 176,   175.942682400000,     2.59000000);
	addIsotopeToAtom("Hf", 72, 180,   179.946548800000,    35.08000000);
	addIsotopeToAtom("Hf", 72, 178,   177.943697700000,    27.28000000);
	addIsotopeToAtom("Hf", 72, 177,   176.943220000000,    18.60000000);
	addIsotopeToAtom("Hf", 72, 179,   178.945815100000,    13.62000000);
	addIsotopeToAtom("Hf", 72, 176,   175.941401800000,     5.26000000);
	addIsotopeToAtom("Hf", 72, 174,   173.940040000000,     0.16000000);
	addIsotopeToAtom("Ta", 73, 181,   180.947996000000,    99.98800000);
	addIsotopeToAtom("Ta", 73, 180,   179.947466000000,     0.01200000);
	addIsotopeToAtom("W", 74, 184,   183.950932600000,    30.64000000);
	addIsotopeToAtom("W", 74, 186,   185.954362000000,    28.43000000);
	addIsotopeToAtom("W", 74, 182,   181.948206000000,    26.50000000);
	addIsotopeToAtom("W", 74, 183,   182.950224500000,    14.31000000);
	addIsotopeToAtom("W", 74, 180,   179.946706000000,     0.12000000);
	addIsotopeToAtom("Re", 75, 187,   186.955750800000,    62.60000000);
	addIsotopeToAtom("Re", 75, 185,   184.952955700000,    37.40000000);
	addIsotopeToAtom("Os", 76, 192,   191.961479000000,    40.78000000);
	addIsotopeToAtom("Os", 76, 190,   189.958445000000,    26.26000000);
	addIsotopeToAtom("Os", 76, 189,   188.958144900000,    16.15000000);
	addIsotopeToAtom("Os", 76, 188,   187.955836000000,    13.24000000);
	addIsotopeToAtom("Os", 76, 187,   186.955747900000,     1.96000000);
	addIsotopeToAtom("Os", 76, 186,   185.953838000000,     1.59000000);
	addIsotopeToAtom("Os", 76, 184,   183.952491000000,     0.02000000);
	addIsotopeToAtom("Ir", 77, 193,   192.962924000000,    62.70000000);
	addIsotopeToAtom("Ir", 77, 191,   190.960591000000,    37.30000000);
	addIsotopeToAtom("Pt", 78, 195,   194.964774000000,    33.83200000);
	addIsotopeToAtom("Pt", 78, 194,   193.962664000000,    32.96700000);
	addIsotopeToAtom("Pt", 78, 196,   195.964935000000,    25.24200000);
	addIsotopeToAtom("Pt", 78, 198,   197.967876000000,     7.16300000);
	addIsotopeToAtom("Pt", 78, 192,   191.961035000000,     0.78200000);
	addIsotopeToAtom("Pt", 78, 190,   189.959930000000,     0.01400000);
	addIsotopeToAtom("Au", 79, 197,   196.966552000000,   100.00000000);
	addIsotopeToAtom("Hg", 80, 202,   201.970626000000,    29.86000000);
	addIsotopeToAtom("Hg", 80, 200,   199.968309000000,    23.10000000);
	addIsotopeToAtom("Hg", 80, 199,   198.968262000000,    16.87000000);
	addIsotopeToAtom("Hg", 80, 201,   200.970285000000,    13.18000000);
	addIsotopeToAtom("Hg", 80, 198,   197.966752000000,     9.97000000);
	addIsotopeToAtom("Hg", 80, 204,   203.973476000000,     6.87000000);
	addIsotopeToAtom("Hg", 80, 196,   195.965815000000,     0.15000000);
	addIsotopeToAtom("Tl", 81, 205,   204.974412000000,    70.47600000);
	addIsotopeToAtom("Tl", 81, 203,   202.972329000000,    29.52400000);
	addIsotopeToAtom("Pb", 82, 208,   207.976636000000,    52.40000000);
	addIsotopeToAtom("Pb", 82, 206,   205.974449000000,    24.10000000);
	addIsotopeToAtom("Pb", 82, 207,   206.975881000000,    22.10000000);
	addIsotopeToAtom("Pb", 82, 204,   203.973029000000,     1.40000000);
	addIsotopeToAtom("Bi", 83, 209,   208.980383000000,   100.00000000);
	addIsotopeToAtom("Po", 84, 209,   208.982416000000,    50.00000000);
	addIsotopeToAtom("Po", 84, 210,   209.982857000000,    50.00000000);
	addIsotopeToAtom("At", 85, 210,   209.987131000000,    50.00000000);
	addIsotopeToAtom("At", 85, 211,   210.987481000000,    50.00000000);
	addIsotopeToAtom("Rn", 86, 211,   210.990585000000,    33.33333333);
	addIsotopeToAtom("Rn", 86, 220,   220.011384100000,    33.33333333);
	addIsotopeToAtom("Rn", 86, 222,   222.017570500000,    33.33333333);
	addIsotopeToAtom("Fr", 87, 223,   223.019730700000,   100.00000000);
	addIsotopeToAtom("Ra", 88, 223,   223.018497000000,    25.00000000);
	addIsotopeToAtom("Ra", 88, 224,   224.020202000000,    25.00000000);
	addIsotopeToAtom("Ra", 88, 226,   226.025402600000,    25.00000000);
	addIsotopeToAtom("Ra", 88, 228,   228.031064100000,    25.00000000);
	addIsotopeToAtom("Ac", 89, 227,   227.027747000000,   100.00000000);
	addIsotopeToAtom("Th", 90, 232,   232.038050400000,   100.00000000);
	addIsotopeToAtom("Th", 90, 230,   230.033126600000,     0.00000000);
	addIsotopeToAtom("Pa", 91, 231,   231.035878900000,   100.00000000);
	addIsotopeToAtom("U", 92, 238,   238.050782600000,    99.27450000);
	addIsotopeToAtom("U", 92, 235,   235.043923100000,     0.72000000);
	addIsotopeToAtom("U", 92, 234,   234.040945600000,     0.00550000);
	addIsotopeToAtom("U", 92, 236,   236.045561900000,     0.00000000);
	addIsotopeToAtom("U", 92, 233,   233.039628000000,     0.00000000);
	addIsotopeToAtom("Np", 93, 237,   237.048167300000,    50.00000000);
	addIsotopeToAtom("Np", 93, 239,   239.052931400000,    50.00000000);
	addIsotopeToAtom("Pu", 94, 238,   238.049553400000,    16.66666667);
	addIsotopeToAtom("Pu", 94, 239,   239.052156500000,    16.66666667);
	addIsotopeToAtom("Pu", 94, 240,   240.053807500000,    16.66666667);
	addIsotopeToAtom("Pu", 94, 241,   241.056845300000,    16.66666667);
	addIsotopeToAtom("Pu", 94, 242,   242.058736800000,    16.66666667);
	addIsotopeToAtom("Pu", 94, 244,   244.064198000000,    16.66666667);
	addIsotopeToAtom("Am", 95, 241,   241.056822900000,    50.00000000);
	addIsotopeToAtom("Am", 95, 243,   243.061372700000,    50.00000000);
	addIsotopeToAtom("Cm", 96, 243,   243.061382200000,    16.66666667);
	addIsotopeToAtom("Cm", 96, 244,   244.062746300000,    16.66666667);
	addIsotopeToAtom("Cm", 96, 245,   245.065485600000,    16.66666667);
	addIsotopeToAtom("Cm", 96, 246,   246.067217600000,    16.66666667);
	addIsotopeToAtom("Cm", 96, 247,   247.070347000000,    16.66666667);
	addIsotopeToAtom("Cm", 96, 248,   248.072342000000,    16.66666667);
	addIsotopeToAtom("Bk", 97, 247,   247.070299000000,    50.00000000);
	addIsotopeToAtom("Bk", 97, 249,   249.074980000000,    50.00000000);
	addIsotopeToAtom("Cf", 98, 249,   249.074847000000,    25.00000000);
	addIsotopeToAtom("Cf", 98, 250,   250.076400000000,    25.00000000);
	addIsotopeToAtom("Cf", 98, 251,   251.079580000000,    25.00000000);
	addIsotopeToAtom("Cf", 98, 252,   252.081620000000,    25.00000000);
	addIsotopeToAtom("Es", 99, 252,   252.082970000000,   100.00000000);
	addIsotopeToAtom("Fm", 100, 257,   257.095099000000,   100.00000000);
	addIsotopeToAtom("Md", 101, 256,   256.094050000000,    50.00000000);
	addIsotopeToAtom("Md", 101, 258,   258.098425000000,    50.00000000);
	addIsotopeToAtom("No", 102, 259,   259.101020000000,   100.00000000);
	addIsotopeToAtom("Lr", 103, 262,   262.109690000000,   100.00000000);
	addIsotopeToAtom("Rf", 104, 261,   261.108750000000,   100.00000000);
	addIsotopeToAtom("Db", 105, 262,   262.114150000000,   100.00000000);
	addIsotopeToAtom("Sg", 106, 266,   266.121930000000,   100.00000000);
	addIsotopeToAtom("Bh", 107, 264,   264.124730000000,   100.00000000);
	addIsotopeToAtom("Hs", 108, 277,   277.000000000000,   100.00000000);
	addIsotopeToAtom("Mt", 109, 268,   268.138820000000,   100.00000000);
	addIsotopeToAtom("Uun", 110, 281,   281.000000000000,   100.00000000);
	addIsotopeToAtom("Uuu", 111, 272,   272.153480000000,   100.00000000);
	addIsotopeToAtom("Uub", 112, 285,   285.000000000000,   100.00000000);
	addIsotopeToAtom("Uuq", 114, 289,   289.000000000000,   100.00000000);
	addIsotopeToAtom("Uuh", 116, 292,   292.000000000000,   100.00000000);
}
/********************************************************************************/
char*** get_periodic_table()
{
	static const char *table0[PERIODIC_TABLE_N_COLUMNS][PERIODIC_TABLE_N_ROWS]={
		{"H" ,"Li","Na","K" ,"Rb","Cs","Fr","00","00","00"},
		{"00","Be","Mg","Ca","Sr","Ba","Ra","00","X","Tv"},
		{"00","00","00","Sc","Y" ,"La","Ac","00","00","00"},
		{"00","00","00","Ti","Zr","Hf","Rf","00","00","00"},
		{"00","00","00","V" ,"Nb","Ta","Db","Ce","Th","00"},
		{"00","00","00","Cr","Mo","W" ,"Sg","Pr","Pa","00"},
		{"00","00","00","Mn","Tc","Re","Bh","Nd","U" ,"00"},
		{"00","00","00","Fe","Ru","Os","Hs","Pm","Np","00"},
		{"00","00","00","Co","Rh","Ir","Mt","Sm","Pu","00"},
		{"00","00","00","Ni","Pd","Pt","00","Eu","Am","00"},
		{"00","00","00","Cu","Ag","Au","00","Gd","Cm","00"},
		{"00","00","00","Zn","Cd","Hg","00","Tb","Bk","00"},
		{"00","B" ,"Al","Ga","In","Tl","00","Dy","Cf","00"},
		{"00","C" ,"Si","Ge","Sn","Pb","00","Ho","Es","00"},
		{"00","N" ,"P" ,"As","Sb","Bi","00","Er","Fm","00"},
		{"00","O" ,"S" ,"Se","Te","Po","00","Tm","Md","00"},
		{"00","F" ,"Cl","Br","I" ,"At","00","Yb","No","00"},
		{"He","Ne","Ar","Kr","Xe","Rn","00","Lu","Lr","00"},
		};
	static char*** table = NULL;
	if(table == NULL)
	{
		int i;
		int j;
		table = malloc(PERIODIC_TABLE_N_COLUMNS*sizeof(char**));
		for(i=0;i<PERIODIC_TABLE_N_COLUMNS;i++)
		{
			table[i] = malloc(PERIODIC_TABLE_N_ROWS*sizeof(char*));
			for(j=0;j<PERIODIC_TABLE_N_ROWS;j++)
				table[i][j] = strdup(table0[i][j]);
		}
	}
	return table;
}
File: ./cchemilib/src/Utils/CreateDefaultPDBTpl.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* +CreateDefaultPDBTpl.c */
#include <stdlib.h>
#include <stdio.h>
#include <math.h>

#include "../Utils/Types.h"
#include "../Utils/Utils.h"
/************************************************************/
void createTitleResidueTpl(FILE* fout)
{
	fprintf(fout,"Begin Title\n");
	fprintf(fout,"	Residue        : PDB type atom  Amber type atom  charge of atom\n");
	fprintf(fout,"End\n");
}
/************************************************************/
void createListResidueTpl(FILE* fout)
{
	fprintf(fout,"Begin Residue List\n");
	fprintf(fout,"HOH\n");
	fprintf(fout,"T3P\n");
	fprintf(fout,"T3H\n");
	fprintf(fout,"T4P\n");
	fprintf(fout,"T4E\n");
	fprintf(fout,"T5P\n");
	fprintf(fout,"IB+\n");
	fprintf(fout,"Ca+\n");
	fprintf(fout,"Cl-\n");
	fprintf(fout,"Na+\n");
	fprintf(fout,"Mg+\n");
	fprintf(fout,"K+\n");
	fprintf(fout,"Rb+\n");
	fprintf(fout,"Cs+\n");
	fprintf(fout,"Li+\n");
	fprintf(fout,"Zn+\n");
	fprintf(fout,"Sr+\n");
	fprintf(fout,"Ba+\n");
	fprintf(fout,"URE\n");
	fprintf(fout,"ACE\n");
	fprintf(fout,"NME\n");
	fprintf(fout,"NHE\n");
	fprintf(fout,"NH2\n");
	fprintf(fout,"ALA\n");
	fprintf(fout,"GLY\n");
	fprintf(fout,"SER\n");
	fprintf(fout,"THR\n");
	fprintf(fout,"LEU\n");
	fprintf(fout,"ILE\n");
	fprintf(fout,"VAL\n");
	fprintf(fout,"ASN\n");
	fprintf(fout,"GLN\n");
	fprintf(fout,"ARG\n");
	fprintf(fout,"HID\n");
	fprintf(fout,"HIE\n");
	fprintf(fout,"HIP\n");
	fprintf(fout,"HIS\n");
	fprintf(fout,"TRP\n");
	fprintf(fout,"PHE\n");
	fprintf(fout,"TYR\n");
	fprintf(fout,"GLU\n");
	fprintf(fout,"ASP\n");
	fprintf(fout,"LYP\n");
	fprintf(fout,"ORN\n");
	fprintf(fout,"DAB\n");
	fprintf(fout,"LYS\n");
	fprintf(fout,"LYN\n");
	fprintf(fout,"PRO\n");
	fprintf(fout,"HYP\n");
	fprintf(fout,"CYS\n");
	fprintf(fout,"CYN\n");
	fprintf(fout,"CYM\n");
	fprintf(fout,"CYX\n");
	fprintf(fout,"CYS2\n");
	fprintf(fout,"MET\n");
	fprintf(fout,"ASH\n");
	fprintf(fout,"GLH\n");
	fprintf(fout,"CALA\n");
	fprintf(fout,"CGLY\n");
	fprintf(fout,"CSER\n");
	fprintf(fout,"CTHR\n");
	fprintf(fout,"CLEU\n");
	fprintf(fout,"CILE\n");
	fprintf(fout,"CVAL\n");
	fprintf(fout,"CASN\n");
	fprintf(fout,"CGLN\n");
	fprintf(fout,"CARG\n");
	fprintf(fout,"CHID\n");
	fprintf(fout,"CHIE\n");
	fprintf(fout,"CHIP\n");
	fprintf(fout,"CHIS\n");
	fprintf(fout,"CTRP\n");
	fprintf(fout,"CPHE\n");
	fprintf(fout,"CTYR\n");
	fprintf(fout,"CGLU\n");
	fprintf(fout,"CASP\n");
	fprintf(fout,"CLYP\n");
	fprintf(fout,"CLYS\n");
	fprintf(fout,"CPRO\n");
	fprintf(fout,"CCYS\n");
	fprintf(fout,"CCYN\n");
	fprintf(fout,"CCYX\n");
	fprintf(fout,"CCYM\n");
	fprintf(fout,"CMET\n");
	fprintf(fout,"CASH\n");
	fprintf(fout,"CGLH\n");
	fprintf(fout,"CLYN\n");
	fprintf(fout,"OALA\n");
	fprintf(fout,"OARG\n");
	fprintf(fout,"OASN\n");
	fprintf(fout,"OASP\n");
	fprintf(fout,"OCYS\n");
	fprintf(fout,"OCYX\n");
	fprintf(fout,"OGLN\n");
	fprintf(fout,"OGLU\n");
	fprintf(fout,"OGLY\n");
	fprintf(fout,"OHID\n");
	fprintf(fout,"OHIE\n");
	fprintf(fout,"OHIP\n");
	fprintf(fout,"OHIS\n");
	fprintf(fout,"OILE\n");
	fprintf(fout,"OLEU\n");
	fprintf(fout,"OLYS\n");
	fprintf(fout,"OMET\n");
	fprintf(fout,"OPHE\n");
	fprintf(fout,"OPRO\n");
	fprintf(fout,"OSER\n");
	fprintf(fout,"OTHR\n");
	fprintf(fout,"OTYR\n");
	fprintf(fout,"OTRP\n");
	fprintf(fout,"OVAL\n");
	fprintf(fout,"OASH\n");
	fprintf(fout,"OGLH\n");
	fprintf(fout,"OLYN\n");
	fprintf(fout,"OCYM\n");
	fprintf(fout,"NALA\n");
	fprintf(fout,"NGLY\n");
	fprintf(fout,"NSER\n");
	fprintf(fout,"NTHR\n");
	fprintf(fout,"NLEU\n");
	fprintf(fout,"NILE\n");
	fprintf(fout,"NVAL\n");
	fprintf(fout,"NASN\n");
	fprintf(fout,"NGLN\n");
	fprintf(fout,"NARG\n");
	fprintf(fout,"NHID\n");
	fprintf(fout,"NHIE\n");
	fprintf(fout,"NHIP\n");
	fprintf(fout,"NHIS\n");
	fprintf(fout,"NTRP\n");
	fprintf(fout,"NPHE\n");
	fprintf(fout,"NTYR\n");
	fprintf(fout,"NGLU\n");
	fprintf(fout,"NASP\n");
	fprintf(fout,"NLYP\n");
	fprintf(fout,"NLYS\n");
	fprintf(fout,"NPRO\n");
	fprintf(fout,"NCYS\n");
	fprintf(fout,"NCYN\n");
	fprintf(fout,"NCYM\n");
	fprintf(fout,"NCYX\n");
	fprintf(fout,"NMET\n");
	fprintf(fout,"NASH\n");
	fprintf(fout,"NGLH\n");
	fprintf(fout,"NLYN\n");
	fprintf(fout,"HALA\n");
	fprintf(fout,"HARG\n");
	fprintf(fout,"HASN\n");
	fprintf(fout,"HASP\n");
	fprintf(fout,"HCYS\n");
	fprintf(fout,"HCYX\n");
	fprintf(fout,"HGLN\n");
	fprintf(fout,"HGLU\n");
	fprintf(fout,"HGLY\n");
	fprintf(fout,"HHID\n");
	fprintf(fout,"HHIE\n");
	fprintf(fout,"HHIP\n");
	fprintf(fout,"HHIS\n");
	fprintf(fout,"HILE\n");
	fprintf(fout,"HLEU\n");
	fprintf(fout,"HLYS\n");
	fprintf(fout,"HMET\n");
	fprintf(fout,"HPHE\n");
	fprintf(fout,"HPRO\n");
	fprintf(fout,"HSER\n");
	fprintf(fout,"HTHR\n");
	fprintf(fout,"HTYR\n");
	fprintf(fout,"HTRP\n");
	fprintf(fout,"HVAL\n");
	fprintf(fout,"HASH\n");
	fprintf(fout,"HGLH\n");
	fprintf(fout,"HLYN\n");
	fprintf(fout,"HCYM\n");
	fprintf(fout,"ROH\n");
	fprintf(fout,"DA5\n");
	fprintf(fout,"DA\n");
	fprintf(fout,"DA3\n");
	fprintf(fout,"DAN\n");
	fprintf(fout,"RA5\n");
	fprintf(fout,"RA\n");
	fprintf(fout,"RA3\n");
	fprintf(fout,"RAN\n");
	fprintf(fout,"DT5\n");
	fprintf(fout,"DT\n");
	fprintf(fout,"DT3\n");
	fprintf(fout,"DTN\n");
	fprintf(fout,"RU5\n");
	fprintf(fout,"RU\n");
	fprintf(fout,"RU3\n");
	fprintf(fout,"RUN\n");
	fprintf(fout,"DG5\n");
	fprintf(fout,"DG\n");
	fprintf(fout,"DG3\n");
	fprintf(fout,"DGN\n");
	fprintf(fout,"RG5\n");
	fprintf(fout,"RG\n");
	fprintf(fout,"RG3\n");
	fprintf(fout,"RGN\n");
	fprintf(fout,"DC5\n");
	fprintf(fout,"DC\n");
	fprintf(fout,"DC3\n");
	fprintf(fout,"DCN\n");
	fprintf(fout,"RC5\n");
	fprintf(fout,"RC\n");
	fprintf(fout,"RC3\n");
	fprintf(fout,"RCN\n");

	fprintf(fout,"1MA\n");
	fprintf(fout,"1MG\n");
	fprintf(fout,"2MG\n");
	fprintf(fout,"5MC\n");
	fprintf(fout,"7MG\n");
	fprintf(fout,"H2U\n");
	fprintf(fout,"I\n");
	fprintf(fout,"M2G\n");
	fprintf(fout,"OMC\n");
	fprintf(fout,"OMG\n");
	fprintf(fout,"PSU\n");
	fprintf(fout,"Y\n");

	fprintf(fout,"GBZN\n");
	fprintf(fout,"GAPT\n");

	fprintf(fout,"ALLRESIDUE\n");
	fprintf(fout,"End\n");
}
/************************************************************/
void createAminoResidueTpl(FILE* fout)
{

	fprintf(fout,"Begin HOH Residue\n");
	fprintf(fout,"OW     OW     -0.834\n");
	fprintf(fout,"HW1    HW     0.417 \n");
	fprintf(fout,"HW2    HW     0.417 \n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin T3P Residue\n");
	fprintf(fout,"OW     OW     -0.834\n");
	fprintf(fout,"HW1    HW     0.417 \n");
	fprintf(fout,"HW2    HW     0.417 \n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin T3H Residue\n");
	fprintf(fout,"OW     OW     -0.834\n");
	fprintf(fout,"HW1    HW     0.417 \n");
	fprintf(fout,"HW2    HW     0.417 \n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin T4P Residue\n");
	fprintf(fout,"OW     OW     0.000 \n");
	fprintf(fout,"HW2    HW     0.520 \n");
	fprintf(fout,"HW3    HW     0.520 \n");
	fprintf(fout,"MW4    MW     -1.040\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin T4E Residue\n");
	fprintf(fout,"OW     OW     0.000 \n");
	fprintf(fout,"HW1    HW     0.52422\n");
	fprintf(fout,"HW2    HW     0.52422\n");
	fprintf(fout,"MW     MW     -1.04844\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin T5P Residue\n");
	fprintf(fout,"OW     OW     0.000 \n");
	fprintf(fout,"HW1    HW     0.241 \n");
	fprintf(fout,"HW2    HW     0.241 \n");
	fprintf(fout,"LP1    MW     -0.241\n");
	fprintf(fout,"LP2    MW     -0.241\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin IB+ Residue\n");
	fprintf(fout,"IB     IB     1.00000\n");
	fprintf(fout,"IB     IB     1.00000\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin Ca+ Residue\n");
	fprintf(fout,"Ca     Ca     2.00000\n");
	fprintf(fout,"Ca     Ca     2.00000\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin Cl- Residue\n");
	fprintf(fout,"Cl     Cl     -1.00000\n");
	fprintf(fout,"Cl     Cl     -1.00000\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin Na+ Residue\n");
	fprintf(fout,"Na     Na     1.00000\n");
	fprintf(fout,"Na     Na     1.00000\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin Mg+ Residue\n");
	fprintf(fout,"Mg     Mg     2.00000\n");
	fprintf(fout,"Mg     Mg     2.00000\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin K+ Residue\n");
	fprintf(fout,"K      K      1.00000\n");
	fprintf(fout,"K      K      1.00000\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin Rb+ Residue\n");
	fprintf(fout,"Rb     Rb     1.00000\n");
	fprintf(fout,"Rb     Rb     1.00000\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin Cs+ Residue\n");
	fprintf(fout,"CS     Cs     1.00000\n");
	fprintf(fout,"CS     Cs     1.00000\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin Li+ Residue\n");
	fprintf(fout,"Li     Li     1.00000\n");
	fprintf(fout,"Li     Li     1.00000\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin Zn+ Residue\n");
	fprintf(fout,"Zn     Zn     2.00000\n");
	fprintf(fout,"Zn     Zn     2.00000\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin Sr+ Residue\n");
	fprintf(fout,"Sr     Sr     2.00000\n");
	fprintf(fout,"Sr     Sr     2.00000\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin Ba+ Residue\n");
	fprintf(fout,"Ba     Ba     2.00000\n");
	fprintf(fout,"Ba     Ba     2.00000\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin URE Residue\n");
	fprintf(fout,"C      C      0.880229\n");
	fprintf(fout,"O      O      -0.613359\n");
	fprintf(fout,"N1     N      -0.923545\n");
	fprintf(fout,"H11    H      0.395055\n");
	fprintf(fout,"H12    H      0.395055\n");
	fprintf(fout,"N2     N      -0.923545\n");
	fprintf(fout,"H21    H      0.395055\n");
	fprintf(fout,"H22    H      0.395055\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin ACE Residue\n");
	fprintf(fout,"CH3    CT     -0.36620\n");
	fprintf(fout,"HH31   HC     0.11230\n");
	fprintf(fout,"HH32   HC     0.11230\n");
	fprintf(fout,"HH33   HC     0.11230\n");
	fprintf(fout,"C      C      0.59720\n");
	fprintf(fout,"O      O      -0.56790\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin NME Residue\n");
	fprintf(fout,"N      N      -0.41570\n");
	fprintf(fout,"H      H      0.27190\n");
	fprintf(fout,"CH3    CT     -0.14900\n");
	fprintf(fout,"HH31   H1     0.09760\n");
	fprintf(fout,"HH32   H1     0.09760\n");
	fprintf(fout,"HH33   H1     0.09760\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin NHE Residue\n");
	fprintf(fout,"N      N      -0.46300\n");
	fprintf(fout,"H1     H      0.23150\n");
	fprintf(fout,"H2     H      0.23150\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin NH2 Residue\n");
	fprintf(fout,"N      N      -0.46300\n");
	fprintf(fout,"H1     H      0.23150\n");
	fprintf(fout,"H2     H      0.23150\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin ALA Residue\n");
	fprintf(fout,"N      N      -0.41570\n");
	fprintf(fout,"H      H      0.27190\n");
	fprintf(fout,"CA     CT     0.03370\n");
	fprintf(fout,"HA     H1     0.08230\n");
	fprintf(fout,"CB     CT     -0.18250\n");
	fprintf(fout,"HB1    HC     0.06030\n");
	fprintf(fout,"HB2    HC     0.06030\n");
	fprintf(fout,"HB3    HC     0.06030\n");
	fprintf(fout,"C      C      0.59730\n");
	fprintf(fout,"O      O      -0.56790\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin GLY Residue\n");
	fprintf(fout,"N      N      -0.41570\n");
	fprintf(fout,"H      H      0.27190\n");
	fprintf(fout,"CA     CT     -0.02520\n");
	fprintf(fout,"HA1    H1     0.06980\n");
	fprintf(fout,"HA2    H1     0.06980\n");
	fprintf(fout,"C      C      0.59730\n");
	fprintf(fout,"O      O      -0.56790\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin SER Residue\n");
	fprintf(fout,"N      N      -0.41570\n");
	fprintf(fout,"H      H      0.27190\n");
	fprintf(fout,"CA     CT     -0.02490\n");
	fprintf(fout,"HA     H1     0.08430\n");
	fprintf(fout,"CB     CT     0.21170\n");
	fprintf(fout,"HB1    H1     0.03520\n");
	fprintf(fout,"HB2    H1     0.03520\n");
	fprintf(fout,"OG     OH     -0.65460\n");
	fprintf(fout,"HG     HO     0.42750\n");
	fprintf(fout,"C      C      0.59730\n");
	fprintf(fout,"O      O      -0.56790\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin THR Residue\n");
	fprintf(fout,"N      N      -0.41570\n");
	fprintf(fout,"H      H      0.27190\n");
	fprintf(fout,"CA     CT     -0.03890\n");
	fprintf(fout,"HA     H1     0.10070\n");
	fprintf(fout,"CB     CT     0.36540\n");
	fprintf(fout,"HB     H1     0.00430\n");
	fprintf(fout,"CG2    CT     -0.24380\n");
	fprintf(fout,"HG21   HC     0.06420\n");
	fprintf(fout,"HG22   HC     0.06420\n");
	fprintf(fout,"HG23   HC     0.06420\n");
	fprintf(fout,"OG1    OH     -0.67610\n");
	fprintf(fout,"HG1    HO     0.41020\n");
	fprintf(fout,"C      C      0.59730\n");
	fprintf(fout,"O      O      -0.56790\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin LEU Residue\n");
	fprintf(fout,"N      N      -0.41570\n");
	fprintf(fout,"H      H      0.27190\n");
	fprintf(fout,"CA     CT     -0.05180\n");
	fprintf(fout,"HA     H1     0.09220\n");
	fprintf(fout,"CB     CT     -0.11020\n");
	fprintf(fout,"HB1    HC     0.04570\n");
	fprintf(fout,"HB2    HC     0.04570\n");
	fprintf(fout,"CG     CT     0.35310\n");
	fprintf(fout,"HG     HC     -0.03610\n");
	fprintf(fout,"CD1    CT     -0.41210\n");
	fprintf(fout,"HD11   HC     0.10000\n");
	fprintf(fout,"HD12   HC     0.10000\n");
	fprintf(fout,"HD13   HC     0.10000\n");
	fprintf(fout,"CD2    CT     -0.41210\n");
	fprintf(fout,"HD21   HC     0.10000\n");
	fprintf(fout,"HD22   HC     0.10000\n");
	fprintf(fout,"HD23   HC     0.10000\n");
	fprintf(fout,"C      C      0.59730\n");
	fprintf(fout,"O      O      -0.56790\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin ILE Residue\n");
	fprintf(fout,"N      N      -0.41570\n");
	fprintf(fout,"H      H      0.27190\n");
	fprintf(fout,"CA     CT     -0.05970\n");
	fprintf(fout,"HA     H1     0.08690\n");
	fprintf(fout,"CB     CT     0.13030\n");
	fprintf(fout,"HB     HC     0.01870\n");
	fprintf(fout,"CG2    CT     -0.32040\n");
	fprintf(fout,"HG21   HC     0.08820\n");
	fprintf(fout,"HG22   HC     0.08820\n");
	fprintf(fout,"HG23   HC     0.08820\n");
	fprintf(fout,"CG1    CT     -0.04300\n");
	fprintf(fout,"HG11   HC     0.02360\n");
	fprintf(fout,"HG12   HC     0.02360\n");
	fprintf(fout,"CD     CT     -0.06600\n");
	fprintf(fout,"HD1    HC     0.01860\n");
	fprintf(fout,"HD2    HC     0.01860\n");
	fprintf(fout,"HD3    HC     0.01860\n");
	fprintf(fout,"CD1    CT     -0.06600\n");
	fprintf(fout,"HD1    HC     0.01860\n");
	fprintf(fout,"HD2    HC     0.01860\n");
	fprintf(fout,"HD3    HC     0.01860\n");
	fprintf(fout,"C      C      0.59730\n");
	fprintf(fout,"O      O      -0.56790\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin VAL Residue\n");
	fprintf(fout,"N      N      -0.41570\n");
	fprintf(fout,"H      H      0.27190\n");
	fprintf(fout,"CA     CT     -0.08750\n");
	fprintf(fout,"HA     H1     0.09690\n");
	fprintf(fout,"CB     CT     0.29850\n");
	fprintf(fout,"HB     HC     -0.02970\n");
	fprintf(fout,"CG1    CT     -0.31920\n");
	fprintf(fout,"HG11   HC     0.07910\n");
	fprintf(fout,"HG12   HC     0.07910\n");
	fprintf(fout,"HG13   HC     0.07910\n");
	fprintf(fout,"CG2    CT     -0.31920\n");
	fprintf(fout,"HG21   HC     0.07910\n");
	fprintf(fout,"HG22   HC     0.07910\n");
	fprintf(fout,"HG23   HC     0.07910\n");
	fprintf(fout,"C      C      0.59730\n");
	fprintf(fout,"O      O      -0.56790\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin ASN Residue\n");
	fprintf(fout,"N      N      -0.41570\n");
	fprintf(fout,"H      H      0.27190\n");
	fprintf(fout,"CA     CT     0.01430\n");
	fprintf(fout,"HA     H1     0.10480\n");
	fprintf(fout,"CB     CT     -0.20410\n");
	fprintf(fout,"HB1    HC     0.07970\n");
	fprintf(fout,"HB2    HC     0.07970\n");
	fprintf(fout,"CG     C      0.71300\n");
	fprintf(fout,"OD1    O      -0.59310\n");
	fprintf(fout,"ND2    N      -0.91910\n");
	fprintf(fout,"HD21   H      0.41960\n");
	fprintf(fout,"HD22   H      0.41960\n");
	fprintf(fout,"C      C      0.59730\n");
	fprintf(fout,"O      O      -0.56790\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin GLN Residue\n");
	fprintf(fout,"N      N      -0.41570\n");
	fprintf(fout,"H      H      0.27190\n");
	fprintf(fout,"CA     CT     -0.00310\n");
	fprintf(fout,"HA     H1     0.08500\n");
	fprintf(fout,"CB     CT     -0.00360\n");
	fprintf(fout,"HB1    HC     0.01710\n");
	fprintf(fout,"HB2    HC     0.01710\n");
	fprintf(fout,"CG     CT     -0.06450\n");
	fprintf(fout,"HG1    HC     0.03520\n");
	fprintf(fout,"HG2    HC     0.03520\n");
	fprintf(fout,"CD     C      0.69510\n");
	fprintf(fout,"OE1    O      -0.60860\n");
	fprintf(fout,"NE2    N      -0.94070\n");
	fprintf(fout,"HE21   H      0.42510\n");
	fprintf(fout,"HE22   H      0.42510\n");
	fprintf(fout,"C      C      0.59730\n");
	fprintf(fout,"O      O      -0.56790\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin ARG Residue\n");
	fprintf(fout,"N      N      -0.34790\n");
	fprintf(fout,"H      H      0.27470\n");
	fprintf(fout,"CA     CT     -0.26370\n");
	fprintf(fout,"HA     H1     0.15600\n");
	fprintf(fout,"CB     CT     -0.00070\n");
	fprintf(fout,"HB1    HC     0.03270\n");
	fprintf(fout,"HB2    HC     0.03270\n");
	fprintf(fout,"CG     CT     0.03900\n");
	fprintf(fout,"HG1    HC     0.02850\n");
	fprintf(fout,"HG2    HC     0.02850\n");
	fprintf(fout,"CD     CT     0.04860\n");
	fprintf(fout,"HD1    H1     0.06870\n");
	fprintf(fout,"HD2    H1     0.06870\n");
	fprintf(fout,"NE     N2     -0.52950\n");
	fprintf(fout,"HE     H      0.34560\n");
	fprintf(fout,"CZ     CA     0.80760\n");
	fprintf(fout,"NH1    N2     -0.86270\n");
	fprintf(fout,"HH11   H      0.44780\n");
	fprintf(fout,"HH12   H      0.44780\n");
	fprintf(fout,"NH2    N2     -0.86270\n");
	fprintf(fout,"HH21   H      0.44780\n");
	fprintf(fout,"HH22   H      0.44780\n");
	fprintf(fout,"C      C      0.73410\n");
	fprintf(fout,"O      O      -0.58940\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin HID Residue\n");
	fprintf(fout,"N      N      -0.41570\n");
	fprintf(fout,"H      H      0.27190\n");
	fprintf(fout,"CA     CT     0.01880\n");
	fprintf(fout,"HA     H1     0.08810\n");
	fprintf(fout,"CB     CT     -0.04620\n");
	fprintf(fout,"HB1    HC     0.04020\n");
	fprintf(fout,"HB2    HC     0.04020\n");
	fprintf(fout,"CG     CC     -0.02660\n");
	fprintf(fout,"ND1    NA     -0.38110\n");
	fprintf(fout,"HD1    H      0.36490\n");
	fprintf(fout,"CE1    CR     0.20570\n");
	fprintf(fout,"HE1    H5     0.13920\n");
	fprintf(fout,"NE2    NB     -0.57270\n");
	fprintf(fout,"CD2    CV     0.12920\n");
	fprintf(fout,"HD2    H4     0.11470\n");
	fprintf(fout,"C      C      0.59730\n");
	fprintf(fout,"O      O      -0.56790\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin HIE Residue\n");
	fprintf(fout,"N      N      -0.41570\n");
	fprintf(fout,"H      H      0.27190\n");
	fprintf(fout,"CA     CT     -0.05810\n");
	fprintf(fout,"HA     H1     0.13600\n");
	fprintf(fout,"CB     CT     -0.00740\n");
	fprintf(fout,"HB1    HC     0.03670\n");
	fprintf(fout,"HB2    HC     0.03670\n");
	fprintf(fout,"CG     CC     0.18680\n");
	fprintf(fout,"ND1    NB     -0.54320\n");
	fprintf(fout,"CE1    CR     0.16350\n");
	fprintf(fout,"HE1    H5     0.14350\n");
	fprintf(fout,"NE2    NA     -0.27950\n");
	fprintf(fout,"HE2    H      0.33390\n");
	fprintf(fout,"CD2    CW     -0.22070\n");
	fprintf(fout,"HD2    H4     0.18620\n");
	fprintf(fout,"C      C      0.59730\n");
	fprintf(fout,"O      O      -0.56790\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin HIP Residue\n");
	fprintf(fout,"N      N      -0.34790\n");
	fprintf(fout,"H      H      0.27470\n");
	fprintf(fout,"CA     CT     -0.13540\n");
	fprintf(fout,"HA     H1     0.12120\n");
	fprintf(fout,"CB     CT     -0.04140\n");
	fprintf(fout,"HB1    HC     0.08100\n");
	fprintf(fout,"HB2    HC     0.08100\n");
	fprintf(fout,"CG     CC     -0.00120\n");
	fprintf(fout,"ND1    NA     -0.15130\n");
	fprintf(fout,"HD1    H      0.38660\n");
	fprintf(fout,"CE1    CR     -0.01700\n");
	fprintf(fout,"HE1    H5     0.26810\n");
	fprintf(fout,"NE2    NA     -0.17180\n");
	fprintf(fout,"HE2    H      0.39110\n");
	fprintf(fout,"CD2    CW     -0.11410\n");
	fprintf(fout,"HD2    H4     0.23170\n");
	fprintf(fout,"C      C      0.73410\n");
	fprintf(fout,"O      O      -0.58940\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin HIS Residue\n");
	fprintf(fout,"N      N      -0.34790\n");
	fprintf(fout,"H      H      0.27470\n");
	fprintf(fout,"CA     CT     -0.13540\n");
	fprintf(fout,"HA     H1     0.12120\n");
	fprintf(fout,"CB     CT     -0.04140\n");
	fprintf(fout,"HB1    HC     0.08100\n");
	fprintf(fout,"HB2    HC     0.08100\n");
	fprintf(fout,"CG     CC     -0.00120\n");
	fprintf(fout,"ND1    NA     -0.15130\n");
	fprintf(fout,"HD1    H      0.38660\n");
	fprintf(fout,"CE1    CR     -0.01700\n");
	fprintf(fout,"HE1    H5     0.26810\n");
	fprintf(fout,"NE2    NA     -0.17180\n");
	fprintf(fout,"HE2    H      0.39110\n");
	fprintf(fout,"CD2    CW     -0.11410\n");
	fprintf(fout,"HD2    H4     0.23170\n");
	fprintf(fout,"C      C      0.73410\n");
	fprintf(fout,"O      O      -0.58940\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin TRP Residue\n");
	fprintf(fout,"N      N      -0.41570\n");
	fprintf(fout,"H      H      0.27190\n");
	fprintf(fout,"CA     CT     -0.02750\n");
	fprintf(fout,"HA     H1     0.11230\n");
	fprintf(fout,"CB     CT     -0.00500\n");
	fprintf(fout,"HB1    HC     0.03390\n");
	fprintf(fout,"HB2    HC     0.03390\n");
	fprintf(fout,"CG     C*     -0.14150\n");
	fprintf(fout,"CD1    CW     -0.16380\n");
	fprintf(fout,"HD1    H4     0.20620\n");
	fprintf(fout,"NE1    NA     -0.34180\n");
	fprintf(fout,"HE1    H      0.34120\n");
	fprintf(fout,"CE2    CN     0.13800\n");
	fprintf(fout,"CZ2    CA     -0.26010\n");
	fprintf(fout,"HZ2    HA     0.15720\n");
	fprintf(fout,"CH2    CA     -0.11340\n");
	fprintf(fout,"HH2    HA     0.14170\n");
	fprintf(fout,"CZ3    CA     -0.19720\n");
	fprintf(fout,"HZ3    HA     0.14470\n");
	fprintf(fout,"CE3    CA     -0.23870\n");
	fprintf(fout,"HE3    HA     0.17000\n");
	fprintf(fout,"CD2    CB     0.12430\n");
	fprintf(fout,"C      C      0.59730\n");
	fprintf(fout,"O      O      -0.56790\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin PHE Residue\n");
	fprintf(fout,"N      N      -0.41570\n");
	fprintf(fout,"H      H      0.27190\n");
	fprintf(fout,"CA     CT     -0.00240\n");
	fprintf(fout,"HA     H1     0.09780\n");
	fprintf(fout,"CB     CT     -0.03430\n");
	fprintf(fout,"HB1    HC     0.02950\n");
	fprintf(fout,"HB2    HC     0.02950\n");
	fprintf(fout,"CG     CA     0.01180\n");
	fprintf(fout,"CD1    CA     -0.12560\n");
	fprintf(fout,"HD1    HA     0.13300\n");
	fprintf(fout,"CE1    CA     -0.17040\n");
	fprintf(fout,"HE1    HA     0.14300\n");
	fprintf(fout,"CZ     CA     -0.10720\n");
	fprintf(fout,"HZ     HA     0.12970\n");
	fprintf(fout,"CE2    CA     -0.17040\n");
	fprintf(fout,"HE2    HA     0.14300\n");
	fprintf(fout,"CD2    CA     -0.12560\n");
	fprintf(fout,"HD2    HA     0.13300\n");
	fprintf(fout,"C      C      0.59730\n");
	fprintf(fout,"O      O      -0.56790\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin TYR Residue\n");
	fprintf(fout,"N      N      -0.41570\n");
	fprintf(fout,"H      H      0.27190\n");
	fprintf(fout,"CA     CT     -0.00140\n");
	fprintf(fout,"HA     H1     0.08760\n");
	fprintf(fout,"CB     CT     -0.01520\n");
	fprintf(fout,"HB1    HC     0.02950\n");
	fprintf(fout,"HB2    HC     0.02950\n");
	fprintf(fout,"CG     CA     -0.00110\n");
	fprintf(fout,"CD1    CA     -0.19060\n");
	fprintf(fout,"HD1    HA     0.16990\n");
	fprintf(fout,"CE1    CA     -0.23410\n");
	fprintf(fout,"HE1    HA     0.16560\n");
	fprintf(fout,"CZ     C      0.32260\n");
	fprintf(fout,"OH     OH     -0.55790\n");
	fprintf(fout,"HH     HO     0.39920\n");
	fprintf(fout,"CE2    CA     -0.23410\n");
	fprintf(fout,"HE2    HA     0.16560\n");
	fprintf(fout,"CD2    CA     -0.19060\n");
	fprintf(fout,"HD2    HA     0.16990\n");
	fprintf(fout,"C      C      0.59730\n");
	fprintf(fout,"O      O      -0.56790\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin GLU Residue\n");
	fprintf(fout,"N      N      -0.51630\n");
	fprintf(fout,"H      H      0.29360\n");
	fprintf(fout,"CA     CT     0.03970\n");
	fprintf(fout,"HA     H1     0.11050\n");
	fprintf(fout,"CB     CT     0.05600\n");
	fprintf(fout,"HB1    HC     -0.01730\n");
	fprintf(fout,"HB2    HC     -0.01730\n");
	fprintf(fout,"CG     CT     0.01360\n");
	fprintf(fout,"HG1    HC     -0.04250\n");
	fprintf(fout,"HG2    HC     -0.04250\n");
	fprintf(fout,"CD     C      0.80540\n");
	fprintf(fout,"OE1    O2     -0.81880\n");
	fprintf(fout,"OE2    O2     -0.81880\n");
	fprintf(fout,"C      C      0.53660\n");
	fprintf(fout,"O      O      -0.58190\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin ASP Residue\n");
	fprintf(fout,"N      N      -0.51630\n");
	fprintf(fout,"H      H      0.29360\n");
	fprintf(fout,"CA     CT     0.03810\n");
	fprintf(fout,"HA     H1     0.08800\n");
	fprintf(fout,"CB     CT     -0.03030\n");
	fprintf(fout,"HB1    HC     -0.01220\n");
	fprintf(fout,"HB2    HC     -0.01220\n");
	fprintf(fout,"CG     C      0.79940\n");
	fprintf(fout,"OD1    O2     -0.80140\n");
	fprintf(fout,"OD2    O2     -0.80140\n");
	fprintf(fout,"C      C      0.53660\n");
	fprintf(fout,"O      O      -0.58190\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin LYP Residue\n");
	fprintf(fout,"N      N      -0.34790\n");
	fprintf(fout,"H      H      0.27470\n");
	fprintf(fout,"CA     CT     -0.24000\n");
	fprintf(fout,"HA     H1     0.14260\n");
	fprintf(fout,"CB     CT     -0.00940\n");
	fprintf(fout,"HB1    HC     0.03620\n");
	fprintf(fout,"HB2    HC     0.03620\n");
	fprintf(fout,"CG     CT     0.01870\n");
	fprintf(fout,"HG1    HC     0.01030\n");
	fprintf(fout,"HG2    HC     0.01030\n");
	fprintf(fout,"CD     CT     -0.04790\n");
	fprintf(fout,"HD1    HC     0.06210\n");
	fprintf(fout,"HD2    HC     0.06210\n");
	fprintf(fout,"CE     CT     -0.01430\n");
	fprintf(fout,"HE1    HP     0.11350\n");
	fprintf(fout,"HE2    HP     0.11350\n");
	fprintf(fout,"NZ     N3     -0.38540\n");
	fprintf(fout,"HZ1    H      0.34000\n");
	fprintf(fout,"HZ2    H      0.34000\n");
	fprintf(fout,"HZ3    H      0.34000\n");
	fprintf(fout,"C      C      0.73410\n");
	fprintf(fout,"O      O      -0.58940\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin ORN Residue\n");
	fprintf(fout,"N      N      -0.34790\n");
	fprintf(fout,"H      H      0.27470\n");
	fprintf(fout,"CA     CT     -0.24000\n");
	fprintf(fout,"HA     H1     0.14260\n");
	fprintf(fout,"CB     CT     0.00990\n");
	fprintf(fout,"HB1    HC     0.03620\n");
	fprintf(fout,"HB2    HC     0.03620\n");
	fprintf(fout,"CG     CT     -0.02790\n");
	fprintf(fout,"HG1    HC     0.06210\n");
	fprintf(fout,"HG2    HC     0.06210\n");
	fprintf(fout,"CD     CT     -0.01430\n");
	fprintf(fout,"HD1    HP     0.11350\n");
	fprintf(fout,"HD2    HP     0.11350\n");
	fprintf(fout,"NE     N3     -0.38540\n");
	fprintf(fout,"HE1    H      0.34000\n");
	fprintf(fout,"HE2    H      0.34000\n");
	fprintf(fout,"HE3    H      0.34000\n");
	fprintf(fout,"C      C      0.73410\n");
	fprintf(fout,"O      O      -0.58940\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin DAB Residue\n");
	fprintf(fout,"N      N      -0.34790\n");
	fprintf(fout,"H      H      0.27470\n");
	fprintf(fout,"CA     CT     -0.24000\n");
	fprintf(fout,"HA     H1     0.14260\n");
	fprintf(fout,"CB     CT     0.02920\n");
	fprintf(fout,"HB1    HC     0.07470\n");
	fprintf(fout,"HB2    HC     0.07470\n");
	fprintf(fout,"CG     CT     -0.01430\n");
	fprintf(fout,"HG1    HP     0.11350\n");
	fprintf(fout,"HG2    HP     0.11350\n");
	fprintf(fout,"ND     N3     -0.38540\n");
	fprintf(fout,"HD1    H      0.34000\n");
	fprintf(fout,"HD2    H      0.34000\n");
	fprintf(fout,"HD3    H      0.34000\n");
	fprintf(fout,"C      C      0.73410\n");
	fprintf(fout,"O      O      -0.58940\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin LYS Residue\n");
	fprintf(fout,"N      N      -0.34790\n");
	fprintf(fout,"H      H      0.27470\n");
	fprintf(fout,"CA     CT     -0.24000\n");
	fprintf(fout,"HA     H1     0.14260\n");
	fprintf(fout,"CB     CT     -0.00940\n");
	fprintf(fout,"HB1    HC     0.03620\n");
	fprintf(fout,"HB2    HC     0.03620\n");
	fprintf(fout,"CG     CT     0.01870\n");
	fprintf(fout,"HG1    HC     0.01030\n");
	fprintf(fout,"HG2    HC     0.01030\n");
	fprintf(fout,"CD     CT     -0.04790\n");
	fprintf(fout,"HD1    HC     0.06210\n");
	fprintf(fout,"HD2    HC     0.06210\n");
	fprintf(fout,"CE     CT     -0.01430\n");
	fprintf(fout,"HE1    HP     0.11350\n");
	fprintf(fout,"HE2    HP     0.11350\n");
	fprintf(fout,"NZ     N3     -0.38540\n");
	fprintf(fout,"HZ1    H      0.34000\n");
	fprintf(fout,"HZ2    H      0.34000\n");
	fprintf(fout,"HZ3    H      0.34000\n");
	fprintf(fout,"C      C      0.73410\n");
	fprintf(fout,"O      O      -0.58940\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin LYN Residue\n");
	fprintf(fout,"N      N      -0.41570\n");
	fprintf(fout,"H      H      0.27190\n");
	fprintf(fout,"CA     CT     -0.07206\n");
	fprintf(fout,"HA     H1     0.09940\n");
	fprintf(fout,"CB     CT     -0.04845\n");
	fprintf(fout,"HB1    HC     0.03400\n");
	fprintf(fout,"HB2    HC     0.03400\n");
	fprintf(fout,"CG     CT     0.06612\n");
	fprintf(fout,"HG1    HC     0.01041\n");
	fprintf(fout,"HG2    HC     0.01041\n");
	fprintf(fout,"CD     CT     -0.03768\n");
	fprintf(fout,"HD1    HC     0.01155\n");
	fprintf(fout,"HD2    HC     0.01155\n");
	fprintf(fout,"CE     CT     0.32604\n");
	fprintf(fout,"HE1    HP     -0.03358\n");
	fprintf(fout,"HE2    HP     -0.03358\n");
	fprintf(fout,"NZ     N3     -1.03581\n");
	fprintf(fout,"HZ1    H      0.38604\n");
	fprintf(fout,"HZ2    H      0.38604\n");
	fprintf(fout,"C      C      0.59730\n");
	fprintf(fout,"O      O      -0.56790\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin PRO Residue\n");
	fprintf(fout,"N      N      -0.25480\n");
	fprintf(fout,"CD     CT     0.01920\n");
	fprintf(fout,"HD1    H1     0.03910\n");
	fprintf(fout,"HD2    H1     0.03910\n");
	fprintf(fout,"CG     CT     0.01890\n");
	fprintf(fout,"HG1    HC     0.02130\n");
	fprintf(fout,"HG2    HC     0.02130\n");
	fprintf(fout,"CB     CT     -0.00700\n");
	fprintf(fout,"HB1    HC     0.02530\n");
	fprintf(fout,"HB2    HC     0.02530\n");
	fprintf(fout,"CA     CT     -0.02660\n");
	fprintf(fout,"HA     H1     0.06410\n");
	fprintf(fout,"C      C      0.58960\n");
	fprintf(fout,"O      O      -0.57480\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin HYP Residue\n");
	fprintf(fout,"N      N      -0.25480\n");
	fprintf(fout,"CD2    CT     0.05950\n");
	fprintf(fout,"HD21   H1     0.07000\n");
	fprintf(fout,"HD22   H1     0.07000\n");
	fprintf(fout,"CG     CT     0.04000\n");
	fprintf(fout,"HG     H1     0.04160\n");
	fprintf(fout,"OD1    OH     -0.61340\n");
	fprintf(fout,"HD1    HO     0.38510\n");
	fprintf(fout,"CB     CT     0.02030\n");
	fprintf(fout,"HB1    HC     0.04260\n");
	fprintf(fout,"HB2    HC     0.04260\n");
	fprintf(fout,"CA     CT     0.00470\n");
	fprintf(fout,"HA     H1     0.07700\n");
	fprintf(fout,"C      C      0.58960\n");
	fprintf(fout,"O      O      -0.57480\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin CYS Residue\n");
	fprintf(fout,"N      N      -0.41570\n");
	fprintf(fout,"H      H      0.27190\n");
	fprintf(fout,"CA     CT     0.02130\n");
	fprintf(fout,"HA     H1     0.11240\n");
	fprintf(fout,"CB     CT     -0.12310\n");
	fprintf(fout,"HB1    H1     0.11120\n");
	fprintf(fout,"HB2    H1     0.11120\n");
	fprintf(fout,"SG     SH     -0.31190\n");
	fprintf(fout,"HG     HS     0.19330\n");
	fprintf(fout,"C      C      0.59730\n");
	fprintf(fout,"O      O      -0.56790\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin CYN Residue\n");
	fprintf(fout,"N      N      -0.41570\n");
	fprintf(fout,"H      H      0.27190\n");
	fprintf(fout,"CA     CT     0.02130\n");
	fprintf(fout,"HA     H1     0.11240\n");
	fprintf(fout,"CB     CT     -0.12310\n");
	fprintf(fout,"HB1    H1     0.11120\n");
	fprintf(fout,"HB2    H1     0.11120\n");
	fprintf(fout,"SG     SH     -0.31190\n");
	fprintf(fout,"HG     HS     0.19330\n");
	fprintf(fout,"C      C      0.59730\n");
	fprintf(fout,"O      O      -0.56790\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin CYM Residue\n");
	fprintf(fout,"N      N      -0.41570\n");
	fprintf(fout,"H      H      0.27190\n");
	fprintf(fout,"CA     CT     -0.03510\n");
	fprintf(fout,"HA     H1     0.05080\n");
	fprintf(fout,"CB     CT     -0.24130\n");
	fprintf(fout,"HB1    H1     0.11220\n");
	fprintf(fout,"HB2    H1     0.11220\n");
	fprintf(fout,"SG     SH     -0.88440\n");
	fprintf(fout,"C      C      0.59730\n");
	fprintf(fout,"O      O      -0.56790\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin CYX Residue\n");
	fprintf(fout,"N      N      -0.41570\n");
	fprintf(fout,"H      H      0.27190\n");
	fprintf(fout,"CA     CT     0.04290\n");
	fprintf(fout,"HA     H1     0.07660\n");
	fprintf(fout,"CB     CT     -0.07900\n");
	fprintf(fout,"HB1    H1     0.09100\n");
	fprintf(fout,"HB2    H1     0.09100\n");
	fprintf(fout,"SG     S      -0.10810\n");
	fprintf(fout,"C      C      0.59730\n");
	fprintf(fout,"O      O      -0.56790\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin CYS2 Residue\n");
	fprintf(fout,"N      N      -0.41570\n");
	fprintf(fout,"H      H      0.27190\n");
	fprintf(fout,"CA     CT     0.04290\n");
	fprintf(fout,"HA     H1     0.07660\n");
	fprintf(fout,"CB     CT     -0.07900\n");
	fprintf(fout,"HB1    H1     0.09100\n");
	fprintf(fout,"HB2    H1     0.09100\n");
	fprintf(fout,"SG     S      -0.10810\n");
	fprintf(fout,"C      C      0.59730\n");
	fprintf(fout,"O      O      -0.56790\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin MET Residue\n");
	fprintf(fout,"N      N      -0.41570\n");
	fprintf(fout,"H      H      0.27190\n");
	fprintf(fout,"CA     CT     -0.02370\n");
	fprintf(fout,"HA     H1     0.08800\n");
	fprintf(fout,"CB     CT     0.03420\n");
	fprintf(fout,"HB1    HC     0.02410\n");
	fprintf(fout,"HB2    HC     0.02410\n");
	fprintf(fout,"CG     CT     0.00180\n");
	fprintf(fout,"HG1    H1     0.04400\n");
	fprintf(fout,"HG2    H1     0.04400\n");
	fprintf(fout,"SD     S      -0.27370\n");
	fprintf(fout,"CE     CT     -0.05360\n");
	fprintf(fout,"HE1    H1     0.06840\n");
	fprintf(fout,"HE2    H1     0.06840\n");
	fprintf(fout,"HE3    H1     0.06840\n");
	fprintf(fout,"C      C      0.59730\n");
	fprintf(fout,"O      O      -0.56790\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin ASH Residue\n");
	fprintf(fout,"N      N      -0.41570\n");
	fprintf(fout,"H      H      0.27190\n");
	fprintf(fout,"CA     CT     0.03410\n");
	fprintf(fout,"HA     H1     0.08640\n");
	fprintf(fout,"CB     CT     -0.03160\n");
	fprintf(fout,"HB1    HC     0.04880\n");
	fprintf(fout,"HB2    HC     0.04880\n");
	fprintf(fout,"CG     C      0.64620\n");
	fprintf(fout,"OD1    O      -0.55540\n");
	fprintf(fout,"OD2    OH     -0.63760\n");
	fprintf(fout,"HD2    HO     0.47470\n");
	fprintf(fout,"C      C      0.59730\n");
	fprintf(fout,"O      O      -0.56790\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin GLH Residue\n");
	fprintf(fout,"N      N      -0.41570\n");
	fprintf(fout,"H      H      0.27190\n");
	fprintf(fout,"CA     CT     0.01450\n");
	fprintf(fout,"HA     H1     0.07790\n");
	fprintf(fout,"CB     CT     -0.00710\n");
	fprintf(fout,"HB1    HC     0.02560\n");
	fprintf(fout,"HB2    HC     0.02560\n");
	fprintf(fout,"CG     CT     -0.01740\n");
	fprintf(fout,"HG1    HC     0.04300\n");
	fprintf(fout,"HG2    HC     0.04300\n");
	fprintf(fout,"CD     C      0.68010\n");
	fprintf(fout,"OE1    O      -0.58380\n");
	fprintf(fout,"OE2    OH     -0.65110\n");
	fprintf(fout,"HE2    HO     0.46410\n");
	fprintf(fout,"C      C      0.59730\n");
	fprintf(fout,"O      O      -0.56790\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin CALA Residue\n");
	fprintf(fout,"N      N      -0.38210\n");
	fprintf(fout,"H      H      0.26810\n");
	fprintf(fout,"CA     CT     -0.17470\n");
	fprintf(fout,"HA     H1     0.10670\n");
	fprintf(fout,"CB     CT     -0.20930\n");
	fprintf(fout,"HB1    HC     0.07640\n");
	fprintf(fout,"HB2    HC     0.07640\n");
	fprintf(fout,"HB3    HC     0.07640\n");
	fprintf(fout,"C      C      0.77310\n");
	fprintf(fout,"OC1    O2     -0.80550\n");
	fprintf(fout,"OC2    O2     -0.80550\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin CGLY Residue\n");
	fprintf(fout,"N      N      -0.38210\n");
	fprintf(fout,"H      H      0.26810\n");
	fprintf(fout,"CA     CT     -0.24930\n");
	fprintf(fout,"HA1    H1     0.10560\n");
	fprintf(fout,"HA2    H1     0.10560\n");
	fprintf(fout,"C      C      0.72310\n");
	fprintf(fout,"OC1    O2     -0.78550\n");
	fprintf(fout,"OC2    O2     -0.78550\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin CSER Residue\n");
	fprintf(fout,"N      N      -0.38210\n");
	fprintf(fout,"H      H      0.26810\n");
	fprintf(fout,"CA     CT     -0.27220\n");
	fprintf(fout,"HA     H1     0.13040\n");
	fprintf(fout,"CB     CT     0.11230\n");
	fprintf(fout,"HB1    H1     0.08130\n");
	fprintf(fout,"HB2    H1     0.08130\n");
	fprintf(fout,"OG     OH     -0.65140\n");
	fprintf(fout,"HG     HO     0.44740\n");
	fprintf(fout,"C      C      0.81130\n");
	fprintf(fout,"OC1    O2     -0.81320\n");
	fprintf(fout,"OC2    O2     -0.81320\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin CTHR Residue\n");
	fprintf(fout,"N      N      -0.38210\n");
	fprintf(fout,"H      H      0.26810\n");
	fprintf(fout,"CA     CT     -0.24200\n");
	fprintf(fout,"HA     H1     0.12070\n");
	fprintf(fout,"CB     CT     0.30250\n");
	fprintf(fout,"HB     H1     0.00780\n");
	fprintf(fout,"CG2    CT     -0.18530\n");
	fprintf(fout,"HG21   HC     0.05860\n");
	fprintf(fout,"HG22   HC     0.05860\n");
	fprintf(fout,"HG23   HC     0.05860\n");
	fprintf(fout,"OG1    OH     -0.64960\n");
	fprintf(fout,"HG1    HO     0.41190\n");
	fprintf(fout,"C      C      0.78100\n");
	fprintf(fout,"OC1    O2     -0.80440\n");
	fprintf(fout,"OC2    O2     -0.80440\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin CLEU Residue\n");
	fprintf(fout,"N      N      -0.38210\n");
	fprintf(fout,"H      H      0.26810\n");
	fprintf(fout,"CA     CT     -0.28470\n");
	fprintf(fout,"HA     H1     0.13460\n");
	fprintf(fout,"CB     CT     -0.24690\n");
	fprintf(fout,"HB1    HC     0.09740\n");
	fprintf(fout,"HB2    HC     0.09740\n");
	fprintf(fout,"CG     CT     0.37060\n");
	fprintf(fout,"HG     HC     -0.03740\n");
	fprintf(fout,"CD1    CT     -0.41630\n");
	fprintf(fout,"HD11   HC     0.10380\n");
	fprintf(fout,"HD12   HC     0.10380\n");
	fprintf(fout,"HD13   HC     0.10380\n");
	fprintf(fout,"CD2    CT     -0.41630\n");
	fprintf(fout,"HD21   HC     0.10380\n");
	fprintf(fout,"HD22   HC     0.10380\n");
	fprintf(fout,"HD23   HC     0.10380\n");
	fprintf(fout,"C      C      0.83260\n");
	fprintf(fout,"OC1    O2     -0.81990\n");
	fprintf(fout,"OC2    O2     -0.81990\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin CILE Residue\n");
	fprintf(fout,"N      N      -0.38210\n");
	fprintf(fout,"H      H      0.26810\n");
	fprintf(fout,"CA     CT     -0.31000\n");
	fprintf(fout,"HA     H1     0.13750\n");
	fprintf(fout,"CB     CT     0.03630\n");
	fprintf(fout,"HB     HC     0.07660\n");
	fprintf(fout,"CG2    CT     -0.34980\n");
	fprintf(fout,"HG21   HC     0.10210\n");
	fprintf(fout,"HG22   HC     0.10210\n");
	fprintf(fout,"HG23   HC     0.10210\n");
	fprintf(fout,"CG1    CT     -0.03230\n");
	fprintf(fout,"HG11   HC     0.03210\n");
	fprintf(fout,"HG12   HC     0.03210\n");
	fprintf(fout,"CD     CT     -0.06990\n");
	fprintf(fout,"HD1    HC     0.01960\n");
	fprintf(fout,"HD2    HC     0.01960\n");
	fprintf(fout,"HD3    HC     0.01960\n");
	fprintf(fout,"C      C      0.83430\n");
	fprintf(fout,"OC1    O2     -0.81900\n");
	fprintf(fout,"OC2    O2     -0.81900\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin CVAL Residue\n");
	fprintf(fout,"N      N      -0.38210\n");
	fprintf(fout,"H      H      0.26810\n");
	fprintf(fout,"CA     CT     -0.34380\n");
	fprintf(fout,"HA     H1     0.14380\n");
	fprintf(fout,"CB     CT     0.19400\n");
	fprintf(fout,"HB     HC     0.03080\n");
	fprintf(fout,"CG1    CT     -0.30640\n");
	fprintf(fout,"HG11   HC     0.08360\n");
	fprintf(fout,"HG12   HC     0.08360\n");
	fprintf(fout,"HG13   HC     0.08360\n");
	fprintf(fout,"CG2    CT     -0.30640\n");
	fprintf(fout,"HG21   HC     0.08360\n");
	fprintf(fout,"HG22   HC     0.08360\n");
	fprintf(fout,"HG23   HC     0.08360\n");
	fprintf(fout,"C      C      0.83500\n");
	fprintf(fout,"OC1    O2     -0.81730\n");
	fprintf(fout,"OC2    O2     -0.81730\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin CASN Residue\n");
	fprintf(fout,"N      N      -0.38210\n");
	fprintf(fout,"H      H      0.26810\n");
	fprintf(fout,"CA     CT     -0.20800\n");
	fprintf(fout,"HA     H1     0.13580\n");
	fprintf(fout,"CB     CT     -0.22990\n");
	fprintf(fout,"HB1    HC     0.10230\n");
	fprintf(fout,"HB2    HC     0.10230\n");
	fprintf(fout,"CG     C      0.71530\n");
	fprintf(fout,"OD1    O      -0.60100\n");
	fprintf(fout,"ND2    N      -0.90840\n");
	fprintf(fout,"HD21   H      0.41500\n");
	fprintf(fout,"HD22   H      0.41500\n");
	fprintf(fout,"C      C      0.80500\n");
	fprintf(fout,"OC1    O2     -0.81470\n");
	fprintf(fout,"OC2    O2     -0.81470\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin CGLN Residue\n");
	fprintf(fout,"N      N      -0.38210\n");
	fprintf(fout,"H      H      0.26810\n");
	fprintf(fout,"CA     CT     -0.22480\n");
	fprintf(fout,"HA     H1     0.12320\n");
	fprintf(fout,"CB     CT     -0.06640\n");
	fprintf(fout,"HB1    HC     0.04520\n");
	fprintf(fout,"HB2    HC     0.04520\n");
	fprintf(fout,"CG     CT     -0.02100\n");
	fprintf(fout,"HG1    HC     0.02030\n");
	fprintf(fout,"HG2    HC     0.02030\n");
	fprintf(fout,"CD     C      0.70930\n");
	fprintf(fout,"OE1    O      -0.60980\n");
	fprintf(fout,"NE2    N      -0.95740\n");
	fprintf(fout,"HE21   H      0.43040\n");
	fprintf(fout,"HE22   H      0.43040\n");
	fprintf(fout,"C      C      0.77750\n");
	fprintf(fout,"OC1    O2     -0.80420\n");
	fprintf(fout,"OC2    O2     -0.80420\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin CARG Residue\n");
	fprintf(fout,"N      N      -0.34810\n");
	fprintf(fout,"H      H      0.27640\n");
	fprintf(fout,"CA     CT     -0.30680\n");
	fprintf(fout,"HA     H1     0.14470\n");
	fprintf(fout,"CB     CT     -0.03740\n");
	fprintf(fout,"HB1    HC     0.03710\n");
	fprintf(fout,"HB2    HC     0.03710\n");
	fprintf(fout,"CG     CT     0.07440\n");
	fprintf(fout,"HG1    HC     0.01850\n");
	fprintf(fout,"HG2    HC     0.01850\n");
	fprintf(fout,"CD     CT     0.11140\n");
	fprintf(fout,"HD1    H1     0.04680\n");
	fprintf(fout,"HD2    H1     0.04680\n");
	fprintf(fout,"NE     N2     -0.55640\n");
	fprintf(fout,"HE     H      0.34790\n");
	fprintf(fout,"CZ     CA     0.83680\n");
	fprintf(fout,"NH1    N2     -0.87370\n");
	fprintf(fout,"HH11   H      0.44930\n");
	fprintf(fout,"HH12   H      0.44930\n");
	fprintf(fout,"NH2    N2     -0.87370\n");
	fprintf(fout,"HH21   H      0.44930\n");
	fprintf(fout,"HH22   H      0.44930\n");
	fprintf(fout,"C      C      0.85570\n");
	fprintf(fout,"OC1    O2     -0.82660\n");
	fprintf(fout,"OC2    O2     -0.82660\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin CHID Residue\n");
	fprintf(fout,"N      N      -0.38210\n");
	fprintf(fout,"H      H      0.26810\n");
	fprintf(fout,"CA     CT     -0.17390\n");
	fprintf(fout,"HA     H1     0.11000\n");
	fprintf(fout,"CB     CT     -0.10460\n");
	fprintf(fout,"HB1    HC     0.05650\n");
	fprintf(fout,"HB2    HC     0.05650\n");
	fprintf(fout,"CG     CC     0.02930\n");
	fprintf(fout,"ND1    NA     -0.38920\n");
	fprintf(fout,"HD1    H      0.37550\n");
	fprintf(fout,"CE1    CR     0.19250\n");
	fprintf(fout,"HE1    H5     0.14180\n");
	fprintf(fout,"NE2    NB     -0.56290\n");
	fprintf(fout,"CD2    CV     0.10010\n");
	fprintf(fout,"HD2    H4     0.12410\n");
	fprintf(fout,"C      C      0.76150\n");
	fprintf(fout,"OC1    O2     -0.80160\n");
	fprintf(fout,"OC2    O2     -0.80160\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin CHIE Residue\n");
	fprintf(fout,"N      N      -0.38210\n");
	fprintf(fout,"H      H      0.26810\n");
	fprintf(fout,"CA     CT     -0.26990\n");
	fprintf(fout,"HA     H1     0.16500\n");
	fprintf(fout,"CB     CT     -0.10680\n");
	fprintf(fout,"HB1    HC     0.06200\n");
	fprintf(fout,"HB2    HC     0.06200\n");
	fprintf(fout,"CG     CC     0.27240\n");
	fprintf(fout,"ND1    NB     -0.55170\n");
	fprintf(fout,"CE1    CR     0.15580\n");
	fprintf(fout,"HE1    H5     0.14480\n");
	fprintf(fout,"NE2    NA     -0.26700\n");
	fprintf(fout,"HE2    H      0.33190\n");
	fprintf(fout,"CD2    CW     -0.25880\n");
	fprintf(fout,"HD2    H4     0.19570\n");
	fprintf(fout,"C      C      0.79160\n");
	fprintf(fout,"OC1    O2     -0.80650\n");
	fprintf(fout,"OC2    O2     -0.80650\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin CHIP Residue\n");
	fprintf(fout,"N      N      -0.34810\n");
	fprintf(fout,"H      H      0.27640\n");
	fprintf(fout,"CA     CT     -0.14450\n");
	fprintf(fout,"HA     H1     0.11150\n");
	fprintf(fout,"CB     CT     -0.08000\n");
	fprintf(fout,"HB1    HC     0.08680\n");
	fprintf(fout,"HB2    HC     0.08680\n");
	fprintf(fout,"CG     CC     0.02980\n");
	fprintf(fout,"ND1    NA     -0.15010\n");
	fprintf(fout,"HD1    H      0.38830\n");
	fprintf(fout,"CE1    CR     -0.02510\n");
	fprintf(fout,"HE1    H5     0.26940\n");
	fprintf(fout,"NE2    NA     -0.16830\n");
	fprintf(fout,"HE2    H      0.39130\n");
	fprintf(fout,"CD2    CW     -0.12560\n");
	fprintf(fout,"HD2    H4     0.23360\n");
	fprintf(fout,"C      C      0.80320\n");
	fprintf(fout,"OC1    O2     -0.81770\n");
	fprintf(fout,"OC2    O2     -0.81770\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin CHIS Residue\n");
	fprintf(fout,"N      N      -0.34810\n");
	fprintf(fout,"H      H      0.27640\n");
	fprintf(fout,"CA     CT     -0.14450\n");
	fprintf(fout,"HA     H1     0.11150\n");
	fprintf(fout,"CB     CT     -0.08000\n");
	fprintf(fout,"HB1    HC     0.08680\n");
	fprintf(fout,"HB2    HC     0.08680\n");
	fprintf(fout,"CG     CC     0.02980\n");
	fprintf(fout,"ND1    NA     -0.15010\n");
	fprintf(fout,"HD1    H      0.38830\n");
	fprintf(fout,"CE1    CR     -0.02510\n");
	fprintf(fout,"HE1    H5     0.26940\n");
	fprintf(fout,"NE2    NA     -0.16830\n");
	fprintf(fout,"HE2    H      0.39130\n");
	fprintf(fout,"CD2    CW     -0.12560\n");
	fprintf(fout,"HD2    H4     0.23360\n");
	fprintf(fout,"C      C      0.80320\n");
	fprintf(fout,"OC1    O2     -0.81770\n");
	fprintf(fout,"OC2    O2     -0.81770\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin CTRP Residue\n");
	fprintf(fout,"N      N      -0.38210\n");
	fprintf(fout,"H      H      0.26810\n");
	fprintf(fout,"CA     CT     -0.20840\n");
	fprintf(fout,"HA     H1     0.12720\n");
	fprintf(fout,"CB     CT     -0.07420\n");
	fprintf(fout,"HB1    HC     0.04970\n");
	fprintf(fout,"HB2    HC     0.04970\n");
	fprintf(fout,"CG     C*     -0.07960\n");
	fprintf(fout,"CD1    CW     -0.18080\n");
	fprintf(fout,"HD1    H4     0.20430\n");
	fprintf(fout,"NE1    NA     -0.33160\n");
	fprintf(fout,"HE1    H      0.34130\n");
	fprintf(fout,"CE2    CN     0.12220\n");
	fprintf(fout,"CZ2    CA     -0.25940\n");
	fprintf(fout,"HZ2    HA     0.15670\n");
	fprintf(fout,"CH2    CA     -0.10200\n");
	fprintf(fout,"HH2    HA     0.14010\n");
	fprintf(fout,"CZ3    CA     -0.22870\n");
	fprintf(fout,"HZ3    HA     0.15070\n");
	fprintf(fout,"CE3    CA     -0.18370\n");
	fprintf(fout,"HE3    HA     0.14910\n");
	fprintf(fout,"CD2    CB     0.10780\n");
	fprintf(fout,"C      C      0.76580\n");
	fprintf(fout,"OC1    O2     -0.80110\n");
	fprintf(fout,"OC2    O2     -0.80110\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin CPHE Residue\n");
	fprintf(fout,"N      N      -0.38210\n");
	fprintf(fout,"H      H      0.26810\n");
	fprintf(fout,"CA     CT     -0.18250\n");
	fprintf(fout,"HA     H1     0.10980\n");
	fprintf(fout,"CB     CT     -0.09590\n");
	fprintf(fout,"HB1    HC     0.04430\n");
	fprintf(fout,"HB2    HC     0.04430\n");
	fprintf(fout,"CG     CA     0.05520\n");
	fprintf(fout,"CD1    CA     -0.13000\n");
	fprintf(fout,"HD1    HA     0.14080\n");
	fprintf(fout,"CE1    CA     -0.18470\n");
	fprintf(fout,"HE1    HA     0.14610\n");
	fprintf(fout,"CZ     CA     -0.09440\n");
	fprintf(fout,"HZ     HA     0.12800\n");
	fprintf(fout,"CE2    CA     -0.18470\n");
	fprintf(fout,"HE2    HA     0.14610\n");
	fprintf(fout,"CD2    CA     -0.13000\n");
	fprintf(fout,"HD2    HA     0.14080\n");
	fprintf(fout,"C      C      0.76600\n");
	fprintf(fout,"OC1    O2     -0.80260\n");
	fprintf(fout,"OC2    O2     -0.80260\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin CTYR Residue\n");
	fprintf(fout,"N      N      -0.38210\n");
	fprintf(fout,"H      H      0.26810\n");
	fprintf(fout,"CA     CT     -0.20150\n");
	fprintf(fout,"HA     H1     0.10920\n");
	fprintf(fout,"CB     CT     -0.07520\n");
	fprintf(fout,"HB1    HC     0.04900\n");
	fprintf(fout,"HB2    HC     0.04900\n");
	fprintf(fout,"CG     CA     0.02430\n");
	fprintf(fout,"CD1    CA     -0.19220\n");
	fprintf(fout,"HD1    HA     0.17800\n");
	fprintf(fout,"CE1    CA     -0.24580\n");
	fprintf(fout,"HE1    HA     0.16730\n");
	fprintf(fout,"CZ     C      0.33950\n");
	fprintf(fout,"OH     OH     -0.56430\n");
	fprintf(fout,"HH     HO     0.40170\n");
	fprintf(fout,"CE2    CA     -0.24580\n");
	fprintf(fout,"HE2    HA     0.16730\n");
	fprintf(fout,"CD2    CA     -0.19220\n");
	fprintf(fout,"HD2    HA     0.17800\n");
	fprintf(fout,"C      C      0.78170\n");
	fprintf(fout,"OC1    O2     -0.80700\n");
	fprintf(fout,"OC2    O2     -0.80700\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin CGLU Residue\n");
	fprintf(fout,"N      N      -0.51920\n");
	fprintf(fout,"H      H      0.30550\n");
	fprintf(fout,"CA     CT     -0.20590\n");
	fprintf(fout,"HA     H1     0.13990\n");
	fprintf(fout,"CB     CT     0.00710\n");
	fprintf(fout,"HB1    HC     -0.00780\n");
	fprintf(fout,"HB2    HC     -0.00780\n");
	fprintf(fout,"CG     CT     0.06750\n");
	fprintf(fout,"HG1    HC     -0.05480\n");
	fprintf(fout,"HG2    HC     -0.05480\n");
	fprintf(fout,"CD     C      0.81830\n");
	fprintf(fout,"OE1    O2     -0.82200\n");
	fprintf(fout,"OE2    O2     -0.82200\n");
	fprintf(fout,"C      C      0.74200\n");
	fprintf(fout,"OC1    O2     -0.79300\n");
	fprintf(fout,"OC2    O2     -0.79300\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin CASP Residue\n");
	fprintf(fout,"N      N      -0.51920\n");
	fprintf(fout,"H      H      0.30550\n");
	fprintf(fout,"CA     CT     -0.18170\n");
	fprintf(fout,"HA     H1     0.10460\n");
	fprintf(fout,"CB     CT     -0.06770\n");
	fprintf(fout,"HB1    HC     -0.02120\n");
	fprintf(fout,"HB2    HC     -0.02120\n");
	fprintf(fout,"CG     C      0.88510\n");
	fprintf(fout,"OD1    O2     -0.81620\n");
	fprintf(fout,"OD2    O2     -0.81620\n");
	fprintf(fout,"C      C      0.72560\n");
	fprintf(fout,"OC1    O2     -0.78870\n");
	fprintf(fout,"OC2    O2     -0.78870\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin CLYS Residue\n");
	fprintf(fout,"N      N      -0.34810\n");
	fprintf(fout,"H      H      0.27640\n");
	fprintf(fout,"CA     CT     -0.29030\n");
	fprintf(fout,"HA     H1     0.14380\n");
	fprintf(fout,"CB     CT     -0.05380\n");
	fprintf(fout,"HB1    HC     0.04820\n");
	fprintf(fout,"HB2    HC     0.04820\n");
	fprintf(fout,"CG     CT     0.02270\n");
	fprintf(fout,"HG1    HC     0.01340\n");
	fprintf(fout,"HG2    HC     0.01340\n");
	fprintf(fout,"CD     CT     -0.03920\n");
	fprintf(fout,"HD1    HC     0.06110\n");
	fprintf(fout,"HD2    HC     0.06110\n");
	fprintf(fout,"CE     CT     -0.01760\n");
	fprintf(fout,"HE1    HP     0.11210\n");
	fprintf(fout,"HE2    HP     0.11210\n");
	fprintf(fout,"NZ     N3     -0.37410\n");
	fprintf(fout,"HZ1    H      0.33740\n");
	fprintf(fout,"HZ2    H      0.33740\n");
	fprintf(fout,"HZ3    H      0.33740\n");
	fprintf(fout,"C      C      0.84880\n");
	fprintf(fout,"OC1    O2     -0.82520\n");
	fprintf(fout,"OC2    O2     -0.82520\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin CLYP Residue\n");
	fprintf(fout,"N      N      -0.34810\n");
	fprintf(fout,"H      H      0.27640\n");
	fprintf(fout,"CA     CT     -0.29030\n");
	fprintf(fout,"HA     H1     0.14380\n");
	fprintf(fout,"CB     CT     -0.05380\n");
	fprintf(fout,"HB1    HC     0.04820\n");
	fprintf(fout,"HB2    HC     0.04820\n");
	fprintf(fout,"CG     CT     0.02270\n");
	fprintf(fout,"HG1    HC     0.01340\n");
	fprintf(fout,"HG2    HC     0.01340\n");
	fprintf(fout,"CD     CT     -0.03920\n");
	fprintf(fout,"HD1    HC     0.06110\n");
	fprintf(fout,"HD2    HC     0.06110\n");
	fprintf(fout,"CE     CT     -0.01760\n");
	fprintf(fout,"HE1    HP     0.11210\n");
	fprintf(fout,"HE2    HP     0.11210\n");
	fprintf(fout,"NZ     N3     -0.37410\n");
	fprintf(fout,"HZ1    H      0.33740\n");
	fprintf(fout,"HZ2    H      0.33740\n");
	fprintf(fout,"HZ3    H      0.33740\n");
	fprintf(fout,"C      C      0.84880\n");
	fprintf(fout,"OC1    O2     -0.82520\n");
	fprintf(fout,"OC2    O2     -0.82520\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin CPRO Residue\n");
	fprintf(fout,"N      N      -0.28020\n");
	fprintf(fout,"CD     CT     0.04340\n");
	fprintf(fout,"HD1    H1     0.03310\n");
	fprintf(fout,"HD2    H1     0.03310\n");
	fprintf(fout,"CG     CT     0.04660\n");
	fprintf(fout,"HG1    HC     0.01720\n");
	fprintf(fout,"HG2    HC     0.01720\n");
	fprintf(fout,"CB     CT     -0.05430\n");
	fprintf(fout,"HB1    HC     0.03810\n");
	fprintf(fout,"HB2    HC     0.03810\n");
	fprintf(fout,"CA     CT     -0.13360\n");
	fprintf(fout,"HA     H1     0.07760\n");
	fprintf(fout,"C      C      0.66310\n");
	fprintf(fout,"OC1    O2     -0.76970\n");
	fprintf(fout,"OC2    O2     -0.76970\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin CCYS Residue\n");
	fprintf(fout,"N      N      -0.38210\n");
	fprintf(fout,"H      H      0.26810\n");
	fprintf(fout,"CA     CT     -0.16350\n");
	fprintf(fout,"HA     H1     0.13960\n");
	fprintf(fout,"CB     CT     -0.19960\n");
	fprintf(fout,"HB1    H1     0.14370\n");
	fprintf(fout,"HB2    H1     0.14370\n");
	fprintf(fout,"SG     SH     -0.31020\n");
	fprintf(fout,"HG     HS     0.20680\n");
	fprintf(fout,"C      C      0.74970\n");
	fprintf(fout,"OC1    O2     -0.79810\n");
	fprintf(fout,"OC2    O2     -0.79810\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin CCYN Residue\n");
	fprintf(fout,"N      N      -0.38210\n");
	fprintf(fout,"H      H      0.26810\n");
	fprintf(fout,"CA     CT     -0.16350\n");
	fprintf(fout,"HA     H1     0.13960\n");
	fprintf(fout,"CB     CT     -0.19960\n");
	fprintf(fout,"HB1    H1     0.14370\n");
	fprintf(fout,"HB2    H1     0.14370\n");
	fprintf(fout,"SG     SH     -0.31020\n");
	fprintf(fout,"HG     HS     0.20680\n");
	fprintf(fout,"C      C      0.74970\n");
	fprintf(fout,"OC1    O2     -0.79810\n");
	fprintf(fout,"OC2    O2     -0.79810\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin CCYX Residue\n");
	fprintf(fout,"N      N      -0.38210\n");
	fprintf(fout,"H      H      0.26810\n");
	fprintf(fout,"CA     CT     -0.13180\n");
	fprintf(fout,"HA     H1     0.09380\n");
	fprintf(fout,"CB     CT     -0.19430\n");
	fprintf(fout,"HB1    H1     0.12280\n");
	fprintf(fout,"HB2    H1     0.12280\n");
	fprintf(fout,"SG     S      -0.05290\n");
	fprintf(fout,"C      C      0.76180\n");
	fprintf(fout,"OC1    O2     -0.80410\n");
	fprintf(fout,"OC2    O2     -0.80410\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin CCYM Residue\n");
	fprintf(fout,"N      N      -0.38210\n");
	fprintf(fout,"H      H      0.26810\n");
	fprintf(fout,"CA     CT     -0.28470\n");
	fprintf(fout,"HA     H1     0.13460\n");
	fprintf(fout,"CB     CT     -0.24130\n");
	fprintf(fout,"HB1    H1     0.11220\n");
	fprintf(fout,"HB2    H1     0.11220\n");
	fprintf(fout,"SG     SH     -0.88440\n");
	fprintf(fout,"C      C      0.83260\n");
	fprintf(fout,"OC1    O2     -0.83360\n");
	fprintf(fout,"OC2    O2     -0.83360\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin CMET Residue\n");
	fprintf(fout,"N      N      -0.38210\n");
	fprintf(fout,"H      H      0.26810\n");
	fprintf(fout,"CA     CT     -0.25970\n");
	fprintf(fout,"HA     H1     0.12770\n");
	fprintf(fout,"CB     CT     -0.02360\n");
	fprintf(fout,"HB1    HC     0.04800\n");
	fprintf(fout,"HB2    HC     0.04800\n");
	fprintf(fout,"CG     CT     0.04920\n");
	fprintf(fout,"HG1    H1     0.03170\n");
	fprintf(fout,"HG2    H1     0.03170\n");
	fprintf(fout,"SD     S      -0.26920\n");
	fprintf(fout,"CE     CT     -0.03760\n");
	fprintf(fout,"HE1    H1     0.06250\n");
	fprintf(fout,"HE2    H1     0.06250\n");
	fprintf(fout,"HE3    H1     0.06250\n");
	fprintf(fout,"C      C      0.80130\n");
	fprintf(fout,"OC1    O2     -0.81050\n");
	fprintf(fout,"OC2    O2     -0.81050\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin CASH Residue\n");
	fprintf(fout,"N      N      -0.41570\n");
	fprintf(fout,"H      H      0.27190\n");
	fprintf(fout,"CA     CT     -0.163500\n");
	fprintf(fout,"HA     H1     0.13310\n");
	fprintf(fout,"CA     CT     -0.16350\n");
	fprintf(fout,"HA     H1     0.13960\n");
	fprintf(fout,"CB     CT     -0.03160\n");
	fprintf(fout,"HB1    HC     0.04880\n");
	fprintf(fout,"HB2    HC     0.04880\n");
	fprintf(fout,"CG     C      0.64620\n");
	fprintf(fout,"OD1    O      -0.55540\n");
	fprintf(fout,"OD2    OH     -0.63760\n");
	fprintf(fout,"HD2    HO     0.47470\n");
	fprintf(fout,"C      C      0.80130\n");
	fprintf(fout,"OC1    O2     -0.81050\n");
	fprintf(fout,"OC2    O2     -0.81050\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin CGLH Residue\n");
	fprintf(fout,"N      N      -0.41570\n");
	fprintf(fout,"H      H      0.27190\n");
	fprintf(fout,"CA     CT     -0.163500\n");
	fprintf(fout,"HA     H1     0.105000\n");
	fprintf(fout,"CB     CT     -0.00710\n");
	fprintf(fout,"HB1    HC     0.02560\n");
	fprintf(fout,"HB2    HC     0.02560\n");
	fprintf(fout,"CG     CT     -0.01740\n");
	fprintf(fout,"HG1    HC     0.04300\n");
	fprintf(fout,"HG2    HC     0.04300\n");
	fprintf(fout,"CD     C      0.68010\n");
	fprintf(fout,"OE1    O      -0.58380\n");
	fprintf(fout,"OE2    OH     -0.65110\n");
	fprintf(fout,"HE2    HO     0.46410\n");
	fprintf(fout,"C      C      0.80130\n");
	fprintf(fout,"OC1    O2     -0.81050\n");
	fprintf(fout,"OC2    O2     -0.81050\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin CLYN Residue\n");
	fprintf(fout,"N      N      -0.41570\n");
	fprintf(fout,"H      H      0.27190\n");
	fprintf(fout,"CA     CT     -0.163500\n");
	fprintf(fout,"HA     H1     0.03994\n");
	fprintf(fout,"CB     CT     -0.04845\n");
	fprintf(fout,"HB1    HC     0.03400\n");
	fprintf(fout,"HB2    HC     0.03400\n");
	fprintf(fout,"CG     CT     0.06612\n");
	fprintf(fout,"HG1    HC     0.01041\n");
	fprintf(fout,"HG2    HC     0.01041\n");
	fprintf(fout,"CD     CT     -0.03768\n");
	fprintf(fout,"HD1    HC     0.01155\n");
	fprintf(fout,"HD2    HC     0.01155\n");
	fprintf(fout,"CE     CT     0.32604\n");
	fprintf(fout,"HE1    HP     -0.03358\n");
	fprintf(fout,"HE2    HP     -0.03358\n");
	fprintf(fout,"NZ     N3     -1.03581\n");
	fprintf(fout,"HZ1    H      0.38604\n");
	fprintf(fout,"HZ2    H      0.38604\n");
	fprintf(fout,"C      C      0.80130\n");
	fprintf(fout,"OC1    O2     -0.81050\n");
	fprintf(fout,"OC2    O2     -0.81050\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin OALA Residue\n");
	fprintf(fout,"N 	N	-0.415700\n");
	fprintf(fout,"H 	H	0.271900\n");
	fprintf(fout,"CA 	CT	0.033700\n");
	fprintf(fout,"HA 	H1	0.082300\n");
	fprintf(fout,"C 	C	0.673401\n");
	fprintf(fout,"O 	O	-0.529947\n");
	fprintf(fout,"CB 	CT	-0.182500\n");
	fprintf(fout,"HB1 	HC	0.060300\n");
	fprintf(fout,"HB2 	HC	0.060300\n");
	fprintf(fout,"HB3 	HC	0.060300\n");
	fprintf(fout,"OH 	OH	-0.609201\n");
	fprintf(fout,"HO 	HO	0.495147\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin OARG Residue\n");
	fprintf(fout,"N 	N	-0.347900\n");
	fprintf(fout,"H 	H	0.274700\n");
	fprintf(fout,"CA 	CT	-0.263700\n");
	fprintf(fout,"HA 	H1	0.156000\n");
	fprintf(fout,"C 	C	0.704557\n");
	fprintf(fout,"O 	O	-0.501460\n");
	fprintf(fout,"CB 	CT	-0.000700\n");
	fprintf(fout,"HB1 	HC	0.032700\n");
	fprintf(fout,"HB2 	HC	0.032700\n");
	fprintf(fout,"CG 	CT	0.039000\n");
	fprintf(fout,"HG1 	HC	0.028500\n");
	fprintf(fout,"HG2 	HC	0.028500\n");
	fprintf(fout,"CD 	CT	0.048600\n");
	fprintf(fout,"HD1 	H1	0.068700\n");
	fprintf(fout,"HD2 	H1	0.068700\n");
	fprintf(fout,"NE 	N2	-0.529500\n");
	fprintf(fout,"HE 	H	0.345600\n");
	fprintf(fout,"CZ 	CA	0.807600\n");
	fprintf(fout,"NH1 	N2	-0.862700\n");
	fprintf(fout,"HH11 	H	0.447800\n");
	fprintf(fout,"HH12 	H	0.447800\n");
	fprintf(fout,"NH2 	N2	-0.862700\n");
	fprintf(fout,"HH21 	H	0.447800\n");
	fprintf(fout,"HH22 	H	0.447800\n");
	fprintf(fout,"OH 	OH	-0.576454\n");
	fprintf(fout,"HO 	HO	0.518057\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin OASN Residue\n");
	fprintf(fout,"N 	N	-0.415700\n");
	fprintf(fout,"H 	H	0.271900\n");
	fprintf(fout,"CA 	CT	0.014300\n");
	fprintf(fout,"HA 	H1	0.104800\n");
	fprintf(fout,"C 	C	0.673401\n");
	fprintf(fout,"O 	O	-0.529947\n");
	fprintf(fout,"CB 	CT	-0.204100\n");
	fprintf(fout,"HB1 	HC	0.079700\n");
	fprintf(fout,"HB2 	HC	0.079700\n");
	fprintf(fout,"CG 	C	0.713000\n");
	fprintf(fout,"OD1 	O	-0.593100\n");
	fprintf(fout,"ND2 	N	-0.919100\n");
	fprintf(fout,"HD21 	H	0.419600\n");
	fprintf(fout,"HD22 	H	0.419600\n");
	fprintf(fout,"OH 	OH	-0.609201\n");
	fprintf(fout,"HO 	HO	0.495147\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin OASP Residue\n");
	fprintf(fout,"N 	N	-0.516300\n");
	fprintf(fout,"H 	H	0.293600\n");
	fprintf(fout,"CA 	CT	0.038100\n");
	fprintf(fout,"HA 	H1	0.088000\n");
	fprintf(fout,"C 	C	0.653215\n");
	fprintf(fout,"O 	O	-0.548403\n");
	fprintf(fout,"CB 	CT	-0.030300\n");
	fprintf(fout,"HB1 	HC	-0.012200\n");
	fprintf(fout,"HB2 	HC	-0.012200\n");
	fprintf(fout,"CG 	C	0.799400\n");
	fprintf(fout,"OD1 	O2	-0.801400\n");
	fprintf(fout,"OD2 	O2	-0.801400\n");
	fprintf(fout,"OH 	OH	-0.630417\n");
	fprintf(fout,"HO 	HO	0.480305\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin OCYS Residue\n");
	fprintf(fout,"N 	N	-0.415700\n");
	fprintf(fout,"H 	H	0.271900\n");
	fprintf(fout,"CA 	CT	0.021300\n");
	fprintf(fout,"HA 	H1	0.112400\n");
	fprintf(fout,"C 	C	0.673401\n");
	fprintf(fout,"O 	O	-0.529947\n");
	fprintf(fout,"CB 	CT	-0.123100\n");
	fprintf(fout,"HB1 	H1	0.111200\n");
	fprintf(fout,"HB2 	H1	0.111200\n");
	fprintf(fout,"SG 	SH	-0.311900\n");
	fprintf(fout,"HG 	HS	0.193300\n");
	fprintf(fout,"OH 	OH	-0.609201\n");
	fprintf(fout,"HO 	HO	0.495147\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin OCYX Residue\n");
	fprintf(fout,"N 	N	-0.415700\n");
	fprintf(fout,"H 	H	0.271900\n");
	fprintf(fout,"CA 	CT	0.042900\n");
	fprintf(fout,"HA 	H1	0.076600\n");
	fprintf(fout,"C 	C	0.673401\n");
	fprintf(fout,"O 	O	-0.529947\n");
	fprintf(fout,"CB 	CT	-0.079000\n");
	fprintf(fout,"HB1 	H1	0.091000\n");
	fprintf(fout,"HB2 	H1	0.091000\n");
	fprintf(fout,"SG 	S	-0.108100\n");
	fprintf(fout,"OH 	OH	-0.609201\n");
	fprintf(fout,"HO 	HO	0.495147\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin OGLN Residue\n");
	fprintf(fout,"N 	N	-0.415700\n");
	fprintf(fout,"H 	H	0.271900\n");
	fprintf(fout,"CA 	CT	-0.003100\n");
	fprintf(fout,"HA 	H1	0.085000\n");
	fprintf(fout,"C 	C	0.673401\n");
	fprintf(fout,"O 	O	-0.529947\n");
	fprintf(fout,"CB 	CT	-0.003600\n");
	fprintf(fout,"HB1 	HC	0.017100\n");
	fprintf(fout,"HB2 	HC	0.017100\n");
	fprintf(fout,"CG 	CT	-0.064500\n");
	fprintf(fout,"HG1 	HC	0.035200\n");
	fprintf(fout,"HG2 	HC	0.035200\n");
	fprintf(fout,"CD 	C	0.695100\n");
	fprintf(fout,"OE1 	O	-0.608600\n");
	fprintf(fout,"NE2 	N	-0.940700\n");
	fprintf(fout,"HE21 	H	0.425100\n");
	fprintf(fout,"HE22 	H	0.425100\n");
	fprintf(fout,"OH 	OH	-0.609201\n");
	fprintf(fout,"HO 	HO	0.495147\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin OGLU Residue\n");
	fprintf(fout,"N 	N	-0.516300\n");
	fprintf(fout,"H 	H	0.293600\n");
	fprintf(fout,"CA 	CT	0.039700\n");
	fprintf(fout,"HA 	H1	0.110500\n");
	fprintf(fout,"C 	C	0.653215\n");
	fprintf(fout,"O 	O	-0.548403\n");
	fprintf(fout,"CB 	CT	0.056000\n");
	fprintf(fout,"HB1 	HC	-0.017300\n");
	fprintf(fout,"HB2 	HC	-0.017300\n");
	fprintf(fout,"CG 	CT	0.013600\n");
	fprintf(fout,"HG1 	HC	-0.042500\n");
	fprintf(fout,"HG2 	HC	-0.042500\n");
	fprintf(fout,"CD 	C	0.805400\n");
	fprintf(fout,"OE1 	O2	-0.818800\n");
	fprintf(fout,"OE2 	O2	-0.818800\n");
	fprintf(fout,"OH 	OH	-0.630417\n");
	fprintf(fout,"HO 	HO	0.480305\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin OGLY Residue\n");
	fprintf(fout,"N 	N	-0.415700\n");
	fprintf(fout,"H 	H	0.271900\n");
	fprintf(fout,"CA 	CT	-0.025200\n");
	fprintf(fout,"HA1 	H1	0.069800\n");
	fprintf(fout,"HA2 	H1	0.069800\n");
	fprintf(fout,"C 	C	0.673401\n");
	fprintf(fout,"O 	O	-0.529947\n");
	fprintf(fout,"OH 	OH	-0.609201\n");
	fprintf(fout,"HO 	HO	0.495147\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin OHID Residue\n");
	fprintf(fout,"N 	N	-0.415700\n");
	fprintf(fout,"H 	H	0.271900\n");
	fprintf(fout,"CA 	CT	0.018800\n");
	fprintf(fout,"HA 	H1	0.088100\n");
	fprintf(fout,"C 	C	0.673401\n");
	fprintf(fout,"O 	O	-0.529947\n");
	fprintf(fout,"CB 	CT	-0.046200\n");
	fprintf(fout,"HB1 	HC	0.040200\n");
	fprintf(fout,"HB2 	HC	0.040200\n");
	fprintf(fout,"CG 	CC	-0.026600\n");
	fprintf(fout,"ND1 	NA	-0.381100\n");
	fprintf(fout,"HD1 	H	0.364900\n");
	fprintf(fout,"CD2 	CV	0.129200\n");
	fprintf(fout,"HD2 	H4	0.114700\n");
	fprintf(fout,"CE1 	CR	0.205700\n");
	fprintf(fout,"HE1 	H5	0.139200\n");
	fprintf(fout,"NE2 	NB	-0.572700\n");
	fprintf(fout,"OH 	OH	-0.609201\n");
	fprintf(fout,"HO 	HO	0.495147\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin OHIE Residue\n");
	fprintf(fout,"N 	N	-0.415700\n");
	fprintf(fout,"H 	H	0.271900\n");
	fprintf(fout,"CA 	CT	-0.058100\n");
	fprintf(fout,"HA 	H1	0.136000\n");
	fprintf(fout,"C 	C	0.673401\n");
	fprintf(fout,"O 	O	-0.529947\n");
	fprintf(fout,"CB 	CT	-0.007400\n");
	fprintf(fout,"HB1 	HC	0.036700\n");
	fprintf(fout,"HB2 	HC	0.036700\n");
	fprintf(fout,"CG 	CC	0.186800\n");
	fprintf(fout,"ND1 	NB	-0.543200\n");
	fprintf(fout,"CD2 	CW	-0.220700\n");
	fprintf(fout,"HD2 	H4	0.186200\n");
	fprintf(fout,"CE1 	CR	0.163500\n");
	fprintf(fout,"HE1 	H5	0.143500\n");
	fprintf(fout,"NE2 	NA	-0.279500\n");
	fprintf(fout,"HE2 	H	0.333900\n");
	fprintf(fout,"OH 	OH	-0.609201\n");
	fprintf(fout,"HO 	HO	0.495147\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin OHIP Residue\n");
	fprintf(fout,"N 	N	-0.347900\n");
	fprintf(fout,"H 	H	0.274700\n");
	fprintf(fout,"CA 	CT	-0.135400\n");
	fprintf(fout,"HA 	H1	0.121200\n");
	fprintf(fout,"C 	C	0.704557\n");
	fprintf(fout,"O 	O	-0.501460\n");
	fprintf(fout,"CB 	CT	-0.041400\n");
	fprintf(fout,"HB1 	HC	0.081000\n");
	fprintf(fout,"HB2 	HC	0.081000\n");
	fprintf(fout,"CG 	CC	-0.001200\n");
	fprintf(fout,"ND1 	NA	-0.151300\n");
	fprintf(fout,"HD1 	H	0.386600\n");
	fprintf(fout,"CD2 	CW	-0.114100\n");
	fprintf(fout,"HD2 	H4	0.231700\n");
	fprintf(fout,"CE1 	CR	-0.017000\n");
	fprintf(fout,"HE1 	H5	0.268100\n");
	fprintf(fout,"NE2 	NA	-0.171800\n");
	fprintf(fout,"HE2 	H	0.391100\n");
	fprintf(fout,"OH 	OH	-0.576454\n");
	fprintf(fout,"HO 	HO	0.518057\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin OHIS Residue\n");
	fprintf(fout,"N 	N	-0.347900\n");
	fprintf(fout,"H 	H	0.274700\n");
	fprintf(fout,"CA 	CT	-0.135400\n");
	fprintf(fout,"HA 	H1	0.121200\n");
	fprintf(fout,"C 	C	0.704557\n");
	fprintf(fout,"O 	O	-0.501460\n");
	fprintf(fout,"CB 	CT	-0.041400\n");
	fprintf(fout,"HB1 	HC	0.081000\n");
	fprintf(fout,"HB2 	HC	0.081000\n");
	fprintf(fout,"CG 	CC	-0.001200\n");
	fprintf(fout,"ND1 	NA	-0.151300\n");
	fprintf(fout,"HD1 	H	0.386600\n");
	fprintf(fout,"CD2 	CW	-0.114100\n");
	fprintf(fout,"HD2 	H4	0.231700\n");
	fprintf(fout,"CE1 	CR	-0.017000\n");
	fprintf(fout,"HE1 	H5	0.268100\n");
	fprintf(fout,"NE2 	NA	-0.171800\n");
	fprintf(fout,"HE2 	H	0.391100\n");
	fprintf(fout,"OH 	OH	-0.576454\n");
	fprintf(fout,"HO 	HO	0.518057\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin OILE Residue\n");
	fprintf(fout,"N 	N	-0.415700\n");
	fprintf(fout,"H 	H	0.271900\n");
	fprintf(fout,"CA 	CT	-0.059700\n");
	fprintf(fout,"HA 	H1	0.086900\n");
	fprintf(fout,"C 	C	0.673401\n");
	fprintf(fout,"O 	O	-0.529947\n");
	fprintf(fout,"CB 	CT	0.130300\n");
	fprintf(fout,"HB 	HC	0.018700\n");
	fprintf(fout,"CG1 	CT	-0.043000\n");
	fprintf(fout,"HG11 	HC	0.023600\n");
	fprintf(fout,"HG12 	HC	0.023600\n");
	fprintf(fout,"CG2 	CT	-0.320400\n");
	fprintf(fout,"HG21 	HC	0.088200\n");
	fprintf(fout,"HG22 	HC	0.088200\n");
	fprintf(fout,"HG23 	HC	0.088200\n");
	fprintf(fout,"CD 	CT	-0.066000\n");
	fprintf(fout,"HD1 	HC	0.018600\n");
	fprintf(fout,"HD2 	HC	0.018600\n");
	fprintf(fout,"HD3 	HC	0.018600\n");
	fprintf(fout,"OH 	OH	-0.609201\n");
	fprintf(fout,"HO 	HO	0.495147\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin OLEU Residue\n");
	fprintf(fout,"N 	N	-0.415700\n");
	fprintf(fout,"H 	H	0.271900\n");
	fprintf(fout,"CA 	CT	-0.051800\n");
	fprintf(fout,"HA 	H1	0.092200\n");
	fprintf(fout,"C 	C	0.673401\n");
	fprintf(fout,"O 	O	-0.529947\n");
	fprintf(fout,"CB 	CT	-0.110200\n");
	fprintf(fout,"HB1 	HC	0.045700\n");
	fprintf(fout,"HB2 	HC	0.045700\n");
	fprintf(fout,"CG 	CT	0.353100\n");
	fprintf(fout,"HG 	HC	-0.036100\n");
	fprintf(fout,"CD1 	CT	-0.412100\n");
	fprintf(fout,"HD11 	HC	0.100000\n");
	fprintf(fout,"HD12 	HC	0.100000\n");
	fprintf(fout,"HD13 	HC	0.100000\n");
	fprintf(fout,"CD2 	CT	-0.412100\n");
	fprintf(fout,"HD21 	HC	0.100000\n");
	fprintf(fout,"HD22 	HC	0.100000\n");
	fprintf(fout,"HD23 	HC	0.100000\n");
	fprintf(fout,"OH 	OH	-0.609201\n");
	fprintf(fout,"HO 	HO	0.495147\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin OLYS Residue\n");
	fprintf(fout,"N 	N	-0.347900\n");
	fprintf(fout,"H 	H	0.274700\n");
	fprintf(fout,"CA 	CT	-0.240000\n");
	fprintf(fout,"HA 	H1	0.142600\n");
	fprintf(fout,"C 	C	0.704557\n");
	fprintf(fout,"O 	O	-0.501460\n");
	fprintf(fout,"CB 	CT	-0.009400\n");
	fprintf(fout,"HB1 	HC	0.036200\n");
	fprintf(fout,"HB2 	HC	0.036200\n");
	fprintf(fout,"CG 	CT	0.018700\n");
	fprintf(fout,"HG1 	HC	0.010300\n");
	fprintf(fout,"HG2 	HC	0.010300\n");
	fprintf(fout,"CD 	CT	-0.047900\n");
	fprintf(fout,"HD1 	HC	0.062100\n");
	fprintf(fout,"HD2 	HC	0.062100\n");
	fprintf(fout,"CE 	CT	-0.014300\n");
	fprintf(fout,"HE1 	HP	0.113500\n");
	fprintf(fout,"HE2 	HP	0.113500\n");
	fprintf(fout,"NZ 	N3	-0.385400\n");
	fprintf(fout,"HZ1 	H	0.340000\n");
	fprintf(fout,"HZ2 	H	0.340000\n");
	fprintf(fout,"HZ3 	H	0.340000\n");
	fprintf(fout,"OH 	OH	-0.576454\n");
	fprintf(fout,"HO 	HO	0.518057\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin OMET Residue\n");
	fprintf(fout,"N 	N	-0.415700\n");
	fprintf(fout,"H 	H	0.271900\n");
	fprintf(fout,"CA 	CT	-0.023700\n");
	fprintf(fout,"HA 	H1	0.088000\n");
	fprintf(fout,"C 	C	0.673401\n");
	fprintf(fout,"O 	O	-0.529947\n");
	fprintf(fout,"CB 	CT	0.034200\n");
	fprintf(fout,"HB1 	HC	0.024100\n");
	fprintf(fout,"HB2 	HC	0.024100\n");
	fprintf(fout,"CG 	CT	0.001800\n");
	fprintf(fout,"HG1 	H1	0.044000\n");
	fprintf(fout,"HG2 	H1	0.044000\n");
	fprintf(fout,"SD 	S	-0.273700\n");
	fprintf(fout,"CE 	CT	-0.053600\n");
	fprintf(fout,"HE1 	H1	0.068400\n");
	fprintf(fout,"HE2 	H1	0.068400\n");
	fprintf(fout,"HE3 	H1	0.068400\n");
	fprintf(fout,"OH 	OH	-0.609201\n");
	fprintf(fout,"HO 	HO	0.495147\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin OPHE Residue\n");
	fprintf(fout,"N 	N	-0.415700\n");
	fprintf(fout,"H 	H	0.271900\n");
	fprintf(fout,"CA 	CT	-0.002400\n");
	fprintf(fout,"HA 	H1	0.097800\n");
	fprintf(fout,"C 	C	0.673401\n");
	fprintf(fout,"O 	O	-0.529947\n");
	fprintf(fout,"CB 	CT	-0.034300\n");
	fprintf(fout,"HB1 	HC	0.029500\n");
	fprintf(fout,"HB2 	HC	0.029500\n");
	fprintf(fout,"CG 	CA	0.011800\n");
	fprintf(fout,"CD1 	CA	-0.125600\n");
	fprintf(fout,"HD1 	HA	0.133000\n");
	fprintf(fout,"CD2 	CA	-0.125600\n");
	fprintf(fout,"HD2 	HA	0.133000\n");
	fprintf(fout,"CE1 	CA	-0.170400\n");
	fprintf(fout,"HE1 	HA	0.143000\n");
	fprintf(fout,"CE2 	CA	-0.170400\n");
	fprintf(fout,"HE2 	HA	0.143000\n");
	fprintf(fout,"CZ 	CA	-0.107200\n");
	fprintf(fout,"HZ 	HA	0.129700\n");
	fprintf(fout,"OH 	OH	-0.609201\n");
	fprintf(fout,"HO 	HO	0.495147\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin OPRO Residue\n");
	fprintf(fout,"N 	N	-0.254800\n");
	fprintf(fout,"CA 	CT	-0.026600\n");
	fprintf(fout,"HA 	H1	0.064100\n");
	fprintf(fout,"C 	C	0.669455\n");
	fprintf(fout,"O 	O	-0.533554\n");
	fprintf(fout,"CB 	CT	-0.007000\n");
	fprintf(fout,"HB1 	HC	0.025300\n");
	fprintf(fout,"HB2 	HC	0.025300\n");
	fprintf(fout,"CG 	CT	0.018900\n");
	fprintf(fout,"HG1 	HC	0.021300\n");
	fprintf(fout,"HG2 	HC	0.021300\n");
	fprintf(fout,"CD 	CT	0.019200\n");
	fprintf(fout,"HD1 	H1	0.039100\n");
	fprintf(fout,"HD2 	H1	0.039100\n");
	fprintf(fout,"OH 	OH	-0.613347\n");
	fprintf(fout,"HO 	HO	0.492247\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin OSER Residue\n");
	fprintf(fout,"N 	N	-0.415700\n");
	fprintf(fout,"H 	H	0.271900\n");
	fprintf(fout,"CA 	CT	-0.024900\n");
	fprintf(fout,"HA 	H1	0.084300\n");
	fprintf(fout,"C 	C	0.673401\n");
	fprintf(fout,"O 	O	-0.529947\n");
	fprintf(fout,"CB 	CT	0.211700\n");
	fprintf(fout,"HB1 	H1	0.035200\n");
	fprintf(fout,"HB2 	H1	0.035200\n");
	fprintf(fout,"OG 	OH	-0.654600\n");
	fprintf(fout,"HG 	HO	0.427500\n");
	fprintf(fout,"OH 	OH	-0.609201\n");
	fprintf(fout,"HO 	HO	0.495147\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin OTHR Residue\n");
	fprintf(fout,"N 	N	-0.415700\n");
	fprintf(fout,"H 	H	0.271900\n");
	fprintf(fout,"CA 	CT	-0.038900\n");
	fprintf(fout,"HA 	H1	0.100700\n");
	fprintf(fout,"C 	C	0.673401\n");
	fprintf(fout,"O 	O	-0.529947\n");
	fprintf(fout,"CB 	CT	0.365400\n");
	fprintf(fout,"HB 	H1	0.004300\n");
	fprintf(fout,"OG1 	OH	-0.676100\n");
	fprintf(fout,"HG1 	HO	0.410200\n");
	fprintf(fout,"CG2 	CT	-0.243800\n");
	fprintf(fout,"HG21 	HC	0.064200\n");
	fprintf(fout,"HG22 	HC	0.064200\n");
	fprintf(fout,"HG23 	HC	0.064200\n");
	fprintf(fout,"OH 	OH	-0.609201\n");
	fprintf(fout,"HO 	HO	0.495147\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin OTYR Residue\n");
	fprintf(fout,"N 	N	-0.415700\n");
	fprintf(fout,"H 	H	0.271900\n");
	fprintf(fout,"CA 	CT	-0.001400\n");
	fprintf(fout,"HA 	H1	0.087600\n");
	fprintf(fout,"C 	C	0.673401\n");
	fprintf(fout,"O 	O	-0.529947\n");
	fprintf(fout,"CB 	CT	-0.015200\n");
	fprintf(fout,"HB1 	HC	0.029500\n");
	fprintf(fout,"HB2 	HC	0.029500\n");
	fprintf(fout,"CG 	CA	-0.001100\n");
	fprintf(fout,"CD1 	CA	-0.190600\n");
	fprintf(fout,"HD1 	HA	0.169900\n");
	fprintf(fout,"CD2 	CA	-0.190600\n");
	fprintf(fout,"HD2 	HA	0.169900\n");
	fprintf(fout,"CE1 	CA	-0.234100\n");
	fprintf(fout,"HE1 	HA	0.165600\n");
	fprintf(fout,"CE2 	CA	-0.234100\n");
	fprintf(fout,"HE2 	HA	0.165600\n");
	fprintf(fout,"CZ 	C	0.322600\n");
	fprintf(fout,"OH 	OH	-0.557900\n");
	fprintf(fout,"HH 	HO	0.399200\n");
	fprintf(fout,"OH 	OH	-0.609201\n");
	fprintf(fout,"HO 	HO	0.495147\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin OTRP Residue\n");
	fprintf(fout,"N 	N	-0.415700\n");
	fprintf(fout,"H 	H	0.271900\n");
	fprintf(fout,"CA 	CT	-0.027500\n");
	fprintf(fout,"HA 	H1	0.112300\n");
	fprintf(fout,"C 	C	0.673401\n");
	fprintf(fout,"O 	O	-0.529947\n");
	fprintf(fout,"CB 	CT	-0.005000\n");
	fprintf(fout,"HB1 	HC	0.033900\n");
	fprintf(fout,"HB2 	HC	0.033900\n");
	fprintf(fout,"CG 	C*	-0.141500\n");
	fprintf(fout,"CD1 	CW	-0.163800\n");
	fprintf(fout,"HD1 	H4	0.206200\n");
	fprintf(fout,"CD2 	CB	0.124300\n");
	fprintf(fout,"NE1 	NA	-0.341800\n");
	fprintf(fout,"HE1 	H	0.341200\n");
	fprintf(fout,"CE2 	CN	0.138000\n");
	fprintf(fout,"CE3 	CA	-0.238700\n");
	fprintf(fout,"HE3 	HA	0.170000\n");
	fprintf(fout,"CZ2 	CA	-0.260100\n");
	fprintf(fout,"HZ2 	HA	0.157200\n");
	fprintf(fout,"CZ3 	CA	-0.197200\n");
	fprintf(fout,"HZ3 	HA	0.144700\n");
	fprintf(fout,"CH2 	CA	-0.113400\n");
	fprintf(fout,"HH2 	HA	0.141700\n");
	fprintf(fout,"OH 	OH	-0.609201\n");
	fprintf(fout,"HO 	HO	0.495147\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin OVAL Residue\n");
	fprintf(fout,"N 	N	-0.415700\n");
	fprintf(fout,"H 	H	0.271900\n");
	fprintf(fout,"CA 	CT	-0.087500\n");
	fprintf(fout,"HA 	H1	0.096900\n");
	fprintf(fout,"C 	C	0.673401\n");
	fprintf(fout,"O 	O	-0.529947\n");
	fprintf(fout,"CB 	CT	0.298500\n");
	fprintf(fout,"HB 	HC	-0.029700\n");
	fprintf(fout,"CG1 	CT	-0.319200\n");
	fprintf(fout,"HG11 	HC	0.079100\n");
	fprintf(fout,"HG12 	HC	0.079100\n");
	fprintf(fout,"HG13 	HC	0.079100\n");
	fprintf(fout,"CG2 	CT	-0.319200\n");
	fprintf(fout,"HG21 	HC	0.079100\n");
	fprintf(fout,"HG22 	HC	0.079100\n");
	fprintf(fout,"HG23 	HC	0.079100\n");
	fprintf(fout,"OH 	OH	-0.609201\n");
	fprintf(fout,"HO 	HO	0.495147\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin OASH Residue\n");
	fprintf(fout,"H 	H	0.271900\n");
	fprintf(fout,"N 	N	-0.415700\n");
	fprintf(fout,"HB2 	HC	0.048800\n");
	fprintf(fout,"C 	C	0.673401\n");
	fprintf(fout,"CA 	CT	0.034100\n");
	fprintf(fout,"CB 	CT	-0.031600\n");
	fprintf(fout,"OD1 	O	-0.555400\n");
	fprintf(fout,"HB1 	HC	0.048800\n");
	fprintf(fout,"CG 	C	0.646200\n");
	fprintf(fout,"O 	O	-0.529947\n");
	fprintf(fout,"HA 	H1	0.086400\n");
	fprintf(fout,"OD2 	OH	-0.637600\n");
	fprintf(fout,"HD2 	HO	0.474700\n");
	fprintf(fout,"OH 	OH	-0.609201\n");
	fprintf(fout,"HO 	HO	0.495147\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin OGLH Residue\n");
	fprintf(fout,"O 	O	-0.529947\n");
	fprintf(fout,"C 	C	0.673401\n");
	fprintf(fout,"HB2 	HC	0.025600\n");
	fprintf(fout,"HB1 	HC	0.025600\n");
	fprintf(fout,"CB 	CT	-0.007100\n");
	fprintf(fout,"CA 	CT	0.014500\n");
	fprintf(fout,"HE2 	HO	0.464100\n");
	fprintf(fout,"OE2 	OH	-0.651100\n");
	fprintf(fout,"H 	H	0.271900\n");
	fprintf(fout,"HA 	H1	0.077900\n");
	fprintf(fout,"CD 	C	0.680100\n");
	fprintf(fout,"OE1 	O	-0.583800\n");
	fprintf(fout,"N 	N	-0.415700\n");
	fprintf(fout,"CG 	CT	-0.017400\n");
	fprintf(fout,"HG1 	HC	0.043000\n");
	fprintf(fout,"HG2 	HC	0.043000\n");
	fprintf(fout,"OH 	OH	-0.609201\n");
	fprintf(fout,"HO 	HO	0.495147\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin OLYN Residue\n");
	fprintf(fout,"O 	O	-0.529947\n");
	fprintf(fout,"HB2 	HC	0.034000\n");
	fprintf(fout,"HD2 	HC	0.011550\n");
	fprintf(fout,"HB1 	HC	0.034000\n");
	fprintf(fout,"HD1 	HC	0.011550\n");
	fprintf(fout,"C 	C	0.673401\n");
	fprintf(fout,"CB 	CT	-0.048450\n");
	fprintf(fout,"CD 	CT	-0.037680\n");
	fprintf(fout,"CA 	CT	-0.072060\n");
	fprintf(fout,"CG 	CT	0.066120\n");
	fprintf(fout,"HE2 	HP	-0.033580\n");
	fprintf(fout,"H 	H	0.271900\n");
	fprintf(fout,"N 	N	-0.415700\n");
	fprintf(fout,"HZ1 	H	0.386040\n");
	fprintf(fout,"CE 	CT	0.326040\n");
	fprintf(fout,"NZ 	N3	-1.035810\n");
	fprintf(fout,"HG1 	HC	0.010410\n");
	fprintf(fout,"HG2 	HC	0.010410\n");
	fprintf(fout,"HA 	H1	0.099400\n");
	fprintf(fout,"HZ2 	H	0.386040\n");
	fprintf(fout,"HE1 	HP	-0.033580\n");
	fprintf(fout,"OH 	OH	-0.609201\n");
	fprintf(fout,"HO 	HO	0.495147\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin OCYM Residue\n");
	fprintf(fout,"N 	N	-0.415700\n");
	fprintf(fout,"H 	H	0.271900\n");
	fprintf(fout,"CA 	CT	-0.035100\n");
	fprintf(fout,"HA 	H1	0.050800\n");
	fprintf(fout,"C 	C	0.673401\n");
	fprintf(fout,"O 	O	-0.529947\n");
	fprintf(fout,"CB 	CT	-0.241300\n");
	fprintf(fout,"HB1 	H1	0.112200\n");
	fprintf(fout,"HB2 	H1	0.112200\n");
	fprintf(fout,"SG 	SH	-0.884400\n");
	fprintf(fout,"OH 	OH	-0.609201\n");
	fprintf(fout,"HO 	HO	0.495147\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin NALA Residue\n");
	fprintf(fout,"N      N3     0.14140\n");
	fprintf(fout,"H1     H      0.19970\n");
	fprintf(fout,"H2     H      0.19970\n");
	fprintf(fout,"H3     H      0.19970\n");
	fprintf(fout,"CA     CT     0.09620\n");
	fprintf(fout,"HA     HP     0.08890\n");
	fprintf(fout,"CB     CT     -0.05970\n");
	fprintf(fout,"HB1    HC     0.03000\n");
	fprintf(fout,"HB2    HC     0.03000\n");
	fprintf(fout,"HB3    HC     0.03000\n");
	fprintf(fout,"C      C      0.61630\n");
	fprintf(fout,"O      O      -0.57220\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin NGLY Residue\n");
	fprintf(fout,"N      N3     0.29430\n");
	fprintf(fout,"H1     H      0.16420\n");
	fprintf(fout,"H2     H      0.16420\n");
	fprintf(fout,"H3     H      0.16420\n");
	fprintf(fout,"CA     CT     -0.01000\n");
	fprintf(fout,"HA1    HP     0.08950\n");
	fprintf(fout,"HA2    HP     0.08950\n");
	fprintf(fout,"C      C      0.61630\n");
	fprintf(fout,"O      O      -0.57220\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin NSER Residue\n");
	fprintf(fout,"N      N3     0.18490\n");
	fprintf(fout,"H1     H      0.18980\n");
	fprintf(fout,"H2     H      0.18980\n");
	fprintf(fout,"H3     H      0.18980\n");
	fprintf(fout,"CA     CT     0.05670\n");
	fprintf(fout,"HA     HP     0.07820\n");
	fprintf(fout,"CB     CT     0.25960\n");
	fprintf(fout,"HB1    H1     0.02730\n");
	fprintf(fout,"HB2    H1     0.02730\n");
	fprintf(fout,"OG     OH     -0.67140\n");
	fprintf(fout,"HG     HO     0.42390\n");
	fprintf(fout,"C      C      0.61630\n");
	fprintf(fout,"O      O      -0.57220\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin NTHR Residue\n");
	fprintf(fout,"N      N3     0.18120\n");
	fprintf(fout,"H1     H      0.19340\n");
	fprintf(fout,"H2     H      0.19340\n");
	fprintf(fout,"H3     H      0.19340\n");
	fprintf(fout,"CA     CT     0.00340\n");
	fprintf(fout,"HA     HP     0.10870\n");
	fprintf(fout,"CB     CT     0.45140\n");
	fprintf(fout,"HB     H1     -0.03230\n");
	fprintf(fout,"CG2    CT     -0.25540\n");
	fprintf(fout,"HG21   HC     0.06270\n");
	fprintf(fout,"HG22   HC     0.06270\n");
	fprintf(fout,"HG23   HC     0.06270\n");
	fprintf(fout,"OG1    OH     -0.67640\n");
	fprintf(fout,"HG1    HO     0.40700\n");
	fprintf(fout,"C      C      0.61630\n");
	fprintf(fout,"O      O      -0.57220\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin NLEU Residue\n");
	fprintf(fout,"N      N3     0.10100\n");
	fprintf(fout,"H1     H      0.21480\n");
	fprintf(fout,"H2     H      0.21480\n");
	fprintf(fout,"H3     H      0.21480\n");
	fprintf(fout,"CA     CT     0.01040\n");
	fprintf(fout,"HA     HP     0.10530\n");
	fprintf(fout,"CB     CT     -0.02440\n");
	fprintf(fout,"HB1    HC     0.02560\n");
	fprintf(fout,"HB2    HC     0.02560\n");
	fprintf(fout,"CG     CT     0.34210\n");
	fprintf(fout,"HG     HC     -0.03800\n");
	fprintf(fout,"CD1    CT     -0.41060\n");
	fprintf(fout,"HD11   HC     0.09800\n");
	fprintf(fout,"HD12   HC     0.09800\n");
	fprintf(fout,"HD13   HC     0.09800\n");
	fprintf(fout,"CD2    CT     -0.41040\n");
	fprintf(fout,"HD21   HC     0.09800\n");
	fprintf(fout,"HD22   HC     0.09800\n");
	fprintf(fout,"HD23   HC     0.09800\n");
	fprintf(fout,"C      C      0.61230\n");
	fprintf(fout,"O      O      -0.57130\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin NILE Residue\n");
	fprintf(fout,"N      N3     0.03110\n");
	fprintf(fout,"H1     H      0.23290\n");
	fprintf(fout,"H2     H      0.23290\n");
	fprintf(fout,"H3     H      0.23290\n");
	fprintf(fout,"CA     CT     0.02570\n");
	fprintf(fout,"HA     HP     0.10310\n");
	fprintf(fout,"CB     CT     0.18850\n");
	fprintf(fout,"HB     HC     0.02130\n");
	fprintf(fout,"CG2    CT     -0.37200\n");
	fprintf(fout,"HG21   HC     0.09470\n");
	fprintf(fout,"HG22   HC     0.09470\n");
	fprintf(fout,"HG23   HC     0.09470\n");
	fprintf(fout,"CG1    CT     -0.03870\n");
	fprintf(fout,"HG11   HC     0.02010\n");
	fprintf(fout,"HG12   HC     0.02010\n");
	fprintf(fout,"CD     CT     -0.09080\n");
	fprintf(fout,"HD1    HC     0.02260\n");
	fprintf(fout,"HD2    HC     0.02260\n");
	fprintf(fout,"HD3    HC     0.02260\n");
	fprintf(fout,"C      C      0.61230\n");
	fprintf(fout,"O      O      -0.57130\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin NVAL Residue\n");
	fprintf(fout,"N      N3     0.05770\n");
	fprintf(fout,"H1     H      0.22720\n");
	fprintf(fout,"H2     H      0.22720\n");
	fprintf(fout,"H3     H      0.22720\n");
	fprintf(fout,"CA     CT     -0.00540\n");
	fprintf(fout,"HA     HP     0.10930\n");
	fprintf(fout,"CB     CT     0.31960\n");
	fprintf(fout,"HB     HC     -0.02210\n");
	fprintf(fout,"CG1    CT     -0.31290\n");
	fprintf(fout,"HG11   HC     0.07350\n");
	fprintf(fout,"HG12   HC     0.07350\n");
	fprintf(fout,"HG13   HC     0.07350\n");
	fprintf(fout,"CG2    CT     -0.31290\n");
	fprintf(fout,"HG21   HC     0.07350\n");
	fprintf(fout,"HG22   HC     0.07350\n");
	fprintf(fout,"HG23   HC     0.07350\n");
	fprintf(fout,"C      C      0.61630\n");
	fprintf(fout,"O      O      -0.57220\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin NASN Residue\n");
	fprintf(fout,"N      N3     0.18010\n");
	fprintf(fout,"H1     H      0.19210\n");
	fprintf(fout,"H2     H      0.19210\n");
	fprintf(fout,"H3     H      0.19210\n");
	fprintf(fout,"CA     CT     0.03680\n");
	fprintf(fout,"HA     HP     0.12310\n");
	fprintf(fout,"CB     CT     -0.02830\n");
	fprintf(fout,"HB1    HC     0.05150\n");
	fprintf(fout,"HB2    HC     0.05150\n");
	fprintf(fout,"CG     C      0.58330\n");
	fprintf(fout,"OD1    O      -0.57440\n");
	fprintf(fout,"ND2    N      -0.86340\n");
	fprintf(fout,"HD21   H      0.40970\n");
	fprintf(fout,"HD22   H      0.40970\n");
	fprintf(fout,"C      C      0.61630\n");
	fprintf(fout,"O      O      -0.57220\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin NGLN Residue\n");
	fprintf(fout,"N      N3     0.14930\n");
	fprintf(fout,"H1     H      0.19960\n");
	fprintf(fout,"H2     H      0.19960\n");
	fprintf(fout,"H3     H      0.19960\n");
	fprintf(fout,"CA     CT     0.05360\n");
	fprintf(fout,"HA     HP     0.10150\n");
	fprintf(fout,"CB     CT     0.06510\n");
	fprintf(fout,"HB1    HC     0.00500\n");
	fprintf(fout,"HB2    HC     0.00500\n");
	fprintf(fout,"CG     CT     -0.09030\n");
	fprintf(fout,"HG1    HC     0.03310\n");
	fprintf(fout,"HG2    HC     0.03310\n");
	fprintf(fout,"CD     C      0.73540\n");
	fprintf(fout,"OE1    O      -0.61330\n");
	fprintf(fout,"NE2    N      -1.00310\n");
	fprintf(fout,"HE21   H      0.44290\n");
	fprintf(fout,"HE22   H      0.44290\n");
	fprintf(fout,"C      C      0.61230\n");
	fprintf(fout,"O      O      -0.57130\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin NARG Residue\n");
	fprintf(fout,"N      N3     0.13050\n");
	fprintf(fout,"H1     H      0.20830\n");
	fprintf(fout,"H2     H      0.20830\n");
	fprintf(fout,"H3     H      0.20830\n");
	fprintf(fout,"CA     CT     -0.02230\n");
	fprintf(fout,"HA     HP     0.12420\n");
	fprintf(fout,"CB     CT     0.01180\n");
	fprintf(fout,"HB1    HC     0.02260\n");
	fprintf(fout,"HB2    HC     0.02260\n");
	fprintf(fout,"CG     CT     0.02360\n");
	fprintf(fout,"HG1    HC     0.03090\n");
	fprintf(fout,"HG2    HC     0.03090\n");
	fprintf(fout,"CD     CT     0.09350\n");
	fprintf(fout,"HD1    H1     0.05270\n");
	fprintf(fout,"HD2    H1     0.05270\n");
	fprintf(fout,"NE     N2     -0.56500\n");
	fprintf(fout,"HE     H      0.35920\n");
	fprintf(fout,"CZ     CA     0.82810\n");
	fprintf(fout,"NH1    N2     -0.86930\n");
	fprintf(fout,"HH11   H      0.44940\n");
	fprintf(fout,"HH12   H      0.44940\n");
	fprintf(fout,"NH2    N2     -0.86930\n");
	fprintf(fout,"HH21   H      0.44940\n");
	fprintf(fout,"HH22   H      0.44940\n");
	fprintf(fout,"C      C      0.72140\n");
	fprintf(fout,"O      O      -0.60130\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin NHID Residue\n");
	fprintf(fout,"N      N3     0.15420\n");
	fprintf(fout,"H1     H      0.19630\n");
	fprintf(fout,"H2     H      0.19630\n");
	fprintf(fout,"H3     H      0.19630\n");
	fprintf(fout,"CA     CT     0.09640\n");
	fprintf(fout,"HA     HP     0.09580\n");
	fprintf(fout,"CB     CT     0.02590\n");
	fprintf(fout,"HB1    HC     0.02090\n");
	fprintf(fout,"HB2    HC     0.02090\n");
	fprintf(fout,"CG     CC     -0.03990\n");
	fprintf(fout,"ND1    NA     -0.38190\n");
	fprintf(fout,"HD1    H      0.36320\n");
	fprintf(fout,"CE1    CR     0.21270\n");
	fprintf(fout,"HE1    H5     0.13850\n");
	fprintf(fout,"NE2    NB     -0.57110\n");
	fprintf(fout,"CD2    CV     0.10460\n");
	fprintf(fout,"HD2    H4     0.12990\n");
	fprintf(fout,"C      C      0.61230\n");
	fprintf(fout,"O      O      -0.57130\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin NHIE Residue\n");
	fprintf(fout,"N      N3     0.14720\n");
	fprintf(fout,"H1     H      0.20160\n");
	fprintf(fout,"H2     H      0.20160\n");
	fprintf(fout,"H3     H      0.20160\n");
	fprintf(fout,"CA     CT     0.02360\n");
	fprintf(fout,"HA     HP     0.13800\n");
	fprintf(fout,"CB     CT     0.04890\n");
	fprintf(fout,"HB1    HC     0.02230\n");
	fprintf(fout,"HB2    HC     0.02230\n");
	fprintf(fout,"CG     CC     0.17400\n");
	fprintf(fout,"ND1    NB     -0.55790\n");
	fprintf(fout,"CE1    CR     0.18040\n");
	fprintf(fout,"HE1    H5     0.13970\n");
	fprintf(fout,"NE2    NA     -0.27810\n");
	fprintf(fout,"HE2    H      0.33240\n");
	fprintf(fout,"CD2    CW     -0.23490\n");
	fprintf(fout,"HD2    H4     0.19630\n");
	fprintf(fout,"C      C      0.61230\n");
	fprintf(fout,"O      O      -0.57130\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin NHIP Residue\n");
	fprintf(fout,"N      N3     0.25600\n");
	fprintf(fout,"H1     H      0.17040\n");
	fprintf(fout,"H2     H      0.17040\n");
	fprintf(fout,"H3     H      0.17040\n");
	fprintf(fout,"CA     CT     0.05810\n");
	fprintf(fout,"HA     HP     0.10470\n");
	fprintf(fout,"CB     CT     0.04840\n");
	fprintf(fout,"HB1    HC     0.05310\n");
	fprintf(fout,"HB2    HC     0.05310\n");
	fprintf(fout,"CG     CC     -0.02360\n");
	fprintf(fout,"ND1    NA     -0.15100\n");
	fprintf(fout,"HD1    H      0.38210\n");
	fprintf(fout,"CE1    CR     -0.00110\n");
	fprintf(fout,"HE1    H5     0.26450\n");
	fprintf(fout,"NE2    NA     -0.17390\n");
	fprintf(fout,"HE2    H      0.39210\n");
	fprintf(fout,"CD2    CW     -0.14330\n");
	fprintf(fout,"HD2    H4     0.24950\n");
	fprintf(fout,"C      C      0.72140\n");
	fprintf(fout,"O      O      -0.60130\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin NHIS Residue\n");
	fprintf(fout,"N      N3     0.25600\n");
	fprintf(fout,"H1     H      0.17040\n");
	fprintf(fout,"H2     H      0.17040\n");
	fprintf(fout,"H3     H      0.17040\n");
	fprintf(fout,"CA     CT     0.05810\n");
	fprintf(fout,"HA     HP     0.10470\n");
	fprintf(fout,"CB     CT     0.04840\n");
	fprintf(fout,"HB1    HC     0.05310\n");
	fprintf(fout,"HB2    HC     0.05310\n");
	fprintf(fout,"CG     CC     -0.02360\n");
	fprintf(fout,"ND1    NA     -0.15100\n");
	fprintf(fout,"HD1    H      0.38210\n");
	fprintf(fout,"CE1    CR     -0.00110\n");
	fprintf(fout,"HE1    H5     0.26450\n");
	fprintf(fout,"NE2    NA     -0.17390\n");
	fprintf(fout,"HE2    H      0.39210\n");
	fprintf(fout,"CD2    CW     -0.14330\n");
	fprintf(fout,"HD2    H4     0.24950\n");
	fprintf(fout,"C      C      0.72140\n");
	fprintf(fout,"O      O      -0.60130\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin NTRP Residue\n");
	fprintf(fout,"N      N3     0.19130\n");
	fprintf(fout,"H1     H      0.18880\n");
	fprintf(fout,"H2     H      0.18880\n");
	fprintf(fout,"H3     H      0.18880\n");
	fprintf(fout,"CA     CT     0.04210\n");
	fprintf(fout,"HA     HP     0.11620\n");
	fprintf(fout,"CB     CT     0.05430\n");
	fprintf(fout,"HB1    HC     0.02220\n");
	fprintf(fout,"HB2    HC     0.02220\n");
	fprintf(fout,"CG     C*     -0.16540\n");
	fprintf(fout,"CD1    CW     -0.17880\n");
	fprintf(fout,"HD1    H4     0.21950\n");
	fprintf(fout,"NE1    NA     -0.34440\n");
	fprintf(fout,"HE1    H      0.34120\n");
	fprintf(fout,"CE2    CN     0.15750\n");
	fprintf(fout,"CZ2    CA     -0.27100\n");
	fprintf(fout,"HZ2    HA     0.15890\n");
	fprintf(fout,"CH2    CA     -0.10800\n");
	fprintf(fout,"HH2    HA     0.14110\n");
	fprintf(fout,"CZ3    CA     -0.20340\n");
	fprintf(fout,"HZ3    HA     0.14580\n");
	fprintf(fout,"CE3    CA     -0.22650\n");
	fprintf(fout,"HE3    HA     0.16460\n");
	fprintf(fout,"CD2    CB     0.11320\n");
	fprintf(fout,"C      C      0.61230\n");
	fprintf(fout,"O      O      -0.57130\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin NPHE Residue\n");
	fprintf(fout,"N      N3     0.17370\n");
	fprintf(fout,"H1     H      0.19210\n");
	fprintf(fout,"H2     H      0.19210\n");
	fprintf(fout,"H3     H      0.19210\n");
	fprintf(fout,"CA     CT     0.07330\n");
	fprintf(fout,"HA     HP     0.10410\n");
	fprintf(fout,"CB     CT     0.03300\n");
	fprintf(fout,"HB1    HC     0.01040\n");
	fprintf(fout,"HB2    HC     0.01040\n");
	fprintf(fout,"CG     CA     0.00310\n");
	fprintf(fout,"CD1    CA     -0.13920\n");
	fprintf(fout,"HD1    HA     0.13740\n");
	fprintf(fout,"CE1    CA     -0.16020\n");
	fprintf(fout,"HE1    HA     0.14330\n");
	fprintf(fout,"CZ     CA     -0.12080\n");
	fprintf(fout,"HZ     HA     0.13290\n");
	fprintf(fout,"CE2    CA     -0.16030\n");
	fprintf(fout,"HE2    HA     0.14330\n");
	fprintf(fout,"CD2    CA     -0.13910\n");
	fprintf(fout,"HD2    HA     0.13740\n");
	fprintf(fout,"C      C      0.61230\n");
	fprintf(fout,"O      O      -0.57130\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin NTYR Residue\n");
	fprintf(fout,"N      N3     0.19400\n");
	fprintf(fout,"H1     H      0.18730\n");
	fprintf(fout,"H2     H      0.18730\n");
	fprintf(fout,"H3     H      0.18730\n");
	fprintf(fout,"CA     CT     0.05700\n");
	fprintf(fout,"HA     HP     0.09830\n");
	fprintf(fout,"CB     CT     0.06590\n");
	fprintf(fout,"HB1    HC     0.01020\n");
	fprintf(fout,"HB2    HC     0.01020\n");
	fprintf(fout,"CG     CA     -0.02050\n");
	fprintf(fout,"CD1    CA     -0.20020\n");
	fprintf(fout,"HD1    HA     0.17200\n");
	fprintf(fout,"CE1    CA     -0.22390\n");
	fprintf(fout,"HE1    HA     0.16500\n");
	fprintf(fout,"CZ     C      0.31390\n");
	fprintf(fout,"OH     OH     -0.55780\n");
	fprintf(fout,"HH     HO     0.40010\n");
	fprintf(fout,"CE2    CA     -0.22390\n");
	fprintf(fout,"HE2    HA     0.16500\n");
	fprintf(fout,"CD2    CA     -0.20020\n");
	fprintf(fout,"HD2    HA     0.17200\n");
	fprintf(fout,"C      C      0.61230\n");
	fprintf(fout,"O      O      -0.57130\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin NGLU Residue\n");
	fprintf(fout,"N      N3     0.00170\n");
	fprintf(fout,"H1     H      0.23910\n");
	fprintf(fout,"H2     H      0.23910\n");
	fprintf(fout,"H3     H      0.23910\n");
	fprintf(fout,"CA     CT     0.05880\n");
	fprintf(fout,"HA     HP     0.12020\n");
	fprintf(fout,"CB     CT     0.09090\n");
	fprintf(fout,"HB1    HC     -0.02320\n");
	fprintf(fout,"HB2    HC     -0.02320\n");
	fprintf(fout,"CG     CT     -0.02360\n");
	fprintf(fout,"HG1    HC     -0.03150\n");
	fprintf(fout,"HG2    HC     -0.03150\n");
	fprintf(fout,"CD     C      0.80870\n");
	fprintf(fout,"OE1    O2     -0.81890\n");
	fprintf(fout,"OE2    O2     -0.81890\n");
	fprintf(fout,"C      C      0.56210\n");
	fprintf(fout,"O      O      -0.58890\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin NASP Residue\n");
	fprintf(fout,"N      N3     0.07820\n");
	fprintf(fout,"H1     H      0.22000\n");
	fprintf(fout,"H2     H      0.22000\n");
	fprintf(fout,"H3     H      0.22000\n");
	fprintf(fout,"CA     CT     0.02920\n");
	fprintf(fout,"HA     HP     0.11410\n");
	fprintf(fout,"CB     CT     -0.02350\n");
	fprintf(fout,"HB1    HC     -0.01690\n");
	fprintf(fout,"HB2    HC     -0.01690\n");
	fprintf(fout,"CG     C      0.81940\n");
	fprintf(fout,"OD1    O2     -0.80840\n");
	fprintf(fout,"OD2    O2     -0.80840\n");
	fprintf(fout,"C      C      0.56210\n");
	fprintf(fout,"O      O      -0.58890\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin NLYS Residue\n");
	fprintf(fout,"N      N3     0.09660\n");
	fprintf(fout,"H1     H      0.21650\n");
	fprintf(fout,"H2     H      0.21650\n");
	fprintf(fout,"H3     H      0.21650\n");
	fprintf(fout,"CA     CT     -0.00150\n");
	fprintf(fout,"HA     HP     0.11800\n");
	fprintf(fout,"CB     CT     0.02120\n");
	fprintf(fout,"HB1    HC     0.02830\n");
	fprintf(fout,"HB2    HC     0.02830\n");
	fprintf(fout,"CG     CT     -0.00480\n");
	fprintf(fout,"HG1    HC     0.01210\n");
	fprintf(fout,"HG2    HC     0.01210\n");
	fprintf(fout,"CD     CT     -0.06080\n");
	fprintf(fout,"HD1    HC     0.06330\n");
	fprintf(fout,"HD2    HC     0.06330\n");
	fprintf(fout,"CE     CT     -0.01810\n");
	fprintf(fout,"HE1    HP     0.11710\n");
	fprintf(fout,"HE2    HP     0.11710\n");
	fprintf(fout,"NZ     N3     -0.37640\n");
	fprintf(fout,"HZ1    H      0.33820\n");
	fprintf(fout,"HZ2    H      0.33820\n");
	fprintf(fout,"HZ3    H      0.33820\n");
	fprintf(fout,"C      C      0.72140\n");
	fprintf(fout,"O      O      -0.60130\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin NLYP Residue\n");
	fprintf(fout,"N      N3     0.09660\n");
	fprintf(fout,"H1     H      0.21650\n");
	fprintf(fout,"H2     H      0.21650\n");
	fprintf(fout,"H3     H      0.21650\n");
	fprintf(fout,"CA     CT     -0.00150\n");
	fprintf(fout,"HA     HP     0.11800\n");
	fprintf(fout,"CB     CT     0.02120\n");
	fprintf(fout,"HB1    HC     0.02830\n");
	fprintf(fout,"HB2    HC     0.02830\n");
	fprintf(fout,"CG     CT     -0.00480\n");
	fprintf(fout,"HG1    HC     0.01210\n");
	fprintf(fout,"HG2    HC     0.01210\n");
	fprintf(fout,"CD     CT     -0.06080\n");
	fprintf(fout,"HD1    HC     0.06330\n");
	fprintf(fout,"HD2    HC     0.06330\n");
	fprintf(fout,"CE     CT     -0.01810\n");
	fprintf(fout,"HE1    HP     0.11710\n");
	fprintf(fout,"HE2    HP     0.11710\n");
	fprintf(fout,"NZ     N3     -0.37640\n");
	fprintf(fout,"HZ1    H      0.33820\n");
	fprintf(fout,"HZ2    H      0.33820\n");
	fprintf(fout,"HZ3    H      0.33820\n");
	fprintf(fout,"C      C      0.72140\n");
	fprintf(fout,"O      O      -0.60130\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin NPRO Residue\n");
	fprintf(fout,"N      N3     -0.20200\n");
	fprintf(fout,"H1     H      0.31200\n");
	fprintf(fout,"H2     H      0.31200\n");
	fprintf(fout,"CD     CT     -0.01200\n");
	fprintf(fout,"HD1    HP     0.10000\n");
	fprintf(fout,"HD2    HP     0.10000\n");
	fprintf(fout,"CG     CT     -0.12100\n");
	fprintf(fout,"HG1    HC     0.10000\n");
	fprintf(fout,"HG2    HC     0.10000\n");
	fprintf(fout,"CB     CT     -0.11500\n");
	fprintf(fout,"HB1    HC     0.10000\n");
	fprintf(fout,"HB2    HC     0.10000\n");
	fprintf(fout,"CA     CT     0.10000\n");
	fprintf(fout,"HA     HP     0.10000\n");
	fprintf(fout,"C      C      0.52600\n");
	fprintf(fout,"O      O      -0.50000\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin NCYS Residue\n");
	fprintf(fout,"N      N3     0.13250\n");
	fprintf(fout,"H1     H      0.20230\n");
	fprintf(fout,"H2     H      0.20230\n");
	fprintf(fout,"H3     H      0.20230\n");
	fprintf(fout,"CA     CT     0.09270\n");
	fprintf(fout,"HA     HP     0.14110\n");
	fprintf(fout,"CB     CT     -0.11950\n");
	fprintf(fout,"HB1    H1     0.11880\n");
	fprintf(fout,"HB2    H1     0.11880\n");
	fprintf(fout,"SG     SH     -0.32980\n");
	fprintf(fout,"HG     HS     0.19750\n");
	fprintf(fout,"C      C      0.61230\n");
	fprintf(fout,"O      O      -0.57130\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin NCYN Residue\n");
	fprintf(fout,"N      N3     0.13250\n");
	fprintf(fout,"H1     H      0.20230\n");
	fprintf(fout,"H2     H      0.20230\n");
	fprintf(fout,"H3     H      0.20230\n");
	fprintf(fout,"CA     CT     0.09270\n");
	fprintf(fout,"HA     HP     0.14110\n");
	fprintf(fout,"CB     CT     -0.11950\n");
	fprintf(fout,"HB1    H1     0.11880\n");
	fprintf(fout,"HB2    H1     0.11880\n");
	fprintf(fout,"SG     SH     -0.32980\n");
	fprintf(fout,"HG     HS     0.19750\n");
	fprintf(fout,"C      C      0.61230\n");
	fprintf(fout,"O      O      -0.57130\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin NCYM Residue\n");
	fprintf(fout,"N      N3     0.098749\n");
	fprintf(fout,"H1     H      0.150769\n");
	fprintf(fout,"H2     H      0.150769\n");
	fprintf(fout,"H3     H      0.150769\n");
	fprintf(fout,"CA     CT     0.069086\n");
	fprintf(fout,"HA     HP     0.105158\n");
	fprintf(fout,"CB     CT     -0.11950\n");
	fprintf(fout,"HB1    H1     0.11880\n");
	fprintf(fout,"HB2    H1     0.11880\n");
	fprintf(fout,"SG     SH     -0.88440\n");
	fprintf(fout,"C      C      0.61230\n");
	fprintf(fout,"O      O      -0.57130\n");

	fprintf(fout,"Begin NCYX Residue\n");
	fprintf(fout,"N      N3     0.20690\n");
	fprintf(fout,"H1     H      0.18150\n");
	fprintf(fout,"H2     H      0.18150\n");
	fprintf(fout,"H3     H      0.18150\n");
	fprintf(fout,"CA     CT     0.10550\n");
	fprintf(fout,"HA     HP     0.09220\n");
	fprintf(fout,"CB     CT     -0.02770\n");
	fprintf(fout,"HB1    H1     0.06800\n");
	fprintf(fout,"HB2    H1     0.06800\n");
	fprintf(fout,"SG     S      -0.09840\n");
	fprintf(fout,"C      C      0.61230\n");
	fprintf(fout,"O      O      -0.57130\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin NMET Residue\n");
	fprintf(fout,"N      N3     0.15920\n");
	fprintf(fout,"H1     H      0.19840\n");
	fprintf(fout,"H2     H      0.19840\n");
	fprintf(fout,"H3     H      0.19840\n");
	fprintf(fout,"CA     CT     0.02210\n");
	fprintf(fout,"HA     HP     0.11160\n");
	fprintf(fout,"CB     CT     0.08650\n");
	fprintf(fout,"HB1    HC     0.01250\n");
	fprintf(fout,"HB2    HC     0.01250\n");
	fprintf(fout,"CG     CT     0.03340\n");
	fprintf(fout,"HG1    H1     0.02920\n");
	fprintf(fout,"HG2    H1     0.02920\n");
	fprintf(fout,"SD     S      -0.27740\n");
	fprintf(fout,"CE     CT     -0.03410\n");
	fprintf(fout,"HE1    H1     0.05970\n");
	fprintf(fout,"HE2    H1     0.05970\n");
	fprintf(fout,"HE3    H1     0.05970\n");
	fprintf(fout,"C      C      0.61230\n");
	fprintf(fout,"O      O      -0.57130\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin NASH Residue\n");
	fprintf(fout,"N      N3     0.09069\n");
	fprintf(fout,"H1     H      0.25517\n");
	fprintf(fout,"H2     H      0.25517\n");
	fprintf(fout,"H3     H      0.25517\n");
	fprintf(fout,"CA     CT     0.03410\n");
	fprintf(fout,"HA     H1     0.08640\n");
	fprintf(fout,"CB     CT     -0.03160\n");
	fprintf(fout,"HB1    HC     0.04880\n");
	fprintf(fout,"HB2    HC     0.04880\n");
	fprintf(fout,"CG     C      0.64620\n");
	fprintf(fout,"OD1    O      -0.55540\n");
	fprintf(fout,"OD2    OH     -0.63760\n");
	fprintf(fout,"HD2    HO     0.47470\n");
	fprintf(fout,"C      C      0.59730\n");
	fprintf(fout,"O      O      -0.56790\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin NGLH Residue\n");
	fprintf(fout,"N      N3     0.32022\n");
	fprintf(fout,"H1     H      0.17866\n");
	fprintf(fout,"H2     H      0.17866\n");
	fprintf(fout,"H3     H      0.17866\n");
	fprintf(fout,"CA     CT     0.01450\n");
	fprintf(fout,"HA     H1     0.07790\n");
	fprintf(fout,"CB     CT     -0.00710\n");
	fprintf(fout,"HB1    HC     0.02560\n");
	fprintf(fout,"HB2    HC     0.02560\n");
	fprintf(fout,"CG     CT     -0.01740\n");
	fprintf(fout,"HG1    HC     0.04300\n");
	fprintf(fout,"HG2    HC     0.04300\n");
	fprintf(fout,"CD     C      0.68010\n");
	fprintf(fout,"OE1    O      -0.58380\n");
	fprintf(fout,"OE2    OH     -0.65110\n");
	fprintf(fout,"HE2    HO     0.46410\n");
	fprintf(fout,"C      C      0.59730\n");
	fprintf(fout,"O      O      -0.56790\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin NLYN Residue\n");
	fprintf(fout,"N      N3     0.32022\n");
	fprintf(fout,"H1     H      0.17866\n");
	fprintf(fout,"H2     H      0.17866\n");
	fprintf(fout,"H3     H      0.17866\n");
	fprintf(fout,"CA     CT     -0.07206\n");
	fprintf(fout,"HA     H1     0.09940\n");
	fprintf(fout,"CB     CT     -0.04845\n");
	fprintf(fout,"HB1    HC     0.03400\n");
	fprintf(fout,"HB2    HC     0.03400\n");
	fprintf(fout,"CG     CT     0.06612\n");
	fprintf(fout,"HG1    HC     0.01041\n");
	fprintf(fout,"HG2    HC     0.01041\n");
	fprintf(fout,"CD     CT     -0.03768\n");
	fprintf(fout,"HD1    HC     0.01155\n");
	fprintf(fout,"HD2    HC     0.01155\n");
	fprintf(fout,"CE     CT     0.32604\n");
	fprintf(fout,"HE1    HP     -0.03358\n");
	fprintf(fout,"HE2    HP     -0.03358\n");
	fprintf(fout,"NZ     N3     -1.03581\n");
	fprintf(fout,"HZ1    H      0.38604\n");
	fprintf(fout,"HZ2    H      0.38604\n");
	fprintf(fout,"C      C      0.59730\n");
	fprintf(fout,"O      O      -0.56790\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin HALA Residue\n");
	fprintf(fout,"N 	N	-0.954950\n");
	fprintf(fout,"H1 	H	0.405575\n");
	fprintf(fout,"H2 	H	0.405575\n");
	fprintf(fout,"CA 	CT	0.033700\n");
	fprintf(fout,"HA 	H1	0.082300\n");
	fprintf(fout,"C 	C	0.597300\n");
	fprintf(fout,"O 	O	-0.567900\n");
	fprintf(fout,"CB 	CT	-0.182500\n");
	fprintf(fout,"HB1 	HC	0.060300\n");
	fprintf(fout,"HB2 	HC	0.060300\n");
	fprintf(fout,"HB3 	HC	0.060300\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin HARG Residue\n");
	fprintf(fout,"N 	N	-0.916539\n");
	fprintf(fout,"H1 	H	0.421669\n");
	fprintf(fout,"H2 	H	0.421669\n");
	fprintf(fout,"CA 	CT	-0.263700\n");
	fprintf(fout,"HA 	H1	0.156000\n");
	fprintf(fout,"C 	C	0.734100\n");
	fprintf(fout,"O 	O	-0.589400\n");
	fprintf(fout,"CB 	CT	-0.000700\n");
	fprintf(fout,"HB1 	HC	0.032700\n");
	fprintf(fout,"HB2 	HC	0.032700\n");
	fprintf(fout,"CG 	CT	0.039000\n");
	fprintf(fout,"HG1 	HC	0.028500\n");
	fprintf(fout,"HG2 	HC	0.028500\n");
	fprintf(fout,"CD 	CT	0.048600\n");
	fprintf(fout,"HD1 	H1	0.068700\n");
	fprintf(fout,"HD2 	H1	0.068700\n");
	fprintf(fout,"NE 	N2	-0.529500\n");
	fprintf(fout,"HE 	H	0.345600\n");
	fprintf(fout,"CZ 	CA	0.807600\n");
	fprintf(fout,"NH1 	N2	-0.862700\n");
	fprintf(fout,"HH11 	H	0.447800\n");
	fprintf(fout,"HH12 	H	0.447800\n");
	fprintf(fout,"NH2 	N2	-0.862700\n");
	fprintf(fout,"HH21 	H	0.447800\n");
	fprintf(fout,"HH22 	H	0.447800\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin HASN Residue\n");
	fprintf(fout,"N 	N	-0.954950\n");
	fprintf(fout,"H1 	H	0.405575\n");
	fprintf(fout,"H2 	H	0.405575\n");
	fprintf(fout,"CA 	CT	0.014300\n");
	fprintf(fout,"HA 	H1	0.104800\n");
	fprintf(fout,"C 	C	0.597300\n");
	fprintf(fout,"O 	O	-0.567900\n");
	fprintf(fout,"CB 	CT	-0.204100\n");
	fprintf(fout,"HB1 	HC	0.079700\n");
	fprintf(fout,"HB2 	HC	0.079700\n");
	fprintf(fout,"CG 	C	0.713000\n");
	fprintf(fout,"OD1 	O	-0.593100\n");
	fprintf(fout,"ND2 	N	-0.919100\n");
	fprintf(fout,"HD21 	H	0.419600\n");
	fprintf(fout,"HD22 	H	0.419600\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin HASP Residue\n");
	fprintf(fout,"N 	N	-0.997877\n");
	fprintf(fout,"H1 	H	0.387588\n");
	fprintf(fout,"H2 	H	0.387588\n");
	fprintf(fout,"CA 	CT	0.038100\n");
	fprintf(fout,"HA 	H1	0.088000\n");
	fprintf(fout,"C 	C	0.536600\n");
	fprintf(fout,"O 	O	-0.581900\n");
	fprintf(fout,"CB 	CT	-0.030300\n");
	fprintf(fout,"HB1 	HC	-0.012200\n");
	fprintf(fout,"HB2 	HC	-0.012200\n");
	fprintf(fout,"CG 	C	0.799400\n");
	fprintf(fout,"OD1 	O2	-0.801400\n");
	fprintf(fout,"OD2 	O2	-0.801400\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin HCYS Residue\n");
	fprintf(fout,"N 	N	-0.954950\n");
	fprintf(fout,"H1 	H	0.405575\n");
	fprintf(fout,"H2 	H	0.405575\n");
	fprintf(fout,"CA 	CT	0.021300\n");
	fprintf(fout,"HA 	H1	0.112400\n");
	fprintf(fout,"C 	C	0.597300\n");
	fprintf(fout,"O 	O	-0.567900\n");
	fprintf(fout,"CB 	CT	-0.123100\n");
	fprintf(fout,"HB1 	H1	0.111200\n");
	fprintf(fout,"HB2 	H1	0.111200\n");
	fprintf(fout,"SG 	SH	-0.311900\n");
	fprintf(fout,"HG 	HS	0.193300\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin HCYX Residue\n");
	fprintf(fout,"N 	N	-0.954950\n");
	fprintf(fout,"H1 	H	0.405575\n");
	fprintf(fout,"H2 	H	0.405575\n");
	fprintf(fout,"CA 	CT	0.042900\n");
	fprintf(fout,"HA 	H1	0.076600\n");
	fprintf(fout,"C 	C	0.597300\n");
	fprintf(fout,"O 	O	-0.567900\n");
	fprintf(fout,"CB 	CT	-0.079000\n");
	fprintf(fout,"HB1 	H1	0.091000\n");
	fprintf(fout,"HB2 	H1	0.091000\n");
	fprintf(fout,"SG 	S	-0.108100\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin HGLN Residue\n");
	fprintf(fout,"N 	N	-0.954950\n");
	fprintf(fout,"H1 	H	0.405575\n");
	fprintf(fout,"H2 	H	0.405575\n");
	fprintf(fout,"CA 	CT	-0.003100\n");
	fprintf(fout,"HA 	H1	0.085000\n");
	fprintf(fout,"C 	C	0.597300\n");
	fprintf(fout,"O 	O	-0.567900\n");
	fprintf(fout,"CB 	CT	-0.003600\n");
	fprintf(fout,"HB1 	HC	0.017100\n");
	fprintf(fout,"HB2 	HC	0.017100\n");
	fprintf(fout,"CG 	CT	-0.064500\n");
	fprintf(fout,"HG1 	HC	0.035200\n");
	fprintf(fout,"HG2 	HC	0.035200\n");
	fprintf(fout,"CD 	C	0.695100\n");
	fprintf(fout,"OE1 	O	-0.608600\n");
	fprintf(fout,"NE2 	N	-0.940700\n");
	fprintf(fout,"HE21 	H	0.425100\n");
	fprintf(fout,"HE22 	H	0.425100\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin HGLU Residue\n");
	fprintf(fout,"N 	N	-0.997877\n");
	fprintf(fout,"H1 	H	0.387588\n");
	fprintf(fout,"H2 	H	0.387588\n");
	fprintf(fout,"CA 	CT	0.039700\n");
	fprintf(fout,"HA 	H1	0.110500\n");
	fprintf(fout,"C 	C	0.536600\n");
	fprintf(fout,"O 	O	-0.581900\n");
	fprintf(fout,"CB 	CT	0.056000\n");
	fprintf(fout,"HB1 	HC	-0.017300\n");
	fprintf(fout,"HB2 	HC	-0.017300\n");
	fprintf(fout,"CG 	CT	0.013600\n");
	fprintf(fout,"HG1 	HC	-0.042500\n");
	fprintf(fout,"HG2 	HC	-0.042500\n");
	fprintf(fout,"CD 	C	0.805400\n");
	fprintf(fout,"OE1 	O2	-0.818800\n");
	fprintf(fout,"OE2 	O2	-0.818800\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin HGLY Residue\n");
	fprintf(fout,"N 	N	-0.954950\n");
	fprintf(fout,"H1 	H	0.405575\n");
	fprintf(fout,"H2 	H	0.405575\n");
	fprintf(fout,"CA 	CT	-0.025200\n");
	fprintf(fout,"HA1 	H1	0.069800\n");
	fprintf(fout,"HA2 	H1	0.069800\n");
	fprintf(fout,"C 	C	0.597300\n");
	fprintf(fout,"O 	O	-0.567900\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin HHID Residue\n");
	fprintf(fout,"N 	N	-0.954950\n");
	fprintf(fout,"H1 	H	0.405575\n");
	fprintf(fout,"H2 	H	0.405575\n");
	fprintf(fout,"CA 	CT	0.018800\n");
	fprintf(fout,"HA 	H1	0.088100\n");
	fprintf(fout,"C 	C	0.597300\n");
	fprintf(fout,"O 	O	-0.567900\n");
	fprintf(fout,"CB 	CT	-0.046200\n");
	fprintf(fout,"HB1 	HC	0.040200\n");
	fprintf(fout,"HB2 	HC	0.040200\n");
	fprintf(fout,"CG 	CC	-0.026600\n");
	fprintf(fout,"ND1 	NA	-0.381100\n");
	fprintf(fout,"HD1 	H	0.364900\n");
	fprintf(fout,"CD2 	CV	0.129200\n");
	fprintf(fout,"HD2 	H4	0.114700\n");
	fprintf(fout,"CE1 	CR	0.205700\n");
	fprintf(fout,"HE1 	H5	0.139200\n");
	fprintf(fout,"NE2 	NB	-0.572700\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin HHIE Residue\n");
	fprintf(fout,"N 	N	-0.954950\n");
	fprintf(fout,"H1 	H	0.405575\n");
	fprintf(fout,"H2 	H	0.405575\n");
	fprintf(fout,"CA 	CT	-0.058100\n");
	fprintf(fout,"HA 	H1	0.136000\n");
	fprintf(fout,"C 	C	0.597300\n");
	fprintf(fout,"O 	O	-0.567900\n");
	fprintf(fout,"CB 	CT	-0.007400\n");
	fprintf(fout,"HB1 	HC	0.036700\n");
	fprintf(fout,"HB2 	HC	0.036700\n");
	fprintf(fout,"CG 	CC	0.186800\n");
	fprintf(fout,"ND1 	NB	-0.543200\n");
	fprintf(fout,"CD2 	CW	-0.220700\n");
	fprintf(fout,"HD2 	H4	0.186200\n");
	fprintf(fout,"CE1 	CR	0.163500\n");
	fprintf(fout,"HE1 	H5	0.143500\n");
	fprintf(fout,"NE2 	NA	-0.279500\n");
	fprintf(fout,"HE2 	H	0.333900\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin HHIP Residue\n");
	fprintf(fout,"N 	N	-0.916539\n");
	fprintf(fout,"H1 	H	0.421669\n");
	fprintf(fout,"H2 	H	0.421669\n");
	fprintf(fout,"CA 	CT	-0.135400\n");
	fprintf(fout,"HA 	H1	0.121200\n");
	fprintf(fout,"C 	C	0.734100\n");
	fprintf(fout,"O 	O	-0.589400\n");
	fprintf(fout,"CB 	CT	-0.041400\n");
	fprintf(fout,"HB1 	HC	0.081000\n");
	fprintf(fout,"HB2 	HC	0.081000\n");
	fprintf(fout,"CG 	CC	-0.001200\n");
	fprintf(fout,"ND1 	NA	-0.151300\n");
	fprintf(fout,"HD1 	H	0.386600\n");
	fprintf(fout,"CD2 	CW	-0.114100\n");
	fprintf(fout,"HD2 	H4	0.231700\n");
	fprintf(fout,"CE1 	CR	-0.017000\n");
	fprintf(fout,"HE1 	H5	0.268100\n");
	fprintf(fout,"NE2 	NA	-0.171800\n");
	fprintf(fout,"HE2 	H	0.391100\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin HHIS Residue\n");
	fprintf(fout,"N 	N	-0.916539\n");
	fprintf(fout,"H1 	H	0.421669\n");
	fprintf(fout,"H2 	H	0.421669\n");
	fprintf(fout,"CA 	CT	-0.135400\n");
	fprintf(fout,"HA 	H1	0.121200\n");
	fprintf(fout,"C 	C	0.734100\n");
	fprintf(fout,"O 	O	-0.589400\n");
	fprintf(fout,"CB 	CT	-0.041400\n");
	fprintf(fout,"HB1 	HC	0.081000\n");
	fprintf(fout,"HB2 	HC	0.081000\n");
	fprintf(fout,"CG 	CC	-0.001200\n");
	fprintf(fout,"ND1 	NA	-0.151300\n");
	fprintf(fout,"HD1 	H	0.386600\n");
	fprintf(fout,"CD2 	CW	-0.114100\n");
	fprintf(fout,"HD2 	H4	0.231700\n");
	fprintf(fout,"CE1 	CR	-0.017000\n");
	fprintf(fout,"HE1 	H5	0.268100\n");
	fprintf(fout,"NE2 	NA	-0.171800\n");
	fprintf(fout,"HE2 	H	0.391100\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin HILE Residue\n");
	fprintf(fout,"N 	N	-0.954950\n");
	fprintf(fout,"H1 	H	0.405575\n");
	fprintf(fout,"H2 	H	0.405575\n");
	fprintf(fout,"CA 	CT	-0.059700\n");
	fprintf(fout,"HA 	H1	0.086900\n");
	fprintf(fout,"C 	C	0.597300\n");
	fprintf(fout,"O 	O	-0.567900\n");
	fprintf(fout,"CB 	CT	0.130300\n");
	fprintf(fout,"HB 	HC	0.018700\n");
	fprintf(fout,"CG1 	CT	-0.043000\n");
	fprintf(fout,"HG11 	HC	0.023600\n");
	fprintf(fout,"HG12 	HC	0.023600\n");
	fprintf(fout,"CG2 	CT	-0.320400\n");
	fprintf(fout,"HG21 	HC	0.088200\n");
	fprintf(fout,"HG22 	HC	0.088200\n");
	fprintf(fout,"HG23 	HC	0.088200\n");
	fprintf(fout,"CD 	CT	-0.066000\n");
	fprintf(fout,"HD1 	HC	0.018600\n");
	fprintf(fout,"HD2 	HC	0.018600\n");
	fprintf(fout,"HD3 	HC	0.018600\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin HLEU Residue\n");
	fprintf(fout,"N 	N	-0.954950\n");
	fprintf(fout,"H1 	H	0.405575\n");
	fprintf(fout,"H2 	H	0.405575\n");
	fprintf(fout,"CA 	CT	-0.051800\n");
	fprintf(fout,"HA 	H1	0.092200\n");
	fprintf(fout,"C 	C	0.597300\n");
	fprintf(fout,"O 	O	-0.567900\n");
	fprintf(fout,"CB 	CT	-0.110200\n");
	fprintf(fout,"HB1 	HC	0.045700\n");
	fprintf(fout,"HB2 	HC	0.045700\n");
	fprintf(fout,"CG 	CT	0.353100\n");
	fprintf(fout,"HG 	HC	-0.036100\n");
	fprintf(fout,"CD1 	CT	-0.412100\n");
	fprintf(fout,"HD11 	HC	0.100000\n");
	fprintf(fout,"HD12 	HC	0.100000\n");
	fprintf(fout,"HD13 	HC	0.100000\n");
	fprintf(fout,"CD2 	CT	-0.412100\n");
	fprintf(fout,"HD21 	HC	0.100000\n");
	fprintf(fout,"HD22 	HC	0.100000\n");
	fprintf(fout,"HD23 	HC	0.100000\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin HLYS Residue\n");
	fprintf(fout,"N 	N	-0.916539\n");
	fprintf(fout,"H1 	H	0.421669\n");
	fprintf(fout,"H2 	H	0.421669\n");
	fprintf(fout,"CA 	CT	-0.240000\n");
	fprintf(fout,"HA 	H1	0.142600\n");
	fprintf(fout,"C 	C	0.734100\n");
	fprintf(fout,"O 	O	-0.589400\n");
	fprintf(fout,"CB 	CT	-0.009400\n");
	fprintf(fout,"HB1 	HC	0.036200\n");
	fprintf(fout,"HB2 	HC	0.036200\n");
	fprintf(fout,"CG 	CT	0.018700\n");
	fprintf(fout,"HG1 	HC	0.010300\n");
	fprintf(fout,"HG2 	HC	0.010300\n");
	fprintf(fout,"CD 	CT	-0.047900\n");
	fprintf(fout,"HD1 	HC	0.062100\n");
	fprintf(fout,"HD2 	HC	0.062100\n");
	fprintf(fout,"CE 	CT	-0.014300\n");
	fprintf(fout,"HE1 	HP	0.113500\n");
	fprintf(fout,"HE2 	HP	0.113500\n");
	fprintf(fout,"NZ 	N3	-0.385400\n");
	fprintf(fout,"HZ1 	H	0.340000\n");
	fprintf(fout,"HZ2 	H	0.340000\n");
	fprintf(fout,"HZ3 	H	0.340000\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin HMET Residue\n");
	fprintf(fout,"N 	N	-0.954950\n");
	fprintf(fout,"H1 	H	0.405575\n");
	fprintf(fout,"H2 	H	0.405575\n");
	fprintf(fout,"CA 	CT	-0.023700\n");
	fprintf(fout,"HA 	H1	0.088000\n");
	fprintf(fout,"C 	C	0.597300\n");
	fprintf(fout,"O 	O	-0.567900\n");
	fprintf(fout,"CB 	CT	0.034200\n");
	fprintf(fout,"HB1 	HC	0.024100\n");
	fprintf(fout,"HB2 	HC	0.024100\n");
	fprintf(fout,"CG 	CT	0.001800\n");
	fprintf(fout,"HG1 	H1	0.044000\n");
	fprintf(fout,"HG2 	H1	0.044000\n");
	fprintf(fout,"SD 	S	-0.273700\n");
	fprintf(fout,"CE 	CT	-0.053600\n");
	fprintf(fout,"HE1 	H1	0.068400\n");
	fprintf(fout,"HE2 	H1	0.068400\n");
	fprintf(fout,"HE3 	H1	0.068400\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin HPHE Residue\n");
	fprintf(fout,"N 	N	-0.954950\n");
	fprintf(fout,"H1 	H	0.405575\n");
	fprintf(fout,"H2 	H	0.405575\n");
	fprintf(fout,"CA 	CT	-0.002400\n");
	fprintf(fout,"HA 	H1	0.097800\n");
	fprintf(fout,"C 	C	0.597300\n");
	fprintf(fout,"O 	O	-0.567900\n");
	fprintf(fout,"CB 	CT	-0.034300\n");
	fprintf(fout,"HB1 	HC	0.029500\n");
	fprintf(fout,"HB2 	HC	0.029500\n");
	fprintf(fout,"CG 	CA	0.011800\n");
	fprintf(fout,"CD1 	CA	-0.125600\n");
	fprintf(fout,"HD1 	HA	0.133000\n");
	fprintf(fout,"CD2 	CA	-0.125600\n");
	fprintf(fout,"HD2 	HA	0.133000\n");
	fprintf(fout,"CE1 	CA	-0.170400\n");
	fprintf(fout,"HE1 	HA	0.143000\n");
	fprintf(fout,"CE2 	CA	-0.170400\n");
	fprintf(fout,"HE2 	HA	0.143000\n");
	fprintf(fout,"CZ 	CA	-0.107200\n");
	fprintf(fout,"HZ 	HA	0.129700\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin HPRO Residue\n");
	fprintf(fout,"N 	N	-0.654800\n");
	fprintf(fout,"H 	H	0.400000\n");
	fprintf(fout,"CA 	CT	-0.026600\n");
	fprintf(fout,"HA 	H1	0.064100\n");
	fprintf(fout,"C 	C	0.589600\n");
	fprintf(fout,"O 	O	-0.574800\n");
	fprintf(fout,"CB 	CT	-0.007000\n");
	fprintf(fout,"HB1 	HC	0.025300\n");
	fprintf(fout,"HB2 	HC	0.025300\n");
	fprintf(fout,"CG 	CT	0.018900\n");
	fprintf(fout,"HG1 	HC	0.021300\n");
	fprintf(fout,"HG2 	HC	0.021300\n");
	fprintf(fout,"CD 	CT	0.019200\n");
	fprintf(fout,"HD1 	H1	0.039100\n");
	fprintf(fout,"HD2 	H1	0.039100\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin HSER Residue\n");
	fprintf(fout,"N 	N	-0.954950\n");
	fprintf(fout,"H1 	H	0.405575\n");
	fprintf(fout,"H2 	H	0.405575\n");
	fprintf(fout,"CA 	CT	-0.024900\n");
	fprintf(fout,"HA 	H1	0.084300\n");
	fprintf(fout,"C 	C	0.597300\n");
	fprintf(fout,"O 	O	-0.567900\n");
	fprintf(fout,"CB 	CT	0.211700\n");
	fprintf(fout,"HB1 	H1	0.035200\n");
	fprintf(fout,"HB2 	H1	0.035200\n");
	fprintf(fout,"OG 	OH	-0.654600\n");
	fprintf(fout,"HG 	HO	0.427500\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin HTHR Residue\n");
	fprintf(fout,"N 	N	-0.954950\n");
	fprintf(fout,"H1 	H	0.405575\n");
	fprintf(fout,"H2 	H	0.405575\n");
	fprintf(fout,"CA 	CT	-0.038900\n");
	fprintf(fout,"HA 	H1	0.100700\n");
	fprintf(fout,"C 	C	0.597300\n");
	fprintf(fout,"O 	O	-0.567900\n");
	fprintf(fout,"CB 	CT	0.365400\n");
	fprintf(fout,"HB 	H1	0.004300\n");
	fprintf(fout,"OG1 	OH	-0.676100\n");
	fprintf(fout,"HG1 	HO	0.410200\n");
	fprintf(fout,"CG2 	CT	-0.243800\n");
	fprintf(fout,"HG21 	HC	0.064200\n");
	fprintf(fout,"HG22 	HC	0.064200\n");
	fprintf(fout,"HG23 	HC	0.064200\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin HTYR Residue\n");
	fprintf(fout,"N 	N	-0.954950\n");
	fprintf(fout,"H1 	H	0.405575\n");
	fprintf(fout,"H2 	H	0.405575\n");
	fprintf(fout,"CA 	CT	-0.001400\n");
	fprintf(fout,"HA 	H1	0.087600\n");
	fprintf(fout,"C 	C	0.597300\n");
	fprintf(fout,"O 	O	-0.567900\n");
	fprintf(fout,"CB 	CT	-0.015200\n");
	fprintf(fout,"HB1 	HC	0.029500\n");
	fprintf(fout,"HB2 	HC	0.029500\n");
	fprintf(fout,"CG 	CA	-0.001100\n");
	fprintf(fout,"CD1 	CA	-0.190600\n");
	fprintf(fout,"HD1 	HA	0.169900\n");
	fprintf(fout,"CD2 	CA	-0.190600\n");
	fprintf(fout,"HD2 	HA	0.169900\n");
	fprintf(fout,"CE1 	CA	-0.234100\n");
	fprintf(fout,"HE1 	HA	0.165600\n");
	fprintf(fout,"CE2 	CA	-0.234100\n");
	fprintf(fout,"HE2 	HA	0.165600\n");
	fprintf(fout,"CZ 	C	0.322600\n");
	fprintf(fout,"OH 	OH	-0.557900\n");
	fprintf(fout,"HH 	HO	0.399200\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin HTRP Residue\n");
	fprintf(fout,"N 	N	-0.954950\n");
	fprintf(fout,"H1 	H	0.405575\n");
	fprintf(fout,"H2 	H	0.405575\n");
	fprintf(fout,"CA 	CT	-0.027500\n");
	fprintf(fout,"HA 	H1	0.112300\n");
	fprintf(fout,"C 	C	0.597300\n");
	fprintf(fout,"O 	O	-0.567900\n");
	fprintf(fout,"CB 	CT	-0.005000\n");
	fprintf(fout,"HB1 	HC	0.033900\n");
	fprintf(fout,"HB2 	HC	0.033900\n");
	fprintf(fout,"CG 	C*	-0.141500\n");
	fprintf(fout,"CD1 	CW	-0.163800\n");
	fprintf(fout,"HD1 	H4	0.206200\n");
	fprintf(fout,"CD2 	CB	0.124300\n");
	fprintf(fout,"NE1 	NA	-0.341800\n");
	fprintf(fout,"HE1 	H	0.341200\n");
	fprintf(fout,"CE2 	CN	0.138000\n");
	fprintf(fout,"CE3 	CA	-0.238700\n");
	fprintf(fout,"HE3 	HA	0.170000\n");
	fprintf(fout,"CZ2 	CA	-0.260100\n");
	fprintf(fout,"HZ2 	HA	0.157200\n");
	fprintf(fout,"CZ3 	CA	-0.197200\n");
	fprintf(fout,"HZ3 	HA	0.144700\n");
	fprintf(fout,"CH2 	CA	-0.113400\n");
	fprintf(fout,"HH2 	HA	0.141700\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin HVAL Residue\n");
	fprintf(fout,"N 	N	-0.954950\n");
	fprintf(fout,"H1 	H	0.405575\n");
	fprintf(fout,"H2 	H	0.405575\n");
	fprintf(fout,"CA 	CT	-0.087500\n");
	fprintf(fout,"HA 	H1	0.096900\n");
	fprintf(fout,"C 	C	0.597300\n");
	fprintf(fout,"O 	O	-0.567900\n");
	fprintf(fout,"CB 	CT	0.298500\n");
	fprintf(fout,"HB 	HC	-0.029700\n");
	fprintf(fout,"CG1 	CT	-0.319200\n");
	fprintf(fout,"HG11 	HC	0.079100\n");
	fprintf(fout,"HG12 	HC	0.079100\n");
	fprintf(fout,"HG13 	HC	0.079100\n");
	fprintf(fout,"CG2 	CT	-0.319200\n");
	fprintf(fout,"HG21 	HC	0.079100\n");
	fprintf(fout,"HG22 	HC	0.079100\n");
	fprintf(fout,"HG23 	HC	0.079100\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin HASH Residue\n");
	fprintf(fout,"H1 	H	0.405575\n");
	fprintf(fout,"H2 	H	0.405575\n");
	fprintf(fout,"N 	N	-0.954950\n");
	fprintf(fout,"HB2 	HC	0.048800\n");
	fprintf(fout,"C 	C	0.597300\n");
	fprintf(fout,"CA 	CT	0.034100\n");
	fprintf(fout,"CB 	CT	-0.031600\n");
	fprintf(fout,"OD1 	O	-0.555400\n");
	fprintf(fout,"HB1 	HC	0.048800\n");
	fprintf(fout,"CG 	C	0.646200\n");
	fprintf(fout,"O 	O	-0.567900\n");
	fprintf(fout,"HA 	H1	0.086400\n");
	fprintf(fout,"OD2 	OH	-0.637600\n");
	fprintf(fout,"HD2 	HO	0.474700\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin HGLH Residue\n");
	fprintf(fout,"O 	O	-0.567900\n");
	fprintf(fout,"C 	C	0.597300\n");
	fprintf(fout,"CB 	CT	-0.007100\n");
	fprintf(fout,"HB2 	HC	0.025600\n");
	fprintf(fout,"HB1 	HC	0.025600\n");
	fprintf(fout,"CA 	CT	0.014500\n");
	fprintf(fout,"HA 	H1	0.077900\n");
	fprintf(fout,"OE1 	O	-0.583800\n");
	fprintf(fout,"OE2 	OH	-0.651100\n");
	fprintf(fout,"HE2 	HO	0.464100\n");
	fprintf(fout,"CD 	C	0.680100\n");
	fprintf(fout,"N 	N	-0.954950\n");
	fprintf(fout,"H1 	H	0.405575\n");
	fprintf(fout,"H2 	H	0.405575\n");
	fprintf(fout,"CG 	CT	-0.017400\n");
	fprintf(fout,"HG1 	HC	0.043000\n");
	fprintf(fout,"HG2 	HC	0.043000\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin HLYN Residue\n");
	fprintf(fout,"O 	O	-0.567900\n");
	fprintf(fout,"C 	C	0.597300\n");
	fprintf(fout,"CB 	CT	-0.048450\n");
	fprintf(fout,"HB1 	HC	0.034000\n");
	fprintf(fout,"HB2 	HC	0.034000\n");
	fprintf(fout,"CD 	CT	-0.037680\n");
	fprintf(fout,"HD1 	HC	0.011550\n");
	fprintf(fout,"HD2 	HC	0.011550\n");
	fprintf(fout,"CA 	CT	-0.072060\n");
	fprintf(fout,"HA 	H1	0.099400\n");
	fprintf(fout,"CG 	CT	0.066120\n");
	fprintf(fout,"HG1 	HC	0.010410\n");
	fprintf(fout,"HG2 	HC	0.010410\n");
	fprintf(fout,"N 	N	-0.954950\n");
	fprintf(fout,"H1 	H	0.405575\n");
	fprintf(fout,"H2 	H	0.405575\n");
	fprintf(fout,"CE 	CT	0.326040\n");
	fprintf(fout,"HE1 	HP	-0.033580\n");
	fprintf(fout,"HE2 	HP	-0.033580\n");
	fprintf(fout,"NZ 	N3	-1.035810\n");
	fprintf(fout,"HZ1 	H	0.386040\n");
	fprintf(fout,"HZ2 	H	0.386040\n");
	fprintf(fout,"End\n");
	fprintf(fout,"Begin HCYM Residue\n");
	fprintf(fout,"N 	N	-0.954950\n");
	fprintf(fout,"H1 	H	0.405575\n");
	fprintf(fout,"H2 	H	0.405575\n");
	fprintf(fout,"CA 	CT	-0.035100\n");
	fprintf(fout,"HA 	H1	0.050800\n");
	fprintf(fout,"C 	C	0.597300\n");
	fprintf(fout,"O 	O	-0.567900\n");
	fprintf(fout,"CB 	CT	-0.241300\n");
	fprintf(fout,"HB1 	H1	0.112200\n");
	fprintf(fout,"HB2 	H1	0.112200\n");
	fprintf(fout,"SG 	SH	-0.884400\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin ROH Residue\n");
	fprintf(fout,"N      N      -0.687400\n");
	fprintf(fout,"H      H      0.362500\n");
	fprintf(fout,"CA     CT     0.613500\n");
	fprintf(fout,"HA     H1     -0.013000\n");
	fprintf(fout,"CB     CT     -0.426200\n");
	fprintf(fout,"HB1    HC     0.162200\n");
	fprintf(fout,"HB2    HC     0.097600\n");
	fprintf(fout,"CG     CT     -0.121200\n");
	fprintf(fout,"HG1    HC     0.126700\n");
	fprintf(fout,"HG2    HC     0.078100\n");
	fprintf(fout,"CD     CT     0.185000\n");
	fprintf(fout,"HD1    H1     0.055100\n");
	fprintf(fout,"HD2    H1     0.059300\n");
	fprintf(fout,"NE     N2     -0.707500\n");
	fprintf(fout,"HE     H      0.383700\n");
	fprintf(fout,"CZ     CA     1.082900\n");
	fprintf(fout,"NH1    N2     -0.981100\n");
	fprintf(fout,"HH11   H      0.452300\n");
	fprintf(fout,"HH12   H      0.483000\n");
	fprintf(fout,"NH2    N2     -1.121400\n");
	fprintf(fout,"HH21   H      0.511600\n");
	fprintf(fout,"HH22   H      0.514900\n");
	fprintf(fout,"C      C      0.683200\n");
	fprintf(fout,"O      O      -0.590800\n");
	fprintf(fout,"OH     OH     -0.747600\n");
	fprintf(fout,"HO     HO     0.544600\n");
	fprintf(fout,"End\n");



	fprintf(fout,"End\n");
}
/************************************************************/
void createNucleicResidueTpl(FILE* fout)
{

	fprintf(fout,"Begin DA5 Residue\n");
	fprintf(fout,"H5T    HO     0.44220\n");
	fprintf(fout,"O5'    OH     -0.63180\n");
	fprintf(fout,"C5'    CT     -0.00690\n");
	fprintf(fout,"H5'1   H1     0.07540\n");
	fprintf(fout,"H5'2   H1     0.07540\n");
	fprintf(fout,"C4'    CT     0.16290\n");
	fprintf(fout,"H4'    H1     0.11760\n");
	fprintf(fout,"O4'    OS     -0.36910\n");
	fprintf(fout,"C1'    CT     0.04310\n");
	fprintf(fout,"H1'    H2     0.18380\n");
	fprintf(fout,"N9     N*     -0.02680\n");
	fprintf(fout,"C8     CK     0.16070\n");
	fprintf(fout,"H8     H5     0.18770\n");
	fprintf(fout,"N7     NB     -0.61750\n");
	fprintf(fout,"C5     CB     0.07250\n");
	fprintf(fout,"C6     CA     0.68970\n");
	fprintf(fout,"N6     N2     -0.91230\n");
	fprintf(fout,"H61    H      0.41670\n");
	fprintf(fout,"H62    H      0.41670\n");
	fprintf(fout,"N1     NC     -0.76240\n");
	fprintf(fout,"C2     CQ     0.57160\n");
	fprintf(fout,"H2     H5     0.05980\n");
	fprintf(fout,"N3     NC     -0.74170\n");
	fprintf(fout,"C4     CB     0.38000\n");
	fprintf(fout,"C3'    CT     0.07130\n");
	fprintf(fout,"H3'    H1     0.09850\n");
	fprintf(fout,"C2'    CT     -0.08540\n");
	fprintf(fout,"H2'1   HC     0.07180\n");
	fprintf(fout,"H2'2   HC     0.07180\n");
	fprintf(fout,"O3'    OS     -0.52320\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin DA Residue\n");
	fprintf(fout,"N      N      -0.34790\n");
	fprintf(fout,"H      H      0.27470\n");
	fprintf(fout,"CA     CT     -0.24000\n");
	fprintf(fout,"HA     H1     0.14260\n");
	fprintf(fout,"CB     CT     0.02920\n");
	fprintf(fout,"HB1    HC     0.07470\n");
	fprintf(fout,"HB2    HC     0.07470\n");
	fprintf(fout,"CG     CT     -0.01430\n");
	fprintf(fout,"HG1    HP     0.11350\n");
	fprintf(fout,"HG2    HP     0.11350\n");
	fprintf(fout,"ND     N3     -0.38540\n");
	fprintf(fout,"HD1    H      0.34000\n");
	fprintf(fout,"HD2    H      0.34000\n");
	fprintf(fout,"HD3    H      0.34000\n");
	fprintf(fout,"C      C      0.73410\n");
	fprintf(fout,"O      O      -0.58940\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin DA3 Residue\n");
	fprintf(fout,"P      P      1.16590\n");
	fprintf(fout,"O1P    O2     -0.77610\n");
	fprintf(fout,"O2P    O2     -0.77610\n");
	fprintf(fout,"O5'    OS     -0.49540\n");
	fprintf(fout,"C5'    CT     -0.00690\n");
	fprintf(fout,"H5'1   H1     0.07540\n");
	fprintf(fout,"H5'2   H1     0.07540\n");
	fprintf(fout,"C4'    CT     0.16290\n");
	fprintf(fout,"H4'    H1     0.11760\n");
	fprintf(fout,"O4'    OS     -0.36910\n");
	fprintf(fout,"C1'    CT     0.04310\n");
	fprintf(fout,"H1'    H2     0.18380\n");
	fprintf(fout,"N9     N*     -0.02680\n");
	fprintf(fout,"C8     CK     0.16070\n");
	fprintf(fout,"H8     H5     0.18770\n");
	fprintf(fout,"N7     NB     -0.61750\n");
	fprintf(fout,"C5     CB     0.07250\n");
	fprintf(fout,"C6     CA     0.68970\n");
	fprintf(fout,"N6     N2     -0.91230\n");
	fprintf(fout,"H61    H      0.41670\n");
	fprintf(fout,"H62    H      0.41670\n");
	fprintf(fout,"N1     NC     -0.76240\n");
	fprintf(fout,"C2     CQ     0.57160\n");
	fprintf(fout,"H2     H5     0.05980\n");
	fprintf(fout,"N3     NC     -0.74170\n");
	fprintf(fout,"C4     CB     0.38000\n");
	fprintf(fout,"C3'    CT     0.07130\n");
	fprintf(fout,"H3'    H1     0.09850\n");
	fprintf(fout,"C2'    CT     -0.08540\n");
	fprintf(fout,"H2'1   HC     0.07180\n");
	fprintf(fout,"H2'2   HC     0.07180\n");
	fprintf(fout,"O3'    OH     -0.65490\n");
	fprintf(fout,"H3T    HO     0.43960\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin DAN Residue\n");
	fprintf(fout,"H5T    HO     0.44220\n");
	fprintf(fout,"O5'    OH     -0.63180\n");
	fprintf(fout,"C5'    CT     -0.00690\n");
	fprintf(fout,"H5'1   H1     0.07540\n");
	fprintf(fout,"H5'2   H1     0.07540\n");
	fprintf(fout,"C4'    CT     0.16290\n");
	fprintf(fout,"H4'    H1     0.11760\n");
	fprintf(fout,"O4'    OS     -0.36910\n");
	fprintf(fout,"C1'    CT     0.04310\n");
	fprintf(fout,"H1'    H2     0.18380\n");
	fprintf(fout,"N9     N*     -0.02680\n");
	fprintf(fout,"C8     CK     0.16070\n");
	fprintf(fout,"H8     H5     0.18770\n");
	fprintf(fout,"N7     NB     -0.61750\n");
	fprintf(fout,"C5     CB     0.07250\n");
	fprintf(fout,"C6     CA     0.68970\n");
	fprintf(fout,"N6     N2     -0.91230\n");
	fprintf(fout,"H61    H      0.41670\n");
	fprintf(fout,"H62    H      0.41670\n");
	fprintf(fout,"N1     NC     -0.76240\n");
	fprintf(fout,"C2     CQ     0.57160\n");
	fprintf(fout,"H2     H5     0.05980\n");
	fprintf(fout,"N3     NC     -0.74170\n");
	fprintf(fout,"C4     CB     0.38000\n");
	fprintf(fout,"C3'    CT     0.07130\n");
	fprintf(fout,"H3'    H1     0.09850\n");
	fprintf(fout,"C2'    CT     -0.08540\n");
	fprintf(fout,"H2'1   HC     0.07180\n");
	fprintf(fout,"H2'2   HC     0.07180\n");
	fprintf(fout,"O3'    OH     -0.65490\n");
	fprintf(fout,"H3T    HO     0.43960\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin RA5 Residue\n");
	fprintf(fout,"H5T    HO     0.42950\n");
	fprintf(fout,"O5'    OH     -0.62230\n");
	fprintf(fout,"C5'    CT     0.05580\n");
	fprintf(fout,"H5'1   H1     0.06790\n");
	fprintf(fout,"H5'2   H1     0.06790\n");
	fprintf(fout,"C4'    CT     0.10650\n");
	fprintf(fout,"H4'    H1     0.11740\n");
	fprintf(fout,"O4'    OS     -0.35480\n");
	fprintf(fout,"C1'    CT     0.03940\n");
	fprintf(fout,"H1'    H2     0.20070\n");
	fprintf(fout,"N9     N*     -0.02510\n");
	fprintf(fout,"C8     CK     0.20060\n");
	fprintf(fout,"H8     H5     0.15530\n");
	fprintf(fout,"N7     NB     -0.60730\n");
	fprintf(fout,"C5     CB     0.05150\n");
	fprintf(fout,"C6     CA     0.70090\n");
	fprintf(fout,"N6     N2     -0.90190\n");
	fprintf(fout,"H61    H      0.41150\n");
	fprintf(fout,"H62    H      0.41150\n");
	fprintf(fout,"N1     NC     -0.76150\n");
	fprintf(fout,"C2     CQ     0.58750\n");
	fprintf(fout,"H2     H5     0.04730\n");
	fprintf(fout,"N3     NC     -0.69970\n");
	fprintf(fout,"C4     CB     0.30530\n");
	fprintf(fout,"C3'    CT     0.20220\n");
	fprintf(fout,"H3'    H1     0.06150\n");
	fprintf(fout,"C2'    CT     0.06700\n");
	fprintf(fout,"H2'1   H1     0.09720\n");
	fprintf(fout,"O2'    OH     -0.61390\n");
	fprintf(fout,"HO'2   HO     0.41860\n");
	fprintf(fout,"O3'    OS     -0.52460\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin RA Residue\n");
	fprintf(fout,"H5T    HO     0.42950\n");
	fprintf(fout,"O5'    OH     -0.62230\n");
	fprintf(fout,"C5'    CT     0.05580\n");
	fprintf(fout,"H5'1   H1     0.06790\n");
	fprintf(fout,"H5'2   H1     0.06790\n");
	fprintf(fout,"C4'    CT     0.10650\n");
	fprintf(fout,"H4'    H1     0.11740\n");
	fprintf(fout,"O4'    OS     -0.35480\n");
	fprintf(fout,"C1'    CT     0.03940\n");
	fprintf(fout,"H1'    H2     0.20070\n");
	fprintf(fout,"N9     N*     -0.02510\n");
	fprintf(fout,"C8     CK     0.20060\n");
	fprintf(fout,"H8     H5     0.15530\n");
	fprintf(fout,"N7     NB     -0.60730\n");
	fprintf(fout,"C5     CB     0.05150\n");
	fprintf(fout,"C6     CA     0.70090\n");
	fprintf(fout,"N6     N2     -0.90190\n");
	fprintf(fout,"H61    H      0.41150\n");
	fprintf(fout,"H62    H      0.41150\n");
	fprintf(fout,"N1     NC     -0.76150\n");
	fprintf(fout,"C2     CQ     0.58750\n");
	fprintf(fout,"H2     H5     0.04730\n");
	fprintf(fout,"N3     NC     -0.69970\n");
	fprintf(fout,"C4     CB     0.30530\n");
	fprintf(fout,"C3'    CT     0.20220\n");
	fprintf(fout,"H3'    H1     0.06150\n");
	fprintf(fout,"C2'    CT     0.06700\n");
	fprintf(fout,"H2'1   H1     0.09720\n");
	fprintf(fout,"O2'    OH     -0.61390\n");
	fprintf(fout,"HO'2   HO     0.41860\n");
	fprintf(fout,"O3'    OS     -0.52460\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin RA3 Residue\n");
	fprintf(fout,"P      P      1.16620\n");
	fprintf(fout,"O1P    O2     -0.77600\n");
	fprintf(fout,"O2P    O2     -0.77600\n");
	fprintf(fout,"O5'    OS     -0.49890\n");
	fprintf(fout,"C5'    CT     0.05580\n");
	fprintf(fout,"H5'1   H1     0.06790\n");
	fprintf(fout,"H5'2   H1     0.06790\n");
	fprintf(fout,"C4'    CT     0.10650\n");
	fprintf(fout,"H4'    H1     0.11740\n");
	fprintf(fout,"O4'    OS     -0.35480\n");
	fprintf(fout,"C1'    CT     0.03940\n");
	fprintf(fout,"H1'    H2     0.20070\n");
	fprintf(fout,"N9     N*     -0.02510\n");
	fprintf(fout,"C8     CK     0.20060\n");
	fprintf(fout,"H8     H5     0.15530\n");
	fprintf(fout,"N7     NB     -0.60730\n");
	fprintf(fout,"C5     CB     0.05150\n");
	fprintf(fout,"C6     CA     0.70090\n");
	fprintf(fout,"N6     N2     -0.90190\n");
	fprintf(fout,"H61    H      0.41150\n");
	fprintf(fout,"H62    H      0.41150\n");
	fprintf(fout,"N1     NC     -0.76150\n");
	fprintf(fout,"C2     CQ     0.58750\n");
	fprintf(fout,"H2     H5     0.04730\n");
	fprintf(fout,"N3     NC     -0.69970\n");
	fprintf(fout,"C4     CB     0.30530\n");
	fprintf(fout,"C3'    CT     0.20220\n");
	fprintf(fout,"H3'    H1     0.06150\n");
	fprintf(fout,"C2'    CT     0.06700\n");
	fprintf(fout,"H2'1   H1     0.09720\n");
	fprintf(fout,"O2'    OH     -0.61390\n");
	fprintf(fout,"HO'2   HO     0.41860\n");
	fprintf(fout,"O3'    OH     -0.65410\n");
	fprintf(fout,"H3T    HO     0.43760\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin RAN Residue\n");
	fprintf(fout,"H5T    HO     0.42950\n");
	fprintf(fout,"O5'    OH     -0.62230\n");
	fprintf(fout,"C5'    CT     0.05580\n");
	fprintf(fout,"H5'1   H1     0.06790\n");
	fprintf(fout,"H5'2   H1     0.06790\n");
	fprintf(fout,"C4'    CT     0.10650\n");
	fprintf(fout,"H4'    H1     0.11740\n");
	fprintf(fout,"O4'    OS     -0.35480\n");
	fprintf(fout,"C1'    CT     0.03940\n");
	fprintf(fout,"H1'    H2     0.20070\n");
	fprintf(fout,"N9     N*     -0.02510\n");
	fprintf(fout,"C8     CK     0.20060\n");
	fprintf(fout,"H8     H5     0.15530\n");
	fprintf(fout,"N7     NB     -0.60730\n");
	fprintf(fout,"C5     CB     0.05150\n");
	fprintf(fout,"C6     CA     0.70090\n");
	fprintf(fout,"N6     N2     -0.90190\n");
	fprintf(fout,"H61    H      0.41150\n");
	fprintf(fout,"H62    H      0.41150\n");
	fprintf(fout,"N1     NC     -0.76150\n");
	fprintf(fout,"C2     CQ     0.58750\n");
	fprintf(fout,"H2     H5     0.04730\n");
	fprintf(fout,"N3     NC     -0.69970\n");
	fprintf(fout,"C4     CB     0.30530\n");
	fprintf(fout,"C3'    CT     0.20220\n");
	fprintf(fout,"H3'    H1     0.06150\n");
	fprintf(fout,"C2'    CT     0.06700\n");
	fprintf(fout,"H2'1   H1     0.09720\n");
	fprintf(fout,"O2'    OH     -0.61390\n");
	fprintf(fout,"HO'2   HO     0.41860\n");
	fprintf(fout,"O3'    OH     -0.65410\n");
	fprintf(fout,"H3T    HO     0.43760\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin DT5 Residue\n");
	fprintf(fout,"H5T    HO     0.44220\n");
	fprintf(fout,"O5'    OH     -0.63180\n");
	fprintf(fout,"C5'    CT     -0.00690\n");
	fprintf(fout,"H5'1   H1     0.07540\n");
	fprintf(fout,"H5'2   H1     0.07540\n");
	fprintf(fout,"C4'    CT     0.16290\n");
	fprintf(fout,"H4'    H1     0.11760\n");
	fprintf(fout,"O4'    OS     -0.36910\n");
	fprintf(fout,"C1'    CT     0.06800\n");
	fprintf(fout,"H1'    H2     0.18040\n");
	fprintf(fout,"N1     N*     -0.02390\n");
	fprintf(fout,"C6     CM     -0.22090\n");
	fprintf(fout,"H6     H4     0.26070\n");
	fprintf(fout,"C5     CM     0.00250\n");
	fprintf(fout,"C7     CT     -0.22690\n");
	fprintf(fout,"H71    HC     0.07700\n");
	fprintf(fout,"H72    HC     0.07700\n");
	fprintf(fout,"H73    HC     0.07700\n");
	fprintf(fout,"C4     C      0.51940\n");
	fprintf(fout,"O4     O      -0.55630\n");
	fprintf(fout,"N3     NA     -0.43400\n");
	fprintf(fout,"H3     H      0.34200\n");
	fprintf(fout,"C2     C      0.56770\n");
	fprintf(fout,"O      O      -0.58810\n");
	fprintf(fout,"C3'    CT     0.07130\n");
	fprintf(fout,"H3'    H1     0.09850\n");
	fprintf(fout,"C2'    CT     -0.08540\n");
	fprintf(fout,"H2'1   HC     0.07180\n");
	fprintf(fout,"H2'2   HC     0.07180\n");
	fprintf(fout,"O3'    OS     -0.52320\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin DT Residue\n");
	fprintf(fout,"H5T    HO     0.44220\n");
	fprintf(fout,"O5'    OH     -0.63180\n");
	fprintf(fout,"C5'    CT     -0.00690\n");
	fprintf(fout,"H5'1   H1     0.07540\n");
	fprintf(fout,"H5'2   H1     0.07540\n");
	fprintf(fout,"C4'    CT     0.16290\n");
	fprintf(fout,"H4'    H1     0.11760\n");
	fprintf(fout,"O4'    OS     -0.36910\n");
	fprintf(fout,"C1'    CT     0.06800\n");
	fprintf(fout,"H1'    H2     0.18040\n");
	fprintf(fout,"N1     N*     -0.02390\n");
	fprintf(fout,"C6     CM     -0.22090\n");
	fprintf(fout,"H6     H4     0.26070\n");
	fprintf(fout,"C5     CM     0.00250\n");
	fprintf(fout,"C7     CT     -0.22690\n");
	fprintf(fout,"H71    HC     0.07700\n");
	fprintf(fout,"H72    HC     0.07700\n");
	fprintf(fout,"H73    HC     0.07700\n");
	fprintf(fout,"C4     C      0.51940\n");
	fprintf(fout,"O4     O      -0.55630\n");
	fprintf(fout,"N3     NA     -0.43400\n");
	fprintf(fout,"H3     H      0.34200\n");
	fprintf(fout,"C2     C      0.56770\n");
	fprintf(fout,"O      O      -0.58810\n");
	fprintf(fout,"C3'    CT     0.07130\n");
	fprintf(fout,"H3'    H1     0.09850\n");
	fprintf(fout,"C2'    CT     -0.08540\n");
	fprintf(fout,"H2'1   HC     0.07180\n");
	fprintf(fout,"H2'2   HC     0.07180\n");
	fprintf(fout,"O3'    OS     -0.52320\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin DT3 Residue\n");
	fprintf(fout,"P      P      1.16590\n");
	fprintf(fout,"O1P    O2     -0.77610\n");
	fprintf(fout,"O2P    O2     -0.77610\n");
	fprintf(fout,"O5'    OS     -0.49540\n");
	fprintf(fout,"C5'    CT     -0.00690\n");
	fprintf(fout,"H5'1   H1     0.07540\n");
	fprintf(fout,"H5'2   H1     0.07540\n");
	fprintf(fout,"C4'    CT     0.16290\n");
	fprintf(fout,"H4'    H1     0.11760\n");
	fprintf(fout,"O4'    OS     -0.36910\n");
	fprintf(fout,"C1'    CT     0.06800\n");
	fprintf(fout,"H1'    H2     0.18040\n");
	fprintf(fout,"N1     N*     -0.02390\n");
	fprintf(fout,"C6     CM     -0.22090\n");
	fprintf(fout,"H6     H4     0.26070\n");
	fprintf(fout,"C5     CM     0.00250\n");
	fprintf(fout,"C7     CT     -0.22690\n");
	fprintf(fout,"H71    HC     0.07700\n");
	fprintf(fout,"H72    HC     0.07700\n");
	fprintf(fout,"H73    HC     0.07700\n");
	fprintf(fout,"C4     C      0.51940\n");
	fprintf(fout,"O4     O      -0.55630\n");
	fprintf(fout,"N3     NA     -0.43400\n");
	fprintf(fout,"H3     H      0.34200\n");
	fprintf(fout,"C2     C      0.56770\n");
	fprintf(fout,"O      O      -0.58810\n");
	fprintf(fout,"C3'    CT     0.07130\n");
	fprintf(fout,"H3'    H1     0.09850\n");
	fprintf(fout,"C2'    CT     -0.08540\n");
	fprintf(fout,"H2'1   HC     0.07180\n");
	fprintf(fout,"H2'2   HC     0.07180\n");
	fprintf(fout,"O3'    OH     -0.65490\n");
	fprintf(fout,"H3T    HO     0.43960\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin DTN Residue\n");
	fprintf(fout,"H5T    HO     0.44220\n");
	fprintf(fout,"O5'    OH     -0.63180\n");
	fprintf(fout,"C5'    CT     -0.00690\n");
	fprintf(fout,"H5'1   H1     0.07540\n");
	fprintf(fout,"H5'2   H1     0.07540\n");
	fprintf(fout,"C4'    CT     0.16290\n");
	fprintf(fout,"H4'    H1     0.11760\n");
	fprintf(fout,"O4'    OS     -0.36910\n");
	fprintf(fout,"C1'    CT     0.06800\n");
	fprintf(fout,"H1'    H2     0.18040\n");
	fprintf(fout,"N1     N*     -0.02390\n");
	fprintf(fout,"C6     CM     -0.22090\n");
	fprintf(fout,"H6     H4     0.26070\n");
	fprintf(fout,"C5     CM     0.00250\n");
	fprintf(fout,"C7     CT     -0.22690\n");
	fprintf(fout,"H71    HC     0.07700\n");
	fprintf(fout,"H72    HC     0.07700\n");
	fprintf(fout,"H73    HC     0.07700\n");
	fprintf(fout,"C4     C      0.51940\n");
	fprintf(fout,"O4     O      -0.55630\n");
	fprintf(fout,"N3     NA     -0.43400\n");
	fprintf(fout,"H3     H      0.34200\n");
	fprintf(fout,"C2     C      0.56770\n");
	fprintf(fout,"O      O      -0.58810\n");
	fprintf(fout,"C3'    CT     0.07130\n");
	fprintf(fout,"H3'    H1     0.09850\n");
	fprintf(fout,"C2'    CT     -0.08540\n");
	fprintf(fout,"H2'1   HC     0.07180\n");
	fprintf(fout,"H2'2   HC     0.07180\n");
	fprintf(fout,"O3'    OH     -0.65490\n");
	fprintf(fout,"H3T    HO     0.43960\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin RU5 Residue\n");
	fprintf(fout,"H5T    HO     0.42950\n");
	fprintf(fout,"O5'    OH     -0.62230\n");
	fprintf(fout,"C5'    CT     0.05580\n");
	fprintf(fout,"H5'1   H1     0.06790\n");
	fprintf(fout,"H5'2   H1     0.06790\n");
	fprintf(fout,"C4'    CT     0.10650\n");
	fprintf(fout,"H4'    H1     0.11740\n");
	fprintf(fout,"O4'    OS     -0.35480\n");
	fprintf(fout,"C1'    CT     0.06740\n");
	fprintf(fout,"H1'    H2     0.18240\n");
	fprintf(fout,"N1     N*     0.04180\n");
	fprintf(fout,"C6     CM     -0.11260\n");
	fprintf(fout,"H6     H4     0.21880\n");
	fprintf(fout,"C5     CM     -0.36350\n");
	fprintf(fout,"H5     HA     0.18110\n");
	fprintf(fout,"C4     C      0.59520\n");
	fprintf(fout,"O4     O      -0.57610\n");
	fprintf(fout,"N3     NA     -0.35490\n");
	fprintf(fout,"H3     H      0.31540\n");
	fprintf(fout,"C2     C      0.46870\n");
	fprintf(fout,"O      O      -0.54770\n");
	fprintf(fout,"C3'    CT     0.20220\n");
	fprintf(fout,"H3'    H1     0.06150\n");
	fprintf(fout,"C2'    CT     0.06700\n");
	fprintf(fout,"H2'1   H1     0.09720\n");
	fprintf(fout,"O2'    OH     -0.61390\n");
	fprintf(fout,"HO'2   HO     0.41860\n");
	fprintf(fout,"O3'    OS     -0.52460\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin RU Residue\n");
	fprintf(fout,"H5T    HO     0.42950\n");
	fprintf(fout,"O5'    OH     -0.62230\n");
	fprintf(fout,"C5'    CT     0.05580\n");
	fprintf(fout,"H5'1   H1     0.06790\n");
	fprintf(fout,"H5'2   H1     0.06790\n");
	fprintf(fout,"C4'    CT     0.10650\n");
	fprintf(fout,"H4'    H1     0.11740\n");
	fprintf(fout,"O4'    OS     -0.35480\n");
	fprintf(fout,"C1'    CT     0.06740\n");
	fprintf(fout,"H1'    H2     0.18240\n");
	fprintf(fout,"N1     N*     0.04180\n");
	fprintf(fout,"C6     CM     -0.11260\n");
	fprintf(fout,"H6     H4     0.21880\n");
	fprintf(fout,"C5     CM     -0.36350\n");
	fprintf(fout,"H5     HA     0.18110\n");
	fprintf(fout,"C4     C      0.59520\n");
	fprintf(fout,"O4     O      -0.57610\n");
	fprintf(fout,"N3     NA     -0.35490\n");
	fprintf(fout,"H3     H      0.31540\n");
	fprintf(fout,"C2     C      0.46870\n");
	fprintf(fout,"O      O      -0.54770\n");
	fprintf(fout,"C3'    CT     0.20220\n");
	fprintf(fout,"H3'    H1     0.06150\n");
	fprintf(fout,"C2'    CT     0.06700\n");
	fprintf(fout,"H2'1   H1     0.09720\n");
	fprintf(fout,"O2'    OH     -0.61390\n");
	fprintf(fout,"HO'2   HO     0.41860\n");
	fprintf(fout,"O3'    OS     -0.52460\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin RU3 Residue\n");
	fprintf(fout,"P      P      1.16620\n");
	fprintf(fout,"O1P    O2     -0.77600\n");
	fprintf(fout,"O2P    O2     -0.77600\n");
	fprintf(fout,"O5'    OS     -0.49890\n");
	fprintf(fout,"C5'    CT     0.05580\n");
	fprintf(fout,"H5'1   H1     0.06790\n");
	fprintf(fout,"H5'2   H1     0.06790\n");
	fprintf(fout,"C4'    CT     0.10650\n");
	fprintf(fout,"H4'    H1     0.11740\n");
	fprintf(fout,"O4'    OS     -0.35480\n");
	fprintf(fout,"C1'    CT     0.06740\n");
	fprintf(fout,"H1'    H2     0.18240\n");
	fprintf(fout,"N1     N*     0.04180\n");
	fprintf(fout,"C6     CM     -0.11260\n");
	fprintf(fout,"H6     H4     0.21880\n");
	fprintf(fout,"C5     CM     -0.36350\n");
	fprintf(fout,"H5     HA     0.18110\n");
	fprintf(fout,"C4     C      0.59520\n");
	fprintf(fout,"O4     O      -0.57610\n");
	fprintf(fout,"N3     NA     -0.35490\n");
	fprintf(fout,"H3     H      0.31540\n");
	fprintf(fout,"C2     C      0.46870\n");
	fprintf(fout,"O      O      -0.54770\n");
	fprintf(fout,"C3'    CT     0.20220\n");
	fprintf(fout,"H3'    H1     0.06150\n");
	fprintf(fout,"C2'    CT     0.06700\n");
	fprintf(fout,"H2'1   H1     0.09720\n");
	fprintf(fout,"O2'    OH     -0.61390\n");
	fprintf(fout,"HO'2   HO     0.41860\n");
	fprintf(fout,"O3'    OH     -0.65410\n");
	fprintf(fout,"H3T    HO     0.43760\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin RUN Residue\n");
	fprintf(fout,"H5T    HO     0.42950\n");
	fprintf(fout,"O5'    OH     -0.62230\n");
	fprintf(fout,"C5'    CT     0.05580\n");
	fprintf(fout,"H5'1   H1     0.06790\n");
	fprintf(fout,"H5'2   H1     0.06790\n");
	fprintf(fout,"C4'    CT     0.10650\n");
	fprintf(fout,"H4'    H1     0.11740\n");
	fprintf(fout,"O4'    OS     -0.35480\n");
	fprintf(fout,"C1'    CT     0.06740\n");
	fprintf(fout,"H1'    H2     0.18240\n");
	fprintf(fout,"N1     N*     0.04180\n");
	fprintf(fout,"C6     CM     -0.11260\n");
	fprintf(fout,"H6     H4     0.21880\n");
	fprintf(fout,"C5     CM     -0.36350\n");
	fprintf(fout,"H5     HA     0.18110\n");
	fprintf(fout,"C4     C      0.59520\n");
	fprintf(fout,"O4     O      -0.57610\n");
	fprintf(fout,"N3     NA     -0.35490\n");
	fprintf(fout,"H3     H      0.31540\n");
	fprintf(fout,"C2     C      0.46870\n");
	fprintf(fout,"O      O      -0.54770\n");
	fprintf(fout,"C3'    CT     0.20220\n");
	fprintf(fout,"H3'    H1     0.06150\n");
	fprintf(fout,"C2'    CT     0.06700\n");
	fprintf(fout,"H2'1   H1     0.09720\n");
	fprintf(fout,"O2'    OH     -0.61390\n");
	fprintf(fout,"HO'2   HO     0.41860\n");
	fprintf(fout,"O3'    OH     -0.65410\n");
	fprintf(fout,"H3T    HO     0.43760\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin DG5 Residue\n");
	fprintf(fout,"H5T    HO     0.44220\n");
	fprintf(fout,"O5'    OH     -0.63180\n");
	fprintf(fout,"C5'    CT     -0.00690\n");
	fprintf(fout,"H5'1   H1     0.07540\n");
	fprintf(fout,"H5'2   H1     0.07540\n");
	fprintf(fout,"C4'    CT     0.16290\n");
	fprintf(fout,"H4'    H1     0.11760\n");
	fprintf(fout,"O4'    OS     -0.36910\n");
	fprintf(fout,"C1'    CT     0.03580\n");
	fprintf(fout,"H1'    H2     0.17460\n");
	fprintf(fout,"N9     N*     0.05770\n");
	fprintf(fout,"C8     CK     0.07360\n");
	fprintf(fout,"H8     H5     0.19970\n");
	fprintf(fout,"N7     NB     -0.57250\n");
	fprintf(fout,"C5     CB     0.19910\n");
	fprintf(fout,"C6     C      0.49180\n");
	fprintf(fout,"O6     O      -0.56990\n");
	fprintf(fout,"N1     NA     -0.50530\n");
	fprintf(fout,"H1     H      0.35200\n");
	fprintf(fout,"C2     CA     0.74320\n");
	fprintf(fout,"N2     N2     -0.92300\n");
	fprintf(fout,"H21    H      0.42350\n");
	fprintf(fout,"H22    H      0.42350\n");
	fprintf(fout,"N3     NC     -0.66360\n");
	fprintf(fout,"C4     CB     0.18140\n");
	fprintf(fout,"C3'    CT     0.07130\n");
	fprintf(fout,"H3'    H1     0.09850\n");
	fprintf(fout,"C2'    CT     -0.08540\n");
	fprintf(fout,"H2'1   HC     0.07180\n");
	fprintf(fout,"H2'2   HC     0.07180\n");
	fprintf(fout,"O3'    OS     -0.52320\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin DG Residue\n");
	fprintf(fout,"H5T    HO     0.44220\n");
	fprintf(fout,"O5'    OH     -0.63180\n");
	fprintf(fout,"C5'    CT     -0.00690\n");
	fprintf(fout,"H5'1   H1     0.07540\n");
	fprintf(fout,"H5'2   H1     0.07540\n");
	fprintf(fout,"C4'    CT     0.16290\n");
	fprintf(fout,"H4'    H1     0.11760\n");
	fprintf(fout,"O4'    OS     -0.36910\n");
	fprintf(fout,"C1'    CT     0.03580\n");
	fprintf(fout,"H1'    H2     0.17460\n");
	fprintf(fout,"N9     N*     0.05770\n");
	fprintf(fout,"C8     CK     0.07360\n");
	fprintf(fout,"H8     H5     0.19970\n");
	fprintf(fout,"N7     NB     -0.57250\n");
	fprintf(fout,"C5     CB     0.19910\n");
	fprintf(fout,"C6     C      0.49180\n");
	fprintf(fout,"O6     O      -0.56990\n");
	fprintf(fout,"N1     NA     -0.50530\n");
	fprintf(fout,"H1     H      0.35200\n");
	fprintf(fout,"C2     CA     0.74320\n");
	fprintf(fout,"N2     N2     -0.92300\n");
	fprintf(fout,"H21    H      0.42350\n");
	fprintf(fout,"H22    H      0.42350\n");
	fprintf(fout,"N3     NC     -0.66360\n");
	fprintf(fout,"C4     CB     0.18140\n");
	fprintf(fout,"C3'    CT     0.07130\n");
	fprintf(fout,"H3'    H1     0.09850\n");
	fprintf(fout,"C2'    CT     -0.08540\n");
	fprintf(fout,"H2'1   HC     0.07180\n");
	fprintf(fout,"H2'2   HC     0.07180\n");
	fprintf(fout,"O3'    OS     -0.52320\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin DG3 Residue\n");
	fprintf(fout,"P      P      1.16590\n");
	fprintf(fout,"O1P    O2     -0.77610\n");
	fprintf(fout,"O2P    O2     -0.77610\n");
	fprintf(fout,"O5'    OS     -0.49540\n");
	fprintf(fout,"C5'    CT     -0.00690\n");
	fprintf(fout,"H5'1   H1     0.07540\n");
	fprintf(fout,"H5'2   H1     0.07540\n");
	fprintf(fout,"C4'    CT     0.16290\n");
	fprintf(fout,"H4'    H1     0.11760\n");
	fprintf(fout,"O4'    OS     -0.36910\n");
	fprintf(fout,"C1'    CT     0.03580\n");
	fprintf(fout,"H1'    H2     0.17460\n");
	fprintf(fout,"N9     N*     0.05770\n");
	fprintf(fout,"C8     CK     0.07360\n");
	fprintf(fout,"H8     H5     0.19970\n");
	fprintf(fout,"N7     NB     -0.57250\n");
	fprintf(fout,"C5     CB     0.19910\n");
	fprintf(fout,"C6     C      0.49180\n");
	fprintf(fout,"O6     O      -0.56990\n");
	fprintf(fout,"N1     NA     -0.50530\n");
	fprintf(fout,"H1     H      0.35200\n");
	fprintf(fout,"C2     CA     0.74320\n");
	fprintf(fout,"N2     N2     -0.92300\n");
	fprintf(fout,"H21    H      0.42350\n");
	fprintf(fout,"H22    H      0.42350\n");
	fprintf(fout,"N3     NC     -0.66360\n");
	fprintf(fout,"C4     CB     0.18140\n");
	fprintf(fout,"C3'    CT     0.07130\n");
	fprintf(fout,"H3'    H1     0.09850\n");
	fprintf(fout,"C2'    CT     -0.08540\n");
	fprintf(fout,"H2'1   HC     0.07180\n");
	fprintf(fout,"H2'2   HC     0.07180\n");
	fprintf(fout,"O3'    OH     -0.65490\n");
	fprintf(fout,"H3T    HO     0.43960\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin DGN Residue\n");
	fprintf(fout,"H5T    HO     0.44220\n");
	fprintf(fout,"O5'    OH     -0.63180\n");
	fprintf(fout,"C5'    CT     -0.00690\n");
	fprintf(fout,"H5'1   H1     0.07540\n");
	fprintf(fout,"H5'2   H1     0.07540\n");
	fprintf(fout,"C4'    CT     0.16290\n");
	fprintf(fout,"H4'    H1     0.11760\n");
	fprintf(fout,"O4'    OS     -0.36910\n");
	fprintf(fout,"C1'    CT     0.03580\n");
	fprintf(fout,"H1'    H2     0.17460\n");
	fprintf(fout,"N9     N*     0.05770\n");
	fprintf(fout,"C8     CK     0.07360\n");
	fprintf(fout,"H8     H5     0.19970\n");
	fprintf(fout,"N7     NB     -0.57250\n");
	fprintf(fout,"C5     CB     0.19910\n");
	fprintf(fout,"C6     C      0.49180\n");
	fprintf(fout,"O6     O      -0.56990\n");
	fprintf(fout,"N1     NA     -0.50530\n");
	fprintf(fout,"H1     H      0.35200\n");
	fprintf(fout,"C2     CA     0.74320\n");
	fprintf(fout,"N2     N2     -0.92300\n");
	fprintf(fout,"H21    H      0.42350\n");
	fprintf(fout,"H22    H      0.42350\n");
	fprintf(fout,"N3     NC     -0.66360\n");
	fprintf(fout,"C4     CB     0.18140\n");
	fprintf(fout,"C3'    CT     0.07130\n");
	fprintf(fout,"H3'    H1     0.09850\n");
	fprintf(fout,"C2'    CT     -0.08540\n");
	fprintf(fout,"H2'1   HC     0.07180\n");
	fprintf(fout,"H2'2   HC     0.07180\n");
	fprintf(fout,"O3'    OH     -0.65490\n");
	fprintf(fout,"H3T    HO     0.43960\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin RG5 Residue\n");
	fprintf(fout,"H5T    HO     0.42950\n");
	fprintf(fout,"O5'    OH     -0.62230\n");
	fprintf(fout,"C5'    CT     0.05580\n");
	fprintf(fout,"H5'1   H1     0.06790\n");
	fprintf(fout,"H5'2   H1     0.06790\n");
	fprintf(fout,"C4'    CT     0.10650\n");
	fprintf(fout,"H4'    H1     0.11740\n");
	fprintf(fout,"O4'    OS     -0.35480\n");
	fprintf(fout,"C1'    CT     0.01910\n");
	fprintf(fout,"H1'    H2     0.20060\n");
	fprintf(fout,"N9     N*     0.04920\n");
	fprintf(fout,"C8     CK     0.13740\n");
	fprintf(fout,"H8     H5     0.16400\n");
	fprintf(fout,"N7     NB     -0.57090\n");
	fprintf(fout,"C5     CB     0.17440\n");
	fprintf(fout,"C6     C      0.47700\n");
	fprintf(fout,"O6     O      -0.55970\n");
	fprintf(fout,"N1     NA     -0.47870\n");
	fprintf(fout,"H1     H      0.34240\n");
	fprintf(fout,"C2     CA     0.76570\n");
	fprintf(fout,"N2     N2     -0.96720\n");
	fprintf(fout,"H21    H      0.43640\n");
	fprintf(fout,"H22    H      0.43640\n");
	fprintf(fout,"N3     NC     -0.63230\n");
	fprintf(fout,"C4     CB     0.12220\n");
	fprintf(fout,"C3'    CT     0.20220\n");
	fprintf(fout,"H3'    H1     0.06150\n");
	fprintf(fout,"C2'    CT     0.06700\n");
	fprintf(fout,"H2'1   H1     0.09720\n");
	fprintf(fout,"O2'    OH     -0.61390\n");
	fprintf(fout,"HO'2   HO     0.41860\n");
	fprintf(fout,"O3'    OS     -0.52460\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin RG Residue\n");
	fprintf(fout,"N      N      -0.34790\n");
	fprintf(fout,"H      H      0.27470\n");
	fprintf(fout,"CA     CT     -0.26370\n");
	fprintf(fout,"HA     H1     0.15600\n");
	fprintf(fout,"CB     CT     -0.00070\n");
	fprintf(fout,"HB1    HC     0.03270\n");
	fprintf(fout,"HB2    HC     0.03270\n");
	fprintf(fout,"CG     CT     0.03900\n");
	fprintf(fout,"HG1    HC     0.02850\n");
	fprintf(fout,"HG2    HC     0.02850\n");
	fprintf(fout,"CD     CT     0.04860\n");
	fprintf(fout,"HD1    H1     0.06870\n");
	fprintf(fout,"HD2    H1     0.06870\n");
	fprintf(fout,"NE     N2     -0.52950\n");
	fprintf(fout,"HE     H      0.34560\n");
	fprintf(fout,"CZ     CA     0.80760\n");
	fprintf(fout,"NH1    N2     -0.86270\n");
	fprintf(fout,"HH11   H      0.44780\n");
	fprintf(fout,"HH12   H      0.44780\n");
	fprintf(fout,"NH2    N2     -0.86270\n");
	fprintf(fout,"HH21   H      0.44780\n");
	fprintf(fout,"HH22   H      0.44780\n");
	fprintf(fout,"C      C      0.73410\n");
	fprintf(fout,"O      O      -0.58940\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin RG3 Residue\n");
	fprintf(fout,"P      P      1.16620\n");
	fprintf(fout,"O1P    O2     -0.77600\n");
	fprintf(fout,"O2P    O2     -0.77600\n");
	fprintf(fout,"O5'    OS     -0.49890\n");
	fprintf(fout,"C5'    CT     0.05580\n");
	fprintf(fout,"H5'1   H1     0.06790\n");
	fprintf(fout,"H5'2   H1     0.06790\n");
	fprintf(fout,"C4'    CT     0.10650\n");
	fprintf(fout,"H4'    H1     0.11740\n");
	fprintf(fout,"O4'    OS     -0.35480\n");
	fprintf(fout,"C1'    CT     0.01910\n");
	fprintf(fout,"H1'    H2     0.20060\n");
	fprintf(fout,"N9     N*     0.04920\n");
	fprintf(fout,"C8     CK     0.13740\n");
	fprintf(fout,"H8     H5     0.16400\n");
	fprintf(fout,"N7     NB     -0.57090\n");
	fprintf(fout,"C5     CB     0.17440\n");
	fprintf(fout,"C6     C      0.47700\n");
	fprintf(fout,"O6     O      -0.55970\n");
	fprintf(fout,"N1     NA     -0.47870\n");
	fprintf(fout,"H1     H      0.34240\n");
	fprintf(fout,"C2     CA     0.76570\n");
	fprintf(fout,"N2     N2     -0.96720\n");
	fprintf(fout,"H21    H      0.43640\n");
	fprintf(fout,"H22    H      0.43640\n");
	fprintf(fout,"N3     NC     -0.63230\n");
	fprintf(fout,"C4     CB     0.12220\n");
	fprintf(fout,"C3'    CT     0.20220\n");
	fprintf(fout,"H3'    H1     0.06150\n");
	fprintf(fout,"C2'    CT     0.06700\n");
	fprintf(fout,"H2'1   H1     0.09720\n");
	fprintf(fout,"O2'    OH     -0.61390\n");
	fprintf(fout,"HO'2   HO     0.41860\n");
	fprintf(fout,"O3'    OH     -0.65410\n");
	fprintf(fout,"H3T    HO     0.43760\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin RGN Residue\n");
	fprintf(fout,"H5T    HO     0.42950\n");
	fprintf(fout,"O5'    OH     -0.62230\n");
	fprintf(fout,"C5'    CT     0.05580\n");
	fprintf(fout,"H5'1   H1     0.06790\n");
	fprintf(fout,"H5'2   H1     0.06790\n");
	fprintf(fout,"C4'    CT     0.10650\n");
	fprintf(fout,"H4'    H1     0.11740\n");
	fprintf(fout,"O4'    OS     -0.35480\n");
	fprintf(fout,"C1'    CT     0.01910\n");
	fprintf(fout,"H1'    H2     0.20060\n");
	fprintf(fout,"N9     N*     0.04920\n");
	fprintf(fout,"C8     CK     0.13740\n");
	fprintf(fout,"H8     H5     0.16400\n");
	fprintf(fout,"N7     NB     -0.57090\n");
	fprintf(fout,"C5     CB     0.17440\n");
	fprintf(fout,"C6     C      0.47700\n");
	fprintf(fout,"O6     O      -0.55970\n");
	fprintf(fout,"N1     NA     -0.47870\n");
	fprintf(fout,"H1     H      0.34240\n");
	fprintf(fout,"C2     CA     0.76570\n");
	fprintf(fout,"N2     N2     -0.96720\n");
	fprintf(fout,"H21    H      0.43640\n");
	fprintf(fout,"H22    H      0.43640\n");
	fprintf(fout,"N3     NC     -0.63230\n");
	fprintf(fout,"C4     CB     0.12220\n");
	fprintf(fout,"C3'    CT     0.20220\n");
	fprintf(fout,"H3'    H1     0.06150\n");
	fprintf(fout,"C2'    CT     0.06700\n");
	fprintf(fout,"H2'1   H1     0.09720\n");
	fprintf(fout,"O2'    OH     -0.61390\n");
	fprintf(fout,"HO'2   HO     0.41860\n");
	fprintf(fout,"O3'    OH     -0.65410\n");
	fprintf(fout,"H3T    HO     0.43760\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin DC5 Residue\n");
	fprintf(fout,"H5T    HO     0.44220\n");
	fprintf(fout,"O5'    OH     -0.63180\n");
	fprintf(fout,"C5'    CT     -0.00690\n");
	fprintf(fout,"H5'1   H1     0.07540\n");
	fprintf(fout,"H5'2   H1     0.07540\n");
	fprintf(fout,"C4'    CT     0.16290\n");
	fprintf(fout,"H4'    H1     0.11760\n");
	fprintf(fout,"O4'    OS     -0.36910\n");
	fprintf(fout,"C1'    CT     -0.01160\n");
	fprintf(fout,"H1'    H2     0.19630\n");
	fprintf(fout,"N1     N*     -0.03390\n");
	fprintf(fout,"C6     CM     -0.01830\n");
	fprintf(fout,"H6     H4     0.22930\n");
	fprintf(fout,"C5     CM     -0.52220\n");
	fprintf(fout,"H5     HA     0.18630\n");
	fprintf(fout,"C4     CA     0.84390\n");
	fprintf(fout,"N4     N2     -0.97730\n");
	fprintf(fout,"H41    H      0.43140\n");
	fprintf(fout,"H42    H      0.43140\n");
	fprintf(fout,"N3     NC     -0.77480\n");
	fprintf(fout,"C2     C      0.79590\n");
	fprintf(fout,"O      O      -0.65480\n");
	fprintf(fout,"C3'    CT     0.07130\n");
	fprintf(fout,"H3'    H1     0.09850\n");
	fprintf(fout,"C2'    CT     -0.08540\n");
	fprintf(fout,"H2'1   HC     0.07180\n");
	fprintf(fout,"H2'2   HC     0.07180\n");
	fprintf(fout,"O3'    OS     -0.52320\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin DC Residue\n");
	fprintf(fout,"H5T    HO     0.44220\n");
	fprintf(fout,"O5'    OH     -0.63180\n");
	fprintf(fout,"C5'    CT     -0.00690\n");
	fprintf(fout,"H5'1   H1     0.07540\n");
	fprintf(fout,"H5'2   H1     0.07540\n");
	fprintf(fout,"C4'    CT     0.16290\n");
	fprintf(fout,"H4'    H1     0.11760\n");
	fprintf(fout,"O4'    OS     -0.36910\n");
	fprintf(fout,"C1'    CT     -0.01160\n");
	fprintf(fout,"H1'    H2     0.19630\n");
	fprintf(fout,"N1     N*     -0.03390\n");
	fprintf(fout,"C6     CM     -0.01830\n");
	fprintf(fout,"H6     H4     0.22930\n");
	fprintf(fout,"C5     CM     -0.52220\n");
	fprintf(fout,"H5     HA     0.18630\n");
	fprintf(fout,"C4     CA     0.84390\n");
	fprintf(fout,"N4     N2     -0.97730\n");
	fprintf(fout,"H41    H      0.43140\n");
	fprintf(fout,"H42    H      0.43140\n");
	fprintf(fout,"N3     NC     -0.77480\n");
	fprintf(fout,"C2     C      0.79590\n");
	fprintf(fout,"O      O      -0.65480\n");
	fprintf(fout,"C3'    CT     0.07130\n");
	fprintf(fout,"H3'    H1     0.09850\n");
	fprintf(fout,"C2'    CT     -0.08540\n");
	fprintf(fout,"H2'1   HC     0.07180\n");
	fprintf(fout,"H2'2   HC     0.07180\n");
	fprintf(fout,"O3'    OS     -0.52320\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin DC3 Residue\n");
	fprintf(fout,"P      P      1.16590\n");
	fprintf(fout,"O1P    O2     -0.77610\n");
	fprintf(fout,"O2P    O2     -0.77610\n");
	fprintf(fout,"O5'    OS     -0.49540\n");
	fprintf(fout,"C5'    CT     -0.00690\n");
	fprintf(fout,"H5'1   H1     0.07540\n");
	fprintf(fout,"H5'2   H1     0.07540\n");
	fprintf(fout,"C4'    CT     0.16290\n");
	fprintf(fout,"H4'    H1     0.11760\n");
	fprintf(fout,"O4'    OS     -0.36910\n");
	fprintf(fout,"C1'    CT     -0.01160\n");
	fprintf(fout,"H1'    H2     0.19630\n");
	fprintf(fout,"N1     N*     -0.03390\n");
	fprintf(fout,"C6     CM     -0.01830\n");
	fprintf(fout,"H6     H4     0.22930\n");
	fprintf(fout,"C5     CM     -0.52220\n");
	fprintf(fout,"H5     HA     0.18630\n");
	fprintf(fout,"C4     CA     0.84390\n");
	fprintf(fout,"N4     N2     -0.97730\n");
	fprintf(fout,"H41    H      0.43140\n");
	fprintf(fout,"H42    H      0.43140\n");
	fprintf(fout,"N3     NC     -0.77480\n");
	fprintf(fout,"C2     C      0.79590\n");
	fprintf(fout,"O      O      -0.65480\n");
	fprintf(fout,"C3'    CT     0.07130\n");
	fprintf(fout,"H3'    H1     0.09850\n");
	fprintf(fout,"C2'    CT     -0.08540\n");
	fprintf(fout,"H2'1   HC     0.07180\n");
	fprintf(fout,"H2'2   HC     0.07180\n");
	fprintf(fout,"O3'    OH     -0.65490\n");
	fprintf(fout,"H3T    HO     0.43960\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin DCN Residue\n");
	fprintf(fout,"H5T    HO     0.44220\n");
	fprintf(fout,"O5'    OH     -0.63180\n");
	fprintf(fout,"C5'    CT     -0.00690\n");
	fprintf(fout,"H5'1   H1     0.07540\n");
	fprintf(fout,"H5'2   H1     0.07540\n");
	fprintf(fout,"C4'    CT     0.16290\n");
	fprintf(fout,"H4'    H1     0.11760\n");
	fprintf(fout,"O4'    OS     -0.36910\n");
	fprintf(fout,"C1'    CT     -0.01160\n");
	fprintf(fout,"H1'    H2     0.19630\n");
	fprintf(fout,"N1     N*     -0.03390\n");
	fprintf(fout,"C6     CM     -0.01830\n");
	fprintf(fout,"H6     H4     0.22930\n");
	fprintf(fout,"C5     CM     -0.52220\n");
	fprintf(fout,"H5     HA     0.18630\n");
	fprintf(fout,"C4     CA     0.84390\n");
	fprintf(fout,"N4     N2     -0.97730\n");
	fprintf(fout,"H41    H      0.43140\n");
	fprintf(fout,"H42    H      0.43140\n");
	fprintf(fout,"N3     NC     -0.77480\n");
	fprintf(fout,"C2     C      0.79590\n");
	fprintf(fout,"O      O      -0.65480\n");
	fprintf(fout,"C3'    CT     0.07130\n");
	fprintf(fout,"H3'    H1     0.09850\n");
	fprintf(fout,"C2'    CT     -0.08540\n");
	fprintf(fout,"H2'1   HC     0.07180\n");
	fprintf(fout,"H2'2   HC     0.07180\n");
	fprintf(fout,"O3'    OH     -0.65490\n");
	fprintf(fout,"H3T    HO     0.43960\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin RC5 Residue\n");
	fprintf(fout,"H5T    HO     0.42950\n");
	fprintf(fout,"O5'    OH     -0.62230\n");
	fprintf(fout,"C5'    CT     0.05580\n");
	fprintf(fout,"H5'1   H1     0.06790\n");
	fprintf(fout,"H5'2   H1     0.06790\n");
	fprintf(fout,"C4'    CT     0.10650\n");
	fprintf(fout,"H4'    H1     0.11740\n");
	fprintf(fout,"O4'    OS     -0.35480\n");
	fprintf(fout,"C1'    CT     0.00660\n");
	fprintf(fout,"H1'    H2     0.20290\n");
	fprintf(fout,"N1     N*     -0.04840\n");
	fprintf(fout,"C6     CM     0.00530\n");
	fprintf(fout,"H6     H4     0.19580\n");
	fprintf(fout,"C5     CM     -0.52150\n");
	fprintf(fout,"H5     HA     0.19280\n");
	fprintf(fout,"C4     CA     0.81850\n");
	fprintf(fout,"N4     N2     -0.95300\n");
	fprintf(fout,"H41    H      0.42340\n");
	fprintf(fout,"H42    H      0.42340\n");
	fprintf(fout,"N3     NC     -0.75840\n");
	fprintf(fout,"C2     C      0.75380\n");
	fprintf(fout,"O      O      -0.62520\n");
	fprintf(fout,"C3'    CT     0.20220\n");
	fprintf(fout,"H3'    H1     0.06150\n");
	fprintf(fout,"C2'    CT     0.06700\n");
	fprintf(fout,"H2'1   H1     0.09720\n");
	fprintf(fout,"O2'    OH     -0.61390\n");
	fprintf(fout,"HO'2   HO     0.41860\n");
	fprintf(fout,"O3'    OS     -0.52460\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin RC Residue\n");
	fprintf(fout,"H5T    HO     0.42950\n");
	fprintf(fout,"O5'    OH     -0.62230\n");
	fprintf(fout,"C5'    CT     0.05580\n");
	fprintf(fout,"H5'1   H1     0.06790\n");
	fprintf(fout,"H5'2   H1     0.06790\n");
	fprintf(fout,"C4'    CT     0.10650\n");
	fprintf(fout,"H4'    H1     0.11740\n");
	fprintf(fout,"O4'    OS     -0.35480\n");
	fprintf(fout,"C1'    CT     0.00660\n");
	fprintf(fout,"H1'    H2     0.20290\n");
	fprintf(fout,"N1     N*     -0.04840\n");
	fprintf(fout,"C6     CM     0.00530\n");
	fprintf(fout,"H6     H4     0.19580\n");
	fprintf(fout,"C5     CM     -0.52150\n");
	fprintf(fout,"H5     HA     0.19280\n");
	fprintf(fout,"C4     CA     0.81850\n");
	fprintf(fout,"N4     N2     -0.95300\n");
	fprintf(fout,"H41    H      0.42340\n");
	fprintf(fout,"H42    H      0.42340\n");
	fprintf(fout,"N3     NC     -0.75840\n");
	fprintf(fout,"C2     C      0.75380\n");
	fprintf(fout,"O      O      -0.62520\n");
	fprintf(fout,"C3'    CT     0.20220\n");
	fprintf(fout,"H3'    H1     0.06150\n");
	fprintf(fout,"C2'    CT     0.06700\n");
	fprintf(fout,"H2'1   H1     0.09720\n");
	fprintf(fout,"O2'    OH     -0.61390\n");
	fprintf(fout,"HO'2   HO     0.41860\n");
	fprintf(fout,"O3'    OS     -0.52460\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin RC3 Residue\n");
	fprintf(fout,"P      P      1.16620\n");
	fprintf(fout,"O1P    O2     -0.77600\n");
	fprintf(fout,"O2P    O2     -0.77600\n");
	fprintf(fout,"O5'    OS     -0.49890\n");
	fprintf(fout,"C5'    CT     0.05580\n");
	fprintf(fout,"H5'1   H1     0.06790\n");
	fprintf(fout,"H5'2   H1     0.06790\n");
	fprintf(fout,"C4'    CT     0.10650\n");
	fprintf(fout,"H4'    H1     0.11740\n");
	fprintf(fout,"O4'    OS     -0.35480\n");
	fprintf(fout,"C1'    CT     0.00660\n");
	fprintf(fout,"H1'    H2     0.20290\n");
	fprintf(fout,"N1     N*     -0.04840\n");
	fprintf(fout,"C6     CM     0.00530\n");
	fprintf(fout,"H6     H4     0.19580\n");
	fprintf(fout,"C5     CM     -0.52150\n");
	fprintf(fout,"H5     HA     0.19280\n");
	fprintf(fout,"C4     CA     0.81850\n");
	fprintf(fout,"N4     N2     -0.95300\n");
	fprintf(fout,"H41    H      0.42340\n");
	fprintf(fout,"H42    H      0.42340\n");
	fprintf(fout,"N3     NC     -0.75840\n");
	fprintf(fout,"C2     C      0.75380\n");
	fprintf(fout,"O      O      -0.62520\n");
	fprintf(fout,"C3'    CT     0.20220\n");
	fprintf(fout,"H3'    H1     0.06150\n");
	fprintf(fout,"C2'    CT     0.06700\n");
	fprintf(fout,"H2'1   H1     0.09720\n");
	fprintf(fout,"O2'    OH     -0.61390\n");
	fprintf(fout,"HO'2   HO     0.41860\n");
	fprintf(fout,"O3'    OH     -0.65410\n");
	fprintf(fout,"H3T    HO     0.43760\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin RCN Residue\n");
	fprintf(fout,"H5T    HO     0.42950\n");
	fprintf(fout,"O5'    OH     -0.62230\n");
	fprintf(fout,"C5'    CT     0.05580\n");
	fprintf(fout,"H5'1   H1     0.06790\n");
	fprintf(fout,"H5'2   H1     0.06790\n");
	fprintf(fout,"C4'    CT     0.10650\n");
	fprintf(fout,"H4'    H1     0.11740\n");
	fprintf(fout,"O4'    OS     -0.35480\n");
	fprintf(fout,"C1'    CT     0.00660\n");
	fprintf(fout,"H1'    H2     0.20290\n");
	fprintf(fout,"N1     N*     -0.04840\n");
	fprintf(fout,"C6     CM     0.00530\n");
	fprintf(fout,"H6     H4     0.19580\n");
	fprintf(fout,"C5     CM     -0.52150\n");
	fprintf(fout,"H5     HA     0.19280\n");
	fprintf(fout,"C4     CA     0.81850\n");
	fprintf(fout,"N4     N2     -0.95300\n");
	fprintf(fout,"H41    H      0.42340\n");
	fprintf(fout,"H42    H      0.42340\n");
	fprintf(fout,"N3     NC     -0.75840\n");
	fprintf(fout,"C2     C      0.75380\n");
	fprintf(fout,"O      O      -0.62520\n");
	fprintf(fout,"C3'    CT     0.20220\n");
	fprintf(fout,"H3'    H1     0.06150\n");
	fprintf(fout,"C2'    CT     0.06700\n");
	fprintf(fout,"H2'1   H1     0.09720\n");
	fprintf(fout,"O2'    OH     -0.61390\n");
	fprintf(fout,"HO'2   HO     0.41860\n");
	fprintf(fout,"O3'    OH     -0.65410\n");
	fprintf(fout,"H3T    HO     0.43760\n");

	fprintf(fout,"Begin 1MA Residue\n");
	fprintf(fout,"P      P      1.072000\n");
	fprintf(fout,"O1P    O2     -0.755200\n");
	fprintf(fout,"O2P    O2     -0.755200\n");
	fprintf(fout,"O5'    OS     -0.408500\n");
	fprintf(fout,"C5'    CT     0.055600\n");
	fprintf(fout,"H5'1   H1     0.060200\n");
	fprintf(fout,"H5'2   H1     0.060200\n");
	fprintf(fout,"C4'    CT     0.021900\n");
	fprintf(fout,"H4'    H1     0.105500\n");
	fprintf(fout,"O4'    OS     -0.259900\n");
	fprintf(fout,"C1'    CT     0.083400\n");
	fprintf(fout,"H1'    H2     0.115000\n");
	fprintf(fout,"N9     N*     -0.169200\n");
	fprintf(fout,"C8     CK     0.215300\n");
	fprintf(fout,"H8     H5     0.145100\n");
	fprintf(fout,"N7     NB     -0.543600\n");
	fprintf(fout,"C5     CB     -0.047500\n");
	fprintf(fout,"C6     CA     0.603800\n");
	fprintf(fout,"N6     N2     -0.713600\n");
	fprintf(fout,"H61    H      0.355800\n");
	fprintf(fout,"H62    H      0.355800\n");
	fprintf(fout,"N1     NC     -0.731300\n");
	fprintf(fout,"C1     C      0.560800\n");
	fprintf(fout,"H11    H      0.420500\n");
	fprintf(fout,"H12    H      0.420500\n");
	fprintf(fout,"H13    H      0.420500\n");
	fprintf(fout,"1H1    H      0.420500\n");
	fprintf(fout,"2H1    H      0.420500\n");
	fprintf(fout,"3H1    H      0.420500\n");
	fprintf(fout,"C2     CQ     0.572600\n");
	fprintf(fout,"H2     H5     0.011900\n");
	fprintf(fout,"N3     NC     -0.764900\n");
	fprintf(fout,"C4     CB     0.549900\n");
	fprintf(fout,"C3'    CT     0.164500\n");
	fprintf(fout,"H3'    H1     0.062300\n");
	fprintf(fout,"C2'    CT     -0.056100\n");
	fprintf(fout,"H2'1   HC     0.048600\n");
	fprintf(fout,"H2'2   HC     0.048600\n");
	fprintf(fout,"O3'    OS     -0.499800\n");
	fprintf(fout,"H2'    H1     0.103300\n");
	fprintf(fout,"O2'    OH     -0.496300\n");
	fprintf(fout,"HO'2   HO     0.372000\n");
	fprintf(fout,"HO2   HO     0.372000\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin 1MG Residue\n");
	fprintf(fout,"P      P      1.072000\n");
	fprintf(fout,"O1P    O2     -0.755200\n");
	fprintf(fout,"O2P    O2     -0.755200\n");
	fprintf(fout,"O5'    OS     -0.408500\n");
	fprintf(fout,"C5'    CT     0.055600\n");
	fprintf(fout,"H5'1   H1     0.060200\n");
	fprintf(fout,"H5'2   H1     0.060200\n");
	fprintf(fout,"C4'    CT     0.021900\n");
	fprintf(fout,"H4'    H1     0.105500\n");
	fprintf(fout,"O4'    OS     -0.259900\n");
	fprintf(fout,"C1'    CT     0.083400\n");
	fprintf(fout,"H1'    H2     0.115000\n");
	fprintf(fout,"N9     N*     -0.169200\n");
	fprintf(fout,"C8     CK     0.215300\n");
	fprintf(fout,"H8     H5     0.145100\n");
	fprintf(fout,"N7     NB     -0.543600\n");
	fprintf(fout,"C5     CB     -0.047500\n");
	fprintf(fout,"C6     CA     0.603800\n");
	fprintf(fout,"N6     N2     -0.713600\n");
	fprintf(fout,"H61    H      0.355800\n");
	fprintf(fout,"H62    H      0.355800\n");
	fprintf(fout,"O6     O      -0.530100\n");
	fprintf(fout,"N1     NC     -0.731300\n");
	fprintf(fout,"C1A    CC      0.0300000\n");
	fprintf(fout,"H11    H      0.420500\n");
	fprintf(fout,"H12    H      0.420500\n");
	fprintf(fout,"H13    H      0.420500\n");
	fprintf(fout,"1H1    H      0.420500\n");
	fprintf(fout,"2H1    H      0.420500\n");
	fprintf(fout,"3H1    H      0.420500\n");
	fprintf(fout,"C2     CQ     0.572600\n");
	fprintf(fout,"N2     N2     -0.750800\n");
	fprintf(fout,"H21    H      0.344300\n");
	fprintf(fout,"H22    H      0.344300\n");
	fprintf(fout,"N3     NC     -0.650200\n");
	fprintf(fout,"C4     CB     0.290900\n");
	fprintf(fout,"C3'    CT     0.164500\n");
	fprintf(fout,"H3'    H1     0.062300\n");
	fprintf(fout,"C2'    CT     -0.056100\n");
	fprintf(fout,"H2'1   HC     0.048600\n");
	fprintf(fout,"H2'2   HC     0.048600\n");
	fprintf(fout,"H2'    H1     0.103300\n");
	fprintf(fout,"O2'    OH     -0.496300\n");
	fprintf(fout,"HO'2   HO     0.372000\n");
	fprintf(fout,"HO2   HO     0.372000\n");
	fprintf(fout,"O3'    OS     -0.499800\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin 2MG Residue\n");
	fprintf(fout,"P      P      1.072000\n");
	fprintf(fout,"O1P    O2     -0.755200\n");
	fprintf(fout,"O2P    O2     -0.755200\n");
	fprintf(fout,"O5'    OS     -0.408500\n");
	fprintf(fout,"C5'    CT     0.055600\n");
	fprintf(fout,"H5'1   H1     0.060200\n");
	fprintf(fout,"H5'2   H1     0.060200\n");
	fprintf(fout,"C4'    CT     0.021900\n");
	fprintf(fout,"H4'    H1     0.105500\n");
	fprintf(fout,"O4'    OS     -0.259900\n");
	fprintf(fout,"C1'    CT     0.083400\n");
	fprintf(fout,"H1'    H2     0.115000\n");
	fprintf(fout,"N9     N*     -0.169200\n");
	fprintf(fout,"C8     CK     0.215300\n");
	fprintf(fout,"H8     H5     0.145100\n");
	fprintf(fout,"N7     NB     -0.543600\n");
	fprintf(fout,"C5     CB     -0.047500\n");
	fprintf(fout,"C6     CA     0.603800\n");
	fprintf(fout,"O6     O      -0.530100\n");
	fprintf(fout,"N1     NC     -0.731300\n");
	fprintf(fout,"H1     H      0.420500\n");
	fprintf(fout,"C2     CQ     0.572600\n");
	fprintf(fout,"N2     N2     -0.750800\n");
	fprintf(fout,"H2     H      0.344300\n");
	fprintf(fout,"C2A    CB    -0.020000\n");
	fprintf(fout,"H2A1   HC     0.080300\n");
	fprintf(fout,"H2A2   HC     0.080300\n");
	fprintf(fout,"H2A3   HC     0.080300\n");
	fprintf(fout,"N3     NC     -0.650200\n");
	fprintf(fout,"C4     CB     0.290900\n");
	fprintf(fout,"C3'    CT     0.164500\n");
	fprintf(fout,"H3'    H1     0.062300\n");
	fprintf(fout,"C2'    CT     -0.056100\n");
	fprintf(fout,"H2'    H1     0.103300\n");
	fprintf(fout,"O2'    OH     -0.496300\n");
	fprintf(fout,"HO'2   HO     0.372000\n");
	fprintf(fout,"HO2   HO     0.372000\n");
	fprintf(fout,"O3'    OS     -0.499800\n");
	fprintf(fout,"H2'1   HC     0.048600\n");
	fprintf(fout,"H2'2   HC     0.048600\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin 5MC Residue\n");
	fprintf(fout,"P      P      1.072000\n");
	fprintf(fout,"O1P    O2     -0.755200\n");
	fprintf(fout,"O2P    O2     -0.755200\n");
	fprintf(fout,"O5'    OS     -0.408500\n");
	fprintf(fout,"C5'    CT     0.055600\n");
	fprintf(fout,"H5'1   H1     0.060200\n");
	fprintf(fout,"H5'2   H1     0.060200\n");
	fprintf(fout,"C4'    CT     0.021900\n");
	fprintf(fout,"H4'    H1     0.105500\n");
	fprintf(fout,"O4'    OS     -0.259900\n");
	fprintf(fout,"C1'    CT     0.083400\n");
	fprintf(fout,"H1'    H2     0.115000\n");
	fprintf(fout,"N1     NC     -0.731300\n");
	fprintf(fout,"C6     CM     -0.011500\n");
	fprintf(fout,"H6     H4     0.209900\n");
	fprintf(fout,"C5     CM     -0.469600\n");
	fprintf(fout,"C5A    CM     -0.469600\n");
	fprintf(fout,"H5A1   HA     0.183300\n");
	fprintf(fout,"H5A2   HA     0.183300\n");
	fprintf(fout,"H5A3   HA     0.183300\n");
	fprintf(fout,"C4     CA     0.701000\n");
	fprintf(fout,"N4     N2     -0.741700\n");
	fprintf(fout,"H41    H      0.352600\n");
	fprintf(fout,"H42    H      0.352600\n");
	fprintf(fout,"N3     NC     -0.755500\n");
	fprintf(fout,"C2     C      0.846400\n");
	fprintf(fout,"O2     O      -0.652400\n");
	fprintf(fout,"C3'    CT     0.164500\n");
	fprintf(fout,"H3'    H1     0.062300\n");
	fprintf(fout,"C2'    CT     -0.056100\n");
	fprintf(fout,"H2'    H1     0.103300\n");
	fprintf(fout,"O2'    OH     -0.496300\n");
	fprintf(fout,"HO'2   HO     0.372000\n");
	fprintf(fout,"HO2    HO     0.372000\n");
	fprintf(fout,"H2'1   HC     0.048600\n");
	fprintf(fout,"H2'2   HC     0.048600\n");
	fprintf(fout,"O3'    OS     -0.499800\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin 5MU Residue\n");
	fprintf(fout,"P      P      1.072000\n");
	fprintf(fout,"O1P    O2     -0.755200\n");
	fprintf(fout,"O2P    O2     -0.755200\n");
	fprintf(fout,"O5'    OS     -0.408500\n");
	fprintf(fout,"C5'    CT     0.055600\n");
	fprintf(fout,"H5'1   H1     0.060200\n");
	fprintf(fout,"H5'2   H1     0.060200\n");
	fprintf(fout,"C4'    CT     0.021900\n");
	fprintf(fout,"H4'    H1     0.105500\n");
	fprintf(fout,"O4'    OS     -0.259900\n");
	fprintf(fout,"C1'    CT     0.083400\n");
	fprintf(fout,"H1'    H2     0.115000\n");
	fprintf(fout,"N1     NC     -0.731300\n");
	fprintf(fout,"C6     CM     -0.011500\n");
	fprintf(fout,"H6     H4     0.209900\n");
	fprintf(fout,"C5     CM     -0.469600\n");
	fprintf(fout,"C5A    CM     -0.469600\n");
	fprintf(fout,"H5A1   HA     0.183300\n");
	fprintf(fout,"H5A2   HA     0.183300\n");
	fprintf(fout,"H5A3   HA     0.183300\n");
	fprintf(fout,"C4     CA     0.701000\n");
	fprintf(fout,"O4     O      -0.545500\n");
	fprintf(fout,"N3     NA     -0.482400\n");
	fprintf(fout,"H3     H      0.354200\n");
	fprintf(fout,"C2     C      0.589200\n");
	fprintf(fout,"O2     O      -0.588000\n");
	fprintf(fout,"C3'    CT     0.164500\n");
	fprintf(fout,"H3'    H1     0.062300\n");
	fprintf(fout,"C2'    CT     -0.056100\n");
	fprintf(fout,"H2'    H1     0.103300\n");
	fprintf(fout,"O2'    OH     -0.496300\n");
	fprintf(fout,"HO'2   HO     0.372000\n");
	fprintf(fout,"HO2    HO     0.372000\n");
	fprintf(fout,"H2'1   HC     0.048600\n");
	fprintf(fout,"H2'2   HC     0.048600\n");
	fprintf(fout,"O3'    OS     -0.499800\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin 7MG Residue\n");
	fprintf(fout,"P      P      1.072000\n");
	fprintf(fout,"O1P    O2     -0.755200\n");
	fprintf(fout,"O2P    O2     -0.755200\n");
	fprintf(fout,"O5'    OS     -0.408500\n");
	fprintf(fout,"C5'    CT     0.055600\n");
	fprintf(fout,"H5'1   H1     0.060200\n");
	fprintf(fout,"H5'2   H1     0.060200\n");
	fprintf(fout,"C4'    CT     0.021900\n");
	fprintf(fout,"H4'    H1     0.105500\n");
	fprintf(fout,"O4'    OS     -0.259900\n");
	fprintf(fout,"C1'    CT     0.083400\n");
	fprintf(fout,"H1'    H2     0.115000\n");
	fprintf(fout,"N9     N*     -0.169200\n");
	fprintf(fout,"C8     CK     0.215300\n");
	fprintf(fout,"H8     H5     0.145100\n");
	fprintf(fout,"N7     NB     -0.543600\n");
	fprintf(fout,"C7     CT     -0.132600\n");
	fprintf(fout,"H71    HC     0.060600\n");
	fprintf(fout,"H72    HC     0.060600\n");
	fprintf(fout,"H73    HC     0.060600\n");
	fprintf(fout,"C5     CB     -0.047500\n");
	fprintf(fout,"C6     CA     0.603800\n");
	fprintf(fout,"O6     O      -0.530100\n");
	fprintf(fout,"N1     NA     -0.540500\n");
	fprintf(fout,"H1     H      0.375000\n");
	fprintf(fout,"C2     CA     0.683400\n");
	fprintf(fout,"N2     N2     -0.750800\n");
	fprintf(fout,"H21    H      0.344300\n");
	fprintf(fout,"H22    H      0.344300\n");
	fprintf(fout,"N3     NC     -0.650200\n");
	fprintf(fout,"C4     CB     0.290900\n");
	fprintf(fout,"C3'    CT     0.164500\n");
	fprintf(fout,"H3'    H1     0.062300\n");
	fprintf(fout,"C2'    CT     -0.056100\n");
	fprintf(fout,"H2'1   HC     0.048600\n");
	fprintf(fout,"H2'2   HC     0.048600\n");
	fprintf(fout,"O3'    OS     -0.499800\n");
	fprintf(fout,"H2'    H1     0.103300\n");
	fprintf(fout,"O2'    OH     -0.496300\n");
	fprintf(fout,"HO'2   HO     0.372000\n");
	fprintf(fout,"HO2    HO     0.372000\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin H2U Residue\n");
	fprintf(fout,"P      P      1.072000\n");
	fprintf(fout,"O1P    O2     -0.755200\n");
	fprintf(fout,"O2P    O2     -0.755200\n");
	fprintf(fout,"O5'    OS     -0.408500\n");
	fprintf(fout,"C5'    CT     0.055600\n");
	fprintf(fout,"H5'1   H1     0.060200\n");
	fprintf(fout,"H5'2   H1     0.060200\n");
	fprintf(fout,"C4'    CT     0.021900\n");
	fprintf(fout,"H4'    H1     0.105500\n");
	fprintf(fout,"O4'    OS     -0.259900\n");
	fprintf(fout,"C1'    CT     0.083400\n");
	fprintf(fout,"H1'    H2     0.115000\n");
	fprintf(fout,"C3'    CT     0.164500\n");
	fprintf(fout,"H3'    H1     0.062300\n");
	fprintf(fout,"C2'    CT     -0.056100\n");
	fprintf(fout,"H2'    H1     0.103300\n");
	fprintf(fout,"O2'    OH     -0.496300\n");
	fprintf(fout,"HO'2   HO     0.372000\n");
	fprintf(fout,"HO2    HO     0.372000\n");
	fprintf(fout,"O3'    OS     -0.499800\n");
	fprintf(fout,"N1     NC     -0.731300\n");
	fprintf(fout,"C6     CM     -0.011500\n");
	fprintf(fout,"H61    H      0.355800\n");
	fprintf(fout,"H62    H      0.355800\n");
	fprintf(fout,"C5     CB     -0.047500\n");
	fprintf(fout,"H51    H      0.355800\n");
	fprintf(fout,"H52    H      0.355800\n");
	fprintf(fout,"C4     C      0.572800\n");
	fprintf(fout,"O4     O      -0.552800\n");
	fprintf(fout,"N3     NA     -0.340900\n");
	fprintf(fout,"H3     H      0.307700\n");
	fprintf(fout,"C2     C      0.462500\n");
	fprintf(fout,"O2     O      -0.559700\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin I Residue\n");
	fprintf(fout,"P      P      1.072000\n");
	fprintf(fout,"O1P    O2     -0.755200\n");
	fprintf(fout,"O2P    O2     -0.755200\n");
	fprintf(fout,"O5'    OS     -0.408500\n");
	fprintf(fout,"C5'    CT     0.055600\n");
	fprintf(fout,"H5'1   H1     0.060200\n");
	fprintf(fout,"H5'2   H1     0.060200\n");
	fprintf(fout,"C4'    CT     0.021900\n");
	fprintf(fout,"H4'    H1     0.105500\n");
	fprintf(fout,"O4'    OS     -0.259900\n");
	fprintf(fout,"C1'    CT     0.083400\n");
	fprintf(fout,"H1'    H2     0.115000\n");
	fprintf(fout,"N9     N*     -0.169200\n");
	fprintf(fout,"C8     CK     0.215300\n");
	fprintf(fout,"H8     H5     0.145100\n");
	fprintf(fout,"N7     NB     -0.543600\n");
	fprintf(fout,"C5     CB     -0.047500\n");
	fprintf(fout,"C6     CA     0.603800\n");
	fprintf(fout,"O6     O      -0.530100\n");
	fprintf(fout,"N1     NA     -0.540500\n");
	fprintf(fout,"H1     H      0.375000\n");
	fprintf(fout,"C2     CA     0.683400\n");
	fprintf(fout,"N3     NC     -0.764900\n");
	fprintf(fout,"C4     CB     0.549900\n");
	fprintf(fout,"C3'    CT     0.164500\n");
	fprintf(fout,"H3'    H1     0.062300\n");
	fprintf(fout,"C2'    CT     -0.056100\n");
	fprintf(fout,"H2'    H1     0.103300\n");
	fprintf(fout,"O2'    OH     -0.496300\n");
	fprintf(fout,"HO'2   HO     0.372000\n");
	fprintf(fout,"HO2    HO     0.372000\n");
	fprintf(fout,"H2'1   HC     0.048600\n");
	fprintf(fout,"H2'2   HC     0.048600\n");
	fprintf(fout,"O3'    OS     -0.499800\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin M2G Residue\n");
	fprintf(fout,"P      P      1.072000\n");
	fprintf(fout,"O1P    O2     -0.755200\n");
	fprintf(fout,"O2P    O2     -0.755200\n");
	fprintf(fout,"O5'    OS     -0.408500\n");
	fprintf(fout,"C5'    CT     0.055600\n");
	fprintf(fout,"H5'1   H1     0.060200\n");
	fprintf(fout,"H5'2   H1     0.060200\n");
	fprintf(fout,"C4'    CT     0.021900\n");
	fprintf(fout,"H4'    H1     0.105500\n");
	fprintf(fout,"O4'    OS     -0.259900\n");
	fprintf(fout,"C1'    CT     0.083400\n");
	fprintf(fout,"H1'    H2     0.115000\n");
	fprintf(fout,"N9     N*     -0.169200\n");
	fprintf(fout,"C8     CK     0.215300\n");
	fprintf(fout,"H8     H5     0.145100\n");
	fprintf(fout,"N7     NB     -0.543600\n");
	fprintf(fout,"C5     CB     -0.047500\n");
	fprintf(fout,"C6     CA     0.603800\n");
	fprintf(fout,"O6     O      -0.530100\n");
	fprintf(fout,"N1     NA     -0.540500\n");
	fprintf(fout,"H1     H      0.375000\n");
	fprintf(fout,"C2     CA     0.683400\n");
	fprintf(fout,"N2     N2     -0.750800\n");
	fprintf(fout,"C2A    CB    -0.020000\n");
	fprintf(fout,"H2A1   HC     0.080300\n");
	fprintf(fout,"H2A2   HC     0.080300\n");
	fprintf(fout,"H2A3   HC     0.080300\n");
	fprintf(fout,"C2B    CB    -0.020000\n");
	fprintf(fout,"H2B1   HC     0.080300\n");
	fprintf(fout,"H2B2   HC     0.080300\n");
	fprintf(fout,"H2B3   HC     0.080300\n");
	fprintf(fout,"N3     NC     -0.650200\n");
	fprintf(fout,"C4     CB     0.290900\n");
	fprintf(fout,"C3'    CT     0.164500\n");
	fprintf(fout,"H3'    H1     0.062300\n");
	fprintf(fout,"C2'    CT     -0.056100\n");
	fprintf(fout,"H2'    H1     0.103300\n");
	fprintf(fout,"O2'    OH     -0.496300\n");
	fprintf(fout,"HO'2   HO     0.372000\n");
	fprintf(fout,"HO2   HO     0.372000\n");
	fprintf(fout,"O3'    OS     -0.499800\n");
	fprintf(fout,"H2'1   HC     0.048600\n");
	fprintf(fout,"H2'2   HC     0.048600\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin OMC Residue\n");
	fprintf(fout,"P      P      1.072000\n");
	fprintf(fout,"O1P    O2     -0.755200\n");
	fprintf(fout,"O2P    O2     -0.755200\n");
	fprintf(fout,"O5'    OS     -0.408500\n");
	fprintf(fout,"C5'    CT     0.055600\n");
	fprintf(fout,"H5'1   H1     0.060200\n");
	fprintf(fout,"H5'2   H1     0.060200\n");
	fprintf(fout,"C4'    CT     0.021900\n");
	fprintf(fout,"H4'    H1     0.105500\n");
	fprintf(fout,"O4'    OS     -0.259900\n");
	fprintf(fout,"C1'    CT     0.083400\n");
	fprintf(fout,"H1'    H2     0.115000\n");
	fprintf(fout,"N1     N*     -0.131800\n");
	fprintf(fout,"C6     CM     -0.011500\n");
	fprintf(fout,"H6     H4     0.209900\n");
	fprintf(fout,"C5     CM     -0.469600\n");
	fprintf(fout,"H5     HA     0.183300\n");
	fprintf(fout,"C4     CA     0.701000\n");
	fprintf(fout,"N4     N2     -0.741700\n");
	fprintf(fout,"H41    H      0.352600\n");
	fprintf(fout,"H42    H      0.352600\n");
	fprintf(fout,"N3     NC     -0.755500\n");
	fprintf(fout,"C2     CQ     0.572600\n");
	fprintf(fout,"O2     O      -0.652400\n");
	fprintf(fout,"H3'    H1     0.062300\n");
	fprintf(fout,"C2'    CT     -0.056100\n");
	fprintf(fout,"H2'    H1     0.103300\n");
	fprintf(fout,"O2'    OH     -0.496300\n");
	fprintf(fout,"C2A    CB    -0.020000\n");
	fprintf(fout,"H2A1   HC     0.080300\n");
	fprintf(fout,"H2A2   HC     0.080300\n");
	fprintf(fout,"H2A3   HC     0.080300\n");
	fprintf(fout,"C3'    CT     0.164500\n");
	fprintf(fout,"O3'    OS     -0.499800\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin OMG Residue\n");
	fprintf(fout,"P      P      1.072000\n");
	fprintf(fout,"O1P    O2     -0.755200\n");
	fprintf(fout,"O2P    O2     -0.755200\n");
	fprintf(fout,"O5'    OS     -0.408500\n");
	fprintf(fout,"C5'    CT     0.055600\n");
	fprintf(fout,"H5'1   H1     0.060200\n");
	fprintf(fout,"H5'2   H1     0.060200\n");
	fprintf(fout,"C4'    CT     0.021900\n");
	fprintf(fout,"H4'    H1     0.105500\n");
	fprintf(fout,"O4'    OS     -0.259900\n");
	fprintf(fout,"C1'    CT     0.083400\n");
	fprintf(fout,"H1'    H2     0.115000\n");
	fprintf(fout,"N9     N*     -0.169200\n");
	fprintf(fout,"C8     CK     0.215300\n");
	fprintf(fout,"H8     H5     0.145100\n");
	fprintf(fout,"N7     NB     -0.543600\n");
	fprintf(fout,"C5     CB     -0.047500\n");
	fprintf(fout,"C6     CA     0.603800\n");
	fprintf(fout,"O6     O      -0.530100\n");
	fprintf(fout,"N1     NA     -0.540500\n");
	fprintf(fout,"H1     H      0.375000\n");
	fprintf(fout,"C2     CA     0.683400\n");
	fprintf(fout,"N2     N2     -0.750800\n");
	fprintf(fout,"H21    H      0.344300\n");
	fprintf(fout,"H22    H      0.344300\n");
	fprintf(fout,"N3     NC     -0.650200\n");
	fprintf(fout,"C4     CB     0.290900\n");
	fprintf(fout,"C3'    CT     0.164500\n");
	fprintf(fout,"H3'    H1     0.062300\n");
	fprintf(fout,"C2'    CT     -0.056100\n");
	fprintf(fout,"H2'    H1     0.103300\n");
	fprintf(fout,"O2'    OH     -0.496300\n");
	fprintf(fout,"C2A    CB    -0.020000\n");
	fprintf(fout,"H2A1   HC     0.080300\n");
	fprintf(fout,"H2A2   HC     0.080300\n");
	fprintf(fout,"H2A3   HC     0.080300\n");
	fprintf(fout,"O3'    OS     -0.499800\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin PSU Residue\n");
	fprintf(fout,"P      P      1.072000\n");
	fprintf(fout,"O1P    O2     -0.755200\n");
	fprintf(fout,"O2P    O2     -0.755200\n");
	fprintf(fout,"O5'    OS     -0.408500\n");
	fprintf(fout,"C5'    CT     0.055600\n");
	fprintf(fout,"H5'1   H1     0.060200\n");
	fprintf(fout,"H5'2   H1     0.060200\n");
	fprintf(fout,"C4'    CT     0.021900\n");
	fprintf(fout,"H4'    H1     0.105500\n");
	fprintf(fout,"O4'    OS     -0.259900\n");
	fprintf(fout,"C1'    CT     0.083400\n");
	fprintf(fout,"H1'    H2     0.115000\n");
	fprintf(fout,"N1     NA     -0.540500\n");
	fprintf(fout,"H1     H      0.375000\n");
	fprintf(fout,"C6     CM     -0.011500\n");
	fprintf(fout,"H6     H4     0.209900\n");
	fprintf(fout,"C5     CM     -0.469600\n");
	fprintf(fout,"C4     CA     0.701000\n");
	fprintf(fout,"O4     O      -0.545500\n");
	fprintf(fout,"N3     NA     -0.482400\n");
	fprintf(fout,"H3     H      0.354200\n");
	fprintf(fout,"C2     C      0.589200\n");
	fprintf(fout,"O2     O      -0.588000\n");
	fprintf(fout,"C3'    CT     0.164500\n");
	fprintf(fout,"H3'    H1     0.062300\n");
	fprintf(fout,"C2'    CT     -0.056100\n");
	fprintf(fout,"H2'    H1     0.103300\n");
	fprintf(fout,"O2'    OH     -0.496300\n");
	fprintf(fout,"HO'2   HO     0.372000\n");
	fprintf(fout,"HO2   HO     0.372000\n");
	fprintf(fout,"H2'1   HC     0.048600\n");
	fprintf(fout,"H2'2   HC     0.048600\n");
	fprintf(fout,"O3'    OS     -0.499800\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin Y Residue\n");
	fprintf(fout,"P      P      1.072000\n");
	fprintf(fout,"O1P    O2     -0.755200\n");
	fprintf(fout,"O2P    O2     -0.755200\n");
	fprintf(fout,"O5'    OS     -0.408500\n");
	fprintf(fout,"C5'    CT     0.055600\n");
	fprintf(fout,"H5'1   H1     0.060200\n");
	fprintf(fout,"H5'2   H1     0.060200\n");
	fprintf(fout,"C4'    CT     0.021900\n");
	fprintf(fout,"H4'    H1     0.105500\n");
	fprintf(fout,"O4'    OS     -0.259900\n");
	fprintf(fout,"C1'    CT     0.083400\n");
	fprintf(fout,"H1'    H2     0.115000\n");
	fprintf(fout,"C3'    CT     0.164500\n");
	fprintf(fout,"H3'    H1     0.062300\n");
	fprintf(fout,"C2'    CT     -0.056100\n");
	fprintf(fout,"H2'    H1     0.103300\n");
	fprintf(fout,"O2'    OH     -0.496300\n");
	fprintf(fout,"HO'2   HO     0.372000\n");
	fprintf(fout,"HO2   HO     0.372000\n");
	fprintf(fout,"O3'    OS     -0.499800\n");
	fprintf(fout,"H2'1   HC     0.048600\n");
	fprintf(fout,"H2'2   HC     0.048600\n");
	fprintf(fout,"N9     N*     -0.169200\n");
	fprintf(fout,"C8     CK     0.215300\n");
	fprintf(fout,"H8     H5     0.145100\n");
	fprintf(fout,"N7     NB     -0.543600\n");
	fprintf(fout,"H7    HC     0.060600\n");
	fprintf(fout,"C5     CB     -0.047500\n");
	fprintf(fout,"C6     CA     0.603800\n");
	fprintf(fout,"O6     O      -0.530100\n");
	fprintf(fout,"N1     NA     -0.540500\n");
	fprintf(fout,"C2     CA     0.683400\n");
	fprintf(fout,"N2     N2     -0.750800\n");
	fprintf(fout,"N3     NC     -0.764900\n");
	fprintf(fout,"C3     C      0.846400\n");
	fprintf(fout,"H31    H      0.354200\n");
	fprintf(fout,"H32    H      0.354200\n");
	fprintf(fout,"H33    H      0.354200\n");
	fprintf(fout,"C4     CB     0.549900\n");
	fprintf(fout,"C10    C      0.846400\n");
	fprintf(fout,"H101   H      0.375000\n");
	fprintf(fout,"H102   H      0.375000\n");
	fprintf(fout,"H103   H      0.375000\n");
	fprintf(fout,"C11    C      0.846400\n");
	fprintf(fout,"C12    C      0.846400\n");
	fprintf(fout,"C13    C      0.846400\n");
	fprintf(fout,"1C1    C      0.846400\n");
	fprintf(fout,"2C1    C      0.846400\n");
	fprintf(fout,"3C1    C      0.846400\n");
	fprintf(fout,"H131   H      0.375000\n");
	fprintf(fout,"H132   H      0.375000\n");
	fprintf(fout,"1H13   H      0.375000\n");
	fprintf(fout,"2H13   H      0.375000\n");
	fprintf(fout,"C14    C      0.846400\n");
	fprintf(fout,"H141   H      0.375000\n");
	fprintf(fout,"H142   H      0.375000\n");
	fprintf(fout,"1H14   H      0.375000\n");
	fprintf(fout,"2H14   H      0.375000\n");
	fprintf(fout,"C15    C      0.846400\n");
	fprintf(fout,"H15   H      0.375000\n");
	fprintf(fout,"C16    C      0.846400\n");
	fprintf(fout,"O17    O      -0.504000\n");
	fprintf(fout,"O18    O      -0.504000\n");
	fprintf(fout,"C19    C      0.846400\n");
	fprintf(fout,"H191   H      0.375000\n");
	fprintf(fout,"H192   H      0.375000\n");
	fprintf(fout,"H193   H      0.375000\n");
	fprintf(fout,"1H19   H      0.375000\n");
	fprintf(fout,"2H19   H      0.375000\n");
	fprintf(fout,"3H19   H      0.375000\n");
	fprintf(fout,"N20    N2     -0.750800\n");
	fprintf(fout,"C21    CQ     0.572600\n");
	fprintf(fout,"H20    H      0.344300\n");
	fprintf(fout,"O22    O      -0.652400\n");
	fprintf(fout,"O23    O      -0.652400\n");
	fprintf(fout,"C24    CQ     0.572600\n");
	fprintf(fout,"H241   H      0.344300\n");
	fprintf(fout,"H242   H      0.344300\n");
	fprintf(fout,"H243   H      0.344300\n");
	fprintf(fout,"1H24   H      0.344300\n");
	fprintf(fout,"2H24   H      0.344300\n");
	fprintf(fout,"3H24   H      0.344300\n");
	fprintf(fout,"End\n");

}
/************************************************************/
void createAllResidueTpl(FILE* fout)
{
	fprintf(fout,"Begin ALLRESIDUE Residue\n");
	fprintf(fout,"OXT    O2    -0.542500\n");
	fprintf(fout,"1H     H	    0.301800\n");
	fprintf(fout,"2H     H      0.301800\n");
	fprintf(fout,"3H     H      0.301800\n");
	fprintf(fout,"O3T    OH     -0.63180\n");
	fprintf(fout,"H3T    HO     0.325000\n");
	fprintf(fout,"HT1    H     0.325000\n");
	fprintf(fout,"HT2    H     0.325000\n");
	fprintf(fout,"HT3    H     0.325000\n");
	fprintf(fout,"Li     Li     1.000000\n");
	fprintf(fout,"Na     Na     1.000000\n");
	fprintf(fout,"K      K      1.000000\n");
	fprintf(fout,"Rb     Rb     1.000000\n");
	fprintf(fout,"Cs     Cs     1.000000\n");
	fprintf(fout,"End\n");
}
/************************************************************/
void createFragResidueTpl(FILE* fout)
{
	fprintf(fout,"Begin GBZN Residue\n");
	fprintf(fout,"C1    CA    -0.542500\n");
	fprintf(fout,"C2    CA    -0.542500\n");
	fprintf(fout,"C3    CA    -0.542500\n");
	fprintf(fout,"C4    CA    -0.542500\n");
	fprintf(fout,"C5    CA    -0.542500\n");
	fprintf(fout,"C6    CA    -0.542500\n");
	fprintf(fout,"H11   HA      0.301800\n");
	fprintf(fout,"H21   HA      0.301800\n");
	fprintf(fout,"H31   HA      0.301800\n");
	fprintf(fout,"H41   HA      0.301800\n");
	fprintf(fout,"H51   HA      0.301800\n");
	fprintf(fout,"H61   HA      0.301800\n");
	fprintf(fout,"End\n");

	fprintf(fout,"Begin GAPT Residue\n");
	fprintf(fout,"C1    CT    -0.542500\n");
	fprintf(fout,"C2    CT    -0.542500\n");
	fprintf(fout,"C3    CA    -0.542500\n");
	fprintf(fout,"C4    CA    -0.542500\n");
	fprintf(fout,"C5    CA    -0.542500\n");
	fprintf(fout,"C6    CA    -0.542500\n");
	fprintf(fout,"C7    CA    -0.542500\n");
	fprintf(fout,"C8    CA    -0.542500\n");
	fprintf(fout,"C9    CA    -0.542500\n");
	fprintf(fout,"C10    CA    -0.542500\n");
	fprintf(fout,"C11    CA    -0.542500\n");
	fprintf(fout,"C12    CA    -0.542500\n");
	fprintf(fout,"H1   HC      0.301800\n");
	fprintf(fout,"H2   HC      0.301800\n");
	fprintf(fout,"H3   HC      0.301800\n");
	fprintf(fout,"H4   HC      0.301800\n");
	fprintf(fout,"H5   HA      0.301800\n");
	fprintf(fout,"H6   HA      0.301800\n");
	fprintf(fout,"H7   HA      0.301800\n");
	fprintf(fout,"H8   HA      0.301800\n");
	fprintf(fout,"H9   HA      0.301800\n");
	fprintf(fout,"H10   HA      0.301800\n");
	fprintf(fout,"End\n");
}
/************************************************************/
boolean CreateDefaultPDBTpl()
{
	char* filename = strdup_printf("%s%sDefaultPDBTemplate.tpl",cchemiDirectory(), DIR_SEPARATOR_S);
	FILE* fout = fopen(filename,"w");
	if(!fout)
		return FALSE;
	createTitleResidueTpl(fout);
	createListResidueTpl(fout);
	createAminoResidueTpl(fout);
	createNucleicResidueTpl(fout);
	createAllResidueTpl(fout);
	createFragResidueTpl(fout);
	fclose(fout);
	return TRUE;
}
File: ./cchemilib/src/Utils/Utils.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* Utils.c */
#include <stdlib.h>
#include <ctype.h>
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h> 
#include <assert.h> 
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>
#ifdef ENABLE_MPI
#include <mpi.h>
#endif

#ifdef OS_WIN32
#include <windows.h>
#include <io.h>
#include <direct.h>
#include <io.h>
#define mkdir(p,m) _mkdir(p)
#ifndef S_ISDIR
#define S_ISDIR(mode) ((mode)&_S_IFDIR)
#endif
#else /* OS_WIN32 */
#include <pwd.h>
#include <unistd.h> 
#include <sys/times.h>
#endif /* OS_WIN32 */

#include "../Utils/Types.h"
#include "../Utils/Constants.h"
#include "../Utils/Timer.h"
#include "../Utils/Utils.h"
#include "../Utils/AtomsProp.h"
#include "../Utils/HydrogenBond.h"
#include "../MolecularMechanics/MolecularMechanics.h"
#ifdef ENABLE_CL
#include "../Utils/CLProp.h"
#endif

/********************************************************************************/
char* strdup_vprintf(const char* format, va_list ap)
{
	va_list ap2;
	int size;
	char* buffer;

	va_copy(ap2, ap);
	size = vsnprintf(NULL, 0, format, ap2)+1;
	va_end(ap2);

	buffer = malloc(size+1);
	assert(buffer != NULL);

	vsnprintf(buffer, size, format, ap);
	return buffer;
}
/********************************************************************************/
char* strdup_printf(const char* format, ...)
{
	char* buffer;
	va_list ap;
	va_start(ap, format);
	buffer = strdup_vprintf(format, ap);
	va_end(ap);
	return buffer;
}
/********************************************************************************/
#ifndef OS_WIN32
#define TIMER_TICK      60
static clock_t it;
static struct tms itt;
void timing(double* cpu,double *sys)
{
	it=times(&itt);
	*cpu=(double) itt.tms_utime / (double) TIMER_TICK;
	*sys=(double) itt.tms_stime / (double) TIMER_TICK;
}
#endif
#ifdef OS_WIN32
void addUnitDisk(FILE* file, const char* name)
{
	if(name && strlen(name)>1 && name[1]==':')
		fprintf(file,"%c%c\n", name[0],name[1]);
}
#endif
/********************************************************************************/
char* getTimeStr()
{
	char* str=NULL;
	time_t t;
	struct tm* ts;

	t = time(NULL);
	ts = localtime(&t);
	str = asctime (ts);

	return str;
}
/********************************************************************************/
boolean isABackspace(char *st)
{
        int i;
        for(i=0;i<(int)strlen(st);i++)
        	if(st[i] != ' ' && st[i] !='\n' && st[i] !='\r')
                	return FALSE;
        return TRUE;
}
/********************************************************************************/
void waiting(double tsecond)
{
        TimerType timer;
        double elaps;

        timer_init(timer);
        do{
        	timer_start( timer );
		elaps = exp(1.0);
        	timer_stop(timer);
                elaps = timer_get(timer);
        }while(elaps*1e-6<tsecond);

}
/*************************************************************************************/
void debug(char *fmt,...)
{
#ifdef DEBUG
	va_list ap;
	va_start(ap,fmt);
	vfprintf(stdout, fmt, ap);
	va_end(ap);
#endif

}
/********************************************************************************/
char* getLineChars(char c,int n)
{
	int i;
	char *line = NULL;

	if(n<1) return line;
	line = malloc((n+1)*sizeof(char));
	for(i=0;i<n;i++) line[i] = c;
	line[n] = '\0';

	return line;
	
}
/********************************************************************************/
char* catFile(char* namefile,boolean tabulation)
{
	char *t = NULL;
	char *tsrt = NULL;
	FILE *fd;
	char *dump = NULL;


	t=malloc(BSIZE*sizeof(char));

	fd = fopen(namefile, "r");
	if(fd)
	{
		while(!feof(fd))
  		{
    		if(!fgets(t,BSIZE, fd)) break;
                dump = tsrt;
		if(!tsrt)
		{
			if(tabulation)
				tsrt = strdup_printf("\t%s",t);
			else
				tsrt = strdup_printf("%s",t);
		}
		else
		{
			if(tabulation)
				tsrt = strdup_printf("%s\t%s",tsrt,t);
			else
				tsrt = strdup_printf("%s%s",tsrt,t);
			free(dump);
			dump = NULL;
		}
  		}
 		fclose(fd);
		unlink (namefile);
 	}
	else
	{
		tsrt = NULL;
	}
	free(t);
	t = tsrt;

	return tsrt;
}
/*************************************************************************************/
char *runCommand(char *command)
{
	char *t;
	char *terr = NULL;
	FILE *fd;
	char *temp;
	char *outfile= strdup_printf("%s%stmp%soutfile",cchemiDirectory(), DIR_SEPARATOR_S, DIR_SEPARATOR_S);
	char *errfile= strdup_printf("%s%stmp%serrfile",cchemiDirectory(), DIR_SEPARATOR_S, DIR_SEPARATOR_S);
	char *dump;

	temp = strdup_printf("sh -c '%s >%s 2>%s'",command,outfile,errfile);
	system(temp);

	t=malloc(BSIZE*sizeof(char));

	fd = fopen(errfile, "r");
	if(fd)
	{
  		while(!feof(fd))
  		{
    			if(!fgets(t,BSIZE, fd)) break;
                	dump = terr;
			if(!terr) terr = strdup_printf("%s",t);
			else
			{
				terr = strdup_printf("%s%s",terr,t);
				free(dump);
			}
  		}
 		fclose(fd);
		unlink (errfile);
 	}
 	else terr = NULL;

	fd = fopen(outfile, "r");
	if(fd)
	{
		unlink (outfile);
	}

	free(t);
	free(temp);
	free(outfile);
	free(errfile);

	return terr;
}
/********************************************************************************/
char *getSuffixNameFile(const char* allname)
{
	char* name = strdup(allname);
	int len=strlen(allname);
	int i;
	for(i=len;i>0;i--)
	if(name[i]=='.')
	{
		name[i] = '\0';
		break;
	}
	if(!strstr(name,DIR_SEPARATOR_S))
	{
		char*t=strdup_printf("%s%s%s", getenv("PWD"),DIR_SEPARATOR_S,name);
		free(name);
		name = t;
	}
	return name;
}
/********************************************************************************/
char* getHomeDir()
{
	char *ptr;
	char *copy = NULL;

	ptr = getenv ("HOME");

#ifdef OS_WIN32
	if (ptr == NULL) return strdup("C:\\");
#else
	if (ptr == NULL) return strdup(DIR_SEPARATOR_S);
#endif

/*
	copy = (char *) malloc (strlen (ptr) + 2);
	strcpy (copy, ptr);
	strcat (copy, DIR_SEPARATOR_S);
*/
	copy = strdup_printf("%s%s",ptr,DIR_SEPARATOR_S);

	return copy;
}
/********************************************************************************/
CONST char* cchemiDirectory()
{
	static char *cchemi_dir = NULL;
	char *home_dir;
	char* Version_S = NULL;

	if (cchemi_dir != NULL) return cchemi_dir;

	home_dir = strdup(getHomeDir());

#ifdef OS_WIN32
	Version_S = strdup_printf("%d%d%d",MAJOR_VERSION,MINOR_VERSION,MICRO_VERSION);
	cchemi_dir = strdup_printf("%s%s%s",home_dir,"cchemi",Version_S);
#else
	Version_S = strdup_printf("%d.%d.%d",MAJOR_VERSION,MINOR_VERSION,MICRO_VERSION);
	cchemi_dir = strdup_printf("%s%s%s",home_dir,".cchemi-",Version_S);
#endif

	free(Version_S);
	free(home_dir);
	return cchemi_dir;
}
/*************************************************************************************/
void deleteLastChar(char *str)
{
        str[strlen(str)-1]='\0';
}
/*************************************************************************************/
void createRessourceFile()
{
	saveAtomsProp();
}
/*************************************************************************************/
void addToPath(char* toAdd)
{
#ifdef OS_WIN32
	{
		char t[BSIZE];
		sprintf(t,"%s;%cPATH%c",
		toAdd,
		'%','%');
		if(strlen(t)>1) setenv("PATH",t,TRUE);
	}
#else
	{
		char t[BSIZE];
		sprintf(t,"%s:%cPATH",
		toAdd,
		'$');
		if(strlen(t)>1) setenv("PATH",t,TRUE);
	}
#endif
}
/*************************************************************************************/
void readRessourceFile()
{
	boolean rOK = FALSE;
 
	defineDefaultAtomsProp();
	rOK = readAtomsProp();
	if(!rOK) defineDefaultAtomsProp();
}
/*************************************************************************************/
void uppercase(char *str)
{
	while( *str != '\0')
	{
		if (isalpha((int)*str))
		if (islower((int)*str))
			*str = toupper((int)*str);
		str ++;
	}
}
/*************************************************************************************/
void lowercase(char *str)
{
	while( *str != '\0')
	{
		*str = (char)tolower((int)*str);
	str ++;
	}
}
/*************************************************************************************/
void strfreev (char **str)
{
	int i;
	if (!str) return;

	for (i = 0; str[i] != NULL; i++) free (str[i]);

	free (str);
}
/*************************************************************************************/
char** split(char *str)
{
	char** strsplit= malloc(sizeof(char*));
	int n=0;
	char* t=str;
	char p[BSIZE];
	while(*t!='\n' && *t !='\0')
	{
		if(*t!=' ' && *t !='\t')
		{
			n++;
			strsplit= realloc(strsplit,(n+1)*sizeof(char*));
			sscanf(t,"%s",p);
			strsplit[n-1]= strdup(p);
			while(*t!=' ' && *t !='\t')
			{
				t++;
				if(*t =='\n' || *t =='\0') break;
			}

		}
		else
		{
			while(*t ==' ' || *t == '\t' )
			{
				t++;
				if(*t =='\n' || *t =='\0') break;
			}
		}
	}
	strsplit[n]= NULL;
	return strsplit;
}
/********************************************************************************/
void deleteLastSpaces(char* str)
{
	char *s;

	if(str == NULL)
		return;

	if (!*str)
		return;
	for (s = str + strlen (str) - 1; s >= str && isspace ((unsigned char)*s); s--)
		*s = '\0';
}
/********************************************************************************/
void deleteFirstSpaces(char* str)
{
	char *start;
	int i;
	int lenSpace = 0;

	if(str == NULL)
		return;
	if (!*str)
		return;

	for (start = str; *start && isspace (*start); start++)lenSpace++;

	for(i=0;i<(int)(strlen(str)-lenSpace);i++)
		str[i] = str[i+lenSpace];
	str[strlen(str)-lenSpace] = '\0';
}
/********************************************************************************/
void deleteAllSpaces(char* str)
{
	int i;
	int j;
	boolean Ok = FALSE;

	deleteLastSpaces(str);
	deleteFirstSpaces(str);
	while(!Ok)
	{
		Ok = TRUE;
		for(i=0;i<(int)strlen(str);i++)
		{
			if(isspace(str[i]))
			{
				Ok = FALSE;
				for(j=i;j<(int)strlen(str);j++)
				{
					str[j] = str[j+1];
				}
				break;
			}
		}
	}
}
/**********************************************/
char* getToStr(char* str,char* end)
{
	char* iend = NULL;
	char* res = NULL;
	int len;
	int i;

	if(str == NULL || end == NULL)
		return NULL;

	iend = strstr(str,end);
	if(iend==NULL)
		return strdup(str);
	len = iend - str;
	if(len<1)
		return NULL;

	res = malloc((len+1)*sizeof(char));
	for(i=0;i<len;i++)
		res[i] = str[i];

	res[len] = '\0';
	return res;
	
}
/*************************************************************************************/
static boolean testi(char c)
{
	switch ( c )
	{
	case	'0':
	case	'1':
	case	'2':
	case	'3':
	case	'4':
	case	'5':
	case	'6':
	case	'7':
	case	'8':
	case	'9': return TRUE;
	}
	return FALSE;
}
/*************************************************************************************/
boolean isInteger(CONST char *t)
{
	int i;
	if(!testi(t[0])&& t[0] != '-' ) return FALSE;
	for(i=1;i<strlen(t);i++)
		if(!testi(t[i]) ) return FALSE;
	return TRUE;

}
/*************************************************************************************/
static boolean testascii(char c)
{
	switch ( c )
	{
	case	'0':
	case	'1':
	case	'2':
	case	'3':
	case	'4':
	case	'5':
	case	'6':
	case	'7':
	case	'8':
	case	'9':
	case	'.':
	case	'e':
	case	'E':
	case	'+':
	case	'-':return TRUE;
	}
	return FALSE;
}
/*************************************************************************************/
boolean isFloat(const char *t)
{
	int i;
	for(i=0;i<strlen(t);i++)
		if(!testascii(t[i]) ) return FALSE;
	if(t[0] =='e' || t[0] =='E' ) return FALSE;
	return TRUE;

}
/*************************************************************************************/
void strDeleten(char* str)
{
	char *s;

	if(str == NULL)
		return;

	if (!*str)
		return;
	for (s = str + strlen (str) - 1; s >= str && ((unsigned char)*s)=='\n'; s--)
		*s = '\0';
}
/*************************************************************************************/
char * mystrcasestr(const char *haystack, const char *needle)
{
	char *i, *startn = 0, *j = 0;
	for (i = (char*)haystack; *i; i++)
	{
		if(j)
		{
			if (toupper(*i) == toupper(*j))
			{
				if (!*++j)
				return startn;
			}
			else j = 0;
		}
		else if (toupper(*i) == toupper(*needle))
		{
			j = (char*)needle + 1;
			startn = i;
		}
	}
	return 0;
}
/*************************************************************************************/
boolean readOneReal(FILE* file, char* tag, double*value)
{
	static char *t = NULL; 
	char* TAG = NULL;
	char* pos;
	if(!tag) return FALSE;
	if(!value) return FALSE;
	if(t==NULL) t = malloc(BSIZE*sizeof(char));

	TAG = strdup(tag);
	uppercase(TAG);
	rewind(file);

	while(!feof(file))
  	{
    		if(!fgets(t,BSIZE, file)) break;
		deleteFirstSpaces(t);
		if(t[0]=='#') continue;
		uppercase(t);
		pos = strstr(t,TAG);
		if(!pos) continue;
		if(strstr(pos,"=")) 
		{
			pos = strstr(pos,"=")+1;
		}
		else pos += strlen(TAG)+1;
		free(TAG);
		if(1==sscanf(pos,"%lf",value)) return TRUE;
		return FALSE;
	}
	free(TAG);
	return FALSE;
}
/********************************************************************************/
boolean readOneRealFromAFile(char* namefile, char* tag, double* value)
{
	FILE* file = NULL;
	boolean res;

	if(!namefile) return FALSE;

	file = fopen(namefile, "rb");
	res = readOneReal(file,tag,value);
	fclose(file);
	return res;
}
/*************************************************************************************/
boolean readOneInt(FILE* file, char* tag, int*value)
{
	static char *t = NULL; 
	char* TAG = NULL;
	char* pos;
	if(!tag) return FALSE;
	if(!value) return FALSE;
	if(t==NULL) t = malloc(BSIZE*sizeof(char));

	TAG = strdup(tag);
	uppercase(TAG);
	rewind(file);

	while(!feof(file))
  	{
    		if(!fgets(t,BSIZE, file)) break;
		deleteFirstSpaces(t);
		if(t[0]=='#') continue;
		uppercase(t);
		pos = strstr(t,TAG);
		if(!pos) continue;
		if(strstr(pos,"=")) 
		{
			pos = strstr(pos,"=")+1;
		}
		else pos += strlen(TAG)+1;
		free(TAG);
		if(1==sscanf(pos,"%d",value)) return TRUE;
		return FALSE;
	}
	free(TAG);
	return FALSE;
}
/********************************************************************************/
boolean readOneIntFromAFile(char* namefile, char* tag, int* value)
{
	FILE* file = NULL;
	boolean res;

	if(!namefile) return FALSE;

	file = fopen(namefile, "rb");
	res = readOneInt(file,tag,value);
	fclose(file);
	return res;
}
/*************************************************************************************/
boolean readOneBoolean(FILE* file, char* tag, boolean*value)
{
	static char *t = NULL; 
	char* TAG = NULL;
	char* pos;
	char tmp[100];
	if(!tag) return FALSE;
	if(!value) return FALSE;
	if(t==NULL) t = malloc(BSIZE*sizeof(char));

	TAG = strdup(tag);
	uppercase(TAG);
	rewind(file);

	while(!feof(file))
  	{
    		if(!fgets(t,BSIZE, file)) break;
		deleteFirstSpaces(t);
		if(t[0]=='#') continue;
		uppercase(t);
		pos = strstr(t,TAG);
		if(!pos) continue;
		if(strstr(pos,"=")) 
		{
			pos = strstr(pos,"=")+1;
		}
		else pos += strlen(TAG)+1;
		free(TAG);
		if(1==sscanf(pos,"%s",tmp)) 
		{
			
			if(!strcmp(tmp,"TRUE"))*value = TRUE;
			else *value = FALSE;
			return TRUE;
		}
		return FALSE;
	}
	free(TAG);
	return FALSE;
}
/********************************************************************************/
boolean readOneBooleanFromAFile(char* namefile, char* tag, boolean* value)
{
	FILE* file = NULL;
	boolean res;

	if(!namefile) return FALSE;

	file = fopen(namefile, "rb");
	res = readOneBoolean(file,tag,value);
	fclose(file);
	return res;
}
/********************************************************************************/
boolean readOneStringFromAFile(char* namefile, char* tag, int* value)
{
	FILE* file = NULL;
	boolean res;

	if(!namefile) return FALSE;

	file = fopen(namefile, "rb");
	res = readOneInt(file,tag,value);
	fclose(file);
	return res;
}
/*************************************************************************************/
boolean readOneString(FILE* file, char* tag, char**value)
{
	static char *t = NULL; 
	static char *t2 = NULL; 
	char* TAG = NULL;
	char* pos;
	if(!tag) return FALSE;
	if(!value) return FALSE;
	if(t==NULL) t = malloc(BSIZE*sizeof(char));
	if(t2==NULL) t2 = malloc((BSIZE+2)*sizeof(char));

	TAG = strdup(tag);
	uppercase(TAG);
	rewind(file);

	while(!feof(file))
  	{
    		if(!fgets(t,BSIZE, file)) break;
		deleteFirstSpaces(t);
		if(t[0]=='#') continue;
		sprintf(t2,"%s",t);
		uppercase(t2);
		pos = strstr(t2,TAG);
		if(!pos) continue;
		if(strstr(pos,"=")) 
		{
			pos = strstr(pos,"=")+1;
		}
		else pos += strlen(TAG)+1;
		free(TAG);
		if(strlen(pos)>0) 
		{
			char* p = t+(int)(pos-t2);
			if(*value) free(*value);
			*value = strdup(p);
			strDeleten(*value);
			deleteFirstSpaces(*value);
			deleteLastSpaces(*value);
			return TRUE;
		}
		return FALSE;
	}
	free(TAG);
	return FALSE;
}
/*****************************************************************************/
void setMDOptions(FILE* file, int* updateFrequency, 
double* heatTime, double*equiTime, double* runTime, double* coolTime, 
double* heatTemp,  double*equiTemp, double*runTemp, double*coolTemp, 
double* stepSize, MDIntegratorType* integrator, MDThermostatType* thermostat, double* friction, double* omegaMax, int* Nf, double* collide, double* qNH)
{
	int itmp;
	*updateFrequency = 5;
	readOneInt(file,"updateFrequency",updateFrequency);
	if(*updateFrequency<0) *updateFrequency = 0;

	*heatTime = 1;
	readOneReal(file,"heatTime",heatTime);
	*equiTime = 2;
	readOneReal(file,"equiTime",equiTime);
	*runTime = 10;
	readOneReal(file,"runTime",runTime);
	*coolTime = 10;
	readOneReal(file,"coolTime",coolTime);
	if(*heatTime<0) *heatTime = 1;
	if(*equiTime<0) *equiTime = 1;
	if(*runTime<0) *runTime = 1;
	if(*coolTime<0) *coolTime = 1;

	*heatTemp = 0;
	readOneReal(file,"heatTemp",heatTemp);
	*runTemp = 300;
	readOneReal(file,"runTemp",runTemp);
	*equiTemp = *runTemp;
	*coolTemp = *heatTemp;
	if(*heatTemp<0) *heatTemp = 0;
	if(*equiTemp<0) *runTemp = 300;
	if(*runTemp<0) *runTemp = 300;
	if(*coolTemp<0) *coolTemp = 0;

	*stepSize = 0.5;
	readOneReal(file,"stepSize",stepSize);
	if(*stepSize<0) *stepSize = 1.0;
	if(*stepSize>5) *stepSize = 5.0;


	*integrator = BEEMAN;
	/* *integrator = STOCHASTIC;*/
	if(readOneInt(file,"integrator",&itmp))*integrator = itmp;

	/* *thermostat = ANDERSEN;*/
	*thermostat = BERENDSEN;
	if(readOneInt(file,"thermostat",&itmp))*thermostat = itmp;

	if(*integrator==STOCHASTIC) *thermostat = NONE;
	if(*integrator==QTB) *thermostat = NONE;


	*friction=-1;
	readOneReal(file,"friction",friction);
	*omegaMax=4000;
	readOneReal(file,"omegaMax",omegaMax);
	*Nf=50;
	readOneInt(file,"Nf",Nf);

	*collide = 20;
	readOneReal(file,"collide",collide);
	*qNH = 20;
	readOneReal(file,"qNoseHoover",qNH);
}
/********************************************************************************/
static boolean createUserCChemIDirectory()
{
	if (mkdir (cchemiDirectory(), 0755) < 0) 
	{
		printf(("Installation failed.  Contact system administrator."));
		exit(1);
		return FALSE;
	}
	return TRUE;
}
/*****************************************************************************************************************************************************/
void userInstallVerify()
{
	const char *filename;
	struct stat  stat_buf;

	filename = cchemiDirectory();

	if (stat(filename, &stat_buf) != 0)
	{
		createUserCChemIDirectory();
		saveAtomsProp();
		saveAmberParameters();
		saveHBondsProperties();
		/*system(strdup_printf("ls -l %s",cchemiDirectory()));*/
	}
}
/*****************************************************************************************************************************************************/
void readRessources()
{
	userInstallVerify();
	readAtomsProp();
	loadAmberParameters();
	readHBondsProperties();

}
/*****************************************************************************************************************************************************/
void initSeed(char* inputFileName)
{
	int seed = -1;
	readOneIntFromAFile(inputFileName,"SeedRandom",&seed);
	if(seed>=0) srand((unsigned int)seed);
	else srand((unsigned int)time(NULL));
	printf("seed = %d\n",seed);
}
/*****************************************************************************************************************************************************/
void initAll(int argc, char * argv[])
{
	initSeed(argv[1]);
	defineDefaultAtomsProp();
	initHBondsProperties();
#ifdef ENABLE_CL
	initCLProp();
#endif
#ifdef ENABLE_MPI
	MPI_Init( &argc, &argv );
#endif
}
/*****************************************************************************************************************************************************/
void finalize()
{
#ifdef ENABLE_MPI
	MPI_Finalize();
#endif
}
/*********************************************************************************/
double drandom()
{
	return (rand()/(double)RAND_MAX);
}
/*****************************************************************************************************************************************************/
/*     "normal" generates a random number from a normal Gaussian
     distribution with a mean of zero and a variance of one
*/
double normal()
{
	double v1,v2,rsq;
	double factor;
	static double store;
	static boolean compute = TRUE;

	if (compute)
	{
		do{
         		v1 = 2.0 * drandom()  - 1.0;
         		v2 = 2.0 * drandom () - 1.0;
         		rsq = v1*v1 + v2*v2;
		}while(rsq >= 1.0);
		compute = FALSE;
		factor = sqrt(-2.0*log(rsq)/rsq);
		store = v1 * factor;
		return v2 * factor;
      }
/*     use the second random value computed at the last call */
      else
      {
		compute = TRUE;
		return store;
      }
}
/*****************************************************************************************************************************************************/
Molecule* getFixedNormalModeSampling(char* inputFileName, int nModes, double* frequencies, double** modes, double* reducedMasses, double* quantumNumbers)
{
	Molecule* mol = NULL;
	int i,k,j;
	int nAtoms;
	double* Q = NULL;
	double* dQ = NULL;
	int ntr = 6;

	mol = readMolecule(inputFileName,TRUE);
	if(!mol) return NULL;
	nAtoms = mol->nAtoms;
	if(mol->klass->isLinear(mol)) ntr = 5;

	Q = malloc(nModes*sizeof(double));
	dQ = malloc(nModes*sizeof(double));
	for(i=0;i<nModes;i++) Q[i] = 0.0;
	for(i=0;i<nModes;i++) dQ[i] = 0.0;

	// Q and dQ in AU
	for(i=ntr;i<nModes;i++) 
	{
		double R = (normal()+1)/2.0;
		double fi = fabs(frequencies[i])/AUTOCM1;
		double Ei = (quantumNumbers[i]+0.5)*frequencies[i]/AUTOCM1; 
		double Ai = 0;
		if(Ei<0) Ei = 0;
		if(fi>1e-10) Ai = sqrt(2.0*fabs(Ei))/fi;
		Q[i] = Ai*cos(2*PI*R); 
		dQ[i] = -fi*Ai*sin(2*PI*R); 
	}
	// Q and dQ in AU
	for(i=ntr;i<nModes;i++)  Q[i]  /= sqrt(reducedMasses[i]*AMUTOAU);
	for(i=ntr;i<nModes;i++)  dQ[i] /= sqrt(reducedMasses[i]*AMUTOAU);

	// Q in Ang
	for(i=ntr;i<nModes;i++)  Q[i] *= BOHRTOANG;
	// dQ in Ang/AKMA-time 
	for(i=ntr;i<nModes;i++)  dQ[i] *= BOHRTOANG/(AUTOfs*fsInAKMA);
	
	for(j=0;j<nAtoms;j++) 
	for(k=0;k<3;k++) mol->atoms[j].velocity[k] = 0.0;

	for(i=0;i<nModes;i++) 
	{
		for(j=0;j<nAtoms;j++) 
		for(k=0;k<3;k++) 
		{
			int jd = 3*j+k; 
			 mol->atoms[j].velocity[k] += modes[jd][i]*dQ[i];
			 mol->atoms[j].coordinates[k] += modes[jd][i]*Q[i];
		}
	}
	free(Q);
	free(dQ);
	return mol;
}
/*****************************************************************************************************************************************************/
void printHarmonicVelocities(char* inputFileName, int nModes, double* frequencies, double** modes, double* reducedMasses)
{
	Molecule* mol = NULL;
	int i;
	double T=0;
	double* quantumNumbers = NULL;

	FILE* file = NULL;

	if(nModes<1) return;
	file = fopen(inputFileName,"rb");
	if(!file) return;
	readOneReal(file,"runTemp",&T);
        fclose(file);
	if(T<=0) T = 300;

	quantumNumbers = malloc(nModes*sizeof(double));
	for(i=0;i<nModes;i++) quantumNumbers[i] = 0.0;
	mol = getFixedNormalModeSampling(inputFileName, nModes, frequencies, modes, reducedMasses, quantumNumbers);
	if(!mol) return;

	mol->klass->removeTranslationAndRotation(mol);
	mol->klass->resetConstraints(mol, mol->constraints);
	mol->klass->scaleVelocities(mol, T);
        fprintf(stdout,"========================================================================================================================\n");
        fprintf(stdout,"# Geometry and velocities\n");
        fprintf(stdout,"# Fixed normal modes (ground, n=0) and scaled to T = %f\n",T);
        mol->klass->addGeometry(mol,stdout);
        mol->klass->addVelocities(mol,stdout);
        fprintf(stdout,"========================================================================================================================\n");

	mol->klass->free(mol);
	free(quantumNumbers);
}
/*****************************************************************************************************************************************************/
void addHarmonicVelocities(char* inputFileName, int nModes, double* frequencies, double** modes, double* reducedMasses, double* IRIntensities)
{
	Molecule* mol = NULL;
	FILE* file = NULL;
	int i;
	int dum = -1;
	double T;
	double *quantumNumbers = NULL;
	int ntr = 6;

	if(nModes<1) return;
	file = fopen(inputFileName,"rb");
	readOneInt(file,"HarmonicVelocityModes",&dum);
	readOneReal(file,"runTemp",&T);
	fclose(file);
	if(T<=0) T = 300;
	if(dum>nModes) 
	{
		fprintf(stderr,"Error in HarmonicVelocityModes keyword, the mode number must be <=i %d\n",nModes);
		return;
	}
	if(dum<=0) return;
	quantumNumbers = malloc(nModes*sizeof(double));
	for(i=0;i<nModes;i++) quantumNumbers[i] = 0.0;
	quantumNumbers[dum-1] = 1.0;
	mol = getFixedNormalModeSampling(inputFileName, nModes, frequencies, modes, reducedMasses, quantumNumbers);
	if(!mol) return;
	if(mol->klass->isLinear(mol)) ntr = 5;
	if(dum<=ntr) 
	{
		fprintf(stdout,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		fprintf(stdout,"Warning : The selected mode is a rotation or translation ; # of trans/rot = %d\n",ntr);
		fprintf(stdout,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
	}

	mol->klass->removeTranslationAndRotation(mol);
	mol->klass->resetConstraints(mol, mol->constraints);
	mol->klass->scaleVelocities(mol, T);

	file = fopen(inputFileName,"ab+");
        mol->klass->addVelocities(mol,file);
	printf("Warning ! The velocities  have been added to the %s file\n",inputFileName);
	fclose(file);
	mol->klass->free(mol);
}
/****************************************************************************************************************************/
double* newVectorDouble(int n)
{
	double* v = malloc(n*sizeof(double));
	return v;
}
/****************************************************************************************************************************/
void initVectorDouble(double* v, int n, double val)
{
	int i;
	if(!v) return;
	for(i = 0;i<n; i++)  v[i] = val;
}
/****************************************************************************************************************************/
void freeVectorDouble(double** v)
{
	if(*v) free(*v);
	*v= NULL;
}
/****************************************************************************************************************************/
double** newMatrixDouble(int nrows, int ncolumns)
{
	double** M  = malloc(nrows*sizeof(double*));
	int i;
	for(i = 0;i<nrows; i++) 
		M[i] = malloc(ncolumns*sizeof(double));
	return M;
}
/****************************************************************************************************************************/
void freeMatrixDouble(double*** M, int nrows)
{
	if(*M) 
	{
		int i;
		for(i = 0;i<nrows; i++) 
			if((*M)[i])free((*M)[i]);
	}
	*M= NULL;
}
/****************************************************************************************************************************/
void initMatrixDouble(double** M, int nrows, int ncolumns, double val)
{
	int i,j;
	if(!M) return;
	for(i = 0;i<nrows; i++) 
		for(j = 0;j<ncolumns; j++)  M[i][j]  = val;
}
/****************************************************************************************************************************/
void printMatrixDouble(double** M, int nrows, int ncolumns)
{
	int i,j;
	for(i = 0;i<nrows; i++) 
	{
		for(j = 0;j<ncolumns; j++) 
      			printf("%f ",M[i][j]);
		printf("\n");
	}
}
/****************************************************************************************************************************/
double*** newCubeDouble(int nrows, int ncolumns, int nslices)
{
	double*** C  = malloc(nrows*sizeof(double**));
	int i,j;
	for(i = 0;i<nrows; i++) 
	{
		C[i] = malloc(ncolumns*sizeof(double*));
		for(j = 0;j<ncolumns; j++) 
			C[i][j] = malloc(nslices*sizeof(double));
	}
	return C;
}
/****************************************************************************************************************************/
void printCubeDouble(double*** C, int nrows, int ncolumns, int nslices)
{
	int i,j,k;
	for(i = 0;i<nrows; i++) 
	{
		for(j = 0;j<ncolumns; j++) 
		{
			for(k = 0;k<nslices; k++) 
      				printf("%f ",C[i][j][k]);
			printf("\n");
		}
		printf("\n");
	}
}
/****************************************************************************************************************************/
void initCubeDouble(double*** C, int nrows, int ncolumns, int nslices, double val)
{
	int i,j,k;
	if(!C) return;
	for(i = 0;i<nrows; i++) 
		for(j = 0;j<ncolumns; j++) 
			for(k = 0;k<nslices; k++) C[i][j][k] = val;
}
/****************************************************************************************************************************/
void freeCubeDouble(double**** C, int nrows, int ncolumns)
{
	if(*C) 
	{
		int i,j;
		for(i = 0;i<nrows; i++) 
		{
			if((*C)[i])
			for(j = 0;j<ncolumns; j++) 
				if((*C)[i][j]) free((*C)[i][j]);
	
			if((*C)[i])free((*C)[i]);
		}
	}
	*C= NULL;
}
/****************************************************************************************************************************/
int* newVectorInt(int n)
{
	int* v = malloc(n*sizeof(int));
	return v;
}
/****************************************************************************************************************************/
void freeVectorInt(int** v)
{
	if(*v) free(*v);
	*v= NULL;
}
/****************************************************************************************************************************/
int** newMatrixInt(int nrows, int ncolumns)
{
	int** M  = malloc(nrows*sizeof(int*));
	int i;
	for(i = 0;i<nrows; i++) 
		M[i] = malloc(ncolumns*sizeof(int));
	return M;
}
/****************************************************************************************************************************/
void freeMatrixInt(int*** M, int nrows)
{
	if(*M) 
	{
		int i;
		for(i = 0;i<nrows; i++) 
			if((*M)[i])free((*M)[i]);
	}
	*M= NULL;
}
/****************************************************************************************************************************/
int*** newCubeInt(int nrows, int ncolumns, int nslices)
{
	int*** C  = malloc(nrows*sizeof(int**));
	int i,j;
	for(i = 0;i<nrows; i++) 
	{
		C[i] = malloc(ncolumns*sizeof(int*));
		for(j = 0;j<ncolumns; j++) 
			C[i][j] = malloc(nslices*sizeof(int));
	}
	return C;
}
/****************************************************************************************************************************/
void freeCubeInt(int**** C, int nrows, int ncolumns)
{
	if(*C) 
	{
		int i,j;
		for(i = 0;i<nrows; i++) 
		{
			if((*C)[i])
			for(j = 0;j<ncolumns; j++) 
				if((*C)[i][j]) free((*C)[i][j]);
	
			if((*C)[i])free((*C)[i]);
		}
	}
	*C= NULL;
}
/****************************************************************************************************************************/
void initMatrixInt(int** M, int nrows, int ncolumns, int val)
{
	int i,j;
	if(!M) return;
	for(i = 0;i<nrows; i++) 
		for(j = 0;j<ncolumns; j++)  M[i][j]  = val;
}
/****************************************************************************************************************************/
void initCubeInt(int*** C, int nrows, int ncolumns, int nslices, int val)
{
	int i,j,k;
	if(!C) return;
	for(i = 0;i<nrows; i++) 
		for(j = 0;j<ncolumns; j++) 
			for(k = 0;k<nslices; k++) C[i][j][k] = val;
}
/****************************************************************************************************************************/
int**** newQuarticInt(int nrows, int ncolumns, int nslices, int nl)
{
	int**** C  = NULL;
	int i,j,k;
	if(nrows<1 || ncolumns<1 || nslices<1) return C;
	C  = malloc(nrows*sizeof(int***));
	for(i = 0;i<nrows; i++) 
	{
		C[i] = malloc(ncolumns*sizeof(int**));
		for(j = 0;j<ncolumns; j++) 
		{
			C[i][j] = malloc(nslices*sizeof(int*));
			for(k = 0;k<nslices; k++) 
				C[i][j][k] = malloc(nl*sizeof(int));
		}
	}
	return C;
}
/****************************************************************************************************************************/
void initQuarticInt(int**** C, int nrows, int ncolumns, int nslices, int nl, int val)
{
	int i,j,k,l;
	if(!C) return;
	for(i = 0;i<nrows; i++) 
		for(j = 0;j<ncolumns; j++) 
			for(k = 0;k<nslices; k++) 
				for(l = 0;l<nl; l++) 
					C[i][j][k][l] = val;
}
/****************************************************************************************************************************/
void freeQuarticInt(int***** C, int nrows, int ncolumns, int nslices)
{
	if(*C) 
	{
		int i,j,k;
		for(i = 0;i<nrows; i++) 
		{
			if((*C)[i])
			for(j = 0;j<ncolumns; j++) 
			{
				if((*C)[i][j])
				{
				for(k = 0;k<nslices; k++) 
					if((*C)[i][j][k]) free((*C)[i][j][k]);
				if((*C)[i][j]) free((*C)[i][j]);
				}
			}
			if((*C)[i])free((*C)[i]);
		}
		free(*C);
	}
	*C= NULL;
}
/****************************************************************************************************************************/
void printVectorDoubleCutOff(double* C, int n, double cutoff)
{
        int i;
        if(!C) return;
        for(i=0;i<n;i++) if(fabs(C[i])>=cutoff) printf("%d %20.10f\n",i+1,C[i]);
}
/****************************************************************************************************************************/
void printMatrixDoubleCutOff(double** M, int nrows, int ncolumns, double cutoff)
{
	int i,j;
	for(i = 0;i<nrows; i++) 
	{
		for(j = 0;j<ncolumns; j++) 
		if(fabs(M[i][j])>=cutoff)
      			printf("%d %d %20.10f\n",i+1,j+1,M[i][j]);
	}
}
/****************************************************************************************************************************/
void printCubeDoubleCutOff(double*** C, int nrows, int ncolumns, int nslices, double cutoff)
{
	int i,j,k;
	for(i = 0;i<nrows; i++) 
	{
		for(j = 0;j<ncolumns; j++) 
		{
			for(k = 0;k<nslices; k++) 
			if(fabs(C[i][j][k])>=cutoff)
      				printf("%d %d %d %20.10f\n",i+1,j+1,k+1,C[i][j][k]);
		}
	}
}
/****************************************************************************************************************************/
void printQuarticDouble(double**** C, int nrows, int ncolumns, int nslices, int nl)
{
	int i,j,k,l;
	for(i = 0;i<nrows; i++) 
	{
		for(j = 0;j<ncolumns; j++) 
		{
			for(k = 0;k<nslices; k++) 
			{
				for(l = 0;l<nl; l++) 
      					printf("%f ",C[i][j][k][l]);
				printf("\n");
			}
		}
		printf("\n");
	}
}
/****************************************************************************************************************************/
void printQuarticDoubleCutOff(double**** C, int nrows, int ncolumns, int nslices, int nl, double cutoff)
{
	int i,j,k,l;
	for(i = 0;i<nrows; i++) 
	{
		for(j = 0;j<ncolumns; j++) 
		{
			for(k = 0;k<nslices; k++) 
			{
				for(l = 0;l<nl; l++) 
				if(fabs(C[i][j][k][l])>=cutoff)
      					printf("%d %d %d %d %20.10f\n",i+1,j+1,k+1,l+1,C[i][j][k][l]);
			}
		}
	}
}
/****************************************************************************************************************************/
/**********************************************************************/
void getRandVect(double len, double V[])
{
	double l = 0;
	int j;
	for(j=0;j<3;j++)
	{
		V [j] = drandom();
		l += V[j]*V[j];
	}
	
	if(l<=0) return;
	l = sqrt(l);
	for(j=0;j<3;j++)
		V [j] *= len/l;
}
/**********************************************************************/
double erfinv( double y )
{
	static double a[] = {0,  0.886226899, -1.645349621,  0.914624893, -0.140543331 };
	static double b[] = {0, -2.118377725,  1.442710462, -0.329097515,  0.012229801 };
	static double c[] = {0, -1.970840454, -1.624906493,  3.429567803,  1.641345311 };
	static double d[] = {0,  3.543889200,  1.637067800 };
	double x=1e100, z;
  
	if ( y < -1. ) return x;
	if ( y >  1. ) return x;
	if ( y >= -.7 )
	{
		if ( y <= .7 )
		{
			z = y*y;
			x = y * (((a[4]*z+a[3])*z+a[2])*z+a[1]) /
			  ((((b[4]*z+b[3])*z+b[2])*z+b[1])*z+1);
		}
		else if ( y < 1 )
		{
			z = sqrt(-log((1-y)/2));
			x = (((c[4]*z+c[3])*z+c[2])*z+c[1]) / ((d[2]*z+d[1])*z+1);
		}
	}
	else
	{
  		z = sqrt(-log((1+y)/2));
  		x = -(((c[4]*z+c[3])*z+c[2])*z+c[1]) / ((d[2]*z+d[1])*z+1);
	}
	return x;
}
/**********************************************************************/
double	maxwel(double mass, double temperature)
{
	/* 
	 *  physical constants in SI units
	 *   ------------------------------
	 *      Kb = 1.380662 E-23 J/K
	 *      Na = 6.022045 E23  1/mol
	 *      e = 1.6021892 E-19 C
	 *      eps = 8.85418782 E-12 F/m
	 *                       
	 *      1 Kcal = 4184.0 J
	 *      1 amu = 1.6605655 E-27 Kg
	 *      1 A = 1.0 E-10 m
	 *                                       
	 *       Internally, AKMA units are used:
	 *       KBOLTZ = Na *Kb  / 1 Kcal
	 */
	/* double Kb = 6.022045e23*1.380662e-23/4184.0;*/
	double beta = sqrt(mass / (2.0*Kb*temperature));
	double rho;
	double xs, ys, zs;
	rho = drandom();
	xs = erfinv(rho)/beta;
	rho = drandom();
	ys = erfinv(rho)/beta;
	rho = drandom();
	zs = erfinv(rho)/beta;

	return sqrt(xs*xs+ys*ys+zs*zs);

}
/**************************************************/
boolean InverseTensor(double mat[3][3],double invmat[3][3])
{
	double t4,t6,t8,t10,t12,t14,t17;
	double d = 0;
	double precision = 1e-12;

	t4 = mat[0][0]*mat[1][1];     
 	t6 = mat[0][0]*mat[1][2];
      	t8 = mat[0][1]*mat[1][0];
      	t10 = mat[0][2]*mat[1][0];
      	t12 = mat[0][1]*mat[2][0];
      	t14 = mat[0][2]*mat[2][0];
      	d =(t4*mat[2][2]-t6*mat[2][1]-t8*mat[2][2]+t10*mat[2][1]+t12*mat[1][2]-t14*mat[1][1]);
	if(fabs(d)<precision) 
	{
      		invmat[0][0] = 0;
      		invmat[0][1] = 0;
      		invmat[0][2] = 0;
      		invmat[1][0] = 0;
      		invmat[1][1] = 0;
      		invmat[1][2] = 0;
      		invmat[2][0] = 0;
      		invmat[2][1] = 0;
      		invmat[2][2] = 0;
		return FALSE;
	}
      	t17 = 1/d;
      	invmat[0][0] = (mat[1][1]*mat[2][2]-mat[1][2]*mat[2][1])*t17;
      	invmat[0][1] = -(mat[0][1]*mat[2][2]-mat[0][2]*mat[2][1])*t17;
      	invmat[0][2] = -(-mat[0][1]*mat[1][2]+mat[0][2]*mat[1][1])*t17;
      	invmat[1][0] = -(mat[1][0]*mat[2][2]-mat[1][2]*mat[2][0])*t17;
      	invmat[1][1] = (mat[0][0]*mat[2][2]-t14)*t17;
      	invmat[1][2] = -(t6-t10)*t17;
      	invmat[2][0] = -(-mat[1][0]*mat[2][1]+mat[1][1]*mat[2][0])*t17;
      	invmat[2][1] = -(mat[0][0]*mat[2][1]-t12)*t17;
      	invmat[2][2] = (t4-t8)*t17;

	return TRUE;
}
/**************************************************/
void computeAngularVelocitiesForALinearMolecule(double* R1, double* R2, double  inert[3][3], double*L, double* vAng)
{
	double rmol[3];/* normal vector parallel to the molecule */
	double ra[3]; /* first vector perpendiculaire to the molecule */
	double rb[3]; /* second vector perpendiculaire to the molecule */
	double dum[3];
	double precision = 1e-12;
	int j,k;
	double d;
	double a00,a01,a11;
	double b0,b1;
	double w0,w1;

	for(j=0;j<3;j++) vAng[j] = 0;

	for(j=0;j<3;j++) rmol[j] = R2[j]- R1[j];

	d = 0;
	for(j=0;j<3;j++) d+=rmol[j]*rmol[j];
	if(d<precision) return;
	d = 1/sqrt(d);
	for(j=0;j<3;j++) rmol[j] *= d;

/*      find two orthogonal vectors to molecule coordinate frame */
	k = 0;
	for(j=1;j<3;j++) if(fabs(rmol[k])>fabs(rmol[j])) k = j;

	for(j=0;j<3;j++) ra[j] = -rmol[k] * rmol[j];
	ra[k] += 1.0;

	d = 0;
	for(j=0;j<3;j++) d+=ra[j]*ra[j];
	if(d<precision) return;
	d = 1/sqrt(d);
	for(j=0;j<3;j++) ra[j] *= d;

	for(j=0;j<3;j++) rb[j] = ra[(j+1)%3]*rmol[(j+2)%3]-rmol[(j+1)%3]*ra[(j+2)%3];

/*      solve the 2 linear system for angular velocity */
	for(k=0;k<3;k++) dum[k] = 0;
	for(k=0;k<3;k++) for(j=0;j<3;j++) dum[k] += inert[j][k]*ra[j];

	a00 = 0;
	for(j=0;j<3;j++) a00 +=ra[j]*dum[j];

	for(k=0;k<3;k++) dum[k] = 0;
	for(k=0;k<3;k++) for(j=0;j<3;j++) dum[k] += inert[j][k]*rb[j];

	a01 = 0;
	for(j=0;j<3;j++) a01 += ra[j]*dum[j];

	a11 = 0;
	for(j=0;j<3;j++) a11 += rb[j]*dum[j];

	b0 = 0;
	for(j=0;j<3;j++) b0 += ra[j]*L[j];

	b1 = 0;
	for(j=0;j<3;j++) b1 += rb[j]*L[j];

	w0 = (a01*b1-a11*b0) / (a01*a01-a00*a11);
	w1 = (b1-a01*w0) / a11;

	for(j=0;j<3;j++) vAng[j] = w0*ra[j] + w1*rb[j];
}
/*************************************************************************************/
boolean readVectorReal(FILE* file, char* tag, int n, double*values)
{
	static char *t = NULL; 
	char* TAG = NULL;
	char* pos = NULL;
	int i;
	int ii;
	double v;
	if(!tag) return FALSE;
	if(!values) return FALSE;
	if(t==NULL) t = malloc(BSIZE*sizeof(char));

	TAG = strdup(tag);
	uppercase(TAG);
	rewind(file);

	while(!feof(file))
  	{
    		if(!fgets(t,BSIZE, file)) break;
		deleteFirstSpaces(t);
		if(t[0]=='#') continue;
		uppercase(t);
		pos = strstr(t,TAG);
		if(!pos) continue;
		break;
	}
	if(!pos) 
	{
		free(TAG);
		return FALSE;
	}
	for(i=0;i<n;i++)
	{
    		if(!fgets(t,BSIZE, file)) break;
		if(2==sscanf(t,"%d %lf",&ii, &v)) 
		{
			if(ii<=n && ii>0) values[ii-1] = v;
			else
			{
				fprintf(stderr,"Erreur dans les donnees de %s: verifie les indices\n",tag);
				exit(1);
			}
		}
		else break;
	}
	free(TAG);
	if(i<=0) return FALSE;
	return TRUE;
}
/********************************************************************************/
int readEnergyAndDipoleFromGabeditFile(char* fileName, double energy[], double dipole[])
{
	FILE* file = NULL;
	static char *t = NULL; 
	int n;
	int i;
	char* pos;
	int nGeoms = 0;
	int nLabels = 0;
	int iEnergy, iDipole;

	if(!fileName) 
	{
		printf("Sorry I cannot read energy and dipole fileName = NULL\n");
		exit(1);
	}
	if(t==NULL) t = malloc(BSIZE*sizeof(char));
	file = fopen(fileName,"rb");
	if(!file)
	{
		printf("Sorry I cannot open %s file\n",fileName);
		exit(1);
	}
	rewind(file);
	iEnergy = -1;
	iDipole = -1;
	while(!feof(file))
  	{
    		if(!fgets(t,BSIZE, file)) break;
		deleteFirstSpaces(t);
		if(t[0]=='#') continue;
		uppercase(t);
		pos = strstr(t,"[GEOMS]");
		if(pos)
		{ 
			while(!feof(file))
			{
    				if(!fgets(t,BSIZE, file)) break;
				deleteFirstSpaces(t);
				if(t[0]=='#') continue;
				break;
			}
			if(2==sscanf(t,"%d%d",&nGeoms,&nLabels))
			{

				for(i=0; i<nLabels; i++)
				{
    					if(!fgets(t,BSIZE, file)) break;
					uppercase(t);
					if(strstr(t,"ENERGY") && strstr(t,"KCAL")) iEnergy = i;
					if(strstr(t,"DIPOLE")) iDipole = i;
				}
			}
			break;
		}
	}
	/* I read the first geometry */
	n = 0;
	for(i=0; i<nLabels; i++)
	{
    		if(!fgets(t,BSIZE, file)) break;
		if(i==iEnergy) { n++; sscanf(t,"%lf",&energy[0]);}
		if(i==iDipole) { n++; sscanf(t,"%lf %lf %lf",&dipole[0], &dipole[1],&dipole[2]);}
	}
	fclose(file);
	return n;
}
/********************************************************************************/
double**** newQuarticDouble(int nrows, int ncolumns, int nslices, int nl)
{
	double**** C  = NULL;
	int i,j,k;
	if(nrows<1 || ncolumns<1 || nslices<1) return C;
	C  = malloc(nrows*sizeof(double***));
	for(i = 0;i<nrows; i++) 
	{
		C[i] = malloc(ncolumns*sizeof(double**));
		for(j = 0;j<ncolumns; j++) 
		{
			C[i][j] = malloc(nslices*sizeof(double*));
			for(k = 0;k<nslices; k++) C[i][j][k] = malloc(nl*sizeof(double));
		}
	}
	return C;
}
/****************************************************************************************************************************/
void initQuarticDouble(double**** C, int nrows, int ncolumns, int nslices, int nl, double val)
{
	int i,j,k,l;
	if(!C) return;
	for(i = 0;i<nrows; i++) 
		for(j = 0;j<ncolumns; j++) 
			for(k = 0;k<nslices; k++) 
				for(l = 0;l<nl; l++) 
					C[i][j][k][l] = val;
}
/****************************************************************************************************************************/
void freeQuarticDouble(double***** C, int nrows, int ncolumns, int nslices)
{
	if(*C) 
	{
		int i,j,k;
		for(i = 0;i<nrows; i++) 
		{
			if((*C)[i])
			for(j = 0;j<ncolumns; j++) 
			{
				if((*C)[i][j])
				{
				for(k = 0;k<nslices; k++) 
					if((*C)[i][j][k]) free((*C)[i][j][k]);
				if((*C)[i][j]) free((*C)[i][j]);
				}
			}
			if((*C)[i])free((*C)[i]);
		}
		free(*C);
	}
	*C= NULL;
}
/********************************************************************************/
double***** newQuinticDouble(int nrows, int ncolumns, int nslices, int nl, int n5)
{
	double***** C  = NULL;
	int i,j,k,l;
	if(nrows<1 || ncolumns<1 || nslices<1 || nl<1 || n5<1) return C;
	C  = malloc(nrows*sizeof(double****));
	for(i = 0;i<nrows; i++) 
	{
		C[i] = malloc(ncolumns*sizeof(double***));
		for(j = 0;j<ncolumns; j++) 
		{
			C[i][j] = malloc(nslices*sizeof(double**));
			for(k = 0;k<nslices; k++) 
			{
				C[i][j][k] = malloc(nl*sizeof(double*));
				for(l = 0;l<nl; l++) 
					C[i][j][k][l] = malloc(n5*sizeof(double));
			}
		}
	}
	return C;
}
/****************************************************************************************************************************/
void initQuinticDouble(double***** C, int nrows, int ncolumns, int nslices, int nl, int n5, double val)
{
	int i,j,k,l,n;
	if(!C) return;
	for(i = 0;i<nrows; i++) 
		for(j = 0;j<ncolumns; j++) 
			for(k = 0;k<nslices; k++) 
				for(l = 0;l<nl; l++) 
				for(n = 0;n<n5; n++) 
					C[i][j][k][l][n] = val;
}
/****************************************************************************************************************************/
void freeQuinticDouble(double****** C, int nrows, int ncolumns, int nslices, int nl)
{
	if(*C) 
	{
		int i,j,k,l;
		for(i = 0;i<nrows; i++) 
		{
			if((*C)[i])
			for(j = 0;j<ncolumns; j++) 
			{
				if((*C)[i][j])
				{
					for(k = 0;k<nslices; k++) 
						if((*C)[i][j][k]) 
						{
							for(l = 0;l<nl; l++) 
								if((*C)[i][j][k][l]) free((*C)[i][j][k][l]);
							free((*C)[i][j][k]);
						}
					if((*C)[i][j]) free((*C)[i][j]);
				}
			}
			if((*C)[i])free((*C)[i]);
		}
		free(*C);
	}
	*C= NULL;
}
/****************************************************************************************************************************/
void symmetrizeMatrixDouble(double** M, int nrows, int ncolumns, double cutOff)
{
	int i,j;
	double x,y;
	if(!M) return;
	for(i = 0;i<nrows; i++) 
		for(j = 0;j<i; j++)  
		{
			if(j>ncolumns-1) continue;
			x =  M[i][j];
			y =  M[j][i];
			if(fabs(x)>cutOff && fabs(y)>cutOff)  M[i][j] = M[j][i] = (x+y)/2;
			else if(fabs(x)>cutOff)  M[i][j] = M[j][i] = x;
			else if(fabs(y)>cutOff)  M[i][j] = M[j][i] = y;
			else M[i][j]  = 0.0;
		}
}
/****************************************************************************************************************************/
static void symmetrizeCubeDoubleIJ(double*** C, int nrows, int ncolumns,  int nslices, double cutOff)
{
	int i,j,k;
	double x,y;
	for(i = 0;i<nrows; i++) 
		for(j = 0;j<i; j++)  
		{
			if(j>ncolumns-1) continue;
			for(k = 0;k<nslices; k++)  
			{
				x =  C[i][j][k];
				y =  C[j][i][k];
				if(fabs(x)>cutOff && fabs(y)>cutOff)  C[i][j][k] = C[j][i][k] = (x+y)/2;
				else if(fabs(x)>cutOff)  C[i][j][k] = C[j][i][k] = x;
				else if(fabs(y)>cutOff)  C[i][j][k] = C[j][i][k] = y;
				else C[i][j][k]  = 0.0;
			}
		}
}
/****************************************************************************************************************************/
static void symmetrizeCubeDoubleJK(double*** C, int nrows, int ncolumns,  int nslices, double cutOff)
{
	int i;
	for(i=0;i<nrows;i++) symmetrizeMatrixDouble(C[i], ncolumns, nslices,  cutOff);
}
/****************************************************************************************************************************/
void symmetrizeCubeDouble(double*** C, int nrows, int ncolumns,  int nslices, double cutOff)
{
	symmetrizeCubeDoubleIJ(C, nrows, ncolumns,  nslices, cutOff);
	symmetrizeCubeDoubleJK(C, nrows, ncolumns,  nslices, cutOff);
	symmetrizeCubeDoubleIJ(C, nrows, ncolumns,  nslices, cutOff);
}
/****************************************************************************************************************************/
/****************************************************************************************************************************/
static void symmetrizeQuarticDoubleIJ(double**** Q, int nrows, int ncolumns,  int nslices, int nq, double cutOff)
{
	int i,j,k,l;
	double x,y;
	for(i = 0;i<nrows; i++) 
		for(j = 0;j<i; j++)  
		{
			if(j>ncolumns-1) continue;
			for(k = 0;k<nslices; k++)  
			for(l = 0;l<nq; l++)  
			{
				x =  Q[i][j][k][l];
				y =  Q[j][i][k][l];
				if(fabs(x)>cutOff && fabs(y)>cutOff)  Q[i][j][k][l] = Q[j][i][k][l] = (x+y)/2;
				else if(fabs(x)>cutOff)  Q[i][j][k][l] = Q[j][i][k][l] = x;
				else if(fabs(y)>cutOff)  Q[i][j][k][l] = Q[j][i][k][l] = y;
				else Q[i][j][k][l]  = 0.0;
			}
		}
}
/****************************************************************************************************************************/
static void symmetrizeQuarticDoubleJKL(double**** Q, int nrows, int ncolumns,  int nslices, int nq, double cutOff)
{
	int i;
	for(i=0;i<nrows;i++) symmetrizeCubeDouble(Q[i], ncolumns, nslices, nq,  cutOff);
}
/****************************************************************************************************************************/
void symmetrizeQuarticDouble(double**** Q, int nrows, int ncolumns,  int nslices, int nq, double cutOff)
{
	symmetrizeQuarticDoubleIJ(Q, nrows, ncolumns,  nslices, nq, cutOff);
	symmetrizeQuarticDoubleJKL(Q, nrows, ncolumns,  nslices, nq, cutOff);
	symmetrizeQuarticDoubleIJ(Q, nrows, ncolumns,  nslices, nq, cutOff);
}
/****************************************************************************************************************************/
boolean goToStr(FILE* file, char* tag)
{
        static char *t = NULL;
        char* TAG = NULL;
        char* pos = NULL;
        if(!tag) return FALSE;
        if(t==NULL) t = malloc(BSIZE*sizeof(char));

        TAG = strdup(tag);
        uppercase(TAG);
        rewind(file);

        while(!feof(file))
        {
                if(!fgets(t,BSIZE, file)) break;
                deleteFirstSpaces(t);
                if(t[0]=='#') continue;
                uppercase(t);
                pos = strstr(t,TAG);
                if(!pos) continue;
                break;
        }
        return pos != NULL;
}

/********************************************************************************/
void computeAndPrintHarmonicVelocitiesCoordinates(Molecule* mol, char* inputFileName, boolean addToInputFile, boolean changeGeom)
{
	int numMode = -1;
	double T = -1;
	FILE* file = fopen(inputFileName,"rb");
	if(!file) return;
	readOneInt(file,"HarmonicVelocityModes",&numMode);
	readOneReal(file,"runTemp",&T);
	fclose(file);
	if(T<=0) T = 300;
	if(numMode>mol->vibration.nModes) 
	{
		fprintf(stderr,"Error in HarmonicVelocityModes keyword, the mode number must be <=i %d\n",mol->vibration.nModes);
		return;
	}
	mol->klass->computeHarmonicVelocitiesCoordinates(mol, T, numMode, changeGeom);
	file = stdout;
	if(addToInputFile) file = fopen(inputFileName,"ab+");
        fprintf(file,"#========================================================================================================================\n");
	if(numMode<1) fprintf(file,"# Fixed normal modes (n=1 for mode %d, n=0 for all other modes) and scaled to T = %f\n",numMode,T);
	else fprintf(file,"# Fixed normal modes (ground, n=0) and scaled to T = %f\n",T);
	if(changeGeom)
	{  
        	fprintf(stdout,"# Geometry and velocities\n");
        	mol->klass->addGeometry(mol,file);
	}
        fprintf(file,"# Harmonic Velocities\n");
        mol->klass->addVelocities(mol,file);
        fprintf(file,"#========================================================================================================================\n");
	if(addToInputFile) fclose(file);
}
/********************************************************************************/
void computeFrequenciesFromFilesDlg(char* inputFileName, boolean oneStep)
{
	Molecule* mol = readMolecule(inputFileName,TRUE);
	double dx = 1e-3;
	char* fileNameOut = strdup_printf("%sFreq.gab",getSuffixNameFile(inputFileName));
	 FILE* file = fopen(inputFileName,"rb");

	readOneReal(file,"dx",&dx);
	fclose(file);

	if(oneStep) mol->klass->computeFrequenciesOneStepFromFiles(mol, inputFileName,  dx);
	else mol->klass->computeFrequenciesFromFiles(mol, inputFileName,  dx);

	printf("Frequencies and modes in the %s file\n",fileNameOut);
	mol->klass->save(mol, fileNameOut);
	computeAndPrintHarmonicVelocitiesCoordinates(mol, inputFileName, FALSE, TRUE);
	computeAndPrintHarmonicVelocitiesCoordinates(mol, inputFileName, TRUE, FALSE);

	mol->klass->free(mol);
	free(fileNameOut);
}
/********************************************************************************/
void computeFrequenciesFromGradFilesDlg(char* inputFileName, boolean oneStep)
{
	Molecule* mol = readMolecule(inputFileName,TRUE);
	double dx = 1e-3;
	char* fileNameOut = strdup_printf("%sFreq.gab",getSuffixNameFile(inputFileName));
	 FILE* file = fopen(inputFileName,"rb");

	readOneReal(file,"dx",&dx);
	fclose(file);

	if(oneStep) mol->klass->computeFrequenciesOneStepFromGradFiles(mol, inputFileName,  dx);
	else mol->klass->computeFrequenciesFromGradFiles(mol, inputFileName,  dx);

	printf("Frequencies and modes in the %s file\n",fileNameOut);
	mol->klass->save(mol, fileNameOut);
	computeAndPrintHarmonicVelocitiesCoordinates(mol, inputFileName, FALSE, TRUE);
	computeAndPrintHarmonicVelocitiesCoordinates(mol, inputFileName, TRUE, FALSE);
	mol->klass->free(mol);
	free(fileNameOut);
}
/********************************************************************************/
void generateCChemIFilesForFrequenciesDlg(char* inputFileName, boolean oneStep)
{
	Molecule* mol = readMolecule(inputFileName,TRUE);
	double dx = 1e-3;
	char* fileNameOut = strdup_printf("%sFreq.gab",getSuffixNameFile(inputFileName));
	 FILE* file = fopen(inputFileName,"rb");

	readOneReal(file,"dx",&dx);
	fclose(file);

	if(oneStep) mol->klass->generateCChemIFilesOneStepForFrequencies(mol, inputFileName,  dx);
	else mol->klass->generateCChemIFilesForFrequencies(mol, inputFileName,  dx);

	mol->klass->free(mol);
	free(fileNameOut);
}
/********************************************************************************/
void generateCChemIGradFilesForFrequenciesDlg(char* inputFileName, boolean oneStep)
{
	Molecule* mol = readMolecule(inputFileName,TRUE);
	double dx = 1e-3;
	char* fileNameOut = strdup_printf("%sFreq.gab",getSuffixNameFile(inputFileName));
	 FILE* file = fopen(inputFileName,"rb");

	readOneReal(file,"dx",&dx);
	fclose(file);

	if(oneStep) mol->klass->generateCChemIGradFilesOneStepForFrequencies(mol, inputFileName,  dx);
	else mol->klass->generateCChemIGradFilesForFrequencies(mol, inputFileName,  dx);

	mol->klass->free(mol);
	free(fileNameOut);
}
/**********************************************************************************************************************************/
int get_num_orbitals_from_aux_mopac_file(FILE* file, char* blockName,  int* begin, int* end)
{
	char t[BSIZE];
	*begin = 0;
	*end = 0;
	 while(!feof(file))
	 {
		if(!fgets(t,BSIZE,file))break;
		if(strstr( t, blockName))
		{
			char* pdest = strstr( t, "=")+1;
			int i = sscanf(pdest,"%d %d",begin,end);
			return i;
		}
	 }
	 return 0;
}
/**********************************************************************************************************************************/
char** get_one_block_from_aux_mopac_file(FILE* file, char* blockName,  int* n)
{
	int nElements = 0;
	char** elements = NULL;
	char t[BSIZE];
	 while(!feof(file))
	 {
		if(!fgets(t,BSIZE,file))break;
		if(strstr( t, blockName))
		{
			char* pdest = strstr( t, "[")+1;
			int i;
			nElements = atoi(pdest);
			if(nElements<1) break;
			else
			{ 
				long int geomposok = ftell(file);
				if(!fgets(t,BSIZE,file))break;
				if(!strstr(t,"# ")) fseek(file, geomposok, SEEK_SET);
			}

			elements = malloc(nElements*sizeof(char*));
			for(i=0;i<nElements;i++)
			{
				int k;
				elements[i] = malloc(100*sizeof(char));
				k = fscanf(file,"%s",elements[i]);
				if(k<1 || strstr(elements[i],"["))
				{
					if(elements)
					{
						for(i=0;i<nElements;i++)
							if(elements[i]) free(elements[i]);
						free(elements);
						elements = NULL;
					}
					break;
				}
				else
				{
					if(!strstr(blockName,"ATOM_EL"))
					for(k=0;k<strlen(elements[i]);k++)
					{
						if(elements[i][k]=='D') elements[i][k]='e';
						if(elements[i][k]=='d') elements[i][k]='e';
					}
				}
			}
			break;
		}
	 }
	 *n = nElements;
	 return elements;
}
/**********************************************************************************************************************************/
char** free_one_string_table(char** table, int n)
{
	if(table)
	{
		int i;
		for(i=0;i<n;i++)
			if(table[i]) free(table[i]);
		free(table);
	}
	return NULL;
}
/********************************************************************************/
void get_dipole_from_gamess_output_file(FILE* file, double dipole[])
{
  	char *t = malloc(BSIZE*sizeof(char));
  	char* t1;

	dipole[0] = dipole[1] = dipole[2] = 0.0;

  	while(!feof(file) )
	{
    		t1 = NULL;
    		if(!fgets(t,BSIZE,file))break;
    		t1 = strstr( t, "ELECTROSTATIC MOMENTS");
		if(t1)
		{
  			while(!feof(file) )
			{
    				if(!fgets(t,BSIZE,file))break;
    				t1 = strstr( t, "DEBYE");
				if(t1)
				{
    					if(!fgets(t,BSIZE,file))break;
					sscanf(t,"%lf %lf %lf",&dipole[0],&dipole[1],&dipole[2]);
					break;
				}
			}
			break;
		}
		else
		{
			if(strstr( t, "END OF PROPERTY" )) break;
		}

	}
	free(t);
}
/********************************************************************************/
void get_dipole_from_turbomole_output_file(FILE* file, double dipole[])
{
  	char *t = malloc(BSIZE*sizeof(char));
  	char dum[100];


	dipole[0] = dipole[1] = dipole[2] = 0.0;

  	while(!feof(file) )
	{
    		if(!fgets(t,BSIZE,file))break;
		if(strstr( t, "electrostatic moments"))
		{
  			while(!feof(file) )
			{
    				if(!fgets(t,BSIZE,file))break;
				if(strstr( t, "dipole moment"))
				{
					double d;
    					if(!fgets(t,BSIZE,file))break;
    					if(!fgets(t,BSIZE,file))break;/* x */
					sscanf(t,"%s %lf %lf %lf",dum, &d, &d, &dipole[0]);
    					if(!fgets(t,BSIZE,file))break;/* y */
					sscanf(t,"%s %lf %lf %lf",dum, &d, &d, &dipole[1]);
    					if(!fgets(t,BSIZE,file))break;/* z */
					sscanf(t,"%s %lf %lf %lf",dum, &d, &d, &dipole[2]);
					break;
				}
			}
			break;
		}
	}
	free(t);
}
/********************************************************************************/
void get_dipole_from_gaussian_output_file(FILE* file, double dipole[])
{
  	char *t = malloc(BSIZE*sizeof(char));
  	char* pdest;
	int ngrad = 0;

	dipole[0] = dipole[1] = dipole[2] = 0.0;

  	while(!feof(file) )
	{
    		pdest = NULL;
		dipole[0] = dipole[1] = dipole[2] = 0.0;
    		if(!fgets(t,BSIZE,file)) break;
    		pdest = strstr( t, "Dipole moment (Debye)");

		if(strstr( t, "Dipole moment") && strstr( t, "Debye")) /* field-independent basis */
		{
    		if(!fgets(t,BSIZE,file)) break;
    		pdest = strstr( t, "X=")+2;
		sscanf(pdest,"%lf",&dipole[0]);
    		pdest = strstr( t, "Y=")+2;
		sscanf(pdest,"%lf",&dipole[1]);
    		pdest = strstr( t, "Z=")+2;
		sscanf(pdest,"%lf",&dipole[2]);
		/*
		Debug("t =%s\n",t);
		*/
		break;
		}
		else
		{
          		pdest = strstr( t, "GradGradGrad" );
			if(pdest)
			{
				ngrad++;
			/*	Debug("ngrad = %d\n",ngrad);*/
			}
			if(ngrad>2)
				break;
		}

	}
	free(t);
}
/********************************************************************************/
void get_dipole_from_molpro_output_file(FILE* file, double dipole[])
{
  	char *t = malloc(BSIZE*sizeof(char));
  	char* t1;
  	char* t2;

	dipole[0] = dipole[1] = dipole[2] = 0.0;

  	while(!feof(file) )
	{
    		t1 = NULL;
    		if(!fgets(t,BSIZE,file)) break;
    		t1 = strstr( t, "DIPOLE MOMENTS:");

		if(t1)
		{
    		t2 = strstr( t1, ":")+2;
		sscanf(t2,"%lf %lf %lf",&dipole[0],&dipole[1],&dipole[2]);
		/*
		Debug("t =%s\n",t);
		*/
		break;
		}
		else
		{
          		t1 = strstr( t, "GEOMETRY OPTIMIZATION STEP" );
			if(t1)
				break;
          		t1 = strstr( t, "SEWARD" );
			if(t1)
				break;
		}

	}
	free(t);
}
/********************************************************************************/
void get_dipole_from_dalton_output_file(FILE* file, double dipole[])
{
  	char *t = malloc(BSIZE*sizeof(char));
  	char* t1;
	char dum[100];

	dipole[0] = dipole[1] = dipole[2] = 0.0;

  	while(!feof(file) )
	{
    		t1 = NULL;
    		if(!fgets(t,BSIZE,file))break;
    		t1 = strstr( t, "Dipole moment components");
		if(t1)
		{
    			if(!fgets(t,BSIZE,file))break;
    			if(!fgets(t,BSIZE,file))break;
    			if(!fgets(t,BSIZE,file))break;
    			if(!fgets(t,BSIZE,file))break;
    			if(!fgets(t,BSIZE,file))break;
			sscanf(t,"%s %lf",dum, &dipole[0]);
    			if(!fgets(t,BSIZE,file))break;
			sscanf(t,"%s %lf",dum, &dipole[1]);
    			if(!fgets(t,BSIZE,file))break;
			sscanf(t,"%s %lf",dum, &dipole[2]);
		/*
			Debug("t =%s\n",t);
		*/
			break;
		}
		else
		{
			if(strstr( t, ">>>>" )) break;
		}

	}
	free(t);
}
/********************************************************************************/
void get_dipole_from_orca_output_file(FILE* file, double dipole[])
{
  	char *t = malloc(BSIZE*sizeof(char));
  	char* pdest;

	dipole[0] = dipole[1] = dipole[2] = 0.0;

  	while(!feof(file) )
	{
    		pdest = NULL;
		dipole[0] = dipole[1] = dipole[2] = 0.0;
    		if(!fgets(t,BSIZE,file)) break;
    		pdest = strstr( t, "Total Dipole Moment");

		if(pdest && strstr( t,":"))
		{
			pdest = strstr( t,":")+1;
			sscanf(pdest,"%lf %lf %lf",&dipole[0],&dipole[1],&dipole[2]);
			break;
		}
	}
	free(t);
}
/********************************************************************************/
void get_dipole_from_vasp_output_file(FILE* file, double dipole[])
{
  	char *t = malloc(BSIZE*sizeof(char));

	dipole[0] = dipole[1] = dipole[2] = 0.0;

	free(t);
}
/********************************************************************************/
void get_dipole_from_nwchem_output_file(FILE* file, double dipole[])
{
  	char *t = malloc(BSIZE*sizeof(char));
  	char* pdest;

	dipole[0] = dipole[1] = dipole[2] = 0.0;

  	while(!feof(file) )
	{
    		pdest = NULL;
		dipole[0] = dipole[1] = dipole[2] = 0.0;
    		if(!fgets(t,BSIZE,file)) break;
    		pdest = strstr( t, "Nuclear Dipole moment");
		if(pdest)
		{
			boolean OK = FALSE;
  			while(!feof(file) )
			{
    				if(!fgets(t,BSIZE,file)) break;
				if(strstr(t,"---------------- ---------------- ----------------"))
				{
					OK = TRUE;
					break;
				}
			}
			if(!OK) break;
    			if(!fgets(t,BSIZE,file)) break;
			sscanf(pdest,"%lf %lf %lf",&dipole[0],&dipole[1],&dipole[2]);
			break;
		}
	}
	free(t);
}
/********************************************************************************/
void get_dipole_from_psicode_output_file(FILE* file, double dipole[])
{
  	char *t = malloc(BSIZE*sizeof(char));
  	char* pdest;

	dipole[0] = dipole[1] = dipole[2] = 0.0;

  	while(!feof(file) )
	{
    		pdest = NULL;
		dipole[0] = dipole[1] = dipole[2] = 0.0;
    		if(!fgets(t,BSIZE,file)) break;
    		pdest = strstr( t, "Nuclear Dipole moment");
		if(pdest)
		{
			boolean OK = FALSE;
  			while(!feof(file) )
			{
    				if(!fgets(t,BSIZE,file)) break;
				if(strstr(t,"---------------- ---------------- ----------------"))
				{
					OK = TRUE;
					break;
				}
			}
			if(!OK) break;
    			if(!fgets(t,BSIZE,file)) break;
			sscanf(pdest,"%lf %lf %lf",&dipole[0],&dipole[1],&dipole[2]);
			break;
		}
	}
	free(t);
}
/********************************************************************************/
void get_dipole_from_qchem_output_file(FILE* file, double dipole[])
{
  	char *t = malloc(BSIZE*sizeof(char));
  	char* pdest;
	int ngrad = 0;

	dipole[0] = dipole[1] = dipole[2] = 0.0;

  	while(!feof(file) )
	{
    		pdest = NULL;
		dipole[0] = dipole[1] = dipole[2] = 0.0;
    		if(!fgets(t,BSIZE,file)) break;
    		pdest = strstr( t, "Dipole Moment (Debye)");

		if(pdest)
		{
    		if(!fgets(t,BSIZE,file)) break;
		else break;
    		pdest = strstr( t, "X")+2;
		if(pdest) sscanf(pdest,"%lf",&dipole[0]);
    		pdest = strstr( t, "Y")+2;
		if(pdest) sscanf(pdest,"%lf",&dipole[1]);
    		pdest = strstr( t, "Z")+2;
		if(pdest) sscanf(pdest,"%lf",&dipole[2]);
		break;
		}
		else
		{
          		pdest = strstr( t, "GradGradGrad" );
			if(pdest)
			{
				ngrad++;
			}
			if(ngrad>2) break;
		}

	}
	free(t);
}
/********************************************************************************/
void get_dipole_from_mopac_output_file(FILE* file, double dipole[])
{
  	char *t = malloc(BSIZE*sizeof(char));
  	char* pdest;
	char dum[100];

	dipole[0] = dipole[1] = dipole[2] = 0.0;

  	while(!feof(file) )
	{
    		pdest = NULL;
		dipole[0] = dipole[1] = dipole[2] = 0.0;
    		if(!fgets(t,BSIZE,file)) break;
    		pdest = strstr( t, "DIPOLE           X         Y         Z");

		if(pdest)
		{
    			if(!fgets(t,BSIZE,file)) break;
    			if(!fgets(t,BSIZE,file)) break;
    			if(!fgets(t,BSIZE,file)) break;
    			pdest = strstr( t, "SUM")+2;
			sscanf(t,"%s %lf %lf %lf",dum,&dipole[0],&dipole[1], &dipole[2]);
			break;
		}
	}
	free(t);
}
/**********************************************************************************************************************************/
void get_dipole_from_mopac_aux_file(FILE* file, double dipole[])
{
  	char t[BSIZE];
  	char* pdest;
	int i;

	rewind(file);
	for(i=0;i<3;i++) dipole[i] = 0;
  	while(!feof(file) )
	{
    		pdest = NULL;
		if(!fgets(t,BSIZE,file))break;
    		pdest = strstr( t, "DIPOLE:DEBYE=");

		if(pdest)
		{
    			pdest = strstr( t, "=")+1;
			for(i=0;i<3;i++) dipole[i] = 0;
			if(pdest) sscanf(pdest,"%lf %lf %lf",&dipole[0], &dipole[1],&dipole[2]);
			break;
		}
	}
}
/********************************************************************************/
void changeDInE(char *st)
{
        int i;
        int l = 0;
        if(!st) return;
        l = strlen(st);
        for(i=0;i<l;i++) if(st[i] == 'D' || st[i] =='d') st[i]='e';
}

/****************************************************************************/
int get_one_int_from_fchk_gaussian_file(FILE* file, char* blockName)
{
	int ipos = 47;
	char t[BSIZE];
	 while(!feof(file))
	 {
		if(!fgets(t,BSIZE,file))break;
		if(strstr( t, blockName))
		{
			if(strlen(t)>ipos+1) return atoi(t+ipos);
			return -1;
		}
	 }
	 return -1;
}
/****************************************************************************/
double get_one_real_from_fchk_gaussian_file(FILE* file, char* blockName)
{
	int ipos = 47;
	char t[BSIZE];
	 while(!feof(file))
	 {
		if(!fgets(t,BSIZE,file))break;
		if(strstr( t, blockName))
		{
			if(strlen(t)>ipos+1) return atof(t+ipos);
			return -1;
		}
	 }
	 return -1;
}
/****************************************************************************/
int* get_array_int_from_fchk_gaussian_file(FILE* file, char* blockName, int* nElements)
{
	int ipos = 43;
	int i;
	char t[BSIZE];
	int* elements = NULL;
	*nElements = 0;
	 while(!feof(file))
	 {
		if(!fgets(t,BSIZE,file))break;
		if(strstr( t, blockName))
		{
			if(!(strstr( t, blockName) && strstr(t,"N=") && strlen(strstr(t,"N="))>2)) return elements;
			if(strlen(t)>ipos+1 && t[ipos]!='I') return elements;
			*nElements = atof(strstr(t,"N=")+2);
			if(*nElements<1) return elements;
			elements = malloc(*nElements*sizeof(int));
			for(i=0;i<*nElements;i++)
			{
				if(1!=fscanf(file,"%d",&elements[i])) break;
			}
			if(i!=*nElements)
			{
				*nElements = 0;
				free(elements);
				return NULL;
			}
			return elements;
		}
	 }
	 return elements;
}
/****************************************************************************/
double* get_array_real_from_fchk_gaussian_file(FILE* file, char* blockName, int* nElements)
{
	int ipos = 43;
	int i;
	char t[BSIZE];
	double* elements = NULL;

	*nElements = 0;
	 while(!feof(file))
	 {
		if(!fgets(t,BSIZE,file))break;
		if(strstr( t, blockName))
		{
			if(!(strstr( t, blockName) && strstr(t,"N=") && strlen(strstr(t,"N="))>2)) return elements;
			if(strlen(t)>ipos+1 && t[ipos]!='R') return elements;
			*nElements = atof(strstr(t,"N=")+2);
			if(*nElements<1) return elements;
			elements = malloc(*nElements*sizeof(double));
			for(i=0;i<*nElements;i++)
				if(1!=fscanf(file,"%lf",&elements[i])) break;
			if(i!=*nElements)
			{
				*nElements = 0;
				free(elements);
				return NULL;
			}
			return elements;
		}
	 }
	 return elements;
}
/****************************************************************************/
char** get_array_string_from_fchk_gaussian_file(FILE* file, char* blockName, int* nElements)
{
	int ipos = 43;
	int i;
	char t[BSIZE];
	char** elements = NULL;
	char type = ' ';

	*nElements = 0;
	 while(!feof(file))
	 {
		if(!fgets(t,BSIZE,file))break;
		if(strstr( t, blockName))
		{
			if(!(strstr( t, blockName) && strstr(t,"N=") && strlen(strstr(t,"N="))>2)) return elements;
			if(strlen(t)>ipos+1 && t[ipos]=='C') type = 'C';
			if(strlen(t)>ipos+1 && t[ipos]=='H') type = 'H';
			if(type!='C' && type!='H') return elements;
			*nElements = atof(strstr(t,"N=")+2);
			if(*nElements<1) return elements;
			elements = malloc(*nElements*sizeof(char*));
			for(i=0;i<*nElements;i++) elements[i] = NULL;
			if(type=='C')
			for(i=0;i<*nElements;i++)
			{
				if(1!=fscanf(file,"%12s",t)) break;
				elements[i] = strdup(t);
			}
			else
			for(i=0;i<*nElements;i++)
			{
				if(1!=fscanf(file,"%8s",t)) break;
				elements[i] = strdup(t);
			}
			
			if(i!=*nElements)
			{
				*nElements = 0;
				free(elements);
				return NULL;
			}
			return elements;
		}
	 }
	 return elements;
}
/****************************************************************************************************************************/
static int getNumAxis(char* s)
{
        if(!s) return 0;
        if(!strcmp(s,"x")) return 1;
        if(!strcmp(s,"X")) return 1;
        if(!strcmp(s,"y")) return 2;
        if(!strcmp(s,"Y")) return 2;
        if(!strcmp(s,"z")) return 3;
        if(!strcmp(s,"Z")) return 3;
        return atoi(s);
}
/****************************************************************************************************************************/
static boolean get2IndexValue(char* t, int* i, int* j, double*value)
{
	char s1[BSIZE];
	char s2[BSIZE];
	*i = 0;
	*j = 0;
	*value = 0;
//	if(mystrcasestr(t,"END")){ printf("%s\n",t);return FALSE;}
	if(mystrcasestr(t,"END"))return FALSE;
	if(3!=sscanf(t,"%s %s %lf",s1, s2,value)) return FALSE;
	*i = getNumAxis(s1);
	*j = getNumAxis(s2);
	return TRUE;
}
/****************************************************************************************************************************/
static boolean get3IndexValue(char* t, int* i, int* j, int* k, double*value)
{
	char s1[BSIZE];
	char s2[BSIZE];
	char s3[BSIZE];
	*i = 0;
	*j = 0;
	*k = 0;
	*value = 0;
	//if(mystrcasestr(t,"END")){ printf("%s\n",t);return FALSE;}
	if(mystrcasestr(t,"END"))return FALSE;
	if(4!=sscanf(t,"%s %s %s %lf",s1, s2,s3, value)) return FALSE;
	*i = getNumAxis(s1);
	*j = getNumAxis(s2);
	*k = getNumAxis(s3);
	return TRUE;
}
/****************************************************************************************************************************/
static boolean get4IndexValue(char* t, int* i, int* j, int* k, int* l, double*value)
{
	char s1[BSIZE];
	char s2[BSIZE];
	char s3[BSIZE];
	char s4[BSIZE];
	*i = 0;
	*j = 0;
	*k = 0;
	*l = 0;
	*value = 0;
	//if(mystrcasestr(t,"END")){ printf("%s\n",t);return FALSE;}
	if(mystrcasestr(t,"END"))return FALSE;
	if(5!=sscanf(t,"%s %s %s %s %lf",s1, s2,s3, s4, value)) return FALSE;
	*i = getNumAxis(s1);
	*j = getNumAxis(s2);
	*k = getNumAxis(s3);
	*l = getNumAxis(s4);
	return TRUE;
}
/****************************************************************************************************************************/
boolean readMatrixReal(FILE* file, char* tag, int nrows, int ncolumns, double**values)
{
	static char *t = NULL; 
	char* TAG = NULL;
	char* pos = NULL;
	int i=0;
	int ii,jj;
	double v;
	int** counter = NULL;
	if(!tag) return FALSE;
	if(!values) return FALSE;
	if(t==NULL) t = malloc(BSIZE*sizeof(char));

	TAG = strdup(tag);
	uppercase(TAG);
	rewind(file);

	while(!feof(file))
  	{
    		if(!fgets(t,BSIZE, file)) break;
		deleteFirstSpaces(t);
		if(t[0]=='#') continue;
		uppercase(t);
		pos = strstr(t,TAG);
		if(!pos) continue;
		break;
	}
	if(!pos) 
	{
		free(TAG);
		return FALSE;
	}
	counter = newMatrixInt(nrows,ncolumns);
	//fprintf(stderr,"nrows=%d ncolums=%d\n",nrows,ncolumns);
	if(!counter) 
	{
		fprintf(stderr,"I am not able to create a %d %d matrix\n",nrows,ncolumns);
		exit(1);
	}
	initMatrixInt(counter, nrows,ncolumns, 0);
	while(!feof(file))
	{
    		if(!fgets(t,BSIZE, file)) break;
		if(get2IndexValue(t,&ii, &jj, &v))
		{
			if(ii<=nrows && ii>0 && jj<=ncolumns && jj>0 ) 
			{ 
				int c=  counter[ii-1][jj-1];  
				counter[ii-1][jj-1]++; 
				i++; 
				//c = 0; // TO DO 
				if(c==0) values[ii-1][jj-1] = v; 
				else values[ii-1][jj-1] = (values[ii-1][jj-1]*c+v)/(c+1);
				//if(c!=0) fprintf(stderr," %d %d v=%f newV=%f c = %d\n",ii,jj,v, values[ii-1][jj-1],c);
			}
			else
			{
				fprintf(stderr,"Erreur dans les donnees de %s: verifie les indices\n",tag);
				fprintf(stderr,"ii=%d jj=%d\n",ii,jj);
				fprintf(stderr,"nr=%d nc=%d\n",nrows,ncolumns);
				exit(1);
			}
		}
		else break;
	}
	free(TAG);
	freeMatrixInt(&counter,nrows);
	if(i<=0) return FALSE;
	return TRUE;
}
/****************************************************************************************************************************/
boolean readCubeReal(FILE* file, char* tag, int nrows, int ncolumns, int nslices, double***values)
{
	static char *t = NULL; 
	char* TAG = NULL;
	char* pos = NULL;
	int i=0;
	int ii,jj,kk;
	double v;
	int*** counter = NULL;
	if(!tag) return FALSE;
	if(!values) return FALSE;
	if(t==NULL) t = malloc(BSIZE*sizeof(char));

	TAG = strdup(tag);
	uppercase(TAG);
	rewind(file);

	while(!feof(file))
  	{
    		if(!fgets(t,BSIZE, file)) break;
		deleteFirstSpaces(t);
		if(t[0]=='#') continue;
		uppercase(t);
		pos = strstr(t,TAG);
		if(!pos) continue;
		break;
	}
	if(!pos) 
	{
		free(TAG);
		return FALSE;
	}
	counter = newCubeInt(nrows,ncolumns,nslices);
	initCubeInt(counter, nrows,ncolumns,nslices, 0);
	while(!feof(file))
	{
    		if(!fgets(t,BSIZE, file)) break;
		if(get3IndexValue(t,&ii, &jj, &kk, &v))
		{
			if(ii<=nrows && ii>0 && jj<=ncolumns && jj>0  &&kk<=nslices && kk>0 ) 
			{ 
				int c=  counter[ii-1][jj-1][kk-1];  
				counter[ii-1][jj-1][kk-1]++; 
				i++; 
				//c = 0;//TO DO
				if(c==0) values[ii-1][jj-1][kk-1] = v; 
				else values[ii-1][jj-1][kk-1] = (values[ii-1][jj-1][kk-1]*c+v)/(c+1);
				//if(c!=0) fprintf(stderr," %d %d %d v=%f newV=%f c = %d\n",ii,jj,kk,v, values[ii-1][jj-1][kk-1],c);
			}
			else
			{
				fprintf(stderr,"Erreur dans les donnees de %s: verifie les indices\n",tag);
				exit(1);
			}
		}
		else break;
	}
	free(TAG);
	freeCubeInt(&counter,nrows,ncolumns);
	if(i<=0) return FALSE;
	return TRUE;
}
/****************************************************************************************************************************/
boolean readQuarticReal(FILE* file, char* tag, int nrows, int ncolumns, int nslices, int nq, double****values)
{
	static char *t = NULL; 
	char* TAG = NULL;
	char* pos = NULL;
	int i=0;
	int ii,jj,kk,ll;
	double v;
	int**** counter = NULL;
	if(!tag) return FALSE;
	if(!values) return FALSE;
	if(t==NULL) t = malloc(BSIZE*sizeof(char));

	TAG = strdup(tag);
	uppercase(TAG);
	rewind(file);

	while(!feof(file))
  	{
    		if(!fgets(t,BSIZE, file)) break;
		deleteFirstSpaces(t);
		if(t[0]=='#') continue;
		uppercase(t);
		pos = strstr(t,TAG);
		if(!pos) continue;
		break;
	}
	if(!pos) 
	{
		free(TAG);
		return FALSE;
	}
	counter = newQuarticInt(nrows,ncolumns,nslices,nq);
	initQuarticInt(counter, nrows,ncolumns,nslices,nq, 0);
	while(!feof(file))
	{
    		if(!fgets(t,BSIZE, file)) break;
		if(get4IndexValue(t,&ii, &jj, &kk, &ll, &v))
		{
			if(ii<=nrows && ii>0 && jj<=ncolumns && jj>0  &&kk<=nslices && kk>0 && ll<=nq && ll>0 )
			{ 
				int c=  counter[ii-1][jj-1][kk-1][ll-1];  
				counter[ii-1][jj-1][kk-1][ll-1]++; 
				i++; 
                                //c = 0;// TO DO
				if(c==0) values[ii-1][jj-1][kk-1][ll-1] = v; 
				else values[ii-1][jj-1][kk-1][ll-1] = (values[ii-1][jj-1][kk-1][ll-1]*c+v)/(c+1);
				//if(c!=0) fprintf(stderr," %d %d %d %d v=%f newV=%f c = %d\n",ii,jj,kk,ll,v, values[ii-1][jj-1][kk-1][ll-1],c);
			}
			else
			{
				fprintf(stderr,"Erreur dans les donnees de %s: verifie les indices\n",tag);
				exit(1);
			}
		}
		else break;
	}
	free(TAG);
	freeQuarticInt(&counter,nrows,ncolumns,nslices);
	if(i<=0) return FALSE;
	return TRUE;
}
/****************************************************************************************************************************/
double getMaxQuarticIJKL(double**** C, int i, int j, int k, int l)
{
	double A[] = { getMaxCubicIJK(C[i],j,k,l), getMaxCubicIJK(C[j],i,k,l), getMaxCubicIJK(C[k],j,i,l), getMaxCubicIJK(C[l],j,k,i)};
	double max=A[0];
	int c;
	for(c=1;c<4;c++) if(fabs(max)<fabs(A[c])) max = A[c];
	return max;
}
/****************************************************************************************************************************/
double getMaxCubicIJK(double*** C, int i, int j, int k)
{
	double A[] = {getMaxMatrixIJ(C[i],j,k), getMaxMatrixIJ(C[j],i,k), getMaxMatrixIJ(C[k],i,j)};
	double max=A[0];
	int c;

	for(c=1;c<3;c++) if(fabs(max)<fabs(A[c])) max = A[c];
	return max;
}
/****************************************************************************************************************************/
double getMaxMatrixIJ(double** C, int i, int j)
{
	double A = C[i][j];
	if(fabs(C[j][i])> fabs(A)) A = C[j][i];
	return A;
}
/****************************************************************************************************************************/
double getMaxCubicIJ(double*** C, int a, int i, int j)
{
	double A = getMaxMatrixIJ(C[a],i,j);
	return A;
}
/****************************************************************************************************************************/
double getMaxQuarticIJK(double**** C, int a, int i, int j, int k)
{
	double A = getMaxCubicIJK(C[a],i,j,k);
	return A;
}
/*************************************************************************************/
void getCrossProduct(double * V1,double * V2, double *PV)
{
	PV[0]= V1[1]*V2[2]-V1[2]*V2[1];
	PV[1]= V1[2]*V2[0]-V1[0]*V2[2];
	PV[2]= V1[0]*V2[1]-V1[1]*V2[0];
} 
/*************************************************************************************/
double getDistancePoints(double* P1,double* P2)
{
	double distance = 0.0;
	int i;
	for(i=0;i<3;i++) distance += (P1[i]- P2[i])*(P1[i]- P2[i]);
	distance = sqrt(distance);
	return distance;
} 
/*************************************************************************************/
double getNorm(double* V)
{
	double norm = 0.0;
	int i;
	for(i=0;i<3;i++) norm += V[i]*V[i];
	return sqrt(norm);
}
/*************************************************************************************/
double getDotProduct(double* V1,double* V2)
{
	double dot = 0.0;
	int i;
	for(i=0;i<3;i++) dot += V1[i]*V2[i];
	return dot;
}
/*************************************************************************************/
double getAngleVectors(double* V1,double* V2)
{
	double angle;
	double modv1v2 = getNorm(V1)*getNorm(V2);
 
	if(fabs(modv1v2)>1e-14 )
	{
		angle = getDotProduct(V1,V2)/modv1v2;
		if(angle<=-1) return 180.0;
		if(angle>=1) return 0.0;
		angle = acos(angle)/DEGTORAD;
	}
	else angle = 0.0;
	return angle;
} 
//  Windows
#ifdef _WIN32
#include <Windows.h>
double get_wall_time(){
    LARGE_INTEGER time,freq;
    if (!QueryPerformanceFrequency(&freq)){
        //  Handle error
        return 0;
    }
    if (!QueryPerformanceCounter(&time)){
        //  Handle error
        return 0;
    }
    return (double)time.QuadPart / freq.QuadPart;
}
double get_cpu_time(){
    FILETIME a,b,c,d;
    if (GetProcessTimes(GetCurrentProcess(),&a,&b,&c,&d) != 0){
        //  Returns total user time.
        //  Can be tweaked to include kernel times as well.
        return
            (double)(d.dwLowDateTime |
            ((unsigned long long)d.dwHighDateTime << 32)) * 0.0000001;
    }else{
        //  Handle error
        return 0;
    }
}

//  Posix/Linux
#else
#include <time.h>
#include <sys/time.h>
double get_wall_time(){
    struct timeval time;
    if (gettimeofday(&time,NULL)){
        //  Handle error
        return 0;
    }
    return (double)time.tv_sec + (double)time.tv_usec * .000001;
}
double get_cpu_time(){
    return (double)clock() / CLOCKS_PER_SEC;
}
#endif

void get3DRandMatrix(double M[3][3])
{
	const double pi = M_PI;
	int i,j;
	double RotMatrix[3][3];
	double x1,x2,x3;
	x1 = drandom();
	x2 = drandom();
	x3 = drandom();

	RotMatrix[0][0] = cos(2.0*pi*x1);
	RotMatrix[0][1] = sin(2.0*pi*x1);
	RotMatrix[0][2] = 0.0;

	RotMatrix[1][0] = -1.0 * sin(2.0*pi*x1);
	RotMatrix[1][1] = cos(2.0*pi*x1);
	RotMatrix[1][2] = 0.0;

	RotMatrix[2][0] = 0.0;
	RotMatrix[2][1] = 0.0;
	RotMatrix[2][2] = 1.0;

	double v[3] = {   
		sqrt(x3)*cos(2.0*pi*x2),
		sqrt(x3)*sin(2.0*pi*x2), 
                sqrt(1.0 - x3) 
		};

	double vv[3][3];
	vv[0][0] = v[0] * v[0];
	vv[0][1] = v[0] * v[1];
	vv[0][2] = v[0] * v[2];

	vv[1][0] = v[1] * v[0];
	vv[1][1] = v[1] * v[1];
	vv[1][2] = v[1] * v[2];

	vv[2][0] = v[2] * v[0];
	vv[2][1] = v[2] * v[1];
	vv[2][2] = v[2] * v[2];

	double H[3][3];

	H[0][0] = 1.0 - 2*vv[0][0];
	H[0][1] = 0.0 - 2*vv[0][1];
	H[0][2] = 0.0 - 2*vv[0][2];
	
	H[1][0] = 0.0 - 2*vv[1][0];
	H[1][1] = 1.0 - 2*vv[1][1];
	H[1][2] = 0.0 - 2*vv[1][2];
	
	H[2][0] = 0.0 - 2*vv[2][0];
	H[2][1] = 0.0 - 2*vv[2][1];
	H[2][2] = 1.0 - 2*vv[2][2];

	for (i = 0; i < 3; i++)
	for (j = 0; j < 3; j++)
	{
		int k;
		M[i][j] = 0.0;
		for(k = 0; k < 3; ++k) M[i][j] += H[i][k] * RotMatrix[k][j];
		M[i][j] = -M[i][j];
	}	
}	
void getRandDirection(double D[])
{
	const double pi = M_PI;
	double x1,x2;
	x1 = drandom();
	x2 = drandom();

	D[2] = cos(pi*x1);
	D[1] = sin(pi*x1)*cos(2.0*pi*x2);
	D[0] = sin(pi*x1)*sin(2.0*pi*x2);
}	
File: ./cchemilib/src/Utils/PDBTemplate.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* PDBTemplate.c */
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>

#include "../Utils/Types.h"
#include "../Utils/Utils.h"
#include "../Utils/PDBTemplate.h"
#include "../Utils/LoadPDBTemplate.h"
#include "../Utils/CreateDefaultPDBTpl.h"
#include "../Utils/SavePDBTemplate.h"
#include "../Molecule/Molecule.h"

static	PDBTemplate* staticPDBTemplate = NULL;
/************************************************************/
PDBTemplate* freePDBTpl(PDBTemplate* pdbTemplate)
{
	int i;
	int j;
	if(!pdbTemplate)
		return NULL;
	for(i=0;i<pdbTemplate->numberOfResidues;i++)
	{
		if(pdbTemplate->residueTemplates[i].residueName)
			free(pdbTemplate->residueTemplates[i].residueName);

		for(j=0;j<pdbTemplate->residueTemplates[i].numberOfTypes;j++)
		{
			if(pdbTemplate->residueTemplates[i].typeTemplates[j].pdbType)
				free(pdbTemplate->residueTemplates[i].typeTemplates[j].pdbType);
			if(pdbTemplate->residueTemplates[i].typeTemplates[j].mmType)
				free(pdbTemplate->residueTemplates[i].typeTemplates[j].mmType);
		}
		if(pdbTemplate->residueTemplates[i].typeTemplates)
			free(pdbTemplate->residueTemplates[i].typeTemplates);
	}
	if(pdbTemplate->residueTemplates)
		free(pdbTemplate->residueTemplates);
	free(pdbTemplate);
	return NULL;
}
/************************************************************/
PDBTemplate* LoadPersonalPDBTpl()
{
	char* filename = strdup_printf("%s%sPersonalPDBTemplate.tpl",
			cchemiDirectory(), DIR_SEPARATOR_S);
	PDBTemplate* pdbTemplate = NULL;

	pdbTemplate = malloc(sizeof(PDBTemplate));
	if(!readPDBTemplate(pdbTemplate,filename))
	{
		free(pdbTemplate);
		pdbTemplate = NULL;
	}

	free(filename);
	return pdbTemplate;
}
/************************************************************/
PDBTemplate* LoadDefaultPDBTpl()
{
	PDBTemplate* pdbTemplate = NULL;
	char* filename = strdup_printf("%s%sDefaultPDBTemplate.tpl",
			cchemiDirectory(), DIR_SEPARATOR_S);

	pdbTemplate = malloc(sizeof(PDBTemplate));
	if(!readPDBTemplate(pdbTemplate,filename))
	{
		free(pdbTemplate);
		pdbTemplate = NULL;
	}

	free(filename);
	return pdbTemplate;
}
/************************************************************/
void LoadPDBTpl()
{
	if(staticPDBTemplate)
		staticPDBTemplate = freePDBTpl(staticPDBTemplate);
	staticPDBTemplate = LoadPersonalPDBTpl();
	if(!staticPDBTemplate)
	{
		staticPDBTemplate = LoadDefaultPDBTpl();
		if(!staticPDBTemplate)
		{

			if(CreateDefaultPDBTpl())
				staticPDBTemplate = LoadDefaultPDBTpl();
		}
	}
}
/************************************************************/
static int getResiduePDBTplNumber(char* residueName)
{
	int i;
	if(!staticPDBTemplate)
		return -1;

	for(i=0;i<staticPDBTemplate->numberOfResidues;i++)
	{
		if(!strcmp(staticPDBTemplate->residueTemplates[i].residueName,residueName))
			return i;
	}
	return -1;
}
/************************************************************/
static char* getmmType(int residueNumber, char* pdbType,double* charge)
{
	int j;
	PDBTypeTemplate* typeTemplates = 
		staticPDBTemplate->residueTemplates[residueNumber].typeTemplates;
	int numberOfTypes = staticPDBTemplate->residueTemplates[residueNumber].numberOfTypes;
	char* mmType = strdup("UNK");
	for(j=0;j<numberOfTypes;j++)
	{
		if(!strcmp(pdbType,typeTemplates[j].pdbType))
		{
			free(mmType);
			mmType = strdup(typeTemplates[j].mmType);
			*charge = typeTemplates[j].charge;
			return mmType;
		}
	}
	return mmType;
}
/************************************************************/
char* getMMTypeFromPDBTpl(char* residueName,char* pdbType,double* charge)
{
	char* mmType = strdup("UNK");
	int residueNumber = -1;
	*charge = 0;

	if(!staticPDBTemplate) return mmType;
	residueNumber = getResiduePDBTplNumber(residueName);
	if(residueNumber==-1)
	{
		residueNumber = getResiduePDBTplNumber("ALLRESIDUE");
		if(residueNumber==-1)
			return mmType;
		else
			return getmmType(residueNumber,pdbType,charge);
	}
	else
	{
		mmType = getmmType(residueNumber,pdbType,charge);
		if(!strcmp(mmType,"UNK"))
		{
			residueNumber = getResiduePDBTplNumber("ALLRESIDUE");
			if(residueNumber==-1)
				return mmType;
			else
				return getmmType(residueNumber,pdbType,charge);
		}
		else
			return mmType;
	}
}
/************************************************************/
static int getHydrogens(int residueNumber, char* pdbType, char** hAtoms)
{
	int j;
	int k;
	PDBTypeTemplate* typeTemplates = 
		staticPDBTemplate->residueTemplates[residueNumber].typeTemplates;
	int numberOfTypes = staticPDBTemplate->residueTemplates[residueNumber].numberOfTypes;
	int nH = 0;
	for(j=0;j<numberOfTypes;j++)
	{
		if(!strcmp(pdbType,typeTemplates[j].pdbType))
		{
			for(k=j+1;k<numberOfTypes;k++)
			{
				if(!typeTemplates[k].pdbType) break;
				if(typeTemplates[k].pdbType[0]!='H') break;
				sprintf(hAtoms[nH],"%s",typeTemplates[k].pdbType);
				nH++;
				if(nH>10) break;
			}
			return nH;
		}
	}
	return nH;
}
/************************************************************/
int getHydrogensFromPDBTpl(char* residueName,char* pdbType, char** hAtoms)
{
	int nH = 0;
	int residueNumber = -1;

	if(!pdbType) return nH;
	if(pdbType && (pdbType[0]=='H' || pdbType[0]=='h')) return nH;
	if(!staticPDBTemplate) return nH;
	residueNumber = getResiduePDBTplNumber(residueName);
	if(residueNumber==-1)
	{
		residueNumber = getResiduePDBTplNumber("ALLRESIDUE");
		if(residueNumber==-1)
			return nH;
		else
			return getHydrogens(residueNumber,pdbType, hAtoms);
	}
	else
	{
		nH = getHydrogens(residueNumber,pdbType, hAtoms);
		if(nH == 0)
		{
			residueNumber = getResiduePDBTplNumber("ALLRESIDUE");
			if(residueNumber==-1)
				return nH;
			else
				return getHydrogens(residueNumber,pdbType, hAtoms);
		}
		else
			return nH;
	}
	return nH;
}
/************************************************************/
PDBTemplate* getPointerPDBTemplate()
{
	return staticPDBTemplate;
}
/************************************************************/
void setPointerPDBTemplate(PDBTemplate* ptr)
{
	staticPDBTemplate = ptr;
}
/************************************************************/
char** getListPDBTypes(char* residueName, int* nlist)
{
	char** t = NULL;
	int j;
	int residueNumber = getResiduePDBTplNumber(residueName);
	PDBTypeTemplate* typeTemplates = NULL;
	int numberOfTypes = 0;

	*nlist = 0;

	if(residueNumber==-1) residueNumber = getResiduePDBTplNumber("ALLRESIDUE");
	if(residueNumber==-1) return NULL;

	typeTemplates = staticPDBTemplate->residueTemplates[residueNumber].typeTemplates;
	numberOfTypes = staticPDBTemplate->residueTemplates[residueNumber].numberOfTypes;
	t = malloc(numberOfTypes*sizeof(char*));
	for(j=0;j<numberOfTypes;j++)
		t[j] = strdup(typeTemplates[j].pdbType);
	*nlist = numberOfTypes;
	return t;
}
/**********************************************************************************************************/
void buildMMTypesFromPDB(Molecule* mol, boolean setCharge)
{
	int i;
	double charge;
	LoadPDBTpl();
	for(i=0;i<mol->nAtoms;i++)
	{
		char* mmType = getMMTypeFromPDBTpl(mol->atoms[i].residueName,mol->atoms[i].pdbType,&charge);
		
		if(mmType)
		{
			if(mol->atoms[i].mmType) free(mol->atoms[i].mmType);
			mol->atoms[i].mmType = mmType;
			if(setCharge) mol->atoms[i].charge = charge;
		}
	}
}
File: ./cchemilib/src/Utils/CLProp.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* CLProp.c */
#include <stdio.h>
#include <stdlib.h>
#include "../Utils/Types.h"

#ifdef ENABLE_CL
#include <CL/cl.h>
static CLProp clProp={0,0};

/*****************************************************************************************/
CLProp getCLProp()
{
	return clProp;
}
/*****************************************************************************************/
void initCLProp()
{
	cl_context_properties properties[3];
	cl_int err;
	cl_uint num_of_platforms=0;
	cl_platform_id platform_id;
	cl_platform_id pid[2];
	cl_device_id device_id;
	cl_uint num_of_devices=0;
	cl_ulong long_entries;
        size_t p_size;
        cl_uint entries;
	char dname[500];
        cl_uint k;
	if(clProp.context!=0) return; /* already initialized */

	// retreive a list of platforms avaible
	if (clGetPlatformIDs(2, pid, &num_of_platforms)!= CL_SUCCESS)
	{
		printf("Unable to get CL platform_id\n");
		exit(1);
	}
	printf("num_of_platforms=%d\n",num_of_platforms);
#ifdef CPU_CL
	platform_id = pid[1];
	// try to get a supported CPU device
	if (clGetDeviceIDs(platform_id, CL_DEVICE_TYPE_CPU, 1, &device_id, &num_of_devices) != CL_SUCCESS)
	{
		printf("Unable to get CL device_id\n");
		exit(1);
	}
#else
	platform_id = pid[0];
	// try to get a supported GPU device
	if (clGetDeviceIDs(platform_id, CL_DEVICE_TYPE_GPU, 1, &device_id, &num_of_devices) != CL_SUCCESS)
	{
		printf("Unable to get CL device_id\n");
		exit(1);
	}
#endif

	/* printf("num_of_devices=%d\n",num_of_devices);*/
	clGetPlatformInfo(platform_id,CL_PLATFORM_NAME,500,dname,NULL);
	printf("CL_PLATFORM_NAME = %s\n", dname);
	clGetPlatformInfo(platform_id,CL_PLATFORM_VERSION,500,dname,NULL);
	printf("CL_PLATFORM_VERSION = %s\n", dname);
	{
		clGetDeviceInfo(device_id, CL_DEVICE_NAME, 500, dname,NULL);
		printf("Device name = %s\n", dname);
		clGetDeviceInfo(device_id,CL_DRIVER_VERSION, 500, dname,NULL);
		printf("\tDriver version = %s\n", dname);
		clGetDeviceInfo(device_id,CL_DEVICE_GLOBAL_MEM_SIZE,sizeof(cl_ulong),&long_entries,NULL);
		printf("\tGlobal Memory (MB):\t%llu\n",long_entries/1024/1024);
		clGetDeviceInfo(device_id,CL_DEVICE_GLOBAL_MEM_CACHE_SIZE,sizeof(cl_ulong),&long_entries,NULL);
		printf("\tGlobal Memory Cache (MB):\t%llu\n",long_entries/1024/1024);
		clGetDeviceInfo(device_id,CL_DEVICE_LOCAL_MEM_SIZE,sizeof(cl_ulong),&long_entries,NULL);
		printf("\tLocal Memory (KB):\t%llu\n",long_entries/1024);
		clGetDeviceInfo(device_id,CL_DEVICE_MAX_CLOCK_FREQUENCY,sizeof(cl_ulong),&long_entries,NULL);
		printf("\tMax clock (MHz) :\t%llu\n",long_entries);
		clGetDeviceInfo(device_id,CL_DEVICE_MAX_WORK_GROUP_SIZE,sizeof(size_t),&p_size,NULL);
		printf("\tMax Work Group Size:\t%d\n",p_size);
		clGetDeviceInfo(device_id,CL_DEVICE_MAX_COMPUTE_UNITS,sizeof(cl_uint),&entries,NULL);
		printf("\tNumber of parallel compute cores:\t%d\n",entries);
		clGetDeviceInfo(device_id,CL_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR,sizeof(cl_uint),&k,NULL);
		printf("\tCL_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR : \t%d\n",k);
		clGetDeviceInfo(device_id,CL_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT,sizeof(cl_uint),&k,NULL);
		printf("\tCL_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT : \t%d\n",k);
		clGetDeviceInfo(device_id,CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT,sizeof(cl_uint),&k,NULL);
		printf("\tCL_DEVICE_PREFERRED_VECTOR_WIDTH_INT : \t%d\n",k);
		clGetDeviceInfo(device_id,CL_DEVICE_PREFERRED_VECTOR_WIDTH_LONG,sizeof(cl_uint),&k,NULL);
		printf("\tCL_DEVICE_PREFERRED_VECTOR_WIDTH_LONG : \t%d\n",k);
		clGetDeviceInfo(device_id,CL_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT,sizeof(cl_uint),&k,NULL);
		printf("\tCL_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT : \t%d\n",k);
		clGetDeviceInfo(device_id,CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE,sizeof(cl_uint),&k,NULL);
		printf("\tCL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE : \t%d\n",k);
	}



	// context properties list - must be terminated with 0
	properties[0]= CL_CONTEXT_PLATFORM;
	properties[1]= (cl_context_properties) platform_id;
	properties[2]= 0;

	// create a context with the GPU device
	clProp.context = clCreateContext(properties,1,&device_id,NULL,NULL,&err);

	// create command queue using the context and device
	clProp.command_queue = clCreateCommandQueue(clProp.context, device_id, 0, &err);
	clProp.device_id = device_id;
}
/*****************************************************************************************/
void freeCLProp()
{
	clReleaseCommandQueue(clProp.command_queue);
	clReleaseContext(clProp.context);
}
void printErrorCLRun(cl_int err)
{
switch(err)
{
case CL_INVALID_PROGRAM_EXECUTABLE : printf("there is no successfully built program executable available for device associated with command_queue\n"); break;
case CL_INVALID_COMMAND_QUEUE :  printf("command_queue is not a valid command-queue.\n");  break;
case CL_INVALID_KERNEL :  printf("kernel is not a valid kernel object.\n");  break;
case CL_INVALID_CONTEXT :  printf("context associated with command_queue and kernel is not the same or if the context associated with command_queue and events in event_wait_list are not the same.\n");  break;
case CL_INVALID_KERNEL_ARGS :  printf("the kernel argument values have not been specified.\n");  break;
case CL_INVALID_WORK_DIMENSION :  printf("work_dim is not a valid value (i.e. a value between 1 and 3).\n");  break;
case CL_INVALID_WORK_GROUP_SIZE :  printf("local_work_size is specified and number of work-items specified by global_work_size is not evenly divisable by size of work-group given by local_work_size or does not match the work-group size specified for kernel using the __attribute__((reqd_work_group_size(X, Y, Z))) qualifier in program source.\n");  break;
printf("local_work_size is specified and the total number of work-items in the work-group computed as local_work_size[0] *... local_work_size[work_dim - 1] is greater than the value specified by CL_DEVICE_MAX_WORK_GROUP_SIZE in the table of OpenCL Device Queries for clGetDeviceInfo.\n");  break;
 printf("local_work_size is NULL and the __attribute__((reqd_work_group_size(X, Y, Z))) qualifier is used to declare the work-group size for kernel in the program source.\n");  break;
case CL_INVALID_WORK_ITEM_SIZE :  printf("the number of work-items specified in any of local_work_size[0], ... local_work_size[work_dim - 1] is greater than the corresponding values specified by CL_DEVICE_MAX_WORK_ITEM_SIZES[0], .... CL_DEVICE_MAX_WORK_ITEM_SIZES[work_dim - 1].\n");  break;
case CL_INVALID_GLOBAL_OFFSET :  printf("global_work_offset is not NULL.\n");  break;
case CL_OUT_OF_RESOURCES :  printf("there is a failure to queue the execution instance of kernel on the command-queue because of insufficient resources needed to execute the kernel. For example, the explicitly specified local_work_size causes a failure to execute the kernel because of insufficient resources such as registers or local memory. Another example would be the number of read-only image args used in kernel exceed the CL_DEVICE_MAX_READ_IMAGE_ARGS value for device or the number of write-only image args used in kernel exceed the CL_DEVICE_MAX_WRITE_IMAGE_ARGS value for device or the number of samplers used in kernel exceed CL_DEVICE_MAX_SAMPLERS for device.\n");  break;
case CL_MEM_OBJECT_ALLOCATION_FAILURE :  printf("there is a failure to allocate memory for data store associated with image or buffer objects specified as arguments to kernel.\n");  break;
case CL_INVALID_EVENT_WAIT_LIST :  printf("event_wait_list is NULL and num_events_in_wait_list > 0, or event_wait_list is not NULL and num_events_in_wait_list is 0, or if event objects in event_wait_list are not valid events.\n");  break;
case CL_OUT_OF_HOST_MEMORY :  printf("there is a failure to allocate resources required by the OpenCL implementation on the host.\n"); break;
default:;
}
}
#endif



File: ./cchemilib/src/Utils/HydrogenBond.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/*HydrogenBond.c*/
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include "../Utils/Types.h"
#include "../Utils/Utils.h"

static int nAtomsCanConnect = 6;
static char** atomsCanConnect = NULL;
static double minDistance = 1.50; /* in Agnstrom */
static double maxDistance = 3.15; /* in Agnstrom */ 
static double minAngle = 145.0;
static double maxAngle = 215.0;

/************************************************************************/
void initHBondsProperties()
{
	nAtomsCanConnect = 6;
	atomsCanConnect = malloc(nAtomsCanConnect*sizeof(char*));
	atomsCanConnect[0] = strdup("N");
	atomsCanConnect[1] = strdup("O");
	atomsCanConnect[2] = strdup("F");
	atomsCanConnect[3] = strdup("Cl");
	atomsCanConnect[4] = strdup("Br");
	atomsCanConnect[5] = strdup("I");
	minDistance = 1.50; /* in Agnstrom */
	maxDistance = 3.15; /* in Agnstrom */ 
	minAngle = 145.0;
	maxAngle = 215.0;
}
/******************************************************************/
void saveHBondsProperties()
{
	char *hbondsfile;
	FILE *file;
	int i;

	hbondsfile = strdup_printf("%s%shbonds.txt",cchemiDirectory(),DIR_SEPARATOR_S);

	file = fopen(hbondsfile, "w");
	if(!file) return;

 	fprintf(file,"%f\n",minDistance);
 	fprintf(file,"%f\n",maxDistance);
 	fprintf(file,"%f\n",minAngle);
 	fprintf(file,"%f\n",maxAngle);
 	fprintf(file,"%d\n",nAtomsCanConnect);
	for(i=0;i<nAtomsCanConnect;i++) fprintf(file,"%s\n",atomsCanConnect[i]);
	fclose(file);

	free(hbondsfile);
}
/******************************************************************/
void readHBondsProperties()
{
	char *hbondsfile;
	FILE *file;
	int n;
	int i;

	initHBondsProperties();
	hbondsfile = strdup_printf("%s%shbonds.txt",cchemiDirectory(),DIR_SEPARATOR_S);

	file = fopen(hbondsfile, "r");
	if(!file) return;

 	n = fscanf(file,"%lf\n",&minDistance);
	if(n != 1) { initHBondsProperties(); return ; fclose(file); free(hbondsfile);}

 	n = fscanf(file,"%lf\n",&maxDistance);
	if(n != 1) { initHBondsProperties(); return ; fclose(file); free(hbondsfile);}

 	n = fscanf(file,"%lf\n",&minAngle);
	if(n != 1) { initHBondsProperties(); return ; fclose(file); free(hbondsfile);}
 	n = fscanf(file,"%lf\n",&maxAngle);
	if(n != 1) { initHBondsProperties(); return ; fclose(file); free(hbondsfile);}

 	n = fscanf(file,"%d\n",&nAtomsCanConnect);
	if(n != 1 || nAtomsCanConnect<0 ) { initHBondsProperties(); return ; fclose(file); free(hbondsfile);}

	for(i=0;i<nAtomsCanConnect;i++)
	{
 		n = fscanf(file,"%s\n",atomsCanConnect[i]);
		if(n != 1) { initHBondsProperties(); return ; fclose(file); free(hbondsfile);}
		deleteLastSpaces(atomsCanConnect[i]);
		deleteFirstSpaces(atomsCanConnect[i]);
		strDeleten(atomsCanConnect[i]);
	}

	fclose(file);

	free(hbondsfile);
}
/************************************************************************/
double getMinDistanceHBonds()
{
	return minDistance;
}
/************************************************************************/
double getMaxDistanceHBonds()
{
	return maxDistance;
}
/************************************************************************/
double getMinAngleHBonds()
{
	return minAngle;
}
/************************************************************************/
double getMaxAngleHBonds()
{
	return maxAngle;
}
/************************************************************************/
boolean atomCanDoHydrogenBond(char* symbol)
{
	int k;
	for(k=0;k<nAtomsCanConnect;k++) if(strcmp(symbol,atomsCanConnect[k])==0) return TRUE;
	return FALSE;
}
/************************************************************************/
File: ./cchemilib/src/Utils/CalculTypesAmber.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* CalculTypesAmber.c */
#include <stdlib.h>
#include <string.h>
#include <math.h>

#include "../Utils/Types.h"
#include "../Utils/Constants.h"
#include "../Utils/Timer.h"
#include "../Utils/Utils.h"
#include "../Utils/AtomsProp.h"
#include "../Utils/SList.h"
#include "../Utils/HydrogenBond.h"
#include "../Molecule/Molecule.h"

/**********************************************************************************************************/
typedef struct _MoleculeData MoleculeData;
struct _MoleculeData
{
	Molecule* mol;
	SList* bondsList;
	int* numberOfDoubleBonds;
	int* numberOfTripleBonds;
	int **connected;
	boolean *inStack;
	boolean doneRing;
	int nBondsRing;
};
/************************************************************************/
static boolean bonded(Molecule* mol, int i,int j)
{
	double distance;
	int k;
	double dif[3];
	for(k=0;k<3;k++) dif[k] = mol->atoms[i].coordinates[k] - mol->atoms[j].coordinates[k];
	distance = 0;
	for(k=0;k<3;k++) distance += dif[k]*dif[k];
	distance = sqrt(distance); 
	distance *= ANGTOBOHR;
	if(distance<(mol->atoms[i].prop.covalentRadii + mol->atoms[j].prop.covalentRadii)) return TRUE;
	else return FALSE;
}
/************************************************************************/
static boolean hbonded(Molecule* mol, int nAtoms, int i,int j)
{
	double minDistanceH;
	double maxDistanceH;
	double minDistanceH2;
	double maxDistanceH2;
	double minAngleH;
	double maxAngleH;
	double distance2;
	double angle;
	double A[3];
	double B[3];
	double dif[3];

	int k;
	int kH;
	int kO;
	int c;

	if(!strcmp(mol->atoms[i].prop.symbol,"H"))
	{
		kH = i;
		kO = j;
		if(!atomCanDoHydrogenBond(mol->atoms[j].prop.symbol)) return FALSE;
	}
	else
	{
		if(!strcmp(mol->atoms[j].prop.symbol,"H"))
		{
			kH = j;
			kO = i;
			if(!atomCanDoHydrogenBond(mol->atoms[i].prop.symbol)) return FALSE;
		}
		else return FALSE;
	}
	minDistanceH = getMinDistanceHBonds();
	minDistanceH2 = minDistanceH*minDistanceH;

	maxDistanceH = getMaxDistanceHBonds();
	maxDistanceH2 = maxDistanceH*maxDistanceH;

	minAngleH = getMinAngleHBonds();
	maxAngleH = getMaxAngleHBonds();

	distance2 = 0;
	for(k=0;k<3;k++) distance2 += dif[k]*dif[k];

	if(distance2<minDistanceH2 || distance2>maxDistanceH2) return FALSE;

	for(k=0;k<nAtoms;k++)
	{
		if(k==kH) continue;
		if(k==kO) continue;
		/* angle kO, kH, connection to kH */
		if(!bonded(mol, kH,k)) continue;

		for(c=0;c<3;c++) A[c] = mol->atoms[kO].coordinates[c]-mol->atoms[kH].coordinates[c];
		for(c=0;c<3;c++) B[c] = mol->atoms[k].coordinates[c]-mol->atoms[kH].coordinates[c];

		angle = getAngleVectors(A,B);
		if(angle>=minAngleH &&angle<=maxAngleH) return TRUE;
	}
	return FALSE;
}
/************************************************************************/
static void freeBonds(SList* bondsList)
{
	if(!bondsList) return;
	bondsList->klass->destroy(bondsList);
}
/************************************************************************/
static void setMultipleBonds(MoleculeData* m, int* nBonds)
{
	SList* bondsList = m->bondsList;
	Molecule* mol = m->mol;
        LNode *target;

	if(!bondsList) return;

        target = bondsList->head;
	while(target)
	{
		BondType* data=(BondType*)target->data;
		int i = data->n1;
		int j = data->n2;
		if(data->bondType == CCHEMI_BONDTYPE_HYDROGEN) continue;
		if(
		 nBonds[i] < mol->atoms[i].prop.maximumBondValence -1 &&
		 nBonds[j] < mol->atoms[j].prop.maximumBondValence -1 
		)
		{
			data->bondType = CCHEMI_BONDTYPE_TRIPLE;
			nBonds[i] += 2;
			nBonds[j] += 2;
		}
		else
		if(
		 nBonds[i] < mol->atoms[i].prop.maximumBondValence &&
		 nBonds[j] < mol->atoms[j].prop.maximumBondValence 
		)
		{
			data->bondType = CCHEMI_BONDTYPE_DOUBLE;
			nBonds[i] += 1;
			nBonds[j] += 1;
		}

		target = target->next;
	}
}
/************************************************************************/
static boolean buildBonds(MoleculeData* m, boolean buildHbonds)
{
	int i;
	int j;
	Molecule* mol = m->mol;
	int nAtoms = mol->nAtoms;
	int* nBonds = NULL;
	m->bondsList = newSList();
	if(nAtoms<1) return FALSE;

	nBonds =malloc(nAtoms*sizeof(int));
	for(i = 0;i<nAtoms;i++) nBonds[i] = 0;
	for(i = 0;i<nAtoms;i++)
	{
		for(j=i+1;j<nAtoms;j++)
			if(bonded(mol, i,j))
			{
				BondType* A=malloc(sizeof(BondType));
				A->n1 = i;
				A->n2 = j;
				nBonds[i]++;
				nBonds[j]++;
				A->bondType = CCHEMI_BONDTYPE_SINGLE;
				m->bondsList->klass->append(m->bondsList,A);
			}
		        else
			if(buildHbonds && hbonded(mol, nAtoms, i,j))
			{
				BondType* A=malloc(sizeof(BondType));
				A->n1 = i;
				A->n2 = j;
				A->bondType = CCHEMI_BONDTYPE_HYDROGEN;
				m->bondsList->klass->append(m->bondsList,A);
			}
	  }
	setMultipleBonds(m, nBonds);
	free(nBonds);
	nBonds = NULL;
	return TRUE;
}
/************************************************************************/
static void freeStack(MoleculeData* m)
{
	if(!m) return;
	if(m->inStack) free(m->inStack);
	m->inStack = NULL;
}
/************************************************************************/
static void initStack(MoleculeData* m)
{
	int i;
	if(!m) return;
	freeStack(m);
	m->inStack = malloc(m->mol->nAtoms*sizeof(boolean));
	for(i=0;i<m->mol->nAtoms;i++) m->inStack[i] = FALSE;
}
/************************************************************************/
static void freeConnections(MoleculeData* m)
{
	int i;
	if(!m->connected) return;
	for(i=0;i< m->mol->nAtoms;i++)
	{
		if(m->connected[i]) free(m->connected[i]);
	}
	free(m->connected);
	m->connected = NULL;
}
/************************************************************************/
/*
static void printConnections(MoleculeData* m)
{
	int nAtoms = m->nAtoms;
	int i = 0;
	int j = 0;
	int** connected = m->connected;
	for(i=0;i<nAtoms;i++)
	{
		printf("Nc = %d : ", i+1);
		for(j=0;j<connected[i][0];j++)
			printf(" %d ",connected[i][j+1]+1);
		printf("\n");
	}
}
*/
/************************************************************************/
static void buildConnections(MoleculeData* m)
{
	int nAtoms = m->mol->nAtoms;
	SList* bondsList = m->bondsList;
	int i = 0;
	int k = 0;
	int** connected = NULL;
        LNode *target;
	if(!bondsList) return;
	connected = malloc(nAtoms*sizeof(int*));
	for(i=0;i<nAtoms;i++)
	{
		connected[i] = malloc((nAtoms+1)*sizeof(int));
		connected[i][0] = 0;
	}
        target = bondsList->head;
	while(target)
	{
		BondType* data=(BondType*)target->data;
		int i = data->n1;
		int j = data->n2;

		connected[i][0]++;
		connected[j][0]++;

		k = connected[i][0];
		connected[i][k]=j;

		k = connected[j][0];
		connected[j][k]=i;
		target = target->next;
	}
	m->connected = connected;
}
/************************************************************************/
static boolean inRingRecursive(MoleculeData* m, int currentAtom, int rootAtom, int ringSize, boolean begin)
{
	int i;
	int** connected = m->connected;

	if(!begin) m->inStack[currentAtom] = TRUE;

	if (m->doneRing) return TRUE;
	else if ( ( currentAtom == rootAtom ) && ( m->nBondsRing == ringSize ) ) return TRUE;
	else if ( ( currentAtom == rootAtom ) && ( m->nBondsRing > 2 ) && ( ringSize < 3 ) ) return TRUE;
	if ( m->nBondsRing < ringSize )
	{
		int numberOfConnections = connected[ currentAtom ][ 0 ];
		for (i = 1; i <= numberOfConnections; i++ )
		{
			int newAtom = connected[currentAtom][i];
			if ( ! ( m->inStack[newAtom] ) )
			{
				m->nBondsRing++;
				m->doneRing = inRingRecursive( m, newAtom, rootAtom, ringSize, FALSE);
			}
			if (m->doneRing) return TRUE;
		}
	}
	m->inStack[currentAtom] = FALSE;
	m->nBondsRing--;
	return FALSE;
}
/************************************************************************/
static boolean atomInRing(MoleculeData* m, int numAtom, int ringSize)
{
	m->doneRing = FALSE;
	m->nBondsRing = 0;
	initStack(m);
	if(!m->connected) return FALSE;
	return inRingRecursive( m, numAtom,  numAtom, ringSize, TRUE);
}
/************************************************************************/
static boolean allCarbon(MoleculeData* m)
{
	Molecule* mol = m->mol;
	int i;
	for(i=0;i<mol->nAtoms;i++)
		if(m->inStack[i] && strcmp(mol->atoms[i].prop.symbol,"C" )) return FALSE;
	return TRUE;
}
/************************************************************************/
static char* subString(char* str, int begin, int end)
{
	char* res = NULL;
	int i;
	int l = strlen(str);
	int l2 = 0;
	if(l<begin) return NULL;
	if(l<end) end = l;
	if(end<0) end = l;
	l2 = end - begin + 1;
	res= malloc((l2+1)*sizeof(char));
	for(i=0;i<l2;i++) res[i] = str[i+begin];
	res[l2] = '\0';
	return res;
}
/************************************************************************/
static char getCharFromString(char* str, int index)
{
	int l = 0;
	if(!str) return '\0';
	l = strlen(str);
	if(l<=index) return '\0';
	return str[index];
}
/************************************************************************/
static boolean bondedType(MoleculeData* m, int atom1, int atom2, CChemIBondType type)
{
	SList* bondsList= m->bondsList;
        LNode *target;
	if(!bondsList) return FALSE;
        target = bondsList->head;
	while(target)
	{
		BondType* data=(BondType*)target->data;
		int i = data->n1;
		int j = data->n2;
		if( (i== atom1 && j == atom2 ) || (j== atom1 && i == atom2 ) )
		{
			if(data->bondType == type ) return TRUE;
		}
		target = target->next;
	}
	return FALSE;
}
/************************************************************************/
static int numberOfConnectedTypes( MoleculeData* m, int atomA, char* name )
{
	Molecule* mol = m->mol;
	int numberOfConnections = m->connected[ atomA ][ 0 ];
	int numberMatching = 0;
	int i;
	if(!name) return 0;
	if (!strcmp(name,"*")) return numberOfConnections;
	for ( i = 1; i <= numberOfConnections; i++ )
	{
		int atomB = m->connected[ atomA ][ i ];
		if ( !strcmp(mol->atoms[atomB].prop.symbol,name ))
			numberMatching++;
	}
	return( numberMatching );
}
/************************************************************************/
int sp(MoleculeData*m, int atomNumber)
{
	int i;
	int spHybridation = 0;
	int totalNumberOfBonds = 0;


	if(!m->connected) return 0;
	totalNumberOfBonds = m->connected[ atomNumber ][ 0 ];
	if ( m->numberOfTripleBonds[atomNumber] >= 1 ) return 1;
	else if ( m->numberOfDoubleBonds[atomNumber] >= 2 ) return 1;
	else if ( m->numberOfDoubleBonds[atomNumber] == 1 ) spHybridation += 2;
	for (  i = 1; i < totalNumberOfBonds; i++ )
	{
		int bondedToAtomNumber = m->connected[ atomNumber ][ i ];
		if (m->numberOfTripleBonds[bondedToAtomNumber] >= 1 ) return 1;
		else if ( bondedType( m, bondedToAtomNumber, atomNumber, CCHEMI_BONDTYPE_DOUBLE )) spHybridation += 2;
	}
	if ( ( spHybridation == 2 ) && ( totalNumberOfBonds == 3 ) ) return 2;
	else if ( ( spHybridation == 4 ) && ( totalNumberOfBonds == 2 ) ) return 1;
	return ( totalNumberOfBonds - 1 );
}
/************************************************************************/
static boolean isConnectedTo( MoleculeData* m, int atomA, char* expression, boolean initialize )
{
	static boolean* inStack = NULL;
	int i;
	int numberOfConnections;
	char* rootAtom;
	char* restOfExpression;
	char firstChar;
	char lastChar;
	int openClose = 0;
	int begin = 0;
	int multiplicity = 1;
	int bondOrder = 0;
	char* index;
	SList* stack = NULL;
	Molecule* mol = m->mol;

	if ( initialize )
	{
		inStack = realloc(inStack, mol->nAtoms*sizeof(boolean));	
		for( i = 0; i < mol->nAtoms; i++ )
				inStack[ i ] = FALSE;
	}
	inStack[ atomA ] = TRUE;
	if ( expression == NULL ) return TRUE;
	if(!m->connected) return FALSE;
	numberOfConnections = m->connected[ atomA ][ 0 ];
	/* printf("numberOfConnections = %d\n",numberOfConnections);*/

	rootAtom = strdup(expression);
	restOfExpression = NULL;
	index = strstr(expression, "(" );
	if ( index != expression )
	{  /* find the new root atom*/
		if ( index != NULL) 
		{
			int n0 = index - expression;
			int n1 = strlen(expression)-1;
			rootAtom = subString(expression, 0, n0-1); /* "N", e.g. */
			restOfExpression = subString(expression, n0, n1); /*  "(C)(C)", e.g. */
		}
		else
			restOfExpression = NULL;
		/*
		if(!strcmp(mol->atoms[atomA].prop.symbol,"N"))
		{
			if(expression) printf("expression = %s\n", expression);
			printf("rootAtom = %s\n", rootAtom);
			if(restOfExpression) printf("restOfExpression = %s\n", restOfExpression);
			else printf("restOfExpression = NULL\n");
		}
		*/

		firstChar = getCharFromString(rootAtom, 0);
		if(rootAtom) lastChar = getCharFromString(rootAtom, strlen(rootAtom) - 1);
		else lastChar = '\0';
		if ( firstChar != '\0' )
		{
			char* rA = rootAtom;
			if ( firstChar == '-' )
			{
				bondOrder = 1;
				rootAtom = subString(rootAtom, 1, -1);
				if(rA) free(rA);
			}
			else if ( firstChar == '=' )
			{
				bondOrder = 2;
				rootAtom = subString(rootAtom, 1, -1);
				if(rA) free(rA);
			}
			else if ( firstChar == '~')
			{
				bondOrder = 2;
				rootAtom = subString(rootAtom, 1, -1);
				if(rA) free(rA);
			}
			else if ( firstChar == '#' )
			{
				bondOrder = 3;
				rootAtom = subString(rootAtom, 1, -1);
				if(rA) free(rA);
			}
		}
		if ( lastChar  != '\0')
		{
			char* rA = rootAtom;
			if ( lastChar == '2' )
			{
				multiplicity = 2;
				rootAtom = subString(rootAtom, 0, strlen(rootAtom) - 2);
				if(rA) free(rA);
			}
			else if ( lastChar == '3' )
			{
				multiplicity = 3;
				rootAtom = subString(rootAtom, 0, strlen(rootAtom) - 2);
				if(rA) free(rA);
			}
			else if ( lastChar == '4'  )
			{
				multiplicity = 4;
				rootAtom = subString(rootAtom, 0, strlen(rootAtom) - 2);
				if(rA) free(rA);
			}
		}
		if ( multiplicity > numberOfConnectedTypes( m, atomA, rootAtom ) ) return FALSE;
		for (i = 1; i <= numberOfConnections; i++ )
		{
			int atomB = m->connected[ atomA ][ i ];
			if ( inStack[ atomB ] ) continue;
			if ( !strcmp(mol->atoms[atomB ].prop.symbol,rootAtom) || ( !strcmp(rootAtom,"*" ) ) )
			{
				if ( isConnectedTo( m, atomB, restOfExpression, FALSE ) )
				{
					if ( bondOrder == 0 ) return TRUE;
					else if ( bondOrder == 3 )
					{
						if ( ( bondedType( m, atomA, atomB, CCHEMI_BONDTYPE_TRIPLE ) ) || 
						      ( sp(m,  atomA ) == 1 ) || ( sp(m, atomB ) == 1 ) )
								return TRUE;
					}
					else if ( bondOrder == 2 )
					{
						if ( ( bondedType( m, atomA, atomB, CCHEMI_BONDTYPE_DOUBLE ) ) || 
						     ( sp(m, atomA ) == 2 ) || ( sp(m, atomB ) == 2 ) )
								return TRUE;
					}
					else if ( bondOrder == 1 )
					{
						if ( sp(m, atomA ) + sp(m, atomB ) >= 4 ) return TRUE;
					}
				}
			}
		}
		return FALSE;
	} 
	/* below, push (C)(C) onto stack */
	restOfExpression = strdup(expression);
	stack = newSList();
	openClose = 0;
	for (i = 0; i < strlen(restOfExpression); i++ )
	{
		if ( restOfExpression[i] == '(' )
		{
			if ( openClose++ == 0 ) begin = i + 1;
		}
		else if ( restOfExpression[i] == ')' )
		{
			if ( --openClose == 0 ) stack->klass->append(stack,subString(expression, begin, i-1) );
		}
	}
	while ( stack  && stack->size > 0 )
	{
		char* newExpression = NULL;
		LNode* last =  stack->klass->last(stack);
		if(!last || !last->data)
		{
			fprintf(stderr,"Error problem with last stack, stakc size = %d\n",stack->size);
			exit(1);
		}
		newExpression = (char*)(last->data);
		stack->klass->remove(stack, newExpression);
		if ( ! ( isConnectedTo( m, atomA, newExpression, FALSE ) ) ) 
		{
			stack->klass->destroy(stack);
			return FALSE;
		}
		// ? free(newExpression);
	}
	return TRUE;
}
/**********************************************************************************************************/
static char* getAmberTypeOfAtom(MoleculeData* m, int atomNumber)
{
	Molecule* mol = m->mol;
	/* printf("Atom number = %d symbol = %s\n",atomNumber, mol->atoms[atomNumber].prop.symbol);*/
	if ( !strcmp(mol->atoms[atomNumber].prop.symbol,"H" ))
	{
		if (  isConnectedTo( m, atomNumber, "N(*4)", TRUE ) ) return "H";
		else if (  isConnectedTo( m, atomNumber, "N(H)(C(N(H2)))", TRUE ) ) return "H";
		else if ( (  isConnectedTo( m, atomNumber, "N(C(N2))", TRUE ) ) &&
			 isConnectedTo( m, atomNumber, "N(C(N(H2))(N(H2)))", TRUE ) ) return "H";
		else if (  isConnectedTo( m, atomNumber, "C", TRUE ) ) 
		{
			int numberOfConnections = m->connected[ atomNumber ][ 0 ];
			int i;
			for (i = 1; i <= numberOfConnections; i++ )
			{
				int newAtom = m->connected[atomNumber][i];
				if(!strcmp(mol->atoms[newAtom].prop.symbol,"C" ))
				{
					if(atomInRing( m, newAtom, 6 ) && allCarbon(m)) return "HA";
					else if (  isConnectedTo( m, newAtom, "N2", TRUE ) ) return "H5";
					else if (  isConnectedTo( m, newAtom, "N(C)", TRUE ) ) return "H4";
					else if (  isConnectedTo( m, newAtom, "N(H3)", TRUE ) ) return "HP";
					else if (  isConnectedTo( m, newAtom, "N(*)", TRUE ) ) return "H1";
					else if (  isConnectedTo( m, newAtom, "S", TRUE ) ) return "H1";
					else if (  isConnectedTo( m, newAtom, "O", TRUE ) ) return "H1";
				}
			}
			return "HC";
		}
		else if (  isConnectedTo( m, atomNumber, "O(H)", TRUE ) ) return "HW";
		else if (  isConnectedTo( m, atomNumber, "O", TRUE ) ) return "HO";
		else if (  isConnectedTo( m, atomNumber, "S", TRUE ) ) return "HS";
		/*
		else if (  isConnectedTo( m, atomNumber, "N(H)(C(~*))", TRUE ) ) return "H2";
		else if (  isConnectedTo( m, atomNumber, "N(H)(C(=N)(-C))", TRUE ) ) return "H2";
		else if (  isConnectedTo( m, atomNumber, "N(H)(C(=N)(-N))", TRUE ) ) return "H2";
		else if (  isConnectedTo( m, atomNumber, "N(H2)", TRUE ) ) return "H2";
		*/
		else return "H";
	}
	else if ( !strcmp(mol->atoms[atomNumber].prop.symbol,"C" ))
	{
		/* printf("sp = %d\n",sp(m, atomNumber ));*/
		if ( sp(m, atomNumber ) == 2 )
		{
			if ( ( atomInRing( m, atomNumber, 5 ) ) && ( atomInRing( m, atomNumber, 6 ) ) )
			{
				if (  isConnectedTo( m, atomNumber, "C(N)", TRUE ) ) return "CB";
				else if (  isConnectedTo( m, atomNumber, "N(Fe)", TRUE ) ) return "CC";
				else if (  isConnectedTo( m, atomNumber, "N", TRUE ) ) return "CN";
				else return "CT";
			}
			else if ( atomInRing( m, atomNumber, 5 ) )
			{
				if (  isConnectedTo( m, atomNumber, "(C)(C)(C(N(Fe)))", TRUE ) ) return "CB";
				else if ( (  isConnectedTo( m, atomNumber, "(H)(N2)", TRUE ) )
					&& (  isConnectedTo( m, atomNumber, "(N)(H)(N(C(N(C(N(C))))))", TRUE ) ) )
							return "CK";
				else if (  isConnectedTo( m, atomNumber,"(N2)(H)", TRUE ) ) return "CR";
				else if (  isConnectedTo( m, atomNumber,"(C(H2))(N)", TRUE ) ) return "CC";
				else if (  isConnectedTo( m, atomNumber,"C(H2)", TRUE ) ) return "C*";
				else if (  isConnectedTo( m, atomNumber,"N(~*)(*)", TRUE ) ) return "CW";
				else if (  isConnectedTo( m, atomNumber,"N", TRUE ) ) return "CV";
				else return "CT";
			}
			else if (atomInRing( m, atomNumber, 6 ) )
			{
				if (  isConnectedTo( m, atomNumber, "O(H)", TRUE ) ) return "C";
				else if (  isConnectedTo( m, atomNumber, "=O", TRUE ) ) return "C";
				else if (  isConnectedTo( m, atomNumber, "(N2)(H)", TRUE ) ) return "CQ";
				else if (  isConnectedTo( m, atomNumber, "N(H2)", TRUE ) ) return "CA";
				else if (  isConnectedTo( m, atomNumber, "C(N(C(=O)))", TRUE ) ) return "CM";
				else if (  isConnectedTo( m, atomNumber, "N(C(=O))", TRUE ) ) return "CM";
				else return "CA";
			}
			else if (  isConnectedTo( m, atomNumber, "(~O2)", TRUE ) ) return "C";
			else if (  isConnectedTo( m, atomNumber, "=O", TRUE ) ) return "C";
			else if (  isConnectedTo( m, atomNumber, "(=C)(-S)", TRUE ) ) return "CY";
			/*else if (  isConnectedTo( m, atomNumber, "(=C)", TRUE ) ) return "CX";*/
			else if (  isConnectedTo( m, atomNumber, "(N3)", TRUE ) ) return "CA";
			else return "CT";
		}
		else if ( sp(m, atomNumber ) == 3 )
		{
			if (  isConnectedTo( m, atomNumber, "(N3)", TRUE ) ) return "CA";
			else if (  isConnectedTo( m, atomNumber, "=O", TRUE ) ) return "C";
			else if (  isConnectedTo( m, atomNumber, "(=C)(-S)", TRUE ) ) return "CY";
			/* else if (  isConnectedTo( m, atomNumber, "(=C)", TRUE ) ) return "CT";*/
			else return "CT";
		}
		else { 
			if (  isConnectedTo( m, atomNumber, "(N3)", TRUE ) ) return "CA";
			else if (  isConnectedTo( m, atomNumber, "=O", TRUE ) ) return "C";
			else if (  isConnectedTo( m, atomNumber, "(=C)(-S)", TRUE ) ) return "CY";
			/* else if (  isConnectedTo( m, atomNumber, "(=C)", TRUE ) ) return "CX";*/
			else if (  isConnectedTo( m, atomNumber, "#C", TRUE ) ) return "CZ";
			else return "CT";
		}
	}
	else if ( !strcmp(mol->atoms[atomNumber].prop.symbol,"N" ) )
	{
		if ( sp(m, atomNumber ) < 3 )
		{
			if ( atomInRing( m, atomNumber, 5 ) )
			{
				if ( (  isConnectedTo( m, atomNumber, "(C3)", TRUE ) ) && 
				     (  isConnectedTo( m, atomNumber, "(C)(C(=*))(C(=*))", TRUE ) ) ) return "N*";
				else if (  isConnectedTo( m, atomNumber, "(C3)", TRUE ) ) return "N*";
				else if (  isConnectedTo( m, atomNumber, "Fe", TRUE ) ) return "NA";
				else if (  isConnectedTo( m, atomNumber, "H", TRUE ) ) return "NA";
				else return "NB";
			}
			else if (atomInRing( m, atomNumber, 6 ) )
			{
				if (  isConnectedTo( m, atomNumber, "H", TRUE ) ) return "NA";
				else if ( (  isConnectedTo( m, atomNumber, "(H)(C2)", TRUE ) ) 
					&& (  isConnectedTo( m, atomNumber, "(H)(C(=O))(C(=O))", TRUE ) ) ) return "NA";
				else if (  isConnectedTo( m, atomNumber, "(H)(C(=O))(C(=N))", TRUE ) ) return "NA";
				else if (  isConnectedTo( m, atomNumber, "(C3)", TRUE ) ) return "N*";
				else return "NC";
			}
			else if (  isConnectedTo( m, atomNumber, "-C(=O)", TRUE ) ) 
			{
				return "N";
			}
			else if (  isConnectedTo( m, atomNumber, "-C(-C(=O))", TRUE ) )
			{
				return "N";
			}
			else if (  isConnectedTo( m, atomNumber, "C(N2)", TRUE ) ) return "N2";
			else if (  isConnectedTo( m, atomNumber, "(H2)(C~*)", TRUE ) ) return "N2";
			else if (  isConnectedTo( m, atomNumber, "(H2)(C=*)", TRUE ) ) return "N2";
			else return "NT";
		}
		else if ( sp(m, atomNumber ) == 3 ) return "N3";
		else return "NT";
	}
	else if ( !strcmp(mol->atoms[atomNumber].prop.symbol,"O" ))
	{
		if (  isConnectedTo( m, atomNumber, "~C(~O2)", TRUE ) ) 
		{
			if (  isConnectedTo( m, atomNumber, "H", TRUE ) ) return "OH";
			else return "O2";
		}
		else if (  isConnectedTo( m, atomNumber, "H2", TRUE ) ) return "OW";
		else if (  isConnectedTo( m, atomNumber, "H", TRUE ) ) return "OH";
		else if (  isConnectedTo( m, atomNumber, "=C", TRUE ) ) return "O";
		else if (  isConnectedTo( m, atomNumber, "(H)(C(=O))", TRUE ) ) return "OH";
		else if (  isConnectedTo( m, atomNumber, "-C2", TRUE ) ) return "OS";
		else if (  isConnectedTo( m, atomNumber, "(C(=O))(C)", TRUE ) ) return "OS";
		else if (  isConnectedTo( m, atomNumber, "(C)(P)", TRUE ) ) return "OS";
		else if (  isConnectedTo( m, atomNumber, "P", TRUE ) ) return "O2";
		else return "OS";
	}
	else if ( !strcmp(mol->atoms[atomNumber].prop.symbol,"F" ) ) return "F";
	else if ( !strcmp(mol->atoms[atomNumber].prop.symbol,"Na" ) ) return "IP";
	else if ( !strcmp(mol->atoms[atomNumber].prop.symbol,"Mg" )) return "MG";
	else if ( !strcmp(mol->atoms[atomNumber].prop.symbol,"P" ) ) return "P";
	else if ( !strcmp(mol->atoms[atomNumber].prop.symbol,"S" ) )
	{
		if (  isConnectedTo( m, atomNumber, "H", TRUE ) ) return "SH";
		else return "S";
	}
	else if ( !strcmp(mol->atoms[atomNumber].prop.symbol,"Cl" ))
	{
		if ( !m->connected ) return "CL";
		if ( m->connected[ atomNumber ][ 0 ] > 0 ) return "CL";
		else return "IM";
	}
	else if ( !strcmp(mol->atoms[atomNumber].prop.symbol,"Ca" ) ) return "C0";
	else if ( !strcmp(mol->atoms[atomNumber].prop.symbol,"Fe" ) ) return "FE";
	else if ( !strcmp(mol->atoms[atomNumber].prop.symbol,"Cu" ) ) return "CU";
	else if ( !strcmp(mol->atoms[atomNumber].prop.symbol,"Br" ) ) return "BR";
	else if ( !strcmp(mol->atoms[atomNumber].prop.symbol,"I" ) ) return "I";

	return mol->atoms[atomNumber].prop.symbol;
}
/************************************************************************/
static int* getNumberOfBonds(MoleculeData* m, CChemIBondType type)
{
	int i;
	int j;
	SList* bondsList = m->bondsList;
	int nAtoms = m->mol->nAtoms;
	int* numberOfBonds = NULL;
        LNode *target;

	if(nAtoms<1) return NULL;
	numberOfBonds =malloc(nAtoms*sizeof(int));
	for(i = 0;i<nAtoms;i++) numberOfBonds[i] = 0;

        target = bondsList->head;
	while(target)
	{
		BondType* data=(BondType*)target->data;
		i = data->n1;
		j = data->n2;
		if(data->bondType == type) 
		{
			numberOfBonds[i]++;
			numberOfBonds[j]++;
		}
		target = target->next;
	}
	return numberOfBonds;
}
/**********************************************************************************************************/
static MoleculeData getMyMoleculeData(Molecule* mol)
{
	MoleculeData m;
	m.mol = mol;

	m.bondsList = NULL;
	m.connected = NULL;
	m.numberOfDoubleBonds = NULL;
	m.numberOfTripleBonds = NULL;
	m.inStack = NULL;
	m.doneRing = FALSE;
	m.nBondsRing = 0;
	buildBonds(&m, FALSE);
	m.numberOfDoubleBonds = getNumberOfBonds(&m, CCHEMI_BONDTYPE_DOUBLE);
	m.numberOfTripleBonds = getNumberOfBonds(&m, CCHEMI_BONDTYPE_TRIPLE);
	buildConnections(&m);
	/* printConnections(&m);*/
	return m;
}
/**********************************************************************************************************/
static void freeMoleculeData(MoleculeData* m)
{
	free(m->numberOfDoubleBonds);
	free(m->numberOfTripleBonds);
	freeConnections(m);
	freeBonds(m->bondsList);
}
/**********************************************************************************************************/
void calculAmberTypes(Molecule* mol)
{
	int i;
	MoleculeData m;
	if(mol->nAtoms<1) return;
	m = getMyMoleculeData(mol);

	printf("End getMyMoleculeData\n");
	for(i=0;i<mol->nAtoms;i++)
	{
 
		/*
		printf("Atom n = %d symb = %s\n", i+1, mol->atoms[i].prop.symbol);
		if( atomInRing( &m, i, 5 )) printf("atom number %d is in pentagon\n",i+1);
		if( atomInRing( &m, i, 6 )) printf("atom number %d is in hexagon\n",i+1);
		if (  isConnectedTo( &m, i, "C", TRUE ) ) printf("atom number %d  have %s type \n",i+1,"HC");
		printf("mm %s\n", mol->atoms[i].mmType);
		*/

		/* printf("i = %d\n",i);*/
		if(mol->atoms[i].mmType) free(mol->atoms[i].mmType);
		mol->atoms[i].mmType = strdup(getAmberTypeOfAtom(&m, i));
	}
	freeMoleculeData(&m);
}
File: ./cchemilib/src/VPT2/VPT2KModel.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* VPT2KModel.c */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include "../VPT2/VPT2KModel.h"

static boolean printMax = FALSE;
//static boolean printMax = TRUE;

static void computeAnharmonic(VPT2KModel* vpt2KModel);
static void readData(VPT2KModel* vpt2KModel, char* inputFileName);
static void computeHarmonicProp(VPT2KModel* vpt2KModel, int i, double* Pav);
static void computeFundamentalsProp(VPT2KModel* vpt2KModel, int i, double* Pav);
static void computeOvertonesProp(VPT2KModel* vpt2KModel, int i, double* Pav);
static void computeCombinationBandsProp(VPT2KModel* vpt2KModel, int i, int j, double* Pav);
static double K22(VPT2KModel* vpt2KModel, int k, int l, int m, int n);
static int getDiff(VPT2KModel* vpt2KModel, int* v, int* iDiff);
/**********************************************************************/
static int getGround(VPT2KModel* vpt2KModel)
{
        int i,j;
	int jmax = 0;
        VKAnharmonic* vAnharmonic  = &vpt2KModel->vAnharmonic;
	PropertiesKAnharmonic* pAnharmonic = &vpt2KModel->pAnharmonic;
        int nStates = pAnharmonic->nStates;
	i=0;
	{
		for(j=0;j<nStates;j++)
			if(fabs(vAnharmonic->eigenVectors[i][j])>fabs(vAnharmonic->eigenVectors[i][jmax])) jmax = j;
		if(jmax!=0) 
		{
			fprintf(stderr,"\n*******************************************\n");
			fprintf(stderr,"Warning the ground state is not the 0 state\n");
			fprintf(stderr,"E(ground state)=%f\n",vAnharmonic->eigenValues[0]);
			fprintf(stderr,"E(0)=%f\n",vAnharmonic->eigenValues[jmax]);
			fprintf(stderr,"*******************************************\n\n");
		}
	}
	return jmax;
}
/**********************************************************************/
static void printOneState(VPT2KModel* vpt2KModel, int j, int j0,double cutoff)
{
        VKAnharmonic* vAnharmonic  = &vpt2KModel->vAnharmonic;
	PropertiesKAnharmonic* pAnharmonic = &vpt2KModel->pAnharmonic;
        int nFrequencies = vAnharmonic->nFrequencies;
        int nStates = pAnharmonic->nStates;
        int i;
        int k;
	
	printf("%14.8f ",vAnharmonic->harmonicEnergies[j]); 
	printf("%14.8f ",vAnharmonic->eigenValues[j]-vAnharmonic->eigenValues[j0]);
	printf("%14.8f ",pAnharmonic->harmonic[j]);
	printf("%14.8f ",pAnharmonic->anHarmonic[j]);
	printf("    ");
	for(i=0;i<nStates;i++)
	if(fabs(vAnharmonic->eigenVectors[i][j])>cutoff ) 
	{
		printf("[% 5.3f",vAnharmonic->eigenVectors[i][j]);
		for(k=0;k<nFrequencies;k++) 
		{
			if(vAnharmonic->v[i][k]>0) 
			{
				printf(" %2d(%d)",k+1,vAnharmonic->v[i][k]);
			}
		}
		printf("] ");
	}
	printf("\n");
}
/**********************************************************************/
static void printTitles()
{
	printf("%14s ","E(harm)");
	printf("%14s ","E(anharm)");
	printf("%14s ","I(harm)");
	printf("%14s ","I(anharm)");
	printf("    ");
	printf("%s ","  Coef. Mode(Quanta)");
	printf("\n");
	printf("%14s ","------------");
	printf("%14s ","------------");
	printf("%14s ","------------");
	printf("%14s ","------------");
	printf("    ");
	printf("%s ","--------------------");
	printf("\n");
}
/**********************************************************************/
static void printIREnergiesPropCompact(VPT2KModel* vpt2KModel, double cutoff)
{
        int i,j;
        VKAnharmonic* vAnharmonic  = &vpt2KModel->vAnharmonic;
	PropertiesKAnharmonic* pAnharmonic = &vpt2KModel->pAnharmonic;
        int nFrequencies = vAnharmonic->nFrequencies;
        int nStates = pAnharmonic->nStates;
	int j0 = getGround(vpt2KModel);
	int* iDiff = newVectorInt(nFrequencies);
	int nd = 0;
	printf("\n\n");
	printf("Results With intensities\n");
	printf("========================\n");

	printf("\n");
	printf("%s\n","Fundamental Bands");
	printf("%s\n","-----------------");
	printTitles();
	// Fundamentals 
	for(j=0;j<nStates;j++)
	{
		int imax = 0;
		for(i=0;i<nStates;i++)
			if(fabs(vAnharmonic->eigenVectors[i][j])>fabs(vAnharmonic->eigenVectors[imax][j])) imax = i;
		int* v = vpt2KModel->vAnharmonic.v[imax];
		nd = getDiff(vpt2KModel, v, iDiff);
		if(nd!=1 || (nd==1 && v[iDiff[0]]!=1)) continue;
		printOneState(vpt2KModel, j, j0, cutoff);
	}
	printf("\n");
	printf("%s\n","Overtones");
	printf("%s\n","---------");
	printTitles();
	// Overtones 
	for(j=0;j<nStates;j++)
	{
		int imax = 0;
		for(i=0;i<nStates;i++)
			if(fabs(vAnharmonic->eigenVectors[i][j])>fabs(vAnharmonic->eigenVectors[imax][j])) imax = i;
		int* v = vpt2KModel->vAnharmonic.v[imax];
		nd = getDiff(vpt2KModel, v, iDiff);
		if(nd!=1 || (nd==1 &&  v[iDiff[0]]!=2)) continue;
		printOneState(vpt2KModel, j, j0, cutoff);
	}
	// Combinaition 
	printf("\n");
	printf("%s\n","Combination Bands");
	printf("%s\n","----------------");
	printTitles();
	for(j=0;j<nStates;j++)
	{
		int imax = 0;
		for(i=0;i<nStates;i++)
			if(fabs(vAnharmonic->eigenVectors[i][j])>fabs(vAnharmonic->eigenVectors[imax][j])) imax = i;
		int* v = vpt2KModel->vAnharmonic.v[imax];
		nd = getDiff(vpt2KModel, v, iDiff);
		if(nd!=2) continue;
		printOneState(vpt2KModel, j, j0, cutoff);
	}
	printf("\n");
	free(iDiff);
}
/**********************************************************************/
static void printIREnergiesPropCompact2(VPT2KModel* vpt2KModel, double cutoff)
{
        int i,j;
        int k;
        VKAnharmonic* vAnharmonic  = &vpt2KModel->vAnharmonic;
	PropertiesKAnharmonic* pAnharmonic = &vpt2KModel->pAnharmonic;
        int nFrequencies = vAnharmonic->nFrequencies;
        int nStates = pAnharmonic->nStates;
	int j0 = getGround(vpt2KModel);
	printf("\n\n");
	printf("Results With intensities\n");
	printf("========================\n");
	printf("%14s ","E(harm)");
	printf("%14s ","E(anharm)");
	printf("%14s ","I(harm)");
	printf("%14s ","I(anharm)");
	printf("    ");
	printf("%s ","Coef Mode(Quanta)");
	printf("\n");
	printf("%14s ","-------");
	printf("%14s ","---------");
	printf("%14s ","-------");
	printf("%14s ","---------");
	printf("    ");
	printf("%s ","----------------");
	printf("\n");
	for(j=0;j<nStates;j++)
	{
		printf("%14.8f ",vAnharmonic->harmonicEnergies[j]); 
		printf("%14.8f ",vAnharmonic->eigenValues[j]-vAnharmonic->eigenValues[j0]);
		printf("%14.8f ",pAnharmonic->harmonic[j]);
		printf("%14.8f ",pAnharmonic->anHarmonic[j]);
		printf("    ");
		for(i=0;i<nStates;i++)
		if(fabs(vAnharmonic->eigenVectors[i][j])>cutoff ) 
		{
			printf("[% 5.3f",vAnharmonic->eigenVectors[i][j]);
			for(k=0;k<nFrequencies;k++) 
			{
				if(vAnharmonic->v[i][k]>0) 
				{
					printf(" %2d(%d)",k+1,vAnharmonic->v[i][k]);
				}
			}
			printf("] ");
		}
		printf("\n");
	}
	printf("\n");
}
/**********************************************************************/
/*
static void printIREnergiesCompact(VPT2KModel* vpt2KModel)
{
	int i,j,k;
        VKAnharmonic* vAnharmonic  = &vpt2KModel->vAnharmonic;
	int nFrequencies = vAnharmonic->nFrequencies;
	int nStates = vAnharmonic->nStates;
	int j0 = getGround(vpt2KModel);
	printf("\n\n");
	printf("Results Compact\n");
	printf("===============\n");
	for(i=0;i<nStates;i++)
	{
		int jmax;
		for(k=0;k<nFrequencies;k++)
			printf("%2d ",vAnharmonic->v[i][k]);
		jmax = 0;
		for(j=0;j<nStates;j++)
			if(fabs(vAnharmonic->eigenVectors[i][j])>fabs(vAnharmonic->eigenVectors[i][jmax])) jmax = j;
		printf("%14.8f ",vAnharmonic->eigenValues[jmax]-vAnharmonic->eigenValues[j0]);
		printf("\n");
	}
	printf("\n");
}
*/
/**********************************************************************/
static void printIREnergiesCompact2(VPT2KModel* vpt2KModel, double cutoff)
{
        int i,j;
        int k;
        VKAnharmonic* vAnharmonic  = &vpt2KModel->vAnharmonic;
        int nFrequencies = vAnharmonic->nFrequencies;
	int nStates = vAnharmonic->nStates;
	int j0 = getGround(vpt2KModel);
	printf("\n\n");
	printf("Results\n");
	printf("========================\n");
	printf("%14s ","E(harm)");
	printf("%14s ","E(anharm)");
	printf("    ");
	printf("%s ","Mode(Quanta), Coef");
	printf("\n");
	printf("%14s ","-------");
	printf("%14s ","---------");
	printf("    ");
	printf("%s ","----------------");
	printf("\n");
	for(j=0;j<nStates;j++)
	{
		int imax = 0;
		for(i=0;i<nStates;i++)
		{
			if(fabs(vAnharmonic->eigenVectors[i][j])>fabs(vAnharmonic->eigenVectors[imax][j])) imax = i;
		}
		int* v = vpt2KModel->vAnharmonic.v[imax];
		double E = 0;
		for(k=0;k<nFrequencies;k++)
			E += v[k]*vpt2KModel->vData.hessian[k][k];

		printf("%14.8f ",E);
		printf("%14.8f ",vAnharmonic->eigenValues[j]-vAnharmonic->eigenValues[j0]);
		printf("    ");
		for(i=0;i<nStates;i++)
		if(fabs(vAnharmonic->eigenVectors[i][j])>cutoff ) 
		{
			printf("[% 5.3f",vAnharmonic->eigenVectors[i][j]);
			for(k=0;k<nFrequencies;k++) 
			{
				if(vAnharmonic->v[i][k]>0) 
				{
					printf(" %2d(%d)",k+1,vAnharmonic->v[i][k]);
				}
			}
			printf("] ");
		}
		printf("\n");
	}
	printf("\n");
}
/**********************************************************************/
/*
static void printIREnergies(VKAnharmonic* vAnharmonic)
{
	int i,j,k;
	int nFrequencies = vAnharmonic->nFrequencies;
	int nStates = vAnharmonic->nStates;
	printf("Results\n");
	for(k=0;k<nFrequencies;k++) printf("%2s "," ");
	for(i=0;i<nStates;i++)
		printf("%14.8f ",vAnharmonic->eigenValues[i]);
	printf("\n");
	for(k=0;k<nFrequencies;k++) printf("%2s "," ");
	for(i=0;i<nStates;i++)
		printf("%14.8f ",vAnharmonic->eigenValues[i]-vAnharmonic->eigenValues[0]);
	printf("\n");

	for(i=0;i<nStates;i++)
	{
		for(k=0;k<nFrequencies;k++)
			printf("%2d ",vAnharmonic->v[i][k]);
		for(j=0;j<nStates;j++)
			printf("%14.8f ",vAnharmonic->eigenVectors[i][j]);
		printf("\n");
	}
	printf("\n");
}
*/
/**********************************************************************/
/*
static double D0(VPT2KModel* vpt2KModel, int ii, int jj, int kk)
{
	VPT2PotentialData* data = &vpt2KModel->vData;
	int i=abs(ii)-1;
	int j=abs(jj)-1;
	int k=abs(kk)-1;
	double wi=(ii>0)?data->hessian[i][i]:-data->hessian[i][i];
	double wj=(jj>0)?data->hessian[j][j]:-data->hessian[j][j];
	double wk=(kk>0)?data->hessian[k][k]:-data->hessian[k][k];
	return 1/(wi+wj+wk);
}
*/
/**********************************************************************/
static double D(VPT2KModel* vpt2KModel, int i, int j, int k)
{
	int n = vpt2KModel->vAnharmonic.nFrequencies;
	return vpt2KModel->vAnharmonic.D[i+n][j+n][k+n];
}
/**********************************************************************/
static void setD(VPT2KModel* vpt2KModel, int i, int j, int k, double value, int*** tag, int t)
{
	int n = vpt2KModel->vAnharmonic.nFrequencies;
	vpt2KModel->vAnharmonic.D[i+n][j+n][k+n] = value;
	tag[i+n][j+n][k+n] = t;
}
/**********************************************************************/
static void setDNull(VPT2KModel* vpt2KModel, int ii, int jj, int kk, int***tag)
{
	VPT2PotentialData* data = &vpt2KModel->vData;
	int i=abs(ii);
	int j=abs(jj);
	int k=abs(kk);
	if(data->hessian[j-1][j-1]>data->hessian[i-1][i-1])
	{
		int l=i;
		i=j;
		j=l;
	}
	if(data->hessian[k-1][k-1]>data->hessian[i-1][i-1])
	{
		int l=i;
		i=k;
		k=l;
	}
	setD(vpt2KModel,i,-j,-k,0.0,tag,1);
	setD(vpt2KModel,i,-k,-j,0.0,tag,1);
	setD(vpt2KModel,-j,i,-k,0.0,tag,1);
	setD(vpt2KModel,-j,-k,i,0.0,tag,1);
	setD(vpt2KModel,-k,i,-j,0.0,tag,1);
	setD(vpt2KModel,-k,-j,i,0.0,tag,1);
        setD(vpt2KModel,-i,j,k,0.0,tag,1);
        setD(vpt2KModel,-i,k,j,0.0,tag,1);
        setD(vpt2KModel,j,-i,k,0.0,tag,1);
        setD(vpt2KModel,j,k,-i,0.0,tag,1);
        setD(vpt2KModel,k,-i,j,0.0,tag,1);
        setD(vpt2KModel,k,j,-i,0.0,tag,1);
}
/**********************************************************************/
static boolean testDD(VPT2KModel* vpt2KModel, int ii, int jj, int kk, int ll)
{
	VPT2PotentialData* data = &vpt2KModel->vData;
	int i=abs(ii)-1;
	int k=abs(kk)-1;
	double wi;
	double wk;
	boolean res = FALSE;
	double sik = 0;
	double tolDD = 10.0;

	if(ii!=jj || kk != ll) return FALSE;
	wi=(ii>0)?data->hessian[i][i]:-data->hessian[i][i];
	wk=(kk>0)?data->hessian[k][k]:-data->hessian[k][k];
	sik =wi+wk;
	if(fabs(sik)<tolDD) 
	{
		double Kiikk = K22(vpt2KModel, i, i, k, k);
		if(fabs(Kiikk)>tolDD) res = TRUE;
		else res=FALSE;
		if(res && printMax)
		{
			fprintf(stderr,"Warning Darling-Dennison resonnance : ");
			fprintf(stderr,"i,k = %d %d dw=%f Kiikk=%f tolDD=%f\n",i+1,k+1,sik,Kiikk,tolDD);
		}
	}
	return res;
}
/**********************************************************************/
static double getMaxDiffVPT2Var(VPT2KModel* vpt2KModel, int i, int j, int k, double sijk)
{
	double fijk=getMaxCubicIJK(vpt2KModel->vData.cubic,i,j,k);
	double dijk = fabs(sijk);
	double X = 1e10;
	if(dijk>1e-10)  X = (fijk*fijk*fijk*fijk)/(dijk*dijk*dijk)/64.0;
	if(i==j||i==k||j==k) X *= 0.25;
	return X;
}
/**********************************************************************/
static boolean testFermi(VPT2KModel* vpt2KModel, int ii, int jj, int kk)
{
	VPT2PotentialData* data = &vpt2KModel->vData;
        double maxFrequencyDifferenceFermi = data->maxFrequencyDifferenceFermi;
        double XI = data->parametersResonance[0];
        double XII = data->parametersResonance[1];
        double Z = data->parametersResonance[2];
	int i=abs(ii)-1;
	int j=abs(jj)-1;
	int k=abs(kk)-1;
	double wi;
	double wj;
	double wk;
	double sqrt8=sqrt(1.0/8.0);
	boolean res = FALSE;
	double sijk = 0;

	if(Z<=0 && XI<=0 && XII<=0) 
	{
		XI = 1.0;
		XII = 1.0;
		if(maxFrequencyDifferenceFermi<=0) maxFrequencyDifferenceFermi = 200;
	}

	wi=(ii>0)?data->hessian[i][i]:-data->hessian[i][i];
	wj=(jj>0)?data->hessian[j][j]:-data->hessian[j][j];
	wk=(kk>0)?data->hessian[k][k]:-data->hessian[k][k];
	sijk =wi+wj+wk;
	if(fabs(sijk)<maxFrequencyDifferenceFermi) 
	{
		//printf("fabs(sijk)=%f\n",fabs(sijk));
		if(Z>0)
		{
			double fijk=getMaxCubicIJK(vpt2KModel->vData.cubic,i,j,k)*sqrt8;
			if(i==j||i==k||j==k) fijk *= 0.5;
			if(fijk/fabs(sijk)>Z) 
			{
				res = TRUE;
				if(printMax)
				{
					fprintf(stderr,"Warning Fermi resonnance : ");
                                	fprintf(stderr,"k,l,m = %d %d %d dklm=%f Z=%f Zcut=%f\n",ii,jj,kk,sijk,fijk/fabs(sijk),Z);
				}
			}
		}
		else if(XI>0 && XII>0)
		{
		 	double X =  getMaxDiffVPT2Var(vpt2KModel, i, j, k, sijk);
			//printf("X=%f\n",X);
			if(i==j||i==k||j==k)
			{
				if(X>XI) 
				{
					res = TRUE;
					if(printMax)
					{
						fprintf(stderr,"Warning Fermi resonnance : ");
						fprintf(stderr,"k,l,m = %d %d %d dklm=%f X=%f XI=%f\n",ii,jj,kk,sijk,X,XI);
					}
				}
			}
			else if(X>XII) { 
				res = TRUE;
				if(printMax)
				{
					fprintf(stderr,"Warning Fermi resonnance : ");
					fprintf(stderr,"k,l,m = %d %d %d dklm=%f X=%f XI=%f\n",ii,jj,kk,sijk,X,XI);
				}
			}
		}
		//printf("res = %d\n",res);
	}
	return res;
}
/**********************************************************************/
static void initD(VPT2KModel* vpt2KModel)
{
	int k,l,m;
	VKAnharmonic* vAnharmonic = &vpt2KModel->vAnharmonic;
	VPT2PotentialData* data = &vpt2KModel->vData;
	int n = data->nFrequencies;
	int ires = 0;
	double dMax = 0;
	int*** tag = newCubeInt(2*n+1, 2*n+1, 2*n+1);
	initCubeDouble(vAnharmonic->D, 2*n+1, 2*n+1, 2*n+1, -1.0);
	initCubeInt(tag, 2*n+1, 2*n+1, 2*n+1, 0);

	for(k=-n;k<=n;k++)
	{
		int kk = abs(k)-1;
		double s =(k<0)?-1:1;
		double wk=(kk>=0 && kk<n)?data->hessian[kk][kk]*s:0;
		if(k==0) continue;
		for(l=-n;l<=n;l++)
		{
			int ll = abs(l)-1;
			double s =(l<0)?-1:1;
			double wl=(ll>=0 && ll<n)?data->hessian[ll][ll]*s:0;

			if(l==0) continue;
			for(m=-n;m<=n;m++)
			{
				boolean res = FALSE;
				int mm = abs(m)-1;
				double s =(m<0)?-1:1;
				double wm=(mm>=0 && mm<n)?data->hessian[mm][mm]*s:0;
				if(m==0) continue;
				if(tag[k+n][l+n][m+n]>0) continue;
				res = testFermi(vpt2KModel, k,l,m);
				if(res)
				{
					ires++;
					vAnharmonic->D[k+n][l+n][m+n]=0.0;
					setDNull(vpt2KModel, kk+1, ll+1, mm+1,tag);
				}
				else 
				{
					if(fabs(wk+wl+wm)<1e-10) printf("Error !!!!\n");
					setD(vpt2KModel,k,l,m,1.0/(wk+wl+wm),tag,2);
				}
				if(fabs(vAnharmonic->D[k+n][l+n][m+n])>dMax) dMax = vAnharmonic->D[k+n][l+n][m+n];
			}
		}
	}
	if(printMax)
	{
		fprintf(stderr,"Dmax = %f\n",dMax);
		fprintf(stderr,"nresonance = %d\n",ires);
	}
	/*
	{
		FILE* file =fopen("res.in","w");
		for(k=1;k<n;k++)
		for(l=1;l<=k;l++)
		for(m=1;m<=l;m++)
			if(tag[k+n][-l+n][-m+n]==1) fprintf(file,"%d %d %d\n",k,l,m);
		fclose(file);
	}
	*/
	freeCubeInt(&tag,2*n+1,2*n+1);
	//if(ires>0) exit(1);
}
/**********************************************************************/
//1-2 Resonance (Fermi)
static double K12(VPT2KModel* vpt2KModel, int k, int l, int m)
{
	double fklm=getMaxCubicIJK(vpt2KModel->vData.cubic,k,l,m);
// k;l,l 
	if(l==m) return 0.5*fklm;
// General k;lm
	return fklm;
}
/**********************************************************************/
//2-2 Resonance 
static double K22(VPT2KModel* vpt2KModel, int k, int l, int m, int n)
{
	VPT2PotentialData* data = &vpt2KModel->vData;
	double fklmn = getMaxQuarticIJKL(data->quartic,k,l,m,n);
	double cor = 0;
	int i,c;
	double wk=data->hessian[k][k];
	double wl=data->hessian[l][l];
	double wm=data->hessian[m][m];
	double wn=data->hessian[n][n];
	double K = 0;
//	printf("K22 %d %d %d %d \n",k+1,l+1,m+1,n+1);
//      kk;mm
	if(k==l && m==n)
	{
		double cub1 = 0.0;
		double cub2 = 0.0;
		// double wkm = (wk+wm)/2;
		K = fklmn*0.25;
		cor = 0;
		for(c=0;c<3;c++)
		{
			double xeta=data->coriolis[c][k][m];
			if(fabs(data->coriolis[c][m][k])>fabs(xeta)) xeta=data->coriolis[c][m][k];
			cor += data->Be[c]*xeta*xeta;
		}
		K += -cor*(wk+wm)*(wk+wm)/wk/wm; // as VPT2+K
		//K += -cor*4;
		if(printMax) fprintf(stderr,"2-2 Kkkmm %d %d %d %d cor = %f\n",k+1,l+1,m+1,n+1,K-fklmn*0.25);
		
		for(i=0;i<data->nFrequencies;i++)
		{
			double fkki=getMaxCubicIJK(data->cubic,k,k,i);
			double fmmi=getMaxCubicIJK(data->cubic,m,m,i);
			double fkmi=getMaxCubicIJK(data->cubic,k,m,i);
			
			int kk=k+1;
			int mm=m+1;
			int ii=i+1;
                	cub1 += -1.0/16.0*fkki*fmmi*(D(vpt2KModel,kk,kk,ii)+D(vpt2KModel,-kk,-kk,ii)+D(vpt2KModel,mm,mm,ii)+D(vpt2KModel,-mm,-mm,ii));
                	cub2 += -0.25*fkmi*fkmi*(D(vpt2KModel,kk,-mm,ii)+D(vpt2KModel,-kk,mm,ii));
			
			/*
			double a1 = 4*wi/(wi*wi-4*wkm*wkm);
                	cub1 += -1.0/16.0*fkki*fmmi*a1;
                	cub2 += -0.25*fkmi*fkmi*(2.0/wi);
			*/
		}
		K += cub1;
		K += cub2;
		if(printMax) fprintf(stderr,"2-2 Kkkmm %d %d %d %d cub1 = %f\n",k+1,l+1,m+1,n+1,cub1);
		if(printMax) fprintf(stderr,"2-2 Kkkmm %d %d %d %d cub2 = %f\n",k+1,l+1,m+1,n+1,cub2);
		if(printMax) fprintf(stderr,"2-2 Kkkmm %d %d %d %d K = %f\n",k+1,l+1,m+1,n+1,K);
		return K;
	}
//      kl;mm or kk;lm
	if(k==l || m==n)
	{
		if(m==n) { i=m; m=k;n=l;k=l=i;}
                // m=>n l=>m in paper notation
                l=m;
                m=n;

		wk=data->hessian[k][k];
		wl=data->hessian[l][l];
		wm=data->hessian[m][m];

		K = fklmn*0.5;
		cor = 0;
		for(c=0;c<3;c++)
		{
			double xetakl=data->coriolis[c][k][l];
			double xetakm=data->coriolis[c][k][m];
			if(fabs(data->coriolis[c][l][k])>fabs(xetakl)) xetakl=data->coriolis[c][l][k];
			if(fabs(data->coriolis[c][m][k])>fabs(xetakm)) xetakm=data->coriolis[c][m][k];
			cor += data->Be[c]*xetakl*xetakm;
		}
		K += -2*cor*(wk+wl)*(wk+wm)/wk/sqrt(wl*wm);
		for(i=0;i<data->nFrequencies;i++)
		{
			double fkli=getMaxCubicIJK(data->cubic,k,l,i);
			double fkmi=getMaxCubicIJK(data->cubic,k,m,i);
			double fkki=getMaxCubicIJK(data->cubic,k,k,i);
			double flmi=getMaxCubicIJK(data->cubic,l,m,i);
			int kk=k+1;
			int mm=m+1;
			int ll=l+1;
			int ii=i+1;
                	K += -1.0/8.0*fkki*flmi*(D(vpt2KModel,kk,kk,ii)+D(vpt2KModel,-kk,-kk,ii)+D(vpt2KModel,ll,mm,ii)+D(vpt2KModel,-ll,mm,ii));
                	K += -0.25*fkli*fkmi*(D(vpt2KModel,kk,-ll,ii)+D(vpt2KModel,-kk,ll,ii)+D(vpt2KModel,kk,-mm,ii)+D(vpt2KModel,-kk,mm,ii));
		}
//		printf("2-2 Kkklm %d %d %d %d K = %f\n",k+1,k+1,l+1,m+1,K);
		return K;
	}

// General case kl;mn
		K = fklmn;
		cor = 0;
		for(c=0;c<3;c++)
		{
			double xetakl=getMaxMatrixIJ(data->coriolis[c],k,l);
			double xetakm=getMaxMatrixIJ(data->coriolis[c],k,m);
			double xetakn=getMaxMatrixIJ(data->coriolis[c],k,n);
			double xetalm=getMaxMatrixIJ(data->coriolis[c],l,m);
			double xetaln=getMaxMatrixIJ(data->coriolis[c],l,n);
			double xetamn=getMaxMatrixIJ(data->coriolis[c],m,n);

			cor +=  data->Be[c]*xetakl*xetamn*(wk-wl)*(wm-wn);
			cor += -data->Be[c]*xetakm*xetaln*(wk+wm)*(wl+wn);
			cor += -data->Be[c]*xetakn*xetalm*(wk+wn)*(wl+wm);
		}
		K += 2*cor/sqrt(wk*wl*wm*wn);

		for(i=0;i<data->nFrequencies;i++)
		{
			double fkli=getMaxCubicIJK(data->cubic,k,l,i);
			double fmni=getMaxCubicIJK(data->cubic,m,n,i);
			double fkmi=getMaxCubicIJK(data->cubic,k,m,i);
			double flni=getMaxCubicIJK(data->cubic,l,n,i);
			double fkni=getMaxCubicIJK(data->cubic,k,n,i);
			double flmi=getMaxCubicIJK(data->cubic,l,m,i);
			int kk=k+1;
			int mm=m+1;
			int ll=l+1;
			int nn=n+1;
			int ii=i+1;
                	K += -0.25*fkli*fmni*(D(vpt2KModel,kk,ll,ii)+D(vpt2KModel,mm,nn,ii)+D(vpt2KModel,-kk,-ll,ii)+D(vpt2KModel,-mm,-nn,ii));
                	K += -0.25*fkmi*flni*(D(vpt2KModel,kk,-mm,ii)+D(vpt2KModel,ll,-nn,ii)+D(vpt2KModel,-kk,mm,ii)+D(vpt2KModel,-ll,nn,ii));
                	K += -0.25*fkni*flmi*(D(vpt2KModel,kk,-nn,ii)+D(vpt2KModel,ll,-mm,ii)+D(vpt2KModel,-kk,nn,ii)+D(vpt2KModel,-ll,mm,ii));
		}
//		printf("2-2 Kklmn %d %d %d %d K = %f\n",k+1,l+1,m+1,n+1,K);
	return K;
}
/**********************************************************************/
//1-3 Resonance 
/*
static double K13(VPT2KModel* vpt2KModel, int k, int l, int m, int n)
{
	VPT2PotentialData* data = &vpt2KModel->vData;
	double fklmn = getMaxQuarticIJKL(data->quartic,k,l,m,n);
	double cor = 0;
	int i,c;
	double wk=data->hessian[k][k];
	double wl=data->hessian[l][l];
	double wm=data->hessian[m][m];
	double wn=data->hessian[n][n];
	double K = 0;

//	printf("K13 %d %d %d %d \n",k+1,l+1,m+1,n+1);
//      k;lll
	if(l==m && m==n)
	{
		K = fklmn/6.0;
		cor = 0;
		for(i=0;i<data->nFrequencies;i++)
		{
			double fkli=getMaxCubicIJK(data->cubic,k,l,i);
			double flli=getMaxCubicIJK(data->cubic,l,l,i);
			int kk=k+1;
			int ll=l+1;
			int ii=i+1;
                	K += -1.0/8*fkli*flli*(D(vpt2KModel,kk,-ll,ii)+D(vpt2KModel,-kk,ll,ii)+D(vpt2KModel,ll,ll,ii)+D(vpt2KModel,-ll,-ll,ii));
		}
		return K;
	}
//      k;llm
	if(l==m || m==n || l==n)
	{
		if(l==n) { i=m; m=n;n=i;}// permut m and n
		if(m==n) { i=n; n=l;l=i; }//permut n and l
		K = fklmn*0.5;
		cor = 0;
		for(c=0;c<3;c++)
		{
			double xetakl=getMaxMatrixIJ(data->coriolis[c],k,l);
			double xetalm=getMaxMatrixIJ(data->coriolis[c],l,m);
			cor += data->Be[c]*xetakl*xetalm;
		}
		K += 2*cor*(wk+wl)*(wl-wm)/wl/sqrt(wk*wm);
		for(i=0;i<data->nFrequencies;i++)
		{
			double fkli=getMaxCubicIJK(data->cubic,k,l,i);
			double fkmi=getMaxCubicIJK(data->cubic,k,m,i);
			double flli=getMaxCubicIJK(data->cubic,l,l,i);
			double flmi=getMaxCubicIJK(data->cubic,l,m,i);
			int kk=k+1;
			int mm=m+1;
			int ll=l+1;
			int ii=i+1;
                	K += -1.0/8.0*fkmi*flli*(D(vpt2KModel,ll,ll,ii)+D(vpt2KModel,-ll,-ll,ii)+D(vpt2KModel,kk,-mm,ii)+D(vpt2KModel,-kk,mm,ii));
                	K += -0.25*fkli*flmi*(D(vpt2KModel,kk,-ll,ii)+D(vpt2KModel,-kk,ll,ii)+D(vpt2KModel,ll,mm,ii)+D(vpt2KModel,-ll,-mm,ii));
		}
		return K;
	}

// General case k;lmn
		K = fklmn;
		cor = 0;
		for(c=0;c<3;c++)
		{
			double xetakl=getMaxMatrixIJ(data->coriolis[c],k,l);
			double xetakm=getMaxMatrixIJ(data->coriolis[c],k,m);
			double xetakn=getMaxMatrixIJ(data->coriolis[c],k,n);
			double xetalm=getMaxMatrixIJ(data->coriolis[c],l,m);
			double xetaln=getMaxMatrixIJ(data->coriolis[c],l,n);
			double xetamn=getMaxMatrixIJ(data->coriolis[c],m,n);

			cor +=  data->Be[c]*xetakl*xetamn*(wk+wl)*(wm-wn);
			cor +=  data->Be[c]*xetakm*xetaln*(wk+wm)*(wl-wn);
			cor +=  data->Be[c]*xetakn*xetalm*(wk+wn)*(wl-wn);
		}
		K += cor/sqrt(wk*wl*wm*wn);

		for(i=0;i<data->nFrequencies;i++)
		{
			double fkli=getMaxCubicIJK(data->cubic,k,l,i);
			double fmni=getMaxCubicIJK(data->cubic,m,n,i);
			double fkmi=getMaxCubicIJK(data->cubic,k,m,i);
			double flni=getMaxCubicIJK(data->cubic,l,n,i);
			double fkni=getMaxCubicIJK(data->cubic,k,n,i);
			double flmi=getMaxCubicIJK(data->cubic,l,m,i);
			int kk=k+1;
			int mm=m+1;
			int ll=l+1;
			int nn=n+1;
			int ii=i+1;
                	K += -0.25*fkli*fmni*(D(vpt2KModel,-kk,ll,ii)+D(vpt2KModel,-mm,-nn,ii)+D(vpt2KModel,kk,-ll,ii)+D(vpt2KModel,mm,nn,ii));
                	K += -0.25*fkmi*flni*(D(vpt2KModel,kk,-mm,ii)+D(vpt2KModel,ll,nn,ii)+D(vpt2KModel,-kk,mm,ii)+D(vpt2KModel,-ll,-nn,ii));
                	K += -0.25*fkni*flmi*(D(vpt2KModel,kk,-nn,ii)+D(vpt2KModel,ll,mm,ii)+D(vpt2KModel,-kk,nn,ii)+D(vpt2KModel,-ll,-mm,ii));
		}
	return K;
}
*/
/**********************************************************************/
//1-1 Resonance 
/*
static double K11(VPT2KModel* vpt2KModel, int k, int l, int m, int n)
{
	VPT2PotentialData* data = &vpt2KModel->vData;
	double fklmn = getMaxQuarticIJKL(data->quartic,k,l,m,n);
	double cor = 0;
	int i,c;
	double wk=data->hessian[k][k];
	double wl=data->hessian[l][l];
	double wm=data->hessian[m][m];
	double K = 0;
	int ne = 0;
	double s2 = 0.5;
	double s6 = 1.0/6.0;
	double s8 = 1.0/8.0;
	double s24 = 1.0/24.0;
	if(k==l) ne++;
	if(k==m) ne++;
	if(k==n) ne++;
	if(l==m) ne++;
	if(l==n) ne++;
	if(m==n) ne++;


//	printf("K11 %d %d %d %d ne = %d\n",k+1,l+1,m+1,n+1,ne);
//      kl;ml
	if(ne==1)
	{
		if(k==m || k==n) {i=l;l=k;k=i;}//permut kl
		if(l==m ) {i=m;m=n;n=i;}//permut mn

		wk=data->hessian[k][k];
		wl=data->hessian[l][l];
		wm=data->hessian[m][m];

		K = fklmn*s2;
		cor = 0;
		//printf("KQuart %d %d %d %d = %f\n",k+1,l+1,m+1,n+1,K);
		for(c=0;c<3;c++)
		{
			double xetakl=getMaxMatrixIJ(data->coriolis[c],k,l);
			double xetaml=getMaxMatrixIJ(data->coriolis[c],m,l);
			cor += data->Be[c]*xetakl*xetaml;
		}
		//printf("Cori %d %d %d %d = %f\n",k+1,l+1,m+1,n+1,2*cor*(wk*wm+wl*wl)/wl/sqrt(wk*wm));
		K += 2*cor*(wk*wm+wl*wl)/wl/sqrt(wk*wm);
		for(i=0;i<data->nFrequencies;i++)
		{
			double fkli=getMaxCubicIJK(data->cubic,k,l,i);
			double fmli=getMaxCubicIJK(data->cubic,m,l,i);
			double fkmi=getMaxCubicIJK(data->cubic,k,m,i);
			double flli=getMaxCubicIJK(data->cubic,l,l,i);
			double wi=data->hessian[i][i];
			int kk=k+1;
			int ll=l+1;
			int mm=m+1;
			int ii=i+1;
                	K += -s8*fkli*fmli*
				(
					D(vpt2KModel,kk,ll,ii)+D(vpt2KModel,-kk,-ll,ii)+D(vpt2KModel,mm,ll,ii)+D(vpt2KModel,-mm,-ll,ii)+
					D(vpt2KModel,kk,-ll,ii)+D(vpt2KModel,-kk,ll,ii)+D(vpt2KModel,ll,-mm,ii)+D(vpt2KModel,-ll,mm,ii)
				);
                	K += -s8*fkmi*flli* (D(vpt2KModel,kk,-mm,ii)+D(vpt2KModel,-kk,mm,ii)+2/wi);
		}
		//fprintf(stderr,"Kklml %d %d %d %d = %f\n",k+1,l+1,m+1,n+1,K);
		return K;
	}
//      kl;ll
	if(ne==3)
	{
		if(k==l )
		{
			i=k;k=m;m=i;
			i=l;l=n;n=i;
		}//permut kl & mn
		if(k==m || k==n) {i=l;l=k;k=i;}//permut kl

		K = fklmn*s6;
		cor = 0;
		//printf("KQuart %d %d %d %d = %f\n",k+1,l+1,m+1,n+1,K);
		for(i=0;i<data->nFrequencies;i++)
		{
			double fkli=getMaxCubicIJK(data->cubic,k,l,i);
			double flli=getMaxCubicIJK(data->cubic,l,l,i);
			double wi=data->hessian[i][i];
			int kk=k+1;
			int ll=l+1;
			int ii=i+1;
                	K += -s24*fkli*flli*(D(vpt2KModel,ll,ll,ii)+D(vpt2KModel,-ll,-ll,ii)+4/wi);
                	K += -s24*fkli*flli*(2*D(vpt2KModel,kk,-ll,ii)+2*D(vpt2KModel,-kk,ll,ii)+D(vpt2KModel,kk,ll,ii)+D(vpt2KModel,-kk,-ll,ii));
		}
		//fprintf(stderr,"Kklll %d %d %d %d = %f\n",k+1,l+1,m+1,n+1,K);
		return K;
	}

	//printf("K %d %d %d %d = %f\n",k+1,l+1,m+1,n+1,K);
	return K;
}
*/
/**********************************************************************/
/* VPT2-K paper */
static void computeXi(VPT2KModel* vpt2KModel)
{
	int k,l,m;
	int c;
	double s = 0;
	VKAnharmonic* vAnharmonic = &vpt2KModel->vAnharmonic;
	VPT2PotentialData* data = &vpt2KModel->vData;
	//VPT2VModel* model = NULL;
	if(!vAnharmonic) return;
	if(!data) return;
	if(!data->hessian) return;
	if(!vAnharmonic->Xi) return;
	//model = &data->model;
	/* compute Xkk */
	for(k=0;k<vAnharmonic->nFrequencies;k++)
	{
		double Skk = 0;
		vAnharmonic->Xi[k][k] = data->quartic[k][k][k][k]/16.0;
		Skk = 0;
		for(l=0;l<vAnharmonic->nFrequencies;l++)
		{
			double fkkl=getMaxCubicIJK(data->cubic,k,k,l);
			double wl=data->hessian[l][l];
			Skk += fkkl*fkkl*(2/wl+0.5*D(vpt2KModel,l+1,k+1,k+1)-0.5*D(vpt2KModel,-l-1,k+1,k+1));
		}
		vAnharmonic->Xi[k][k] += -Skk/16.0;
	}
	/* compute Xkl */
	for(k=0;k<vAnharmonic->nFrequencies;k++)
	{
		double wk=data->hessian[k][k];
		int kk=k+1;
		for(l=0;l<vAnharmonic->nFrequencies;l++)
		{
			double wl=data->hessian[l][l];
			double skl = wk/wl+wl/wk;
			int ll=l+1;
			if(k==l) continue;
			vAnharmonic->Xi[k][l] = getMaxQuarticIJKL(data->quartic,k,k,l,l)*0.25;
			for(m=0;m<vAnharmonic->nFrequencies;m++)
			{
				double wm=data->hessian[m][m];
				double fklm=getMaxCubicIJK(data->cubic,k,l,m);
				double fkkm=getMaxCubicIJK(data->cubic,k,k,m);
				double fmll=getMaxCubicIJK(data->cubic,m,l,l);
				int mm=m+1;
				vAnharmonic->Xi[k][l] += -0.25*fkkm*fmll/wm;
				vAnharmonic->Xi[k][l] += -0.125*fklm*fklm*
				( D(vpt2KModel,mm,kk, ll) + D(vpt2KModel,mm,-kk,-ll)
				+ D(vpt2KModel,mm,kk,-ll) + D(vpt2KModel,mm,-kk, ll));
			}
			s = 0;
			for(c=0;c<3;c++)
			{
				double xeta=data->coriolis[c][k][l];
				if(fabs(data->coriolis[c][l][k])>fabs(xeta)) xeta=data->coriolis[c][l][k];
				s += data->Be[c]*xeta*xeta;
			}
			vAnharmonic->Xi[k][l] += skl*s;
		}
	}
}
/**********************************************************************/
static void computeC(VPT2KModel* vpt2KModel)
{
	int k,l,m;
	int c;
	double s = 0;
	double C = 0;
	boolean resonance = FALSE;
	VKAnharmonic* vAnharmonic = &vpt2KModel->vAnharmonic;
	VPT2PotentialData* data = &vpt2KModel->vData;
	if(!vAnharmonic) return;
	if(!data) return;
	if(!data->hessian) return;
	if(!vAnharmonic->Xi) return;
	

	s = 0;
	for(k=0;k<vAnharmonic->nFrequencies;k++)
		s += data->quartic[k][k][k][k];
	s  = s/64.0;
	C += s;

	s = 0;
	for(k=0;k<vAnharmonic->nFrequencies;k++)
	{
		int kk=k+1;
		for(l=0;l<vAnharmonic->nFrequencies;l++)
		{
			int ll=l+1;
			double fkkl=getMaxCubicIJK(data->cubic,k,k,l);
			if(k!=l) s += fkkl*fkkl*0.5*(D(vpt2KModel,ll,kk,kk)+D(vpt2KModel,-ll,kk,kk));
		}
	}
	s = 3*s/64.0;
	C += s;

	s = 0;
	for(k=0;k<vAnharmonic->nFrequencies;k++)
	{
		double fkkk=getMaxCubicIJK(data->cubic,k,k,k);
		double wk=data->hessian[k][k];
		s += fkkk*fkkk/wk;
	}
	s  = -7*s/576;
	C += s;

	s = 0;
	for(k=0;k<vAnharmonic->nFrequencies;k++)
	{
		int kk=k+1;
		for(l=0;l<vAnharmonic->nFrequencies;l++)
		{
			int ll=l+1;
			for(m=0;m<vAnharmonic->nFrequencies;m++)
			{
				int mm=m+1;
             			if (
					(!resonance && (k!=l && l!=m && k!=m))
					||
            				( resonance && ((k>l) && l>m && k>m))
				)
				{
					double fklm=getMaxCubicIJK(data->cubic,k,l,m);
  					s += fklm*fklm*(D(vpt2KModel,mm,kk,ll)+D(vpt2KModel,mm,-kk,-ll)-D(vpt2KModel,mm,kk,-ll)-D(vpt2KModel,mm,-kk,ll))/8;
				}
			}
		}
	}
	s = -s /4.0;
	if(!resonance) s = s/6;
	C += s;

	s = 0;
	for(k=0;k<vAnharmonic->nFrequencies;k++)
	{
		for(l=0;l<vAnharmonic->nFrequencies;l++)
		{
                    	if ((!resonance && k!=l) || (resonance && k>l))
			{
				for(c=0;c<3;c++)
				{
					double xetakl = getMaxMatrixIJ(data->coriolis[c],k,l);
					s += -0.5*data->Be[c]*xetakl*xetakl;
				}
			}
		}
	}
	if(!resonance) s = s/2;
	C += s;

	vpt2KModel->vAnharmonic.C = C;
}
/**********************************************************************/
static double Ekl(VPT2KModel* vpt2KModel, int* v)
{
	int k,l;
	int nFrequencies = vpt2KModel->vAnharmonic.nFrequencies;
	double E = 0;
	double shift = 0.5;
	for(k=0;k<nFrequencies;k++)
	{
		double wk=vpt2KModel->vData.hessian[k][k];
		E += wk*(v[k]+shift);
		for(l=0;l<=k;l++)
			E += vpt2KModel->vAnharmonic.Xi[k][l]*(v[k]+shift)*(v[l]+shift);
	}
	return E;
}
/**********************************************************************/
static double Eoff12(VPT2KModel* vpt2KModel, int* vDiff, int* vMax, int noneZero, int negative)
{
	int nFrequencies = vpt2KModel->vAnharmonic.nFrequencies;
	//int i,k,l,m,n;
	int i,k,l,m;
	double E = 0;
//  1-2 Resonances
	k = -1;
	l = -1;
	m = -1;
	//n = -1;
//	printf("Eoff12 noneZero=%d negative=%d \n",noneZero,negative);
	if(noneZero==3) // Resonance type: k;lm
	{
		for(i=0;i<nFrequencies;i++) 
		if(negative==1)
		{
			if(vDiff[i]<0 && k==-1) k=i;
			else if (vDiff[i]>0 && l==-1) l=i;
			else if (vDiff[i]>0 && l!=-1 && m==-1) m=i;
		}
		else if(negative==2)
		{
			if(vDiff[i]>0 && k==-1) k=i;
			else if (vDiff[i]<0 && l==-1) l=i;
			else if (vDiff[i]<0 && l!=-1 && m==-1) m=i;
		}
		if(k==-1 || l==-1 || m==-1) {printf("No 12 reseonance \n");return E;};
		if(testFermi(vpt2KModel,-(k+1),l+1,m+1))
			E=K12(vpt2KModel,k,l,m)*sqrt(vMax[k]*vMax[l]*vMax[m])/2.0/sqrt(2.0);
		return E;
	}
	else if(noneZero==2) // Resonance type: k;ll
	{
		for(i=0;i<nFrequencies;i++) 
		if(negative==1)
		{
			if(abs(vDiff[i])==1 && k==-1) k=i;
			else if (abs(vDiff[i])==2 && l==-1) l=i;
		}
		if(k==-1 || l==-1) {printf("No 12 reseonance \n");return E;};
		if(testFermi(vpt2KModel,-(k+1),l+1,l+1))
			E=K12(vpt2KModel,k,l,l)*sqrt(vMax[k]*(vMax[l]-1)*vMax[l])/2.0/sqrt(2.0);
		return E;
	}
	return E;
}
/**********************************************************************/
static double Eoff22(VPT2KModel* vpt2KModel, int* vDiff, int* vMax, int noneZero, int negative)
{
	int nFrequencies = vpt2KModel->vAnharmonic.nFrequencies;
	int i,k,l,m,n;
	double E = 0;

	k = -1;
	l = -1;
	m = -1;
	n = -1;

	//kl;mn : nonZero = 4;
//	printf("Eoff22 noneZero=%d negative=%d \n",noneZero,negative);
	if(noneZero==4) // Resonance type: kl;mn
	{
		for(i=0;i<nFrequencies;i++) 
		{
			if(vDiff[i]==-1 && k==-1) k=i;
			else if (vDiff[i]==-1 && k!=-1) l=i;
			else if(vDiff[i]==1 && m==-1) m=i;
			else if (vDiff[i]==1 && m!=-1) n=i;
		}
		if(k==-1 || l==-1 || m==-1 || n==-1) {printf("No 22 reseonance noneZero=%d negative=%d \n",noneZero,negative);return E;};
		if(testDD(vpt2KModel,k+1,l+1,-(m+1),-(n+1)))
			E=0.25*K22(vpt2KModel,k,l,m,n)*sqrt(vMax[k]*vMax[l]*vMax[m]*vMax[n]);
		return E;
	}
	else if(noneZero==3) // Resonance type: kl;mm or kk;lm
	{
		for(i=0;i<nFrequencies;i++) 
		if(negative==1)
		{
			if(vDiff[i]<0) k=i;
			else if (vDiff[i]>0 && l==-1) l=i;
			else if (vDiff[i]>0 && l!=-1 && m==-1) m=i;
		}
		else if(negative==2)
		{
			if(vDiff[i]>0) k=i;
			//else if (vDiff[i]<0 && k==-1) l=i;
			else if (vDiff[i]<0 && l==-1) l=i;
			else if (vDiff[i]<0 && l!=-1 && m==-1) m=i;
		}
		if(k==-1 || l==-1 || m==-1) {printf("No 22 reseonance noneZero=%d negative=%d klm = %d %d %d\n",noneZero,negative,k,l,m);return E;};
//		printf(" Resonance type: kl;mm or kk;lm klmn %d %d %d %d\n",k,l,m,n);
		if(testDD(vpt2KModel,k+1,k+1,-(l+1),-(m+1)))
			E=0.25*K22(vpt2KModel,k,k,l,m)*sqrt((vMax[k]-1)*vMax[k]*vMax[l]*vMax[m]);
		return E;
	}
	else if(noneZero==2) // Resonance type: kk;ll
	{
		for(i=0;i<nFrequencies;i++) 
		{
			if(vDiff[i]<0) k=i;
			else if (vDiff[i]>0) l=i;
		}
		if(k==-1 || l==-1) {printf("No 22 reseonance noneZero=%d negative=%d \n",noneZero,negative);return E;};
		if(testDD(vpt2KModel,k+1,k+1,-(l+1),-(l+1)))
			E=0.25*K22(vpt2KModel,k,k,l,l)*sqrt((vMax[k]-1)*vMax[k]*(vMax[l]-1)*vMax[l]);
		// TO DO return E;
		return E/2;
	}
	return E;
}
/**********************************************************************/
/*
static double Eoff13(VPT2KModel* vpt2KModel, int* vDiff, int* vMax, int noneZero, int negative)
{
	int nFrequencies = vpt2KModel->vAnharmonic.nFrequencies;
	int i,k,l,m,n;
	double E = 0;

	k = -1;
	l = -1;
	m = -1;
	n = -1;
//	printf("Eoff13 noneZero=%d negative=%d \n",noneZero,negative);
	//k;lmn : nonZero = 4;
	if(noneZero==4) // Resonance type: k;lmn
	{
		for(i=0;i<nFrequencies;i++) 
		if(negative==1)
		{
			if(vDiff[i]<0) k=i;
			else if (vDiff[i]>0 && l!=-1) l=i;
			else if(vDiff[i]>0 && l!=-1 && m==-1) m=i;
			else if (vDiff[i]>0 && l!=-1 && m!=-1 && n==-1) n=i;
		}
		else if(negative==3)
		{
			if(vDiff[i]>0) k=i;
			else if (vDiff[i]<0 && l!=-1) l=i;
			else if(vDiff[i]<0 && l!=-1 && m==-1) m=i;
			else if (vDiff[i]<0 && l!=-1 && m!=-1 && n==-1) n=i;
		}
		if(k==-1 || l==-1 || m==-1 || n==-1) {printf("No 13 reseonance \n");return E;};
		E=0.25*K13(vpt2KModel,k,l,m,n)*sqrt(vMax[k]*vMax[l]*vMax[m]*vMax[n]);
		return E;
	}
	if(noneZero==3) // Resonance type: k;llm
	{
		for(i=0;i<nFrequencies;i++) 
		if(negative==1)
		{
			if(vDiff[i]<0) k=i;
			else if (abs(vDiff[i])>1 && l!=-1) l=i;
			else if(abs(vDiff[i])==1 && m==-1) m=i;
		}
		else if(negative==2)
		{
			if(vDiff[i]>0) k=i;
			else if (abs(vDiff[i])>1 && l!=-1) l=i;
			else if(abs(vDiff[i])==1 && m==-1) m=i;
		}
		if(k==-1 || l==-1 || m==-1) {printf("No 13 reseonance \n");return E;};
		E=0.25*K13(vpt2KModel,k,l,l,m)*sqrt(vMax[k]*(vMax[l]-1)*vMax[l]*vMax[m]);
		return E;
	}
	if(noneZero==2) // Resonance type: k;lll
	{
		for(i=0;i<nFrequencies;i++) 
		{
			if(abs(vDiff[i])==1) k=i;
			else if (abs(vDiff[i])==3) l=i;
		}
		if(k==-1 || l==-1) {printf("No 13 reseonance \n"); return 0;};
		E=0.25*K13(vpt2KModel,k,l,l,l)*sqrt(vMax[k]*(vMax[l]-1)*(vMax[l]-2)*vMax[l]);
		return E;
	}
	return E;
}
*/
/**********************************************************************/
/*
static double Eoff11(VPT2KModel* vpt2KModel, int* vDiff, int* vMax, int noneZero, int absSum)
{
	int nFrequencies = vpt2KModel->vAnharmonic.nFrequencies;
	int i,k,l,m,n;
	double E = 0;
	double E1,E2;
	double shift = 0.5;

	k = -1;
	l = -1;
	m = -1;
	n = -1;
	if(noneZero==2 && absSum==0) // Resonance type: kl;ll or kl;lm
	{
		for(i=0;i<nFrequencies;i++) 
		{
			if(vDiff[i]<0) k=i;
			else if (vDiff[i]>0) m=i;
		}
		if(k==-1 || m==-1) {printf("No 11 reseonance \n");return E;};
		E1 = 0.75*sqrt(vMax[k]*vMax[m])*vMax[m]*K11(vpt2KModel,k,m,m,m); // kl;ll
		E2 = 0.75*sqrt(vMax[k]*vMax[m])*vMax[k]*K11(vpt2KModel,k,k,k,m); //kk;km
		for(l=0;l<nFrequencies;l++) 
		{
			if(l!=m && l!=k) 
			{
				double E3 = 0.5*sqrt(vMax[k]*vMax[m])*(vMax[l]+shift)*K11(vpt2KModel,k,l,m,l); //kl;lm
				E += E3;
				//if(fabs(E3)>20.0) fprintf(stderr,"k=%d l=%d m=%d Eklml=%f\n",k,l,m,E3);
			}
		}
		E += E1+E2;
		if(fabs(E)>100.0 && printMax) fprintf(stderr,"k=%d m=%d Eklll = %f Ekkkm= %f Eklml=%f\n",k,m,E1,E2,E-E1-E2);
		return E;
	}
	return E;
}
*/
/**********************************************************************/
static double Eoff(VPT2KModel* vpt2KModel, int* vA, int* vB)
{
	int nFrequencies = vpt2KModel->vAnharmonic.nFrequencies;
	int* vDiff = newVectorInt(nFrequencies);
	int* vMax = newVectorInt(nFrequencies);
	double E = 0;
	int negative = 0;
	int noneZero = 0;
	int absSum = 0;
	int sumAbs = 0;
	int i;

	for(i=0;i<nFrequencies;i++) vDiff[i] = vB[i]-vA[i];
	for(i=0;i<nFrequencies;i++) absSum += vDiff[i];
	absSum = abs(absSum);
	for(i=0;i<nFrequencies;i++) sumAbs += abs(vDiff[i]);
	for(i=0;i<nFrequencies;i++) noneZero += (vDiff[i]!=0)?1:0;
	for(i=0;i<nFrequencies;i++) negative += (vDiff[i]<0)?1:0;
	for(i=0;i<nFrequencies;i++) vMax[i] = (vB[i]>vA[i])?vB[i]:vA[i];

	if(sumAbs==3) E = Eoff12(vpt2KModel, vDiff, vMax, noneZero, negative);
	if(sumAbs==4 && absSum==0) E = Eoff22(vpt2KModel, vDiff, vMax, noneZero, negative);
	//if(sumAbs==4 && absSum==2) E = Eoff13(vpt2KModel, vDiff, vMax, noneZero, negative);
	//if(sumAbs==2) E = Eoff11(vpt2KModel, vDiff, vMax, noneZero, absSum);

	freeVectorInt(&vDiff);
	freeVectorInt(&vMax);
	return E;
}
/**********************************************************************/
static void computeHMatrix(VPT2KModel* vpt2KModel)
{
	int i,j;
	VKAnharmonic* vAnharmonic = &vpt2KModel->vAnharmonic;
	int nStates = vAnharmonic->nStates;

//	printf("begin freeMatrixDouble in computeHMatrix\n");
	freeMatrixDouble(&vAnharmonic->H, nStates);
//	printf("End freeMatrixDouble in computeHMatrix\n");
	vAnharmonic->H = newMatrixDouble(nStates, nStates);
	initMatrixDouble(vAnharmonic->H, nStates, nStates, 0.0);
	for(i=0;i<nStates;i++)
	{
		vAnharmonic->H[i][i] = Ekl(vpt2KModel,vAnharmonic->v[i]);
		for(j=0;j<i;j++)
		{
			vAnharmonic->H[i][j] = Eoff(vpt2KModel,vAnharmonic->v[i],vAnharmonic->v[j]);
			//vAnharmonic->H[i][j] = rand()*1.0/RAND_MAX;
			vAnharmonic->H[j][i] = vAnharmonic->H[i][j];
		}
	}
}
/**********************************************************************/
static void diagonalizeHMatrix(VPT2KModel* vpt2KModel)
{
	VKAnharmonic* vAnharmonic = &vpt2KModel->vAnharmonic;
	int nStates = vAnharmonic->nStates;

	if(vAnharmonic->eigenVectors) freeMatrixDouble(&vAnharmonic->eigenVectors, nStates);
	vAnharmonic->eigenVectors = newMatrixDouble(nStates, nStates);
	initMatrixDouble(vAnharmonic->eigenVectors, nStates, nStates, 0.0);

	if(vAnharmonic->eigenValues) freeVectorDouble(&vAnharmonic->eigenValues);
	vAnharmonic->eigenValues = newVectorDouble(nStates);
	initVectorDouble(vAnharmonic->eigenValues, nStates, 0.0);

	eigen(vAnharmonic->H, nStates, vAnharmonic->eigenValues, vAnharmonic->eigenVectors);
}
/**********************************************************************/
static void addGroundState(VKAnharmonic* vAnharmonic)
{
	int nFrequencies = vAnharmonic->nFrequencies;
	if(vAnharmonic->v == NULL)
	{
		vAnharmonic->nStates = 1;
		vAnharmonic->v = newMatrixInt(vAnharmonic->nStates, nFrequencies);
		initMatrixInt(vAnharmonic->v, vAnharmonic->nStates, nFrequencies,0.0);
	}
	else
	{
		
		vAnharmonic->nStates += 1;
		vAnharmonic->v = realloc (vAnharmonic->v, vAnharmonic->nStates*sizeof(int*));
		{
			int ii=vAnharmonic->nStates-1;
			vAnharmonic->v[ii] = malloc(nFrequencies*sizeof(int));
		}
	}
	{
		int ii=vAnharmonic->nStates-1;
		int k;
		for(k=0;k<nFrequencies;k++)
			vAnharmonic->v[ii][k] = 0;
	}
}
/**********************************************************************/
static void addFundamentalsStates(VKAnharmonic* vAnharmonic)
{
	int nFrequencies = vAnharmonic->nFrequencies;
	int k,i;
	if(vAnharmonic->v == NULL)
	{
		vAnharmonic->nStates = nFrequencies;
		vAnharmonic->v = newMatrixInt(vAnharmonic->nStates, nFrequencies);
		initMatrixInt(vAnharmonic->v, vAnharmonic->nStates, nFrequencies,0.0);
	}
	else
	{
		
		vAnharmonic->nStates += nFrequencies;
		vAnharmonic->v = realloc (vAnharmonic->v, vAnharmonic->nStates*sizeof(int*));
		for(i=0;i<nFrequencies;i++)
		{
			int ii=i+vAnharmonic->nStates-nFrequencies;
			vAnharmonic->v[ii] = malloc(nFrequencies*sizeof(int));
		}
	}
	for(i=0;i<nFrequencies;i++)
	{
		int ii=i+vAnharmonic->nStates-nFrequencies;
		for(k=0;k<nFrequencies;k++)
			vAnharmonic->v[ii][k] = (i==k)?1:0;
	}
}
/**********************************************************************/
static void addOvertonesStates(VKAnharmonic* vAnharmonic)
{
	int nFrequencies = vAnharmonic->nFrequencies;
	int k,i;
	if(vAnharmonic->v == NULL)
	{
		vAnharmonic->nStates = nFrequencies;
		vAnharmonic->v = newMatrixInt(vAnharmonic->nStates, nFrequencies);
		initMatrixInt(vAnharmonic->v, vAnharmonic->nStates, nFrequencies,0.0);
	}
	else
	{
		vAnharmonic->nStates += nFrequencies;
		vAnharmonic->v = realloc (vAnharmonic->v, vAnharmonic->nStates*sizeof(int*));
		for(i=0;i<nFrequencies;i++)
		{
			int ii=i+vAnharmonic->nStates-nFrequencies;
			vAnharmonic->v[ii] = malloc(nFrequencies*sizeof(int));
		}
	}
	for(i=0;i<nFrequencies;i++)
	{
		int ii=i+vAnharmonic->nStates-nFrequencies;
		for(k=0;k<nFrequencies;k++)
			vAnharmonic->v[ii][k] = (i==k)?2:0;
	}
}
/**********************************************************************/
static void addCombination11States(VKAnharmonic* vAnharmonic)
{
	int nFrequencies = vAnharmonic->nFrequencies;
	int k,l,i;
	int n = 0;
	int ii;
	for(i=0;i<nFrequencies;i++)
	for(k=i+1;k<nFrequencies;k++) n++;

	if(vAnharmonic->v == NULL)
	{
		vAnharmonic->nStates = nFrequencies;
		vAnharmonic->v = newMatrixInt(vAnharmonic->nStates, nFrequencies);
		initMatrixInt(vAnharmonic->v, vAnharmonic->nStates, nFrequencies,0.0);
	}
	else
	{

		vAnharmonic->nStates += n;
		vAnharmonic->v = realloc (vAnharmonic->v, vAnharmonic->nStates*sizeof(int*));
		for(i=0;i<n;i++)
		{
			int ii=i+vAnharmonic->nStates-n;
			vAnharmonic->v[ii] = malloc(nFrequencies*sizeof(int));
			for(k=0;k<nFrequencies;k++) vAnharmonic->v[ii][k] = 0;
		}
	}
	ii = vAnharmonic->nStates-n;
	for(k=0;k<nFrequencies;k++)
	{
		for(l=k+1;l<nFrequencies;l++) 
		{
			vAnharmonic->v[ii][k] = 1;
			vAnharmonic->v[ii][l] = 1;
			ii++;
		}
	}
}
/**********************************************************************/
static void printStates(VKAnharmonic* vAnharmonic)
{
	int nFrequencies = vAnharmonic->nFrequencies;
	int nStates = vAnharmonic->nStates;
	int k,i;
	//FILE* file = NULL;
	if(nFrequencies>0)
	{
	printf("nFrequencies %d\n",nFrequencies);
	printf("nStates %d\n",nStates);
	for(i=0;i<nStates;i++)
	{
		printf("State n %d\t",i+1);
		for(k=0;k<nFrequencies;k++)
			printf("%d ",vAnharmonic->v[i][k]);
		printf("\n");
	}
	}
	/*
	file =fopen("poly.in","w");
	for(i=0;i<nStates;i++)
	{
		for(k=0;k<nFrequencies;k++)
			fprintf(file,"%d ",vAnharmonic->v[i][k]);
		fprintf(file, "\n");
	}
	fclose(file);
	*/
}
/**********************************************************************/
static VKAnharmonic newVKAnharmonic(VPT2PotentialData* vData)
{
	VKAnharmonic vAnharmonic;
	int n = 0;
	if(vData) n = vData->nFrequencies;
	vAnharmonic.nFrequencies = n;
	if(vAnharmonic.nFrequencies<=0) vAnharmonic.nFrequencies = 0;

	vAnharmonic.Xi = newMatrixDouble(vAnharmonic.nFrequencies,vAnharmonic.nFrequencies);
	initMatrixDouble(vAnharmonic.Xi, vAnharmonic.nFrequencies, vAnharmonic.nFrequencies, 0.0);
	vAnharmonic.C = 0.0;

	vAnharmonic.D = newCubeDouble(2*vAnharmonic.nFrequencies+1, 2*vAnharmonic.nFrequencies+1, 2*vAnharmonic.nFrequencies+1);
	initCubeDouble(vAnharmonic.D, 2*vAnharmonic.nFrequencies+1, 2*vAnharmonic.nFrequencies+1, 2*vAnharmonic.nFrequencies+1, 0.0);

	vAnharmonic.nStates = 0;

	vAnharmonic.v = NULL;
	addGroundState(&vAnharmonic);
	addFundamentalsStates(&vAnharmonic);
	addOvertonesStates(&vAnharmonic);
  	addCombination11States(&vAnharmonic);
	printStates(&vAnharmonic);
	vAnharmonic.H = newMatrixDouble(vAnharmonic.nStates, vAnharmonic.nStates);
	initMatrixDouble(vAnharmonic.H, vAnharmonic.nStates, vAnharmonic.nStates, 0.0);

	vAnharmonic.eigenValues = NULL;
	vAnharmonic.eigenVectors = NULL;

	vAnharmonic.harmonicEnergies = newVectorDouble(vAnharmonic.nStates);
	initVectorDouble(vAnharmonic.harmonicEnergies, vAnharmonic.nStates, 0.0);

	return vAnharmonic;
}
/*****************************************************************************/
static void readData(VPT2KModel* vpt2KModel, char* inputFileName)
{
	FILE* inputFile;
        inputFile = fopen(inputFileName,"rb");
	if(!inputFile)
	{
		fprintf(stderr, "==========================================================\n");
		fprintf(stderr, "Sorry, I cannot open the %s file\n", inputFileName);
		fprintf(stderr, "==========================================================\n");
		exit(1);
	}
	fclose(inputFile);
	vpt2KModel->vData.klass->readData(&vpt2KModel->vData, inputFileName);
	vpt2KModel->pData.klass->readData(&vpt2KModel->pData, inputFileName);
//	printf("End read readData\n");
}
/**********************************************************************/
static void printResonanceMatrix(VPT2KModel* vpt2KModel)
{
	int n = vpt2KModel->vAnharmonic.nStates;
	VKAnharmonic* vAnharmonic  = &vpt2KModel->vAnharmonic;
	int nFrequencies = vAnharmonic->nFrequencies;
        int i,j;
	int k;
	double cutoff = 1e-9;
	double** M = vAnharmonic->H;
	double E0 = M[0][0];
	int nR;
	double df;
	int* iDiff = newVectorInt(nFrequencies);
	int* jDiff = newVectorInt(nFrequencies);
	int ndi,ndj;
	// Fermi Resonances
	nR = 0;
        printf(" Fermi Resonances terms :\n");
        for(i = 0;i<n; i++)
        {
		int ni = 0; 
		for(k=0;k<nFrequencies;k++) ni += vAnharmonic->v[i][k];

                for(j = 0;j<i; j++)
                if(fabs(M[i][j])>=cutoff)
		{
			int nj = 0; 
			double X;
			for(k=0;k<nFrequencies;k++) nj += vAnharmonic->v[j][k];
                        if( !(ni==1 && nj==2) && !(ni==2 && nj==1)) continue;
			df = 0; for(k=0;k<nFrequencies;k++) df += (vAnharmonic->v[j][k]-vAnharmonic->v[i][k])*vpt2KModel->vData.hessian[k][k];
		 	X =  0.0;
			ndi = getDiff(vpt2KModel, vAnharmonic->v[i], iDiff);
			ndj = getDiff(vpt2KModel, vAnharmonic->v[j], jDiff);
			if(ndi==1 && ndj==2) X =  getMaxDiffVPT2Var(vpt2KModel, iDiff[0], jDiff[0], jDiff[1], df);
			if(ndi==2 && ndj==1) X =  getMaxDiffVPT2Var(vpt2KModel, iDiff[0], iDiff[1], jDiff[0], df);
			if(ndi==1 && ndj==1) 
			{
				if(ni==2) X =  getMaxDiffVPT2Var(vpt2KModel, iDiff[0], iDiff[0], jDiff[0], df);
				if(nj==2) X =  getMaxDiffVPT2Var(vpt2KModel, iDiff[0], jDiff[0], jDiff[0], df);
			}

			if(nR==0) printf("%20s %20s %20s %20s %20s\n", "Diff. harm.","PT2-Var","Hii","Hij","Hjj");
                        printf("%20.10f %20.10f ",df,X);
                        printf("%20.10f %20.10f %20.10f ",M[i][i]-E0,M[i][j],M[j][j]-E0);
                	for(k=0;k<nFrequencies;k++) if(vAnharmonic->v[i][k]>0) printf("%2d(%d) ",k+1,vAnharmonic->v[i][k]);
			printf(" --- ");
                	for(k=0;k<nFrequencies;k++) if(vAnharmonic->v[j][k]>0) printf("%2d(%d) ",k+1,vAnharmonic->v[j][k]);
			printf("\n");
			nR++;
		}
        }
        printf(" %d Fermi Resonances \n",nR);
        for(k=0;k<100;k++) if(k<99) printf("-"); else printf("-\n\n");
	// Darling-Dennison Resonances
	nR = 0;
        printf(" Darling-Dennison Resonances terms :\n");
        for(i = 0;i<n; i++)
        {
		int ni = 0; 
		for(k=0;k<nFrequencies;k++) ni += vAnharmonic->v[i][k];

                for(j = 0;j<i; j++)
                if(fabs(M[i][j])>=cutoff)
		{
			int nj = 0; 
			for(k=0;k<nFrequencies;k++) nj += vAnharmonic->v[j][k];
                        if (!(ni==2 && nj==2)) continue;

			df = 0; for(k=0;k<nFrequencies;k++) df += (vAnharmonic->v[j][k]-vAnharmonic->v[i][k])*vpt2KModel->vData.hessian[k][k];
			df /= 2; // 2(wi-wj); df = wi-wj
			if(nR==0) printf("%20s %20s %20s %20s\n", "Diff. harm.","Hii","Hij","Hjj");
                        printf("%20.10f ",df);
                        printf("%20.10f %20.10f %20.10f ",M[i][i]-E0,M[i][j],M[j][j]-E0);
                	for(k=0;k<nFrequencies;k++) if(vAnharmonic->v[i][k]>0) printf("%2d(%d) ",k+1,vAnharmonic->v[i][k]);
			printf(" --- ");
                	for(k=0;k<nFrequencies;k++) if(vAnharmonic->v[j][k]>0) printf("%2d(%d) ",k+1,vAnharmonic->v[j][k]);
			printf("\n");
			nR++;
		}
        }
        printf(" %d Darling-Dennison Resonances \n",nR);
        for(k=0;k<100;k++) if(k<99) printf("-"); else printf("-\n\n");
	nR = 0;
        for(i = 0;i<n; i++)
        {
		int ni = 0; 
		for(k=0;k<nFrequencies;k++) ni += vAnharmonic->v[i][k];

                for(j = 0;j<i; j++)
                if(fabs(M[i][j])>=cutoff)
		{
			int nj = 0; 
			for(k=0;k<nFrequencies;k++) nj += vAnharmonic->v[j][k];
                        if( !(ni==1 && nj==2) && !(ni==2 && nj==1)) continue;
                        if (!(ni==2 && nj==2)) continue;

			df = 0; for(k=0;k<nFrequencies;k++) df += (vAnharmonic->v[j][k]-vAnharmonic->v[i][k])*vpt2KModel->vData.hessian[k][k];
			if(nR==0) printf("%20s %20s %20s %20s\n", "Diff. harm.","Hii","Hij","Hjj");
                        printf("%20.10f ",df);
                        printf("%20.10f %20.10f %20.10f ",M[i][i]-E0,M[i][j],M[j][j]-E0);
                	for(k=0;k<nFrequencies;k++) if(vAnharmonic->v[i][k]>0) printf("%2d(%d) ",k+1,vAnharmonic->v[i][k]);
			printf(" --- ");
                	for(k=0;k<nFrequencies;k++) if(vAnharmonic->v[j][k]>0) printf("%2d(%d) ",k+1,vAnharmonic->v[j][k]);
			printf("\n");
		}
        }
        if(nR>0) printf(" %d others Resonances \n",nR);
        if(nR>0) 
	{
		for(k=0;k<100;k++) 
			if(k<99) printf("-"); 
			else printf("-\n\n");
	}
	free(iDiff);
	free(jDiff);
}
/**********************************************************************/
static void printDiagonalMatrix(VPT2KModel* vpt2KModel)
{
	int n = vpt2KModel->vAnharmonic.nStates;
	VKAnharmonic* vAnharmonic  = &vpt2KModel->vAnharmonic;
	int nFrequencies = vAnharmonic->nFrequencies;
        int i;
	int k;
	double** M = vAnharmonic->H;
	double E0 = M[0][0];
        for(i = 0;i<n; i++)
        {
                printf("%20.10f %20.10f ",M[i][i],M[i][i]-E0);
                for(k=0;k<nFrequencies;k++) if(vAnharmonic->v[i][k]>0) printf("%2d(%d) ",k+1,vAnharmonic->v[i][k]);
		printf("\n");
        }
}
/**********************************************************************/
static void computeAnharmonicEnergies(VPT2KModel* vpt2KModel)
{
	computeXi(vpt2KModel);
	computeC(vpt2KModel);
	printf("\nXkl (cm^-1) by VPT2+K model\n");
	printMatrixDoubleCutOff(vpt2KModel->vAnharmonic.Xi, vpt2KModel->vAnharmonic.nFrequencies, vpt2KModel->vAnharmonic.nFrequencies,1e-10);
	printf("END\n\n");
	printf("C=%f\n",vpt2KModel->vAnharmonic.C);
	computeHMatrix(vpt2KModel);
	/*
	printf("\nH (cm^-1) by VPT2+K model\n");
	printMatrixDoubleCutOff(vpt2KModel->vAnharmonic.H, vpt2KModel->vAnharmonic.nStates, vpt2KModel->vAnharmonic.nStates,100.0);
	printf("END\n\n");
	*/

	printf("\nDiagonal of H (cm^-1) by VPT2+K model\n");
	printDiagonalMatrix(vpt2KModel);
	printf("END\n\n");

	printf("\nResonance Matrix (cm^-1) by VPT2+K model\n");
	printf("========================================\n");
	printResonanceMatrix(vpt2KModel);
	printf("END\n\n");

	diagonalizeHMatrix(vpt2KModel);

	//printIREnergies(&vpt2KModel->vAnharmonic);
	printIREnergiesCompact2(vpt2KModel,0.0);
	//printIREnergiesCompact2(vpt2KModel,0.5);
}

/**********************************************************************/
static PropertiesKAnharmonic newPAnharmonic(VPT2PotentialData* vData, int nStates)
{
	PropertiesKAnharmonic pAnharmonic;
	int i;
	int n = 0;
	if(vData) n = vData->nFrequencies;
	pAnharmonic.nFrequencies = n;
	if(pAnharmonic.nFrequencies<=0) pAnharmonic.nFrequencies = 0;
	pAnharmonic.nStates = nStates;

	pAnharmonic.harmonic = newVectorDouble(pAnharmonic.nStates);
	initVectorDouble(pAnharmonic.harmonic, pAnharmonic.nStates, 0.0);

	pAnharmonic.anHarmonic = newVectorDouble(pAnharmonic.nStates);
	initVectorDouble(pAnharmonic.anHarmonic, pAnharmonic.nStates, 0.0);

        pAnharmonic.maxFrequencyDifference11Resonance = 2.0;
        for( i=0;i<2;i++) pAnharmonic.thresholds11Numerators[i] = 10.0;
        for( i=0;i<3;i++) pAnharmonic.parameters11Resonance[i] = 0.0;

	return pAnharmonic;
}
/**********************************************************************/
static int getDiff(VPT2KModel* vpt2KModel, int* v, int* iDiff)
{
	int nFrequencies = vpt2KModel->vAnharmonic.nFrequencies;
	int nd=0;
	int i=0;

	for(i=0;i<nFrequencies;i++) iDiff[i] = -1;
	for(i=0;i<nFrequencies;i++) {if(v[i]>0) iDiff[nd++] = i;};
	return nd;
}
/**********************************************************************/
static void computeHarmonicValues(VPT2KModel* vpt2KModel)
{
        int i,j;
        int k;
        int a;
        int nd;
	int jmax;
        VKAnharmonic* vAnharmonic  = &vpt2KModel->vAnharmonic;
	PropertiesKAnharmonic* pAnharmonic = &vpt2KModel->pAnharmonic;
        int nFrequencies = vAnharmonic->nFrequencies;
        int nStates = pAnharmonic->nStates;
	int nDim = vpt2KModel->pData.nDim;
	double* V = newVectorDouble(nDim);
	double mu0 = 4*M_PI*1e-7;
	double eps0 = 1.0/(mu0*slight*slight);
	double   kmmolm1 = 8*M_PI*M_PI*M_PI*NAvogadro/3/hPlank/slight/4/M_PI/eps0*1e-3*100.0*8.47835267e-30*8.47835267e-30;/* 1e-3 m to km, 100 : cm-1 to m-1 */
	int* iDiff = newVectorInt(nFrequencies);

	for(i=0;i<nStates;i++)
	{
		double E = 0;
		int* v = vpt2KModel->vAnharmonic.v[i];
		k = 0;
		jmax = 0;
		for(j=0;j<nStates;j++)
			if(fabs(vAnharmonic->eigenVectors[i][j])>fabs(vAnharmonic->eigenVectors[i][jmax])) jmax = j;
		nd = getDiff(vpt2KModel, v, iDiff);
		if(nd==1 && v[iDiff[k]]==1) 
		{
			computeHarmonicProp(vpt2KModel, iDiff[k], V);
			pAnharmonic->harmonic[jmax] = 0.0;
			for(a=0;a<nDim;a++) pAnharmonic->harmonic[jmax] += V[a]*V[a];
			pAnharmonic->harmonic[jmax] *= kmmolm1;
		}
		for(k=0;k<nFrequencies;k++)
			E += v[k]*vpt2KModel->vData.hessian[k][k];
		vAnharmonic->harmonicEnergies[jmax] = E;
		//printf("i=%d jmax = %d E=%f\n",i,jmax,E);
	}
	for(j=0;j<nStates;j++)
	{
		int imax = 0;
		for(i=0;i<nStates;i++)
		{
			if(fabs(vAnharmonic->eigenVectors[i][j])>fabs(vAnharmonic->eigenVectors[imax][j])) imax = i;
		}
		int* v = vpt2KModel->vAnharmonic.v[imax];
		double E = 0;
		for(k=0;k<nFrequencies;k++)
			E += v[k]*vpt2KModel->vData.hessian[k][k];
		vAnharmonic->harmonicEnergies[j] = E;
	}

	free(iDiff);
	free(V);
}
/**********************************************************************/
static void computeAnharmonicProperties(VPT2KModel* vpt2KModel)
{
	int i,j;
	int k;
	int a;
	int nd;
	int nFrequencies = vpt2KModel->vAnharmonic.nFrequencies;
	int nStates = vpt2KModel->pAnharmonic.nStates;
	int* iDiff = newVectorInt(nFrequencies);
	int nDim = vpt2KModel->pData.nDim;
	double** P = newMatrixDouble(nStates, nDim);
	double* V = newVectorDouble(nDim);
	int* v;
	VKAnharmonic* vAnharmonic = &vpt2KModel->vAnharmonic;
	PropertiesKAnharmonic* pAnharmonic = &vpt2KModel->pAnharmonic;
	double mu0 = 4*M_PI*1e-7;
	double eps0 = 1.0/(mu0*slight*slight);
	double   kmmolm1 = 8*M_PI*M_PI*M_PI*NAvogadro/3/hPlank/slight/4/M_PI/eps0*1e-3*100.0*8.47835267e-30*8.47835267e-30;/* 1e-3 m to km, 100 : cm-1 to m-1 */

	initMatrixDouble(P, nStates, nDim, 0.0);
	for(i=0;i<nStates;i++)
	{
		v = vpt2KModel->vAnharmonic.v[i];
		nd = getDiff(vpt2KModel, v, iDiff);
		if(printMax)
		{
			for(k=0;k<nFrequencies;k++) printf("%2d ",v[k]);
			printf(" : ");
			if(nd==0) { printf("\n");continue;}
			for(k=0;k<nd;k++)
				printf(" %2d(%d) ", iDiff[k]+1, v[iDiff[k]]);
		}
		if(nd==1) {
			int k = 0;
			// fund or overtones
			if(v[iDiff[k]]==1) 
			{
				computeFundamentalsProp(vpt2KModel, iDiff[k], P[i]);
				if(printMax)
				{
					printf(" fundamental(%d) ",iDiff[k]+1);
					for(a=0;a<nDim;a++) printf(" %f ",P[i][a]);
					printf("\n");
				}
			}
			else if(v[iDiff[k]]==2) 
			{
				computeOvertonesProp(vpt2KModel, iDiff[k], P[i]);
				if(printMax)
				{
					printf(" overtones(%d) ",iDiff[k]+1);
					for(a=0;a<nDim;a++) printf(" %f ",P[i][a]);
					printf("\n");
				}
			}
			else 
			{
				printf(" not yet implemented(%d)\n",iDiff[k]+1);
			}
		
		}
		if(nd==2) {
		// combination
			int k = 0; 
			int l = 1;
			if(v[iDiff[k]]==1 && v[iDiff[l]]==1)
			{
				computeCombinationBandsProp(vpt2KModel,iDiff[k],iDiff[l], P[i]);
				if(printMax)
				{
					printf(" Combination 1-1(%d,%d) ",iDiff[k]+1,iDiff[l]+1);
					for(a=0;a<nDim;a++) printf(" %f ",P[i][a]);
					printf("\n");
				}
			}
			else 
			{
				printf(" not yet implemented(%d,%d)\n",iDiff[k]+1,iDiff[l]+1);
			}
		}
		if(nd>2)
		printf("nd=%d\n",nd);
	}
	for(j=0;j<nStates;j++)
	{
		double intensity=0;
		for(a=0;a<nDim;a++) V[a] = 0.0;
		if(vpt2KModel->pData.model.type==MODEL_PROP_GVPT2) 
		{
			int imax = 0;
			for(i=1;i<nStates;i++) if(fabs(vAnharmonic->eigenVectors[i][j])>fabs(vAnharmonic->eigenVectors[imax][j])) imax = i;
			//for(a=0;a<nDim;a++) V[a] = vAnharmonic->eigenVectors[imax][j]*P[imax][a];
			for(a=0;a<nDim;a++) V[a] = P[imax][a];
		}
		else
		{
			for(i=0;i<nStates;i++) for(a=0;a<nDim;a++) 
				V[a] += vAnharmonic->eigenVectors[i][j]*P[i][a];
		}
		for(a=0;a<nDim;a++) intensity += V[a]*V[a];
		intensity *= kmmolm1*(vAnharmonic->eigenValues[j]-vAnharmonic->eigenValues[0]);
		pAnharmonic->anHarmonic[j] = intensity;
	}
	freeMatrixDouble(&P,nStates);
	free(V);
	computeHarmonicValues(vpt2KModel);
	printIREnergiesPropCompact2(vpt2KModel,0.0);
	printIREnergiesPropCompact(vpt2KModel,1e-4);
	free(iDiff);
}
/**********************************************************************/
VPT2KModel newVPT2KModel()
{
	VPT2KModel vpt2KModel;
	vpt2KModel.klass = malloc(sizeof(VPT2KModelClass));
	vpt2KModel.klass->readData = readData;
	vpt2KModel.klass->computeAnharmonic =computeAnharmonic;
	vpt2KModel.vData = newVPT2PotentialData(0);
	vpt2KModel.pData = newVPT2PropertiesData(0,0);
	vpt2KModel.vAnharmonic = newVKAnharmonic(&vpt2KModel.vData);
	vpt2KModel.pAnharmonic = newPAnharmonic(&vpt2KModel.vData,vpt2KModel.vAnharmonic.nStates);
	initD(&vpt2KModel);
//	printf("End newVPT2KModel\n");
	return vpt2KModel;
}
/**********************************************************************/
static void computeAnharmonic(VPT2KModel* vpt2KModel)
{
	if(!vpt2KModel) return;
//	printf("Begin newVKAnharmonic\n");
	vpt2KModel->vAnharmonic = newVKAnharmonic(&vpt2KModel->vData);
	vpt2KModel->pAnharmonic = newPAnharmonic(&vpt2KModel->vData, vpt2KModel->vAnharmonic.nStates);
	initD(vpt2KModel);
//	printf("Begin computeAnharmonicEnergies\n");
	computeAnharmonicEnergies(vpt2KModel);
//	printf("End computeAnharmonicEnergies\n");
	computeAnharmonicProperties(vpt2KModel);
}
/**********************************************************************/
static boolean testDegen(VPT2KModel* vpt2KModel, double w1, double w2)
{
        double maxFrequencyDifference11Resonance = vpt2KModel->pAnharmonic.maxFrequencyDifference11Resonance;
	if(fabs(w2-w1)<maxFrequencyDifference11Resonance) return TRUE;
	return FALSE;
}
/**********************************************************************/
static boolean testResonanceFreq(VPT2KModel* vpt2KModel, double w1, double w2)
{
	double* parameters11Resonance = vpt2KModel->pAnharmonic.parameters11Resonance;
        double maxFrequencyDifference11Resonance = vpt2KModel->pAnharmonic.maxFrequencyDifference11Resonance;
	double min = w1;
	double max = w1;
	if(min>w2) min = w2;
	if(max<w2) max = w2;
	//printf(" w1 = %f w2 = %f thr = %f\n",w1,w2,maxFrequencyDifference11Resonance);
	if(min>parameters11Resonance[0] && max<parameters11Resonance[1] && fabs(w2-w1)<parameters11Resonance[2]) return TRUE;
	if(fabs(w2-w1)<maxFrequencyDifference11Resonance) return TRUE;
	return FALSE;
}
/**********************************************************************/
static boolean testResonanceCubic(VPT2KModel* vpt2KModel, double w1, double w2, double v)
{
	if(testResonanceFreq(vpt2KModel,w1,w2) && fabs(v)>= vpt2KModel->pAnharmonic.thresholds11Numerators[0]) return TRUE;
	return FALSE;
}
/**********************************************************************/
static boolean testResonanceQuartic(VPT2KModel* vpt2KModel, double w1, double w2, double v)
{
	if(testResonanceFreq(vpt2KModel,w1,w2) && fabs(v)>= vpt2KModel->pAnharmonic.thresholds11Numerators[1]) return TRUE;
	return FALSE;
}
/**********************************************************************/
static double VPT2K(VPT2KModel* vpt2KModel, double k2, int ii, int jj, int kk)
{
	double vpt2k = 0.0;
	if(fabs(k2)>1e-10) vpt2k = k2*D(vpt2KModel,ii,jj,kk);
	//printf("ii=%d jj=%d kk=%d D=%f\n",ii,jj,kk,D(vpt2KModel,ii,jj,kk));
	/*
	VPT2PotentialData* vData = &vpt2KModel->vData;
	VPT2PropModel* pModel = &vpt2KModel->pData.model;
	double wi=(ii>0)?vData->hessian[ii-1][ii-1]:-vData->hessian[-ii-1][-ii-1];
	double wj=(jj>0)?vData->hessian[jj-1][jj-1]:-vData->hessian[-jj-1][-jj-1];
	double wk=(kk>0)?vData->hessian[kk-1][kk-1]:-vData->hessian[-kk-1][-kk-1];
	double epsilon = wi+wj+wk;
	double vpt2k = k2/epsilon;
	*/
	return vpt2k;
}
/**********************************************************************/
static double VPT2(double k2, double epsilon)
{
	double vpt2 = 0.0;
	if(fabs(k2)>1e-10) vpt2 = k2/epsilon;
	return vpt2;
}
/**********************************************************************/
/* PT2 pModel: Degeneracy-corrected PT2 (DCPT2)
 Refs: K.M. Kuhler, D.G. Truhlar, A.D. Isaacson,
       J. Chem. Phys. 104, 12, 4664 (1996)
       &
       J. Bloino, M. Biczysko and V. Barone, JCTC, 8, 1015 (2012)
*/
static double DCPT2(double k2, double epsilon)
{
	double sign = (epsilon<=0)?-1.0:1.0;
	double sign2 = (k2<=0)?-1.0:1.0;
	double e = sign*epsilon*0.5;
	double r =  sign*sign2*(sqrt(sign2*k2+e*e)-e);
	//double ex = k2/epsilon;
//	printf("k2=%e\n",k2);
//	printf("e2=%e\n",e*e);
//	printf("r=%e r0=%e diff=%e\n",r,ex,r-ex);
	k2*=1;
	e *=1;
	r =  sign*sign2*(sqrt(sign2*k2+e*e)-e);
//	printf("r=%e r0=%e diff=%e\n",r,ex,r-ex);
	return r;
}
/**********************************************************************/
static double lambda(double k2, double epsilon, double alpha, double beta)
{
	double e2 = epsilon*epsilon/4;
	double x = sqrt(fabs(k2*e2))-beta;
	double l = (tanh(alpha*x)+1.0)/2.0;
//	printf("k2=%e\n",k2);
//	printf("e2=%e\n",e2);
//	printf("k2*e2=%e\n",k2*e2);
//	printf("sqrt(k2*e2)-beta=%e\n",sqrt(fabs(k2*e2))-beta);

//	printf("l%e\n",l);
	return l;
}
/**********************************************************************/
static double HDCPT2(double k2, double epsilon, double alpha, double beta)
{
	double l = lambda(k2,epsilon,alpha,beta);
	double dcpt2 = DCPT2(k2,epsilon);
	double vpt2 = VPT2(k2,epsilon);
//	printf("lambda = %f\n",l);
	return (1-l)*dcpt2+l*vpt2;
}
/**********************************************************************/
/*
static double applyModelProp(double k2, double epsilon, VPT2PropModel* pModel)
{
	if(pModel->type==MODEL_PROP_DCPT2) return DCPT2(k2,epsilon);
	if(pModel->type==MODEL_PROP_HDCPT2) return HDCPT2(k2,epsilon,pModel->alphaHDCPT2,pModel->betaHDCPT2);
	return VPT2(k2,epsilon);
}
*/
/**********************************************************************/
static double applyModelPropNew(VPT2KModel* vpt2KModel, double k2, int ii, int jj, int kk)
{
	VPT2PotentialData* vData = &vpt2KModel->vData;
	VPT2PropModel* pModel = &vpt2KModel->pData.model;
	double wi=(ii>0)?vData->hessian[ii-1][ii-1]:-vData->hessian[-ii-1][-ii-1];
	double wj=(jj>0)?vData->hessian[jj-1][jj-1]:-vData->hessian[-jj-1][-jj-1];
	double wk=(kk>0)?vData->hessian[kk-1][kk-1]:-vData->hessian[-kk-1][-kk-1];
	double epsilon = wi+wj+wk;
	if(pModel->type==MODEL_PROP_DCPT2) return DCPT2(k2,epsilon);
	if(pModel->type==MODEL_PROP_HDCPT2) return HDCPT2(k2,epsilon,pModel->alphaHDCPT2,pModel->betaHDCPT2);
	//if(pModel->type==MODEL_PROP_VPT2) {fprintf(stderr,"VPT2 PROP\n");return VPT2(k2,epsilon);}
	if(pModel->type==MODEL_PROP_VPT2) return VPT2(k2,epsilon);
	return VPT2K(vpt2KModel,k2,ii,jj,kk);
}
/**********************************************************************/
/**********************************************************************/
/* PCCP, 2014, 16, 1759-1787, page 1763-4 */
/* CPL, 496 (2010) 157161 */
/**********************************************************************/
static void computeFundamentalsProp(VPT2KModel* vpt2KModel, int i, double* Pav)
{
	int j,k,l;
	int a,c;
	double s = 0;
	double* V = NULL;
	double mu0 = 4*M_PI*1e-7;
	double eps0 = 1.0/(mu0*slight*slight);
	//double MWQ2q  = hPlank/4/M_PI/slight;
	double   kmmolm1 = 8*M_PI*M_PI*M_PI*NAvogadro/3/hPlank/slight/4/M_PI/eps0*1e-3*100.0*8.47835267e-30*8.47835267e-30;/* 1e-3 m to km, 100 : cm-1 to m-1 */
	double s0 = 1.0/sqrt(2.0);
	double s1 = s0/2;
	double s2 = s0/6;
	double S = 1.0;
	//VPT2PropModel* pModel = NULL;
	VPT2PotentialData vData;
	VPT2PropertiesData pData;
	//VKAnharmonic vAnharmonic;
	//PropertiesKAnharmonic pAnharmonic;

	if(!vpt2KModel) return;
	if(printMax) printf("kmmolm1=%f\n",kmmolm1);
	pData = vpt2KModel->pData;
	vData = vpt2KModel->vData;
	//pModel = &pData.model;
	//pAnharmonic = vpt2KModel->pAnharmonic;
	//vAnharmonic = vpt2KModel->vAnharmonic;

	V = malloc(pData.nDim*sizeof(double));

	{
		double wi=vData.hessian[i][i];
		double si=1/(wi);
		double sqrti=(wi>0)?sqrt(1.0/wi):0;

		// HARMONIC
		for(a=0;a<pData.nDim;a++) Pav[a] = 0;
		for(a=0;a<pData.nDim;a++) V[a] = 0;
		for(a=0;a<pData.nDim;a++)
		{
			double Pi = pData.first[a][i]*sqrti;
			V[a] = s0*S*Pi;
		}
		if(printMax){
		printf("%s %d %s %14.8f %20s","Mode = ",i+1,"Harmonic Frequency = ",wi," Harmonic term ");
		for(a=0;a<pData.nDim;a++) printf("%14.8f ",V[a]);
		printf("\n");
		}

		for(a=0;a<pData.nDim;a++) Pav[a] += V[a];
		for(a=0;a<pData.nDim;a++) V[a] = 0;

		for(a=0;a<pData.nDim;a++)
		{
			s = 0;
			for(j=0;j<vData.nFrequencies;j++) 
			{
				double wj = vData.hessian[j][j];
				double sqrtijj=(wi*wj*wj>0)?sqrt(1.0/(wi*wj*wj)):0;
				//double Pjji = getMaxCubicIJK(pData.cubic[a],j,j,i)*sqrtijj;
				double Pjji = (pData.cubic[a][j][j][i])*sqrtijj;
				double Pijj = (pData.cubic[a][i][j][j])*sqrtijj;
				double Pjij = (pData.cubic[a][j][i][j])*sqrtijj;
				//printf("a=%d P%d%d%d = %f %f %f\n",a,j+1,j+1,i+1,Pjji,Pijj,Pjij);
				s+= (Pjji+Pijj+S*Pjij);
			}
			V[a] += s*s2/2;
		}
		if(printMax){
		printf("%s %d %s %14.8f %20s","Mode = ",i+1,"Harmonic Frequency = ",wi," Electric term ");
		for(a=0;a<pData.nDim;a++) printf("%14.8f ",V[a]);
		printf("\n");
		}

		for(a=0;a<pData.nDim;a++) Pav[a] += V[a];
		for(a=0;a<pData.nDim;a++) V[a] = 0;

		for(a=0;a<pData.nDim;a++)
		{
			s = 0;
			for(j=0;j<vData.nFrequencies;j++) 
			{
				double wj = vData.hessian[j][j];
				double sqrtj=(wj>0)?sqrt(1.0/wj):0;
				double Pj = pData.first[a][j]*sqrtj;
				double simj=(i==j || fabs(wi-wj)<1e-13)?0:1/(wi-wj);
				double A = (1/(wi+wj))*Pj;
				double B = -simj*S*Pj;
				//boolean resDD = FALSE;
				//if(j!=i && testDD(vpt2KModel, i+1, i+1, -(j+1), -(j+1))) { resDD=TRUE;}
				/*
				if(!resDD)
				for(k=0;k<vData.nFrequencies;k++) 
				{
					if(k!=i && k!=j && testDD(vpt2KModel, i+1, i+1, -(k+1), -(k+1)) && testDD(vpt2KModel, j+1, j+1, -(k+1), -(k+1))) { resDD=TRUE;break;}
				}
				*/
				for(k=0;k<vData.nFrequencies;k++) 
				{
					//double wk=vData.hessian[k][k];
					double kijkk = getMaxQuarticIJKL(vData.quartic, i, j, k, k);
					s += kijkk*A;
					// ALLOUCHE Changed remove resDD. gaussian use resDD here
					//if(!resDD && !testDegen(vpt2KModel, wi,wj) && !testResonanceQuartic(vpt2KModel,wi,wj,kijkk)) s+= kijkk*B;
					if(!testDegen(vpt2KModel, wi,wj) && !testResonanceQuartic(vpt2KModel,wi,wj,kijkk)) s+= kijkk*B;
				}
			}
			V[a] += -s*s0/8;
		}
		if(printMax){
		printf("%s %d %s %14.8f %20s","Mode = ",i+1,"Harmonic Frequency = ",wi," Quartic term ");
		for(a=0;a<pData.nDim;a++) printf("%14.8f ",V[a]);
		printf("\n");
		}

		for(a=0;a<pData.nDim;a++) Pav[a] += V[a];
		for(a=0;a<pData.nDim;a++) V[a] = 0;

		int nnRes = 0;
		int nT1 = 0;
		double TT1 = 0.0;
		double TTT1 = 0.0;
		for(a=0;a<pData.nDim;a++)
		{
			s = 0;
			for(j=0;j<vData.nFrequencies;j++) 
			{
				double wj=vData.hessian[j][j];
				double sqrtij=(wi*wj>0)?sqrt(1.0/(wi*wj)):0;
				//double Pji = getMaxMatrixIJ(pData.second[a],j,i)*sqrtij;
				//double Pij = getMaxMatrixIJ(pData.second[a],i,j)*sqrtij;
				double Pji = (pData.second[a][j][i])*sqrtij;
				double Pij = (pData.second[a][i][j])*sqrtij;

				for(k=0;k<vData.nFrequencies;k++) 
				{
					double wk=vData.hessian[k][k];
					double sqrtjk=(wj*wk>0)?sqrt(1.0/(wj*wk)):0;
					double kijk = getMaxCubicIJK(vData.cubic,i,j,k);
					double kjkk = getMaxCubicIJK(vData.cubic,j,k,k);
					//double Pjk = getMaxMatrixIJ(pData.second[a],j,k)*sqrtjk;
					//double Pkj = getMaxMatrixIJ(pData.second[a],k,j)*sqrtjk;
					double Pjk = (pData.second[a][j][k])*sqrtjk;
					double Pkj = (pData.second[a][k][j])*sqrtjk;

					if(fabs(kijk)>1e-6)
					{
					s += kijk*(Pjk+Pkj)*(1/(wi+wj+wk));
					//s += -(Pjk+Pkj)*S*applyModelProp(kijk,wi-wj-wk,pModel);
					//if(!testFermi(vpt2KModel, i+1,-(j+1),-(k+1))) { s += -(Pjk+Pkj)*kijk/(wi-wj-wk);}
					s += -(Pjk+Pkj)*S*applyModelPropNew(vpt2KModel, kijk, i+1,-(j+1),-(k+1));
					if(testFermi(vpt2KModel, i+1,-(j+1),-(k+1))) nnRes++;
					if(!testFermi(vpt2KModel, i+1,-(j+1),-(k+1))) { nT1++; if(a==2) TT1 += (Pjk+Pkj)*kijk/(wi-wj-wk); TTT1 += kijk/(wi-wj-wk);}
					//printf("%14.8f %14.8f\n",wi, (Pjk+Pkj)*S*applyModelPropNew(vpt2KModel, kijk, i+1,-(j+1),-(k+1))*s1/8);
					//s += -(Pjk+Pkj)*S*kijk/(wi-wj-wk);
					}

					s += kjkk/wj*(2*S*Pji+(1+S)*Pij);
				}
			}
			V[a] += -s*s1/8;
		}
		if(printMax){
		printf("nnRes = %d\n",nnRes/pData.nDim);
		printf("nT1 = %d\n",nT1/pData.nDim);
		printf("TT1 = %14.8e\n",TT1);
		printf("TTT1 = %14.8e\n",TTT1/pData.nDim);
		printf("%s %d %s %14.8f %20s","Mode = ",i+1,"Harmonic Frequency = ",wi," Mixed term ");
		for(a=0;a<pData.nDim;a++) printf("%14.8f ",V[a]);
		printf("\n");
		}

		for(a=0;a<pData.nDim;a++) Pav[a] += V[a];
		for(a=0;a<pData.nDim;a++) V[a] = 0;

		for(a=0;a<pData.nDim;a++)
		{
			s = 0;
			for(j=0;j<vData.nFrequencies;j++) 
			{
				double wj=vData.hessian[j][j];
				double simj=(i==j || fabs(wi-wj)<1e-13)?0:1/(wi-wj);
				double sij=1/(wi+wj);
				double sqrtj=(wj>0)?sqrt(1.0/wj):0;
				double Pj = pData.first[a][j]*sqrtj;
				double A;
				double B;

				if(fabs(Pj)<1e-10) continue;

				for(k=0;k<vData.nFrequencies;k++) 
				{
					double wk=vData.hessian[k][k];
					double sum = 0;
					for(c=0;c<3;c++)
					{
						double cik = getMaxMatrixIJ(vData.coriolis[c],i,k);
						double cjk = getMaxMatrixIJ(vData.coriolis[c],j,k);
						double Be = vData.Be[c];
						sum += Be*cik*cjk;
					}
					A = sij*(sqrt(wi*wj)/wk-wk/sqrt(wi*wj))*Pj;
					s += A*sum;
					if(!testDegen(vpt2KModel, wi,wj) && !testResonanceQuartic(vpt2KModel,wi,wj,sum)) 
					{
						//printf("xwi = %f wj = %f sum = %f pas de res \n",wi,wj,sum);
						B = S*simj*(sqrt(wi*wj)/wk+wk/sqrt(wi*wj))*Pj;
						s += B*sum;
					}
				}
			}
			V[a] += s*s0/2;
		}
		if(printMax){
		printf("%s %d %s %14.8f %20s","Mode = ",i+1,"Harmonic Frequency = ",wi," Coriolis term ");
		for(a=0;a<pData.nDim;a++) printf("%14.8f ",V[a]);
		printf("\n");
		}
		for(a=0;a<pData.nDim;a++) Pav[a] += V[a];
		for(a=0;a<pData.nDim;a++) V[a] = 0;


		for(a=0;a<pData.nDim;a++)
		{
			s = 0;
			for(j=0;j<vData.nFrequencies;j++) 
			{
				double wj=vData.hessian[j][j];
				double sj = 1/wj;
				double sij=1/(wi+wj);
				double siij=1/(wi+wi+wj);
				double sqrtj=(wj>0)?sqrt(1.0/wj):0;
				double Pj = pData.first[a][j]*sqrtj;
				double dij = (i==j)?1.0:0.0;
				double ddij = (i==j)?0.0:1.0;
				double simj=(i==j || fabs(wi-wj)<1e-13)?0:1/(wi-wj);

				if(fabs(Pj)<1e-10) continue;
				for(k=0;k<vData.nFrequencies;k++) 
				{
					double wk=vData.hessian[k][k];
					double sk = 1/wk;
					double sijk  = 1/(wi+wj+wk);
					double siik  = 1/(wi+wi+wk);
					double dik = (i==k)?1:0.0;
					double ddik = (i==k)?0:1.0;
					double kijk = getMaxCubicIJK(vData.cubic,i,j,k);

					for(l=0;l<vData.nFrequencies;l++) 
					{
						double wl=vData.hessian[l][l];
						double sjkl=1/(wj+wk+wl);
						double sikl=1/(wi+wk+wl);
						double dil = (i==l)?1:0.0;
						double ddil = (i==l)?0:1.0;
						double dijk = ddij*ddik*ddil;
						double kikl = getMaxCubicIJK(vData.cubic,i,k,l);
						double kjkl = getMaxCubicIJK(vData.cubic,j,k,l);
						double kllk = getMaxCubicIJK(vData.cubic,l,l,k);
						double kABC= kikl*kjkl;
						double kDEF=  kijk*kllk;
						double t;

						double A = 0.0;
						double B = 0.0;
						double C = 0.0;
						double D = 0.0;
						double E = 0.0;
						double F = 0.0;

						A = kABC*dijk*(sij*sjkl+S*sikl*sjkl+sij*sikl);
					        //A  += -applyModelProp(kABC*dijk*sjkl,wi-wk-wl,pModel);
					        A  += -applyModelPropNew(vpt2KModel, kABC*dijk*sjkl, i+1,-(k+1),-(l+1));
						B = kABC*dij*(1+dik)*ddil*(0.5*si*sikl+S*0.5*sikl*sikl);
					        //t = applyModelProp(sqrt(kABC*dij*(1+dik)*ddil*0.5),wi-wk-wl,pModel);
					        t = applyModelPropNew(vpt2KModel, sqrt(kABC*dij*(1+dik)*ddil*0.5), i+1,-(k+1),-(l+1));
					        B  += -S*t*t;
					        //B  += -applyModelProp(kABC*dij*(1+dik)*ddil*0.5*si,wi-wk-wl,pModel);
					        B  += -applyModelPropNew(vpt2KModel, kABC*dij*(1+dik)*ddil*0.5*si, i+1,-(k+1),-(l+1));

						C = kABC*ddij*ddik*dil*(sk*sij+2.0*siik*sij+3.0*sij*sijk+2*S*siik*sijk+3*sk*sijk);
					        //C  += -S*applyModelProp(kABC*ddij*ddik*dil*sk,wi-wj-wk,pModel);
					        C  += -S*applyModelPropNew(vpt2KModel, kABC*ddij*ddik*dil*sk,i+1,-(j+1),-(k+1));

						if(!testDegen(vpt2KModel, wi,wj) && !testResonanceCubic(vpt2KModel,wi,wj,kikl*kjkl))
						{ 
							A += kABC*ddik*ddil*S*simj*(-sjkl);
					        	//A  += S*applyModelProp(kABC*ddik*ddil*simj,wi-wk-wl,pModel);
					        	A  += S*applyModelPropNew(vpt2KModel,kABC*ddik*ddil*simj, i+1,-(k+1),-(l+1));
							C += kABC*ddik*dil*S*simj*(-2*sijk-3*sk);
					        	//C  += S*applyModelProp( kABC*ddik*dil*simj,wi-wj-wk,pModel);
					        	C  += S*applyModelPropNew(vpt2KModel, kABC*ddik*dil*simj,i+1,-(j+1),-(k+1));
						}

						D  = kDEF*dij*si*sk*(1.0+(6.0-4.0*S)*dik*dil/9.0);
						E  = kDEF*dijk*(sij*sijk+sk*sij+sk*sijk);
					        //E  += -S*applyModelProp(kDEF*dijk*sk,wi-wj-wk,pModel);
					        E  += -S*applyModelPropNew(vpt2KModel, kDEF*dijk*sk,i+1,-(j+1),-(k+1));
						F  = kDEF*dik*ddij*(1.0+dil)*(siij*sij+si*siij);
						F += kDEF*dik*ddij*(dil)*(1.0/3.0*si*sij+S/3.0*si*siij);
						F += kDEF*dik*ddij*(si*sij+S*si*sj);

						if(!testDegen(vpt2KModel, wi,wj) && !testResonanceCubic(vpt2KModel,wi,wj,kijk*kllk))
						{ 
							E += kDEF*ddik*ddil*S*simj*(-sk);
					        	//E += S*applyModelProp(kDEF*ddik*ddil*simj,wi-wj-wk,pModel);
					        	E += S*applyModelPropNew(vpt2KModel, kDEF*ddik*ddil*simj,i+1,-(j+1),-(k+1));
							F += -kDEF*dik*(1.0+dil)*S*simj*si;
							F += -kDEF*dik*(dil)*S*simj*siij;
							F += -kDEF*dik*S*simj*sj;
						}
						s += (A+B+C)*Pj;
						s += (D+E+F)*Pj;
					}
				}
			}
			V[a] += s*s0/16.0;
		}
		if(printMax){
		printf("%s %d %s %14.8f %20s","Mode = ",i+1,"Harmonic Frequency = ",wi," Cubic term ");
		for(a=0;a<pData.nDim;a++) printf("%14.8f ",V[a]);
		printf("\n");
		}

		for(a=0;a<pData.nDim;a++) Pav[a] += V[a];
		for(a=0;a<pData.nDim;a++) V[a] = 0;

		if(printMax){
		printf("%s %d %s %14.8f %20s","Mode = ",i+1,"Harmonic Frequency = ",wi," SUM ");
		for(a=0;a<pData.nDim;a++) printf("%14.8f ",Pav[a]);
		printf("\n");
		}
	}
	free(V);
}
/**********************************************************************/
/* JCP 136, 124108, 2012 Bloino & Barone */
/* JPCA 2015, Bloino DOI: 10.1021/jp509985u */
static void computeOvertonesProp(VPT2KModel* vpt2KModel, int i, double* Pav)
{
	int k;
	int a;
	double s;
	double s0 = 1.0/sqrt(2.0);
	double s1 = s0/2;
	//double s2 = s0/6;
	double S = 1;
	//VPT2PropModel* pModel = NULL;
	VPT2PotentialData vData;
	VPT2PropertiesData pData;
	//VKAnharmonic vAnharmonic;
	//PropertiesKAnharmonic pAnharmonic;

	if(!vpt2KModel) return;

	pData = vpt2KModel->pData;
	vData = vpt2KModel->vData;
	//pModel = &pData.model;
	//pAnharmonic = vpt2KModel->pAnharmonic;
	//vAnharmonic = vpt2KModel->vAnharmonic;
	{
		double wi=vData.hessian[i][i];

		for(a=0;a<pData.nDim;a++) Pav[a] = 0;

		for(a=0;a<pData.nDim;a++)
		{
			double Pii=pData.second[a][i][i]/sqrt(wi*wi);
			Pav[a] += Pii*s1*S;
			s = 0;
			for(k=0;k<vData.nFrequencies;k++) 
			{
				double wk=vData.hessian[k][k];
				double Pk = pData.first[a][k]/sqrt(wk);
				double kiik = getMaxCubicIJK(vData.cubic, i, i, k);
				//s += S*applyModelProp(kiik,wi+wi-wk,pModel)*Pk;
				s += S*applyModelPropNew(vpt2KModel, kiik,i+1,i+1,-(k+1))*Pk;
				s += -kiik*Pk/(wi+wi+wk);
			}
			Pav[a] += s*s0/4;
		}
	}
}
/**********************************************************************/
static void computeCombinationBandsProp(VPT2KModel* vpt2KModel, int i, int j, double* Pav)
{
	int k;
	int a;
	double s;
	double s0 = 1.0/sqrt(2.0);
	double s1 = s0/2;
	//double s2 = s0/6;
	double S = 1;
	double sqrt2 = sqrt(2.0);
	//VPT2PropModel* pModel = NULL;
	VPT2PotentialData vData;
	VPT2PropertiesData pData;
	//VKAnharmonic vAnharmonic;
	//PropertiesKAnharmonic pAnharmonic;

	if(!vpt2KModel) return;
	//pAnharmonic = vpt2KModel->pAnharmonic;
	//vAnharmonic = vpt2KModel->vAnharmonic;

	pData = vpt2KModel->pData;
	vData = vpt2KModel->vData;
	//pModel = &pData.model;

	{
		double wi=vData.hessian[i][i];
		{
			double wj=vData.hessian[j][j];
			for(a=0;a<pData.nDim;a++) Pav[a] = 0;
			if(i==j) return;
			for(a=0;a<pData.nDim;a++)
			{
				double Pij=(pData.second[a][i][j]+pData.second[a][j][i])/2.0/sqrt(wi*wj);
				//double Pij=getMaxMatrixIJ(pData.second[a],i,j)/sqrt(wi*wj);
				Pav[a] += s1*S*Pij;
				s = 0;
				for(k=0;k<vData.nFrequencies;k++) 
				{
					double wk=vData.hessian[k][k];
					double Pk = pData.first[a][k]/sqrt(wk);
					double kijk = getMaxCubicIJK(vData.cubic, i, j, k);
					//s += S*applyModelProp(kijk,wi+wj-wk,pModel)*Pk;
					s += S*applyModelPropNew(vpt2KModel,kijk,i+1,j+1,-(k+1))*Pk;
					s += -kijk*Pk/(wi+wj+wk);
				}
				Pav[a] += s*s0/4;
			}
			for(a=0;a<pData.nDim;a++) Pav[a] *= sqrt2;
		}
	}
}
/**********************************************************************/
static void computeHarmonicProp(VPT2KModel* vpt2KModel, int i, double* Pav)
{
	VPT2PropertiesData* pData = &vpt2KModel->pData;
	int a;
	for(a=0;a<pData->nDim;a++) Pav[a] = pData->first[a][i]/sqrt(2.0);
}
File: ./cchemilib/src/VPT2/VPT2PropertiesData.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* VPT2Properties.c */

#include <math.h>
#include "VPT2PropertiesData.h"

//static boolean printMax = FALSE;

static void readData(VPT2PropertiesData* vpt2PropertiesData, char* fileName);
static void printData(VPT2PropertiesData* vpt2PropertiesData);
/**********************************************************************/
static VPT2PropModel newModel(VPT2PropModelType type, double alpha, double beta)
{
	VPT2PropModel model;
	model.type = type;
	model.alphaHDCPT2 = alpha;
	model.betaHDCPT2 = beta;
	return model;
}
/**********************************************************************/
/* PCCP, 2014, 16, 1759-1787, page 1763-4 */
/* CPL, 496 (2010) 157161 */
/**********************************************************************/
VPT2PropertiesData newVPT2PropertiesData(int nDim, int n)
{
	VPT2PropertiesData vpt2PropertiesData;
	vpt2PropertiesData.klass = malloc(sizeof(VPT2PropertiesDataClass));
	vpt2PropertiesData.klass->readData = readData;
	vpt2PropertiesData.nFrequencies = n;
	vpt2PropertiesData.nDim = nDim;
	if(vpt2PropertiesData.nFrequencies<=0) vpt2PropertiesData.nFrequencies = 0;
	if(vpt2PropertiesData.nDim<=0) vpt2PropertiesData.nDim = 0;
	if(vpt2PropertiesData.nDim>6) vpt2PropertiesData.nDim = 6;
	vpt2PropertiesData.first = NULL;
	vpt2PropertiesData.first = newMatrixDouble(vpt2PropertiesData.nDim,vpt2PropertiesData.nFrequencies);
	initMatrixDouble(vpt2PropertiesData.first, vpt2PropertiesData.nDim, vpt2PropertiesData.nFrequencies, 0.0);

	vpt2PropertiesData.second = newCubeDouble(vpt2PropertiesData.nDim, vpt2PropertiesData.nFrequencies,vpt2PropertiesData.nFrequencies);
	initCubeDouble(vpt2PropertiesData.second, vpt2PropertiesData.nDim, vpt2PropertiesData.nFrequencies, vpt2PropertiesData.nFrequencies, 0.0);

	vpt2PropertiesData.cubic = newQuarticDouble(vpt2PropertiesData.nDim, vpt2PropertiesData.nFrequencies, vpt2PropertiesData.nFrequencies, vpt2PropertiesData.nFrequencies);
	initQuarticDouble(vpt2PropertiesData.cubic, vpt2PropertiesData.nDim, vpt2PropertiesData.nFrequencies, vpt2PropertiesData.nFrequencies, vpt2PropertiesData.nFrequencies, 0.0);
	vpt2PropertiesData.model = newModel(MODEL_PROP_VPT2,1.0,5e5);
	return vpt2PropertiesData;
}
/*****************************************************************************/
static void printFirst(VPT2PropertiesData* vpt2PropertiesData)
{
	printf("\nFirst derivatives\n");
	printMatrixDoubleCutOff(vpt2PropertiesData->first, vpt2PropertiesData->nDim, vpt2PropertiesData->nFrequencies, 1e-10);
	printf("END\n\n");
}
static void printSecond(VPT2PropertiesData* vpt2PropertiesData)
{
	printf("\nSecond derivatives\n");
	printCubeDoubleCutOff(vpt2PropertiesData->second, vpt2PropertiesData->nDim, vpt2PropertiesData->nFrequencies, vpt2PropertiesData->nFrequencies,1e-10);
	printf("END\n\n");
}
static void printCubic(VPT2PropertiesData* vpt2PropertiesData)
{
	printf("\nCubic derivatives\n");
	printQuarticDoubleCutOff(vpt2PropertiesData->cubic, vpt2PropertiesData->nDim, vpt2PropertiesData->nFrequencies, vpt2PropertiesData->nFrequencies, vpt2PropertiesData->nFrequencies,1e-10);
	printf("END\n\n");
}
static void printData(VPT2PropertiesData* vpt2PropertiesData)
{
	printFirst(vpt2PropertiesData);
	printSecond(vpt2PropertiesData);
	printCubic(vpt2PropertiesData);
}
/*****************************************************************************/
static void readData(VPT2PropertiesData* vpt2PropertiesData, char* inputFileName)
{
	FILE* inputFile;
	char* tmp = NULL;
        inputFile = fopen(inputFileName,"rb");
	if(!inputFile)
	{
		fprintf(stderr, "==========================================================\n");
		fprintf(stderr, "Sorry, I cannot opent the %s file\n", inputFileName);
		fprintf(stderr, "==========================================================\n");
		exit(1);
	}
	readOneInt(inputFile,"nFrequencies",&vpt2PropertiesData->nFrequencies);
	fprintf(stdout, "nFrequencies=%d\n", vpt2PropertiesData->nFrequencies);
	readOneInt(inputFile,"nDim",&vpt2PropertiesData->nDim);
	fprintf(stdout, "nDim=%d\n", vpt2PropertiesData->nDim);
	if(vpt2PropertiesData->nDim<=0)
	{
		fprintf(stderr, "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		fprintf(stderr, "I cannot read properties vpt2PropertiesData from input file : nDim=%d\n", vpt2PropertiesData->nDim);
		fprintf(stderr, "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n");
		exit(1);
	}
	*vpt2PropertiesData = newVPT2PropertiesData(vpt2PropertiesData->nDim, vpt2PropertiesData->nFrequencies);

	readMatrixReal(inputFile,"First Derivatives",vpt2PropertiesData->nDim, vpt2PropertiesData->nFrequencies, vpt2PropertiesData->first);
	readCubeReal(inputFile,"Second Derivatives",vpt2PropertiesData->nDim, vpt2PropertiesData->nFrequencies, vpt2PropertiesData->nFrequencies, vpt2PropertiesData->second);
	readQuarticReal(inputFile,"Cubic Derivatives", vpt2PropertiesData->nDim, vpt2PropertiesData->nFrequencies, vpt2PropertiesData->nFrequencies, vpt2PropertiesData->nFrequencies, vpt2PropertiesData->cubic);

	readOneReal(inputFile,"alphaPropHDCPT2",&vpt2PropertiesData->model.alphaHDCPT2);
	readOneReal(inputFile,"betaPropHDCPT2",&vpt2PropertiesData->model.betaHDCPT2);
	
	readOneString(inputFile,"PropModel",&tmp);
	if(tmp && mystrcasestr(tmp,"NONE")) vpt2PropertiesData->model.type = MODEL_PROP_VPT2;
	if(tmp && mystrcasestr(tmp,"VPT2")) vpt2PropertiesData->model.type = MODEL_PROP_VPT2;
	if(tmp && mystrcasestr(tmp,"DCPT2")) vpt2PropertiesData->model.type = MODEL_PROP_DCPT2;
	if(tmp && mystrcasestr(tmp,"HDCPT2")) vpt2PropertiesData->model.type = MODEL_PROP_HDCPT2;
	if(tmp && mystrcasestr(tmp,"VPT2+K")) vpt2PropertiesData->model.type = MODEL_PROP_VPT2K;
	if(tmp && mystrcasestr(tmp,"GVPT2")) vpt2PropertiesData->model.type = MODEL_PROP_GVPT2;
	if(tmp && mystrcasestr(tmp,"GVPT2S")) vpt2PropertiesData->model.type = MODEL_PROP_GVPT2S;
	if(tmp) free(tmp);
	if(vpt2PropertiesData->model.type==MODEL_PROP_VPT2) printf("VPT2 Properties model : VPT2\n");
	if(vpt2PropertiesData->model.type==MODEL_PROP_DCPT2) printf("VPT2 Properties model : DCPT2\n");
	if(vpt2PropertiesData->model.type==MODEL_PROP_HDCPT2) printf("VPT2 Propertiesmodel : HDCPT2\n");
	if(vpt2PropertiesData->model.type==MODEL_PROP_VPT2K) printf("VPT2 Properties model : VPT2+K\n");
	if(vpt2PropertiesData->model.type==MODEL_PROP_GVPT2) printf("VPT2 Properties model : GVPT2 : Gaussian method\n");
	if(vpt2PropertiesData->model.type==MODEL_PROP_GVPT2S) printf("VPT2 Properties model : GVPT2 : Gaussian method but sum on all basis set\n");

	printData(vpt2PropertiesData);

}
File: ./cchemilib/src/VPT2/VPT2Model.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* VPT2Model.c */
#include <math.h>
#include "VPT2Model.h"

static boolean printMax = FALSE;

static void computeAnharmonic(VPT2Model* vpt2Model);
static void readData(VPT2Model* vpt2Model, char* inputFileName);
static boolean testDegen(VPT2Model* vpt2Model, double w1, double w2);
static boolean testResonanceCubic(VPT2Model* vpt2Model, double w1, double w2, double v);
static boolean testResonanceQuartic(VPT2Model* vpt2Model, double w1, double w2, double v);
static double applyModelPropNew(VPT2Model* vpt2Model, double k2, int ii, int jj, int kk);
/**********************************************************************/
static boolean testFermi(VPT2Model* vpt2Model, int ii, int jj, int kk)
{
	VPT2PotentialData* data = &vpt2Model->vData;
        double maxFrequencyDifferenceFermi = data->maxFrequencyDifferenceFermi;
        double XI = data->parametersResonance[0];
        double XII = data->parametersResonance[1];
        double Z = data->parametersResonance[2];
	int i=abs(ii)-1;
	int j=abs(jj)-1;
	int k=abs(kk)-1;
	double wi;
	double wj;
	double wk;
	double sqrt8=sqrt(1.0/8.0);
	boolean res = FALSE;
	double sijk = 0;

	if(Z<=0 && XI<=0 && XII<=0) 
	{
		XI = 1.0;
		XII = 1.0;
		if(maxFrequencyDifferenceFermi<=0) maxFrequencyDifferenceFermi = 200;
	}

	wi=(ii>0)?data->hessian[i][i]:-data->hessian[i][i];
	wj=(jj>0)?data->hessian[j][j]:-data->hessian[j][j];
	wk=(kk>0)?data->hessian[k][k]:-data->hessian[k][k];
	sijk =wi+wj+wk;
	if(fabs(sijk)<maxFrequencyDifferenceFermi) 
	{
		if(Z>0)
		{
			double fijk=getMaxCubicIJK(vpt2Model->vData.cubic,i,j,k)*sqrt8;
			if(i==j||i==k||j==k) fijk *= 0.5;
			if(fijk/fabs(sijk)>Z) 
			{
					res = TRUE;
					fprintf(stderr,"Warning Fermi resonnance : ");
					fprintf(stderr,"k,l,m = %d %d %d dklm=%f Z=%f Zcut=%f\n",i+1,j+1,k+1,sijk,fijk/fabs(sijk),Z);
			}
		}
		else if(XI>0 && XII>0)
		{
			double X = 0;
			double dijk = fabs(sijk);
			double fijk=getMaxCubicIJK(vpt2Model->vData.cubic,i,j,k);
			X = (fijk*fijk*fijk*fijk)/(dijk*dijk*dijk)/64.0;
			if(i==j||i==k||j==k)
			{
				X *= 0.25;
				if(X>XI) 
				{
					res = TRUE;
					fprintf(stderr,"Warning Fermi resonnance : ");
					fprintf(stderr,"k,l,m = %d %d %d dklm=%f X=%f XI=%f\n",ii,jj,kk,sijk,X,XI);
				}
			}
			else if(X>XII) { 
				res = TRUE;
				fprintf(stderr,"Warning Fermi resonnance : ");
				fprintf(stderr,"k,l,m = %d %d %d dklm=%f X=%f XI=%f\n",ii,jj,kk,sijk,X,XI);
			}
		}
	}
	return res;
}
/**********************************************************************/
static void computeFundamentalsEnergies(VAnharmonic* vAnharmonic)
{
	int i,j;
	if(!vAnharmonic) return;
	if(!vAnharmonic->Xi) return;
	for(i=0;i<vAnharmonic->nFrequencies;i++) 
	{
		vAnharmonic->fundamentals[i] = vAnharmonic->harmonicFrequencies[i]+2*vAnharmonic->Xi[i][i];
		for(j=0;j<vAnharmonic->nFrequencies;j++)
		{
			if(i!=j) vAnharmonic->fundamentals[i] += 0.5*vAnharmonic->Xi[i][j];
		}
	}
}
/**********************************************************************/
static void printFundamentalsEnergies(VAnharmonic* vAnharmonic)
{
	int i;
	if(!vAnharmonic) return;
	if(!vAnharmonic->fundamentals) return;
	printf("Fundamentals\n");
	printf("------------\n");
	printf("%-10s %-10s %-20s %-20s\n","Mode","Quanta","E(harm)","E(anharm)");
	for(i=0;i<vAnharmonic->nFrequencies;i++) 
		printf("%-10d %-10d %-20.8f %-20.8f\n",i+1,1,vAnharmonic->harmonicFrequencies[i], vAnharmonic->fundamentals[i]);
	printf("\n");
}
/**********************************************************************/
static void computeOvertonesEnergies(VAnharmonic* vAnharmonic)
{
	int i,j;
	if(!vAnharmonic) return;
	if(!vAnharmonic->Xi) return;
	for(i=0;i<vAnharmonic->nFrequencies;i++) 
	{
		vAnharmonic->overtones[i] = 2*vAnharmonic->harmonicFrequencies[i]+6*vAnharmonic->Xi[i][i];
		for(j=0;j<vAnharmonic->nFrequencies;j++)
			if(i!=j) vAnharmonic->overtones[i] += vAnharmonic->Xi[i][j];
	}
}
/**********************************************************************/
static void printOvertonesEnergies(VAnharmonic* vAnharmonic)
{
	int i;
	if(!vAnharmonic) return;
	if(!vAnharmonic->Xi) return;
	printf("Overtones\n");
	printf("---------\n");
	printf("%-10s %-10s %-20s %-20s\n","Mode","Quanta","E(harm)","E(anharm)");
	for(i=0;i<vAnharmonic->nFrequencies;i++) 
		printf("%-10d %-10d %-20.8f %-20.8f\n",i+1,2,2*vAnharmonic->harmonicFrequencies[i], vAnharmonic->overtones[i]);
	printf("\n");
}
/**********************************************************************/
static void computeCombinationBandsEnergies(VAnharmonic* vAnharmonic)
{
	int i,j,k;
	if(!vAnharmonic) return;
	if(!vAnharmonic->Xi) return;

	for(i=0;i<vAnharmonic->nFrequencies;i++) 
	for(j=0;j<i;j++) 
	{
		vAnharmonic->combinationBands[i][j] = 
						  vAnharmonic->harmonicFrequencies[i]
						+ vAnharmonic->harmonicFrequencies[j]
						+ 2*vAnharmonic->Xi[i][i]
						+ 2*vAnharmonic->Xi[j][j]
						+ 2*vAnharmonic->Xi[i][j]
						;
		for(k=0;k<vAnharmonic->nFrequencies;k++)
			if(k!=i && k!=j) vAnharmonic->combinationBands[i][j] += 0.5*vAnharmonic->Xi[i][k]+ 0.5*vAnharmonic->Xi[j][k];
	}
}
/**********************************************************************/
static void printCombinationBandsEnergies(VAnharmonic* vAnharmonic)
{
	int i,j;
	if(!vAnharmonic) return;
	if(!vAnharmonic->Xi) return;
	printf("Combination Bands\n");
	printf("-----------------\n");
	printf("%-10s %-10s %-10s %-10s %-20s %-20s\n","Mode","Quanta","Mode","Quanta","E(harm)","E(anharm)");
	for(i=0;i<vAnharmonic->nFrequencies;i++) 
	for(j=0;j<i;j++) 
		printf("%-10d %-10d %-10d %-10d %-20.8f %-20.8f\n",i+1,1,j+1,1,vAnharmonic->harmonicFrequencies[i]+vAnharmonic->harmonicFrequencies[j], vAnharmonic->combinationBands[i][j]);
	printf("\n");
}
/**********************************************************************/
static void printIREnergies(VAnharmonic* vAnharmonic)
{
	printFundamentalsEnergies(vAnharmonic);
	printOvertonesEnergies(vAnharmonic);
	printCombinationBandsEnergies(vAnharmonic);
}
/**********************************************************************/
static double VPT2(double k2, double epsilon)
{
	double vpt2 = 0.0;
	if(fabs(epsilon)>1e-10) vpt2 = k2/epsilon;
	//else printf("warning k2 = %f epslison = %f\n",k2,epsilon);
	return vpt2;
}
/**********************************************************************/
static double VPT2Fermi(VPT2Model* vpt2Model, double k2, int ii, int jj, int kk)
{
	VPT2PotentialData* vData = &vpt2Model->vData;
	double wi;
	double wj;
	double wk;
	double epsilon;
	if(testFermi(vpt2Model, ii, jj, kk)) return 0.0;

	wi=(ii>0)?vData->hessian[ii-1][ii-1]:-vData->hessian[-ii-1][-ii-1];
	wj=(jj>0)?vData->hessian[jj-1][jj-1]:-vData->hessian[-jj-1][-jj-1];
	wk=(kk>0)?vData->hessian[kk-1][kk-1]:-vData->hessian[-kk-1][-kk-1];
	epsilon = wi+wj+wk;
	return k2/epsilon;
}
/**********************************************************************/
/* PT2 pModel: Degeneracy-corrected PT2 (DCPT2)
 Refs: K.M. Kuhler, D.G. Truhlar, A.D. Isaacson,
       J. Chem. Phys. 104, 12, 4664 (1996)
       &
       J. Bloino, M. Biczysko and V. Barone, JCTC, 8, 1015 (2012)
*/
static double DCPT2(double k2, double epsilon)
{
	double sign = (epsilon<=0)?-1.0:1.0;
	double sign2 = (k2<=0)?-1.0:1.0;
	double e = sign*epsilon*0.5;
	double r =  sign*sign2*(sqrt(sign2*k2+e*e)-e);
	//double ex = k2/epsilon;
//	printf("k2=%e\n",k2);
//	printf("e2=%e\n",e*e);
//	printf("r=%e r0=%e diff=%e\n",r,ex,r-ex);
	k2*=1;
	e *=1;
	r =  sign*sign2*(sqrt(sign2*k2+e*e)-e);
//	printf("r=%e r0=%e diff=%e\n",r,ex,r-ex);
	return r;
}
/**********************************************************************/
static double lambda(double k2, double epsilon, double alpha, double beta)
{
	double e2 = epsilon*epsilon/4;
	double x = sqrt(fabs(k2*e2))-beta;
	double l = (tanh(alpha*x)+1.0)/2.0;
//	printf("k2=%e\n",k2);
//	printf("e2=%e\n",e2);
//	printf("k2*e2=%e\n",k2*e2);
//	printf("sqrt(k2*e2)-beta=%e\n",sqrt(fabs(k2*e2))-beta);

//	printf("l%e\n",l);
	return l;
}
/**********************************************************************/
static double HDCPT2(double k2, double epsilon, double alpha, double beta)
{
	double l = lambda(k2,epsilon,alpha,beta);
	double dcpt2 = DCPT2(k2,epsilon);
	double vpt2 = VPT2(k2,epsilon);
//	printf("lambda = %f\n",l);
	return (1-l)*dcpt2+l*vpt2;
}
/**********************************************************************/
static double applyModelEnergies(double k2, double epsilon, VPT2VModel* model)
{
	if(model->type==MODEL_DCPT2) return DCPT2(k2,epsilon);
	if(model->type==MODEL_HDCPT2) return HDCPT2(k2,epsilon,model->alphaHDCPT2,model->betaHDCPT2);
	return VPT2(k2,epsilon);
}
/**********************************************************************/
/* PCCP, 2014, 16, 1759-1787, page 1761 */
static void computeXi(VPT2Model* vpt2Model)
{
	int i,j,k;
	int c;
	double s = 0;
	VAnharmonic* vAnharmonic = &vpt2Model->vAnharmonic;
	VPT2PotentialData* data = &vpt2Model->vData;
	VPT2VModel* model = NULL;
	if(!vAnharmonic) return;
	if(!data) return;
	if(!data->hessian) return;
	if(!vAnharmonic->Xi) return;
	model = &data->model;
	/* compute Xii */
	for(i=0;i<vAnharmonic->nFrequencies;i++)
	{
		double wi=data->hessian[i][i];
		double si = 1/(wi);
		double s16w2 = si*si/16;
		double sqrti = (wi>0)?sqrt(wi):0;
		double kiii=data->cubic[i][i][i];
		double Sii = 0;
		vAnharmonic->Xi[i][i] = 0;
		/* Nii terms  see JCTC 2012, 8, 1015*/
		vAnharmonic->Xi[i][i] += data->quartic[i][i][i][i]/16.0;
		vAnharmonic->Xi[i][i] += -kiii*kiii/wi*5.0/3.0/16.0;
		/* Sii terms */
		Sii = 0;
		for(j=0;j<vAnharmonic->nFrequencies;j++)
		{
			double kiij=getMaxCubicIJK(data->cubic,i,i,j);
			double wj=data->hessian[j][j];
			double sqrtj = (wj>0)?sqrt(wj):0;
			double sj = 1/(wj);
			double sj2 = sj*sj;
			double siij = 1/(wi+wi+wj);
			double Kiij = kiij*sqrti*sqrti*sqrtj;
			double Kiij2 = Kiij*Kiij;
			if(j==i) continue;
		
			Sii += -(2*Kiij2*sj2+Kiij2*0.5*sj*siij)*s16w2;
			Sii += applyModelEnergies(Kiij2*0.5*sj*s16w2,2*wi-wj,model);
		}
		vAnharmonic->Xi[i][i] += Sii;
	}
	/* compute Xij */
	/* Nij terms */
	for(i=0;i<vAnharmonic->nFrequencies;i++)
	{
		double wi=data->hessian[i][i];
		double wi2=wi*wi;
		double kiii=data->cubic[i][i][i];
		for(j=0;j<vAnharmonic->nFrequencies;j++)
		{
			double wj=data->hessian[j][j];
			double wj2=wj*wj;
			double kjjj=getMaxCubicIJK(data->cubic,j,j,j);
			double kiij=getMaxCubicIJK(data->cubic,i,i,j);
			double kijj=getMaxCubicIJK(data->cubic,i,j,j);
			double kiijj=getMaxQuarticIJKL(data->quartic, i, i, j, j);
			double num;
			double denom;
			if(i==j) continue;

			vAnharmonic->Xi[i][j] = 0;
			vAnharmonic->Xi[i][j] += kiijj;

			num = kiii*kijj;
			denom=wi;
			if(fabs(denom)>1e-10) vAnharmonic->Xi[i][j] += -num/denom;

			num = kjjj*kiij;
			denom=wj;
			if(fabs(denom)>1e-10) vAnharmonic->Xi[i][j] += -num/denom;

			s = 0;
			for(k=0;k<vAnharmonic->nFrequencies;k++)
			{
				double wk=data->hessian[k][k];
				double kiik=getMaxCubicIJK(data->cubic,i,i,k);
				double kjjk=getMaxCubicIJK(data->cubic,j,j,k);
				if(k==j || k==i) continue;
				num = kiik*kjjk;
				denom=wk;
				if(fabs(denom)>1e-10) s += -num/denom;
			}
			vAnharmonic->Xi[i][j] += s;
			/* coriolis contributions */
			num = 4*(wi2+wj2);
			denom=wi*wj;
			if(fabs(denom)>1e-10) 
			{
				double s = 0;
				for(c=0;c<3;c++)
				{
					double xetaij=data->coriolis[c][i][j];
					if(fabs(data->coriolis[c][j][i])>fabs(xetaij)) xetaij=data->coriolis[c][j][i];
					s += data->Be[c]*xetaij*xetaij;
				}
				vAnharmonic->Xi[i][j] += num/denom*s;
			}
		}
	}
	for(i=0;i<vAnharmonic->nFrequencies;i++)
		for(j=0;j<vAnharmonic->nFrequencies;j++)
			if(i!=j)vAnharmonic->Xi[i][j] /= 4;
	/* Sij terms */
	/* JCTC, Bloino, 2012 : page 1018 : error in sign, first term in Sij */
	for(i=0;i<vAnharmonic->nFrequencies;i++)
	{
		double wi=data->hessian[i][i];
		double si=1/wi;
		double sqrti = sqrt(wi);

		for(j=0;j<vAnharmonic->nFrequencies;j++)
		{
			double wj=data->hessian[j][j];
			double sqrtj = sqrt(wj);
			double sj=1/wj;
			double s4wiwj=si*sj/4;
			double siij=1/(wi+wi+wj);
			double sjji=1/(wj+wj+wi);
			double kiij=getMaxCubicIJK(data->cubic,i,i,j);
			double kijj=getMaxCubicIJK(data->cubic,i,j,j);
			double Kiij=kiij*sqrti*sqrti*sqrtj;
			double Kijj=kijj*sqrti*sqrtj*sqrtj;
			double Kiij2=Kiij*Kiij;
			double Kijj2=Kijj*Kijj;
			double Sij = 0;
			if(i==j) continue;

			Sij += -Kiij2/8/wi/wi/wj*siij;
			Sij += -applyModelEnergies(Kiij2/8/wi/wi/wj,2*wi-wj,model);
			Sij += -Kijj2/8/wi/wj/wj*sjji;
			Sij += -applyModelEnergies(Kijj2/8/wi/wj/wj,2*wj-wi,model);

			for(k=0;k<vAnharmonic->nFrequencies;k++)
			{
				double wk=data->hessian[k][k];
				double sqrtk = sqrt(wk);
				double sk=1/wk;
				double sijk=1/(wi+wj+wk);
				double kijk=getMaxCubicIJK(data->cubic,i,j,k);
				double Kijk=kijk*sqrti*sqrtj*sqrtk;
				double Kijk2=Kijk*Kijk;
				double k2 = Kijk2*0.5*sk*s4wiwj;
				if(k==j || k==i) continue;
				Sij +=  -k2*sijk;
				/*
				Sij +=-k2/(wk-wi-wj);
				Sij += k2/(wi-wj-wk);
				Sij += k2/(wj-wi-wk);
				*/
				Sij +=  -applyModelEnergies(k2,wk-wi-wj,model);
				Sij += applyModelEnergies(k2,wi-wj-wk,model);
				Sij += applyModelEnergies(k2,wj-wi-wk,model);
			}
			vAnharmonic->Xi[i][j] += Sij;
		}
	}
}
/**********************************************************************/
static VAnharmonic newVAnharmonic(VPT2PotentialData* vData)
{
	VAnharmonic vAnharmonic;
	int n = 0;
	if(vData) n = vData->nFrequencies;
	vAnharmonic.nFrequencies = n;
	if(vAnharmonic.nFrequencies<=0) vAnharmonic.nFrequencies = 0;

	vAnharmonic.harmonicFrequencies = newVectorDouble(vAnharmonic.nFrequencies);
	initVectorDouble(vAnharmonic.harmonicFrequencies, vAnharmonic.nFrequencies, 0.0);

	if(vData && vData->hessian)
	{
		int i=0;
		for(i=0;i<vAnharmonic.nFrequencies;i++) vAnharmonic.harmonicFrequencies[i] = vData->hessian[i][i];
	}
	vAnharmonic.Xi = newMatrixDouble(vAnharmonic.nFrequencies,vAnharmonic.nFrequencies);
	initMatrixDouble(vAnharmonic.Xi, vAnharmonic.nFrequencies, vAnharmonic.nFrequencies, 0.0);
	vAnharmonic.fundamentals = newVectorDouble(vAnharmonic.nFrequencies);
	initVectorDouble(vAnharmonic.fundamentals, vAnharmonic.nFrequencies, 0.0);

	vAnharmonic.overtones = newVectorDouble(vAnharmonic.nFrequencies);
	initVectorDouble(vAnharmonic.overtones, vAnharmonic.nFrequencies, 0.0);

	vAnharmonic.combinationBands = newMatrixDouble(vAnharmonic.nFrequencies,vAnharmonic.nFrequencies);
	initMatrixDouble(vAnharmonic.combinationBands, vAnharmonic.nFrequencies, vAnharmonic.nFrequencies, 0.0);

	return vAnharmonic;
}
/*****************************************************************************/
static void readData(VPT2Model* vpt2Model, char* inputFileName)
{
	FILE* inputFile;
        inputFile = fopen(inputFileName,"rb");
	if(!inputFile)
	{
		fprintf(stderr, "==========================================================\n");
		fprintf(stderr, "Sorry, I cannot opent the %s file\n", inputFileName);
		fprintf(stderr, "==========================================================\n");
		exit(1);
	}
	fclose(inputFile);
	vpt2Model->vData.klass->readData(&vpt2Model->vData, inputFileName);
	vpt2Model->pData.klass->readData(&vpt2Model->pData, inputFileName);
}
/**********************************************************************/
static void computeAnharmonicEnergies(VPT2Model* vpt2Model)
{
	computeXi(vpt2Model);
	printf("\nXi (cm^-1)\n");
	printMatrixDoubleCutOff(vpt2Model->vAnharmonic.Xi, vpt2Model->vAnharmonic.nFrequencies, vpt2Model->vAnharmonic.nFrequencies,1e-10);
	printf("END\n\n");

	computeFundamentalsEnergies(&vpt2Model->vAnharmonic);
	computeOvertonesEnergies(&vpt2Model->vAnharmonic);
	computeCombinationBandsEnergies(&vpt2Model->vAnharmonic);
	printIREnergies(&vpt2Model->vAnharmonic);
}
/**********************************************************************/
/*
static double applyModelProp(double k2, double epsilon, VPT2PropModel* pModel)
{
	if(pModel->type==MODEL_PROP_DCPT2) return DCPT2(k2,epsilon);
	if(pModel->type==MODEL_PROP_HDCPT2) return HDCPT2(k2,epsilon,pModel->alphaHDCPT2,pModel->betaHDCPT2);
	return VPT2(k2,epsilon);
}
*/
/**********************************************************************/
static double applyModelPropNew(VPT2Model* vpt2Model, double k2, int ii, int jj, int kk)
{
	VPT2PropModel* pModel = &vpt2Model->pData.model;
	VPT2PotentialData* vData = &vpt2Model->vData;
	double wi=(ii>0)?vData->hessian[ii-1][ii-1]:-vData->hessian[-ii-1][-ii-1];
	double wj=(jj>0)?vData->hessian[jj-1][jj-1]:-vData->hessian[-jj-1][-jj-1];
	double wk=(kk>0)?vData->hessian[kk-1][kk-1]:-vData->hessian[-kk-1][-kk-1];
	double epsilon = wi+wj+wk;
	if(pModel->type==MODEL_PROP_DCPT2) return DCPT2(k2,epsilon);
	if(pModel->type==MODEL_PROP_HDCPT2) return HDCPT2(k2,epsilon,pModel->alphaHDCPT2,pModel->betaHDCPT2);
	if(pModel->type==MODEL_PROP_VPT2) return VPT2(k2,epsilon);
	return VPT2Fermi(vpt2Model,k2,ii,jj,kk);
}
/**********************************************************************/
/* PCCP, 2014, 16, 1759-1787, page 1763-4 */
/* CPL, 496 (2010) 157161 */
/**********************************************************************/
static void computeFundamentalsProp(VPT2Model* vpt2Model)
{
	int i,j,k,l;
	int a,c;
	double s = 0;
	double* Pav = NULL;
	double* V = NULL;
	double mu0 = 4*PI*1e-7;
	double eps0 = 1.0/(mu0*slight*slight);
	//double MWQ2q  = hPlank/4/PI/slight;
	double   kmmolm1 = 8*PI*PI*PI*NAvogadro/3/hPlank/slight/4/PI/eps0*1e-3*100.0*8.47835267e-30*8.47835267e-30;/* 1e-3 m to km, 100 : cm-1 to m-1 */
	double s0 = 1.0/sqrt(2.0);
	double s1 = s0/2;
	double s2 = s0/6;
	double S = 1.0;
	//VPT2PropModel* pModel = NULL;
	VPT2PotentialData vData;
	VPT2PropertiesData pData;
	VAnharmonic vAnharmonic;
	PropertiesAnharmonic pAnharmonic;

	if(!vpt2Model) return;
	if(printMax) printf("kmmolm1=%f\n",kmmolm1);
	pData = vpt2Model->pData;
	vData = vpt2Model->vData;
	//pModel = &pData.model;
	pAnharmonic = vpt2Model->pAnharmonic;
	vAnharmonic = vpt2Model->vAnharmonic;

	Pav = malloc(pData.nDim*sizeof(double));
	V = malloc(pData.nDim*sizeof(double));

	for(i=0;i<vData.nFrequencies;i++) 
	{
		double wi=vData.hessian[i][i];
		double si=1/(wi);
		double sqrti=(wi>0)?sqrt(1.0/wi):0;

		pAnharmonic.harmonic[i]     = 0.0;
		pAnharmonic.fundamentals[i] = 0.0;

		// HARMONIC
		for(a=0;a<pData.nDim;a++) Pav[a] = 0;
		for(a=0;a<pData.nDim;a++) V[a] = 0;
		for(a=0;a<pData.nDim;a++)
		{
			double Pi = pData.first[a][i]*sqrti;
			V[a] = s0*S*Pi;
		}
		if(printMax){
		printf("%s %d %s %10.4f %20s","Mode = ",i+1,"Harmonic Frequency = ",wi," Harmonic term ");
		for(a=0;a<pData.nDim;a++) printf("%f ",V[a]);
		printf("\n");
		}

		for(a=0;a<pData.nDim;a++) Pav[a] += V[a];
		for(a=0;a<pData.nDim;a++) V[a] = 0;

		for(a=0;a<pData.nDim;a++)
		{
			s = 0;
			for(j=0;j<vData.nFrequencies;j++) 
			{
				double wj = vData.hessian[j][j];
				double sqrtijj=(wi*wj*wj>0)?sqrt(1.0/(wi*wj*wj)):0;
				//double Pjji = getMaxCubicIJK(pData.cubic[a],j,j,i)*sqrtijj;
				double Pjji = (pData.cubic[a][j][j][i])*sqrtijj;
				double Pijj = (pData.cubic[a][i][j][j])*sqrtijj;
				double Pjij = (pData.cubic[a][j][i][j])*sqrtijj;
				//printf("a=%d P%d%d%d = %f %f %f\n",a,j+1,j+1,i+1,Pjji,Pijj,Pjij);
				s+= (Pjji+Pijj+S*Pjij);
			}
			V[a] += s*s2/2;
		}
		if(printMax){
		printf("%s %d %s %10.4f %20s","Mode = ",i+1,"Harmonic Frequency = ",wi," Electric term ");
		for(a=0;a<pData.nDim;a++) printf("%f ",V[a]);
		printf("\n");
		}

		for(a=0;a<pData.nDim;a++) Pav[a] += V[a];
		for(a=0;a<pData.nDim;a++) V[a] = 0;

		for(a=0;a<pData.nDim;a++)
		{
			s = 0;
			for(j=0;j<vData.nFrequencies;j++) 
			{
				double wj = vData.hessian[j][j];
				double sqrtj=(wj>0)?sqrt(1.0/wj):0;
				double Pj = pData.first[a][j]*sqrtj;
				double simj=(i==j || fabs(wi-wj)<1e-13)?0:1/(wi-wj);
				double A = (1/(wi+wj))*Pj;
				double B = -simj*S*Pj;
				for(k=0;k<vData.nFrequencies;k++) 
				{
					//double wk=vData.hessian[k][k];
					double kijkk = getMaxQuarticIJKL(vData.quartic, i, j, k, k);
					s += kijkk*A;
					if(!testDegen(vpt2Model, wi,wj) && !testResonanceQuartic(vpt2Model,wi,wj,kijkk)) 
						s+= kijkk*B;
				}
			}
			V[a] += -s*s0/8;
		}
		if(printMax){
		printf("%s %d %s %10.4f %20s","Mode = ",i+1,"Harmonic Frequency = ",wi," Quartic term ");
		for(a=0;a<pData.nDim;a++) printf("%f ",V[a]);
		printf("\n");
		}

		for(a=0;a<pData.nDim;a++) Pav[a] += V[a];
		for(a=0;a<pData.nDim;a++) V[a] = 0;

		for(a=0;a<pData.nDim;a++)
		{
			s = 0;
			for(j=0;j<vData.nFrequencies;j++) 
			{
				double wj=vData.hessian[j][j];
				double sqrtij=(wi*wj>0)?sqrt(1.0/(wi*wj)):0;
				//double Pji = getMaxMatrixIJ(pData.second[a],j,i)*sqrtij;
				double Pji = (pData.second[a][j][i])*sqrtij;
				double Pij = (pData.second[a][i][j])*sqrtij;

				for(k=0;k<vData.nFrequencies;k++) 
				{
					double wk=vData.hessian[k][k];
					double sqrtjk=(wj*wk>0)?sqrt(1.0/(wj*wk)):0;
					double kijk = getMaxCubicIJK(vData.cubic,i,j,k);
					double kjkk = getMaxCubicIJK(vData.cubic,j,k,k);
					//double Pjk = getMaxMatrixIJ(pData.second[a],j,k)*sqrtjk;
					//double Pkj = getMaxMatrixIJ(pData.second[a],k,j)*sqrtjk;
					double Pjk = (pData.second[a][j][k])*sqrtjk;
					double Pkj = (pData.second[a][k][j])*sqrtjk;


					s += kijk*(Pjk+Pkj)*(1/(wi+wj+wk));
					//s += -(Pjk+Pkj)*S*applyModelProp(kijk,wi-wj-wk,pModel);
					s += -(Pjk+Pkj)*S*applyModelPropNew(vpt2Model,kijk,i+1,-(j+1),-(k+1));
					s += kjkk/wj*(2*S*Pji+(1+S)*Pij);
				}
			}
			V[a] += -s*s1/8;
		}
		if(printMax){
		printf("%s %d %s %10.4f %20s","Mode = ",i+1,"Harmonic Frequency = ",wi," Mixed term ");
		for(a=0;a<pData.nDim;a++) printf("%f ",V[a]);
		printf("\n");
		}

		for(a=0;a<pData.nDim;a++) Pav[a] += V[a];
		for(a=0;a<pData.nDim;a++) V[a] = 0;

		for(a=0;a<pData.nDim;a++)
		{
			s = 0;
			for(j=0;j<vData.nFrequencies;j++) 
			{
				double wj=vData.hessian[j][j];
				double simj=(i==j)?0:1/(wi-wj);
				double sij=1/(wi+wj);
				double sqrtj=(wj>0)?sqrt(1.0/wj):0;
				double Pj = pData.first[a][j]*sqrtj;
				double A;
				double B;

				if(fabs(Pj)<1e-10) continue;

				for(k=0;k<vData.nFrequencies;k++) 
				{
					double wk=vData.hessian[k][k];
					double sum = 0;
					for(c=0;c<3;c++)
					{
						double cik = getMaxMatrixIJ(vData.coriolis[c],i,k);
						double cjk = getMaxMatrixIJ(vData.coriolis[c],j,k);
						double Be = vData.Be[c];
						sum += Be*cik*cjk;
					}
					A = sij*(sqrt(wi*wj)/wk-wk/sqrt(wi*wj))*Pj;
					s += A*sum;
					if(!testDegen(vpt2Model, wi,wj) && !testResonanceQuartic(vpt2Model,wi,wj,sum)) 
					{
						//printf("xwi = %f wj = %f sum = %f pas de res \n",wi,wj,sum);
						B = S*simj*(sqrt(wi*wj)/wk+wk/sqrt(wi*wj))*Pj;
						s += B*sum;
					}
				}
			}
			V[a] += s*s0/2;
		}
		if(printMax){
		printf("%s %d %s %10.4f %20s","Mode = ",i+1,"Harmonic Frequency = ",wi," Coriolis term ");
		for(a=0;a<pData.nDim;a++) printf("%f ",V[a]);
		printf("\n");
		}
		for(a=0;a<pData.nDim;a++) Pav[a] += V[a];
		for(a=0;a<pData.nDim;a++) V[a] = 0;


		for(a=0;a<pData.nDim;a++)
		{
			s = 0;
			for(j=0;j<vData.nFrequencies;j++) 
			{
				double wj=vData.hessian[j][j];
				double sj = 1/wj;
				double sij=1/(wi+wj);
				double siij=1/(wi+wi+wj);
				double sqrtj=(wj>0)?sqrt(1.0/wj):0;
				double Pj = pData.first[a][j]*sqrtj;
				double dij = (i==j)?1.0:0.0;
				double ddij = (i==j)?0.0:1.0;
				double simj=(i==j)?0:1.0/(wi-wj);

				if(fabs(Pj)<1e-10) continue;
				for(k=0;k<vData.nFrequencies;k++) 
				{
					double wk=vData.hessian[k][k];
					double sk = 1/wk;
					double sijk  = 1/(wi+wj+wk);
					double siik  = 1/(wi+wi+wk);
					double dik = (i==k)?1:0.0;
					double ddik = (i==k)?0:1.0;
					double kijk = getMaxCubicIJK(vData.cubic,i,j,k);

					for(l=0;l<vData.nFrequencies;l++) 
					{
						double wl=vData.hessian[l][l];
						double sjkl=1/(wj+wk+wl);
						double sikl=1/(wi+wk+wl);
						double dil = (i==l)?1:0.0;
						double ddil = (i==l)?0:1.0;
						double dijk = ddij*ddik*ddil;
						double kikl = getMaxCubicIJK(vData.cubic,i,k,l);
						double kjkl = getMaxCubicIJK(vData.cubic,j,k,l);
						double kllk = getMaxCubicIJK(vData.cubic,l,l,k);
						double kABC= kikl*kjkl;
						double kDEF=  kijk*kllk;
						double t;

						double A = 0.0;
						double B = 0.0;
						double C = 0.0;
						double D = 0.0;
						double E = 0.0;
						double F = 0.0;

						A = kABC*dijk*(sij*sjkl+S*sikl*sjkl+sij*sikl);
					        //A  += -applyModelProp(kABC*dijk*sjkl,wi-wk-wl,pModel);
					        A  += -applyModelPropNew(vpt2Model, kABC*dijk*sjkl,i+1,-(k+1),-(l+1));

						B = kABC*dij*(1+dik)*ddil*(0.5*si*sikl+S*0.5*sikl*sikl);
					        //t = applyModelProp(sqrt(kABC*dij*(1+dik)*ddil*0.5),wi-wk-wl,pModel);
					        t = applyModelPropNew(vpt2Model, sqrt(kABC*dij*(1+dik)*ddil*0.5),i+1,-(k+1),-(l+1));
					        B  += -S*t*t;
					        //B  += -applyModelProp(kABC*dij*(1+dik)*ddil*0.5*si,wi-wk-wl,pModel);
					        B  += -applyModelPropNew(vpt2Model, kABC*dij*(1+dik)*ddil*0.5*si,i+1,-(k+1),-(l+1));

						C = kABC*ddij*ddik*dil*(sk*sij+2.0*siik*sij+3.0*sij*sijk+2*S*siik*sijk+3*sk*sijk);
					        //C  += -S*applyModelProp(kABC*ddij*ddik*dil*sk,wi-wj-wk,pModel);
					        C  += -S*applyModelPropNew(vpt2Model, kABC*ddij*ddik*dil*sk,i+1,-(j+1),-(k+1));

						if(!testDegen(vpt2Model, wi,wj) && !testResonanceCubic(vpt2Model,wi,wj,kikl*kjkl))
						{ 
							A += kABC*ddik*ddil*S*simj*(-sjkl);
					        	//A  += S*applyModelProp(kABC*ddik*ddil*simj,wi-wk-wl,pModel);
					        	A  += S*applyModelPropNew(vpt2Model, kABC*ddik*ddil*simj,i+1,-(k+1),-(l+1));

							C += kABC*ddik*dil*S*simj*(-2*sijk-3*sk);
					        	//C  += S*applyModelProp( kABC*ddik*dil*simj,wi-wj-wk,pModel);
					        	C  += S*applyModelPropNew(vpt2Model,  kABC*ddik*dil*simj,i+1,-(j+1),-(k+1));
						}

						D  = kDEF*dij*si*sk*(1.0+(6.0-4.0*S)*dik*dil/9.0);
						E  = kDEF*dijk*(sij*sijk+sk*sij+sk*sijk);
					        //E  += -S*applyModelProp(kDEF*dijk*sk,wi-wj-wk,pModel);
					        E  += -S*applyModelPropNew(vpt2Model, kDEF*dijk*sk,i+1,-(j+1),-(k+1));
						F  = kDEF*dik*ddij*(1.0+dil)*(siij*sij+si*siij);
						F += kDEF*dik*ddij*(dil)*(1.0/3.0*si*sij+S/3.0*si*siij);
						F += kDEF*dik*ddij*(si*sij+S*si*sj);

						if(!testDegen(vpt2Model, wi,wj) && !testResonanceCubic(vpt2Model,wi,wj,kijk*kllk))
						{ 
							E += kDEF*ddik*ddil*S*simj*(-sk);
					        	//E += S*applyModelProp(kDEF*ddik*ddil*simj,wi-wj-wk,pModel);
					        	E += S*applyModelPropNew(vpt2Model, kDEF*ddik*ddil*simj,i+1,-(j+1),-(k+1));
							F += -kDEF*dik*(1.0+dil)*S*simj*si;
							F += -kDEF*dik*(dil)*S*simj*siij;
							F += -kDEF*dik*S*simj*sj;
						}
						s += (A+B+C)*Pj;
						s += (D+E+F)*Pj;
					}
				}
			}
			V[a] += s*s0/16.0;
		}
		if(printMax){
		printf("%s %d %s %10.4f %20s","Mode = ",i+1,"Harmonic Frequency = ",wi," Cubic term ");
		for(a=0;a<pData.nDim;a++) printf("%f ",V[a]);
		printf("\n");
		}

		for(a=0;a<pData.nDim;a++) Pav[a] += V[a];
		for(a=0;a<pData.nDim;a++) V[a] = 0;

		if(printMax){
		printf("%s %d %s %10.4f %20s","Mode = ",i+1,"Harmonic Frequency = ",wi," SUM ");
		for(a=0;a<pData.nDim;a++) printf("%f ",Pav[a]);
		printf("\n");
		}

		pAnharmonic.fundamentals[i] = 0.0;
		for(a=0;a<pData.nDim;a++) pAnharmonic.fundamentals[i] += Pav[a]*Pav[a];
		pAnharmonic.fundamentals[i] *= kmmolm1*vAnharmonic.fundamentals[i];
		pAnharmonic.harmonic[i] = 0.0;
		for(a=0;a<pData.nDim;a++) pAnharmonic.harmonic[i] += pData.first[a][i]*pData.first[a][i]/2;
		pAnharmonic.harmonic[i] *=  kmmolm1;
	}
	
	free(Pav);
	free(V);
}
/**********************************************************************/
static void printFundamentalsProp(VPT2Model* vpt2Model)
{
	int i;
	VAnharmonic vAnharmonic;
	PropertiesAnharmonic pAnharmonic;
	if(!vpt2Model) return;
	vAnharmonic = vpt2Model->vAnharmonic;
	pAnharmonic = vpt2Model->pAnharmonic;

	printf("Fundamentals\n");
	printf("------------\n");
	printf("%-10s %-10s %-20s %-20s %-20s %-20s\n","Mode","Quanta","E(harm)","E(anharm)", "I(harm)","I(anharm)");
	for(i=0;i<vAnharmonic.nFrequencies;i++) 
		printf("%-10d %-10d %-20.8f %-20.8f %-20.8f %-20.8f\n",i+1,1,
		vAnharmonic.harmonicFrequencies[i], vAnharmonic.fundamentals[i],
		pAnharmonic.harmonic[i], pAnharmonic.fundamentals[i]);
	printf("\n");
}
/**********************************************************************/
/* JCP 136, 124108, 2012 Bloino & Barone */
/* JPCA 2015, Bloino DOI: 10.1021/jp509985u */
static void computeOvertonesProp(VPT2Model* vpt2Model)
{
	int i,k;
	int a;
	double* Pav;
	double s;
	double mu0 = 4*PI*1e-7;
	double eps0 = 1.0/(mu0*slight*slight);
	double   kmmolm1 = 8*PI*PI*PI*NAvogadro/3/hPlank/slight/4/PI/eps0*1e-3*100.0*8.47835267e-30*8.47835267e-30;/* 1e-3 m to km, 100 : cm-1 to m-1 */
	double s0 = 1.0/sqrt(2.0);
	double s1 = s0/2;
	//double s2 = s0/6;
	double S = 1;
	//VPT2PropModel* pModel = NULL;
	VPT2PotentialData vData;
	VPT2PropertiesData pData;
	VAnharmonic vAnharmonic;
	PropertiesAnharmonic pAnharmonic;

	if(!vpt2Model) return;

	pData = vpt2Model->pData;
	vData = vpt2Model->vData;
	//pModel = &pData.model;
	pAnharmonic = vpt2Model->pAnharmonic;
	vAnharmonic = vpt2Model->vAnharmonic;

	Pav = malloc(pData.nDim*sizeof(double));
	for(i=0;i<pAnharmonic.nFrequencies;i++) 
	{
		double wi=vData.hessian[i][i];

		pAnharmonic.overtones[i] = 0.0;
		for(a=0;a<pData.nDim;a++) Pav[a] = 0;

		for(a=0;a<pData.nDim;a++)
		{
			double Pii=pData.second[a][i][i]/sqrt(wi*wi);
			Pav[a] += Pii*s1*S;
			s = 0;
			for(k=0;k<vData.nFrequencies;k++) 
			{
				double wk=vData.hessian[k][k];
				double Pk = pData.first[a][k]/sqrt(wk);
				double kiik = getMaxCubicIJK(vData.cubic, i, i, k);
				//s += S*applyModelProp(kiik,wi+wi-wk,pModel)*Pk;
				s += S*applyModelPropNew(vpt2Model, kiik,i+1,i+1,-(k+1))*Pk;
				s += -kiik*Pk/(wi+wi+wk);
			}
			Pav[a] += s*s0/4;
		}
		pAnharmonic.overtones[i] = 0.0;
		for(a=0;a<pData.nDim;a++) pAnharmonic.overtones[i] += Pav[a]*Pav[a];
		pAnharmonic.overtones[i] *= kmmolm1*vAnharmonic.overtones[i];
	}
	free(Pav);
}
/**********************************************************************/
static void printOvertonesProp(VPT2Model* vpt2Model)
{
	int i;
	VAnharmonic vAnharmonic;
	PropertiesAnharmonic pAnharmonic;
	if(!vpt2Model) return;
	vAnharmonic = vpt2Model->vAnharmonic;
	pAnharmonic = vpt2Model->pAnharmonic;
	printf("Overtones\n");
	printf("---------\n");
	printf("%-10s %-10s %-20s %-20s %-20s\n","Mode","Quanta","E(harm)","E(anharm)","I(anharm)");
	for(i=0;i<vAnharmonic.nFrequencies;i++) 
		printf("%-10d %-10d %-20.8f %-20.8f %-20.8f\n",i+1,2,
		2*vAnharmonic.harmonicFrequencies[i], 
		vAnharmonic.overtones[i],pAnharmonic.overtones[i]);
	printf("\n");
}
/**********************************************************************/
static void computeCombinationBandsProp(VPT2Model* vpt2Model)
{
	int i,j,k;
	int a;
	double* Pav;
	double s;
	double mu0 = 4*PI*1e-7;
	double eps0 = 1.0/(mu0*slight*slight);
	double   kmmolm1 = 8*PI*PI*PI*NAvogadro/3/hPlank/slight/4/PI/eps0*1e-3*100.0*8.47835267e-30*8.47835267e-30;/* 1e-3 m to km, 100 : cm-1 to m-1 */
	double s0 = 1.0/sqrt(2.0);
	double s1 = s0/2;
	//double s2 = s0/6;
	double S = 1;
	double sqrt2 = sqrt(2.0);
	//VPT2PropModel* pModel = NULL;
	VPT2PotentialData vData;
	VPT2PropertiesData pData;
	VAnharmonic vAnharmonic;
	PropertiesAnharmonic pAnharmonic;

	if(!vpt2Model) return;
	pAnharmonic = vpt2Model->pAnharmonic;
	vAnharmonic = vpt2Model->vAnharmonic;

	pData = vpt2Model->pData;
	vData = vpt2Model->vData;
	//pModel = &pData.model;

	Pav = malloc(pData.nDim*sizeof(double));
	for(i=0;i<pAnharmonic.nFrequencies;i++) 
	{
		double wi=vData.hessian[i][i];
		for(j=0;j<vData.nFrequencies;j++) 
		{
			double wj=vData.hessian[j][j];
			if(i==j) {vAnharmonic.combinationBands[i][j] = 0.0; continue;}
			for(a=0;a<pData.nDim;a++) Pav[a] = 0;
			for(a=0;a<pData.nDim;a++)
			{
				//double Pij=(pData.second[a][i][j]+pData.second[a][j][i])/sqrt(wi*wj);
				double Pij=getMaxMatrixIJ(pData.second[a],i,j)/sqrt(wi*wj);
				Pav[a] += s1*S*Pij;
				s = 0;
				for(k=0;k<vData.nFrequencies;k++) 
				{
					double wk=vData.hessian[k][k];
					double Pk = pData.first[a][k]/sqrt(wk);
					double kijk = getMaxCubicIJK(vData.cubic, i, j, k);
					//s += S*applyModelProp(kijk,wi+wj-wk,pModel)*Pk;
					s += S*applyModelPropNew(vpt2Model, kijk,i+1,j+1,-(k+1))*Pk;
					s += -kijk*Pk/(wi+wj+wk);
				}
				Pav[a] += s*s0/4;
			}
			for(a=0;a<pData.nDim;a++) Pav[a] *= sqrt2;

			pAnharmonic.combinationBands[i][j] = 0.0;
			for(a=0;a<pData.nDim;a++) pAnharmonic.combinationBands[i][j] += Pav[a]*Pav[a];
			pAnharmonic.combinationBands[i][j] *= kmmolm1*vAnharmonic.combinationBands[i][j];
		}
	}
	free(Pav);
}
/**********************************************************************/
static void printCombinationBandsProp(VPT2Model* vpt2Model)
{
	int i,j;
	VAnharmonic vAnharmonic;
	PropertiesAnharmonic pAnharmonic;

	if(!vpt2Model) return;
	pAnharmonic = vpt2Model->pAnharmonic;
	vAnharmonic = vpt2Model->vAnharmonic;
	printf("Combination Bands\n");
	printf("-----------------\n");
	printf("%-10s %-10s %-10s %-10s %-20s %-20s %-20s\n","Mode","Quanta","Mode","Quanta","E(harm)","E(anharm)","I(anharm)");
	for(i=0;i<vAnharmonic.nFrequencies;i++) 
	for(j=0;j<i;j++) 
		printf("%-10d %-10d %-10d %-10d %-20.8f %-20.8f %-20.8f\n",i+1,1,j+1,1,
		vAnharmonic.harmonicFrequencies[i]+vAnharmonic.harmonicFrequencies[j], 
		vAnharmonic.combinationBands[i][j],pAnharmonic.combinationBands[i][j]);
	printf("\n");
}
/**********************************************************************/
static void printIRProp(VPT2Model* vpt2Model)
{
	printFundamentalsProp(vpt2Model);
	printOvertonesProp(vpt2Model);
	printCombinationBandsProp(vpt2Model);
}
/**********************************************************************/
static boolean testDegen(VPT2Model* vpt2Model, double w1, double w2)
{
        double maxFrequencyDifference11Resonance = vpt2Model->pAnharmonic.maxFrequencyDifference11Resonance;
	if(fabs(w2-w1)<maxFrequencyDifference11Resonance) return TRUE;
	return FALSE;
}
/**********************************************************************/
static boolean testResonanceFreq(VPT2Model* vpt2Model, double w1, double w2)
{
	double* parameters11Resonance = vpt2Model->pAnharmonic.parameters11Resonance;
        double maxFrequencyDifference11Resonance = vpt2Model->pAnharmonic.maxFrequencyDifference11Resonance;
	double min = w1;
	double max = w1;
	if(min>w2) min = w2;
	if(max<w2) max = w2;
	//printf(" w1 = %f w2 = %f thr = %f\n",w1,w2,maxFrequencyDifference11Resonance);
	if(min>parameters11Resonance[0] && max<parameters11Resonance[1] && fabs(w2-w1)<parameters11Resonance[2]) return TRUE;
	if(fabs(w2-w1)<maxFrequencyDifference11Resonance) return TRUE;
	return FALSE;
}
/**********************************************************************/
static boolean testResonanceCubic(VPT2Model* vpt2Model, double w1, double w2, double v)
{
	if(testResonanceFreq(vpt2Model,w1,w2) && fabs(v)>= vpt2Model->pAnharmonic.thresholds11Numerators[0]) return TRUE;
	return FALSE;
}
/**********************************************************************/
static boolean testResonanceQuartic(VPT2Model* vpt2Model, double w1, double w2, double v)
{
	if(testResonanceFreq(vpt2Model,w1,w2) && fabs(v)>= vpt2Model->pAnharmonic.thresholds11Numerators[1]) return TRUE;
	return FALSE;
}
/**********************************************************************/
static PropertiesAnharmonic  newPAnharmonic(VPT2PotentialData*  vData)
{
	PropertiesAnharmonic pAnharmonic;
	int i;
	int n = 0;
	if(vData) n = vData->nFrequencies;
	pAnharmonic.nFrequencies = n;
	if(pAnharmonic.nFrequencies<=0) pAnharmonic.nFrequencies = 0;

	pAnharmonic.harmonic = newVectorDouble(pAnharmonic.nFrequencies);
	initVectorDouble(pAnharmonic.harmonic, pAnharmonic.nFrequencies, 0.0);

	pAnharmonic.fundamentals = newVectorDouble(pAnharmonic.nFrequencies);
	initVectorDouble(pAnharmonic.fundamentals, pAnharmonic.nFrequencies, 0.0);

	pAnharmonic.overtones = newVectorDouble(pAnharmonic.nFrequencies);
	initVectorDouble(pAnharmonic.overtones, pAnharmonic.nFrequencies, 0.0);

	pAnharmonic.combinationBands = newMatrixDouble(pAnharmonic.nFrequencies,pAnharmonic.nFrequencies);
	initMatrixDouble(pAnharmonic.combinationBands, pAnharmonic.nFrequencies, pAnharmonic.nFrequencies, 0.0);

        pAnharmonic.maxFrequencyDifference11Resonance = 2;
        for( i=0;i<2;i++) pAnharmonic.thresholds11Numerators[i] = 10.0;
        for( i=0;i<3;i++) pAnharmonic.parameters11Resonance[i] = 0.0;

	return pAnharmonic;
}
/**********************************************************************/
static void computeAnharmonicProperties(VPT2Model* vpt2Model)
{
	computeFundamentalsProp(vpt2Model);
	computeOvertonesProp(vpt2Model);
	computeCombinationBandsProp(vpt2Model);
	printIRProp(vpt2Model);
}
/**********************************************************************/
VPT2Model newVPT2Model()
{
	VPT2Model vpt2Model;
	vpt2Model.klass = malloc(sizeof(VPT2ModelClass));
	vpt2Model.klass->readData = readData;
	vpt2Model.klass->computeAnharmonic =computeAnharmonic;
	vpt2Model.vData = newVPT2PotentialData(0);
	vpt2Model.pData = newVPT2PropertiesData(0,0);
	vpt2Model.vAnharmonic = newVAnharmonic(&vpt2Model.vData);
	vpt2Model.pAnharmonic = newPAnharmonic(&vpt2Model.vData);
	return vpt2Model;
}
/**********************************************************************/
static void computeAnharmonic(VPT2Model* vpt2Model)
{
	//int nf;
	if(!vpt2Model) return;
	vpt2Model->vAnharmonic = newVAnharmonic(&vpt2Model->vData);
	computeAnharmonicEnergies(vpt2Model);
	//nf = vpt2Model->vAnharmonic.nFrequencies;
	//freeCubeDouble(&vpt2Model->vData.cubic, nf, nf);
	//freeQuarticDouble(&vpt2Model->vData.quartic, nf, nf, nf);
	vpt2Model->pAnharmonic = newPAnharmonic(&vpt2Model->vData);
	//computeAnharmonicEnergies(vpt2Model);
	computeAnharmonicProperties(vpt2Model);
}
/**********************************************************************/
File: ./cchemilib/src/VPT2/VPT2PotentialData.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* VPT2PotentialData.c */
#include <math.h>
#include "VPT2PotentialData.h"

static void readData(VPT2PotentialData* vpt2PotentialData, char* fileName);
/**********************************************************************/
static VPT2VModel newModel(VPT2ModelType type, double alpha, double beta)
{
	VPT2VModel model;
	model.type = type;
	model.alphaHDCPT2 = alpha;
	model.betaHDCPT2 = beta;
	return model;
}
/**********************************************************************/
VPT2PotentialData newVPT2PotentialData(int n)
{
	VPT2PotentialData vpt2PotentialData;
	vpt2PotentialData.klass = malloc(sizeof(VPT2PotentialDataClass));
	vpt2PotentialData.klass->readData = readData;
	vpt2PotentialData.nFrequencies = n;
	if(vpt2PotentialData.nFrequencies<=0) vpt2PotentialData.nFrequencies = 0;
	vpt2PotentialData.gradients = NULL;
	vpt2PotentialData.gradients = newVectorDouble(vpt2PotentialData.nFrequencies);
	initVectorDouble(vpt2PotentialData.gradients, vpt2PotentialData.nFrequencies, 0.0);

	vpt2PotentialData.hessian = newMatrixDouble(vpt2PotentialData.nFrequencies,vpt2PotentialData.nFrequencies);
	initMatrixDouble(vpt2PotentialData.hessian, vpt2PotentialData.nFrequencies, vpt2PotentialData.nFrequencies, 0.0);

	vpt2PotentialData.Be = newVectorDouble(3);
	initVectorDouble(vpt2PotentialData.Be, 3, 1.0);

	vpt2PotentialData.cubic = newCubeDouble(vpt2PotentialData.nFrequencies, vpt2PotentialData.nFrequencies, vpt2PotentialData.nFrequencies);
	initCubeDouble(vpt2PotentialData.cubic, vpt2PotentialData.nFrequencies, vpt2PotentialData.nFrequencies, vpt2PotentialData.nFrequencies, 0.0);

	vpt2PotentialData.coriolis = newCubeDouble(3, vpt2PotentialData.nFrequencies, vpt2PotentialData.nFrequencies);
	initCubeDouble(vpt2PotentialData.coriolis, 3, vpt2PotentialData.nFrequencies, vpt2PotentialData.nFrequencies, 0.0);

	vpt2PotentialData.quartic = newQuarticDouble(vpt2PotentialData.nFrequencies, vpt2PotentialData.nFrequencies, vpt2PotentialData.nFrequencies, vpt2PotentialData.nFrequencies);
	initQuarticDouble(vpt2PotentialData.quartic, vpt2PotentialData.nFrequencies, vpt2PotentialData.nFrequencies, vpt2PotentialData.nFrequencies, vpt2PotentialData.nFrequencies, 0.0);
	vpt2PotentialData.model = newModel(MODEL_VPT2,1.0,5e5);

	vpt2PotentialData.maxFrequencyDifferenceFermi=-1;
	vpt2PotentialData.parametersResonance[0]=-1.0;
	vpt2PotentialData.parametersResonance[1]=-1.0;
	vpt2PotentialData.parametersResonance[2]=-1.0;
	return vpt2PotentialData;

}
/*****************************************************************************/
/*
static void printVPT2KHessian(VPT2PotentialData* vpt2PotentialData, char* fileName)
{
	FILE* file =fopen(fileName,"w");
	int n = vpt2PotentialData->nFrequencies;
	double cutoff = 1e-10;
	double** M = vpt2PotentialData->hessian;
	int i;
	for(i = 0;i<n; i++) 
	{
		if(fabs(M[i][i])>=cutoff)
      			fprintf(file,"%d %d %20.10f\n",i+1,i+1,M[i][i]);
	}
	fclose(file);
}
static void printVPT2KCubic(VPT2PotentialData* vpt2PotentialData, char* fileName)
{
	FILE* file =fopen(fileName,"w");
	int n = vpt2PotentialData->nFrequencies;
	double cutoff = 1e-10;
	double*** M = vpt2PotentialData->cubic;
	int i,j,k;
	for(i = 0;i<n; i++) 
	{
		for(j = 0;j<n; j++) 
		for(k = 0;k<n; k++) 
			if(fabs(M[k][i][j])>=cutoff)
      			fprintf(file,"%d %d %d %20.10f\n",i+1,j+1,k+1,M[k][i][j]);
	}
	fclose(file);
}
static void printVPT2KCoriolis(VPT2PotentialData* vpt2PotentialData, char* fileName)
{
	FILE* file =fopen(fileName,"w");
	int n = vpt2PotentialData->nFrequencies;
	int m = 3;
	double cutoff = 1e-10;
	double*** M = vpt2PotentialData->coriolis;
	int i,j,k;
	for(i = 0;i<n; i++) 
	{
		for(j = 0;j<n; j++) 
		for(k = 0;k<m; k++) 
			if(fabs(M[k][i][j])>=cutoff)
      			fprintf(file,"%d %d %d %20.10f\n",i+1,j+1,k+1,M[k][i][j]);
	}
	fclose(file);
}
static void printVPT2KRot(VPT2PotentialData* vpt2PotentialData, char* fileName)
{
	FILE* file =fopen(fileName,"w");
	double cutoff = 1e-10;
	double* M = vpt2PotentialData->Be;
	int i;
	for(i = 0;i<3; i++) 
	{
		if(fabs(M[i])>=cutoff)
      			fprintf(file,"%d %20.10f\n",i+1,M[i]);
	}
	fclose(file);
}
static void printVPT2KQuartic(VPT2PotentialData* vpt2PotentialData, char* fileName)
{
	FILE* file =fopen(fileName,"w");
	int i,j,k,l;
	double cutoff = 1e-10;
	double**** C = vpt2PotentialData->quartic;
	int n = vpt2PotentialData->nFrequencies;
	for(i = 0;i<n; i++) 
	{
		for(j = 0;j<n; j++) 
		{
			for(k = 0;k<n; k++) 
			{
				for(l = 0;l<n; l++) 
				if(fabs(C[i][j][k][l])>=cutoff)
      					fprintf(file,"%d %d %d %d %20.10f\n",i+1,j+1,k+1,l+1,C[i][j][k][l]);
			}
		}
	}
	fclose(file);
}
*/
/*
static void printVPT2KData(VPT2PotentialData* vpt2PotentialData)
{
	printVPT2KHessian(vpt2PotentialData,"data.w");
	printVPT2KCubic(vpt2PotentialData,"data.f3");
	printVPT2KQuartic(vpt2PotentialData,"data.f4");
	printVPT2KRot(vpt2PotentialData,"data.b");
	printVPT2KCoriolis(vpt2PotentialData,"data.z");
}
*/
/*****************************************************************************/
static void printGradients(VPT2PotentialData* vpt2PotentialData)
{
	printf("\nGradients\n");
	printVectorDoubleCutOff(vpt2PotentialData->gradients, vpt2PotentialData->nFrequencies, 1e-10);
	printf("END\n");
}
static void printHessian(VPT2PotentialData* vpt2PotentialData)
{
	printf("\nHessian\n");
	printMatrixDoubleCutOff(vpt2PotentialData->hessian, vpt2PotentialData->nFrequencies, vpt2PotentialData->nFrequencies,1e-10);
	printf("END\n");
}
static void printCubic(VPT2PotentialData* vpt2PotentialData)
{
	printf("\nCubic\n");
	printCubeDoubleCutOff(vpt2PotentialData->cubic, vpt2PotentialData->nFrequencies, vpt2PotentialData->nFrequencies, vpt2PotentialData->nFrequencies,1e-10);
	printf("END\n");
}
static void printCoriolis(VPT2PotentialData* vpt2PotentialData)
{
	printf("\nCoriolis\n");
	printCubeDoubleCutOff(vpt2PotentialData->coriolis, 3, vpt2PotentialData->nFrequencies, vpt2PotentialData->nFrequencies,1e-10);
	printf("END\n");
}
static void printRot(VPT2PotentialData* vpt2PotentialData)
{
	printf("\nRotation constants\n");
	printVectorDoubleCutOff(vpt2PotentialData->Be, 3,1e-10);
	printf("END\n");
}
static void printQuartic(VPT2PotentialData* vpt2PotentialData)
{
   printf("\nQuartic\n");
   printQuarticDoubleCutOff(vpt2PotentialData->quartic, vpt2PotentialData->nFrequencies, vpt2PotentialData->nFrequencies, vpt2PotentialData->nFrequencies, vpt2PotentialData->nFrequencies,1e-10);
	printf("END\n");
}
static void printData(VPT2PotentialData* vpt2PotentialData)
{
	printGradients(vpt2PotentialData);
	printHessian(vpt2PotentialData);
	printCubic(vpt2PotentialData);
	printQuartic(vpt2PotentialData);
	printCoriolis(vpt2PotentialData);
	printRot(vpt2PotentialData);
}
/*****************************************************************************/
static void readResonancesData(VPT2PotentialData* vpt2PotentialData, char* inputFileName)
{
	FILE* inputFile = fopen(inputFileName,"rb");
	readOneReal(inputFile,"maxFrequencyDifferenceFermi",&vpt2PotentialData->maxFrequencyDifferenceFermi);
	readOneReal(inputFile,"MartinCutOff1",&vpt2PotentialData->parametersResonance[0]);
	readOneReal(inputFile,"MartinCutOff2",&vpt2PotentialData->parametersResonance[1]);
	readOneReal(inputFile,"ZCutOff",&vpt2PotentialData->parametersResonance[2]);
	//printf("Zcutoff=%f\n",vpt2PotentialData->parametersResonance[2]);
	fclose(inputFile);
}
/*****************************************************************************/
static void readData(VPT2PotentialData* vpt2PotentialData, char* inputFileName)
{
	FILE* inputFile;
	char* tmp = NULL;
        inputFile = fopen(inputFileName,"rb");
	if(!inputFile)
	{
		fprintf(stderr, "==========================================================\n");
		fprintf(stderr, "Sorry, I cannot opent the %s file\n", inputFileName);
		fprintf(stderr, "==========================================================\n");
		exit(1);
	}
	readOneInt(inputFile,"nFrequencies",&vpt2PotentialData->nFrequencies);
	fprintf(stdout, "nFrequencies=%d\n", vpt2PotentialData->nFrequencies);
	*vpt2PotentialData = newVPT2PotentialData(vpt2PotentialData->nFrequencies);
	readOneReal(inputFile,"alphaHDCPT2",&vpt2PotentialData->model.alphaHDCPT2);
	readOneReal(inputFile,"betaHDCPT2",&vpt2PotentialData->model.betaHDCPT2);
	
	readOneString(inputFile,"VPT2Model",&tmp);
	if(tmp && mystrcasestr(tmp,"NONE")) vpt2PotentialData->model.type = MODEL_VPT2;
	if(tmp && mystrcasestr(tmp,"DCPT2")) vpt2PotentialData->model.type = MODEL_DCPT2;
	if(tmp && mystrcasestr(tmp,"HDCPT2")) vpt2PotentialData->model.type = MODEL_HDCPT2;
	if(tmp && mystrcasestr(tmp,"GVPT2")) vpt2PotentialData->model.type = MODEL_GVPT2;
	if(tmp && mystrcasestr(tmp,"VPT2+K")) vpt2PotentialData->model.type = MODEL_VPT2K;
	if(tmp) free(tmp);
	if(vpt2PotentialData->model.type==MODEL_GVPT2) printf("VPT2 model : GVPT2\n");
	if(vpt2PotentialData->model.type==MODEL_VPT2K) printf("VPT2 model : VPT2+K\n");
	if(vpt2PotentialData->model.type==MODEL_VPT2) printf("VPT2 model : VPT2\n");
	if(vpt2PotentialData->model.type==MODEL_DCPT2) printf("VPT2 model : DCPT2\n");
	if(vpt2PotentialData->model.type==MODEL_HDCPT2) printf("VPT2 model : HDCPT2\n");

	
	readVectorReal(inputFile,"Gradients",vpt2PotentialData->nFrequencies, vpt2PotentialData->gradients);/* vpt2PotentialData.gradients presently not used, min surface */
	readMatrixReal(inputFile,"Hessian",vpt2PotentialData->nFrequencies, vpt2PotentialData->nFrequencies, vpt2PotentialData->hessian);
	readCubeReal(inputFile,"Cubic",vpt2PotentialData->nFrequencies, vpt2PotentialData->nFrequencies, vpt2PotentialData->nFrequencies, vpt2PotentialData->cubic);
	readQuarticReal(inputFile,"Quartic",vpt2PotentialData->nFrequencies, vpt2PotentialData->nFrequencies, vpt2PotentialData->nFrequencies, vpt2PotentialData->nFrequencies, vpt2PotentialData->quartic);
	
	readVectorReal(inputFile,"Rotational",3, vpt2PotentialData->Be);
	readCubeReal(inputFile,"Coriolis",3, vpt2PotentialData->nFrequencies, vpt2PotentialData->nFrequencies, vpt2PotentialData->coriolis);
	readResonancesData(vpt2PotentialData, inputFileName);
	printData(vpt2PotentialData);
	//printVPT2KData(vpt2PotentialData);
	fclose(inputFile);

	
}
/**********************************************************************/
File: ./cchemilib/src/VPT2/VPT2.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "../VPT2/VPT2Model.h"
#include "../VPT2/VPT2KModel.h"
#include "../Utils/Utils.h"
#include "../Utils/Constants.h"
boolean vpt2k(char* fileName)
{
	char* tmp = NULL;
	FILE* file = fopen(fileName, "rb");
	readOneString(file,"VPT2Model",&tmp);
	fclose(file);
	if(tmp && strstr(tmp,"VPT2+K")) return TRUE;
	return FALSE;
}
boolean gvpt2(char* fileName)
{
	char* tmp = NULL;
	FILE* file = fopen(fileName, "rb");
	readOneString(file,"VPT2Model",&tmp);
	fclose(file);
	if(tmp && strstr(tmp,"GVPT2")) return TRUE;
	return FALSE;
}
int vpt2(char* fileName)
{
	if(!fileName)
	{
		printf("Vous devez fournir le nom du fichier de donnees\n");
		return 1;
	}
	if(!vpt2k(fileName) && !gvpt2(fileName))
	{
		VPT2Model  vpt2Model = newVPT2Model();
		vpt2Model.klass->readData(&vpt2Model, fileName);
		vpt2Model.klass->computeAnharmonic(&vpt2Model);
	}
	else
	{
		VPT2KModel  vpt2KModel = newVPT2KModel();
		vpt2KModel.klass->readData(&vpt2KModel, fileName);
		vpt2KModel.klass->computeAnharmonic(&vpt2KModel);
	}

	return 0;
}
File: ./cchemilib/src/PathIntegral/NoseHooverThermostat.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include "Paths.h"
#include "../Utils/Constants.h"
#include "../Utils/QL.h"
#include "../Utils/Utils.h"

static void applyNoseHooverThermostat(Paths* paths);
static void evolveFirstLast(Paths* paths, int iSY);
static void evolveLastFirst(Paths* paths, int iSY);
static void evolveParticleMoments(Paths* paths, int iSY);
static void evolvePositions(Paths* paths, int iSY);
static void initSY(Paths* paths);
static void initMassesNH(Paths* paths);
static void initNHForcesMoments(Paths* paths);
/*********************************************************************************************************************/
void initNoseHooverThermostat(Paths* paths)
{
	initMassesNH(paths);
	initNHForcesMoments(paths);
	initSY(paths);
	paths->klass->applyThermostat = applyNoseHooverThermostat;
	paths->xNHTotal = 0;
	printf("End nosee hoover\n");
}
/*****************************************************************************************************************************/
static void applyNoseHooverThermostat(Paths* paths)
{
	int iNHSteps,iSY;

	for (iNHSteps = 0; iNHSteps < paths->nNHSteps; iNHSteps++)
    	for (iSY = 0; iSY < paths->nSY; iSY += 1)
	{
		evolveLastFirst(paths, iSY);
		evolveParticleMoments(paths, iSY);
		evolvePositions(paths, iSY);
		evolveFirstLast(paths, iSY);
	}
}
/*********************************************************************************************************************/
static void initNHForcesMoments(Paths* paths)
{
	int nAtoms = paths->molecules[0]->nAtoms;
	int nBeads = paths->nBeads;
	paths->NHP = newCubeDouble(nBeads,3*nAtoms,paths->nNH);
	initCubeDouble(paths->NHP, nBeads,3*nAtoms,paths->nNH,0.0);
	paths->NHF = newCubeDouble(nBeads,3*nAtoms,paths->nNH);
	initCubeDouble(paths->NHF, nBeads,3*nAtoms,paths->nNH,0.0);
}
/*********************************************************************************************************************/
static void initMassesNH(Paths* paths)
{
	int i,iAtom;
	int nAtoms = paths->molecules[0]->nAtoms;
	int nBeads = paths->nBeads;

// Eq. 12.6.14, Tuckerman book
	paths->oneOverNHM = newVectorDouble(paths->nNH);
	for (i = 0; i < paths->nNH; i++) paths->oneOverNHM[i] = paths->wp2/paths->kT;

	paths->oneOverM = newMatrixDouble(nBeads,nAtoms);
	for (i = 0; i < paths->nBeads; i++) 
	for (iAtom = 0; iAtom < nAtoms; iAtom++) paths->oneOverM[i][iAtom] = 1.0/paths->Mprim[i][iAtom];
}
/*********************************************************************************************************************/
static void initSY(Paths* paths)
{
// Eqs. 4.11.xx, Tuckerman book
	int i;
	if (paths->nSY == 1)
	{
		paths->NHd = newVectorDouble(paths->nSY);
    		paths->NHd[0] = 1.0;
	} else if (paths->nSY == 3)
	{
		paths->NHd = newVectorDouble(paths->nSY);
    		paths->NHd[0] = 1.0/(2.0 - pow(2.0,1.0/3.0));
    		paths->NHd[2] = paths->NHd[0];
    		paths->NHd[1] = 1.0 - (paths->NHd[0] + paths->NHd[2]);
	} else if (paths->nSY == 5)
	{
		double bi = 1/(2.0*2-1.0);
		double dum = 1.0/(4.0-pow(4.0,bi));
		paths->NHd = newVectorDouble(paths->nSY);
		for(i=0;i<paths->nSY;i++) paths->NHd[i] = dum;
		paths->NHd[2] = 1.0-4.0*dum;
	} else if (paths->nSY == 7)
	{
		int nc;
		nc = paths->nSY/2;
		paths->NHd = newVectorDouble(paths->nSY);
    		paths->NHd[0] = 0.784513610477560;
    		paths->NHd[1] = 0.235573213359357;
    		paths->NHd[2] = -1.17767998417887;
		for(i=0;i<nc;i++) paths->NHd[paths->nSY-1-i] = paths->NHd[i];
    		paths->NHd[nc] = 1;
		for(i=0;i<nc;i++) paths->NHd[nc] -= paths->NHd[i]+paths->NHd[paths->nSY-1-i];
	} else if (paths->nSY == 9)
	{
		int nc;
		nc = paths->nSY/2;
		paths->NHd = newVectorDouble(paths->nSY);
    		paths->NHd[0] = 0.192;
    		paths->NHd[1] = 0.554910818409783619692725006662999;
    		paths->NHd[2] = 0.124659619941888644216504240951585;
    		paths->NHd[3] = -0.843182063596933505315033808282941; 
		for(i=0;i<nc;i++) paths->NHd[paths->nSY-1-i] = paths->NHd[i];
    		paths->NHd[nc] = 1;
		for(i=0;i<nc;i++) paths->NHd[nc] -= paths->NHd[i]+paths->NHd[paths->nSY-1-i];
	}
	else
	{
		printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		printf("Suzuki-Yoshida Order must be 1,3,5,7 or 9!\n");
		printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		fflush(stdout);
    		exit(1);
	}
  	for (i = 0; i < paths->nSY; i++) paths->NHd[i] *= paths->dt/(paths->nNHSteps*1.0);
}
// Eqs 12.6.14 && 4.11.17 &&  4.11.18 Tuckerman book
/*****************************************************************************************************************************/
static void NHPScale(Paths* paths, int iNH, double f)
{
	int i,j,iAtom;
	double*** NHP = paths->NHP;
      	double* oneOverNHM = paths->oneOverNHM;

	for(i = 0;i<paths->nBeads; i++) 
	for(iAtom = 0;iAtom<paths->molecules[i]->nAtoms; iAtom++) 
	for(j = 0;j<3; j++) 
      		NHP[i][3*iAtom+j][iNH] *=  exp(f * NHP[i][3*iAtom+j][iNH+1] * oneOverNHM[iNH+1]);
}
/*****************************************************************************************************************************/
static void NHPShift(Paths* paths, int iNH, double f)
{
	int i,j,iAtom;
	double*** NHP = paths->NHP;
	double*** NHF = paths->NHF;

	for(i = 0;i<paths->nBeads; i++) 
	for(iAtom = 0;iAtom<paths->molecules[i]->nAtoms; iAtom++) 
	for(j = 0;j<3; j++) 
      		NHP[i][3*iAtom+j][iNH] += f * NHF[i][3*iAtom+j][iNH];
}
/*****************************************************************************************************************************/
static void NHFSet(Paths* paths, int iNH)
{
	int i,j,iAtom;
	double*** NHP = paths->NHP;
	double*** NHF = paths->NHF;
      	double* oneOverNHM = paths->oneOverNHM;
	double*** P = paths->P;

	if(iNH!=0)
	{
		for(i = 0;i<paths->nBeads; i++) 
			for(iAtom = 0;iAtom<paths->molecules[i]->nAtoms; iAtom++) 
			for(j = 0;j<3; j++) 
      				NHF[i][3*iAtom+j][iNH] = NHP[i][3*iAtom+j][iNH-1] * NHP[i][3*iAtom+j][iNH-1] * oneOverNHM[iNH-1] -paths->kT;
	}
	else
	{
		for(i = 0;i<paths->nBeads; i++) 
		for(iAtom = 0;iAtom<paths->molecules[i]->nAtoms; iAtom++) 
		for(j = 0;j<3; j++) 
		{
      			NHF[i][3*iAtom+j][iNH] =  P[j][i][iAtom]*P[j][i][iAtom]*paths->oneOverM[i][iAtom]- paths->kT;
		}
	}
}
/*****************************************************************************************************************************/
static void evolveLastFirst(Paths* paths, int iSY)
{
	int iNH;
	int nNH = paths->nNH;
      	double* NHd = paths->NHd;
	double fscale = -0.125 * NHd[iSY];
	double fshift = 0.25 * NHd[iSY];

	/* Evolve the last therm moment in each chain */
	iNH = nNH-1;
	NHFSet(paths, iNH);
	NHPShift(paths, iNH,  fshift);
      
	/* Evolve the last-1 to the first thermo velocitiy in each chain */
	for (iNH = nNH-2; iNH >= 0; iNH--)
	{
		NHPScale(paths, iNH, fscale);
		NHFSet(paths, iNH);
		NHPShift(paths, iNH,  fshift);
		NHPScale(paths, iNH, fscale);
	}
}
/*****************************************************************************************************************************/
static void evolveFirstLast(Paths* paths, int iSY)
{
	int iNH;
	int nNH = paths->nNH;
      	double* NHd = paths->NHd;
	double fscale = -0.125 * NHd[iSY];
	double fshift = 0.25 * NHd[iSY];

	/* Evolve the 1 to last-1 therm moment in each chain  calculting therm forces as you go along */
	/* 0 => last-1 */
	for (iNH = 0; iNH<paths->nNH-1; iNH++)
	{
		NHPScale(paths, iNH, fscale);
		NHFSet(paths, iNH);
		NHPShift(paths, iNH,  fshift);
		NHPScale(paths, iNH, fscale);
	}
      
	/* last term */
	iNH = nNH-1;
	NHFSet(paths, iNH);
	NHPShift(paths, iNH,  fshift);
}
/*****************************************************************************************************************************/
static void evolveParticleMoments(Paths* paths, int iSY)
{
	int i,j,iAtom;
	double*** NHP = paths->NHP;
      	double* oneOverNHM = paths->oneOverNHM;
      	double* NHd = paths->NHd;
	double*** P = paths->P;
	double f = -0.5 * NHd[iSY]*oneOverNHM[0];

	/* Evolve the particle velocities (by the scaling factor) */
	for(i = 0;i<paths->nBeads; i++) 
	for(iAtom = 0;iAtom<paths->molecules[i]->nAtoms; iAtom++) 
		for(j = 0;j<3; j++) 
			P[j][i][iAtom] *=  exp(f* NHP[i][3*iAtom+j][0]);

}
/*****************************************************************************************************************************/
static void evolvePositions(Paths* paths, int iSY)
{
	int i,j,iNH,iAtom;
	double*** NHP = paths->NHP;
      	double* oneOverNHM = paths->oneOverNHM;
	// double f =  -paths->NHd[iSY]*0.5; // negative from eq 4.11.17 !
	double f =  paths->NHd[iSY]*0.5;

	for (iNH = 0; iNH <paths->nNH; iNH++)
	for(i = 0;i<paths->nBeads; i++) 
	for(iAtom = 0;iAtom<paths->molecules[i]->nAtoms; iAtom++) 
		for(j = 0;j<3; j++) 
		paths->xNHTotal += NHP[i][3*iAtom+j][iNH]*oneOverNHM[iNH]*f;

}
/*****************************************************************************************************************************/
double getNHEnergy(Paths* paths)
{
	int i,j,iAtom;
	double*** NHP = paths->NHP;
      	double* oneOverNHM = paths->oneOverNHM;
	int iNH;

	double energy  = 0;
	for (iNH = 0; iNH <paths->nNH; iNH++)
		for(i = 0;i<paths->nBeads; i++) 
			for(iAtom = 0;iAtom<paths->molecules[i]->nAtoms; iAtom++) 
			for(j = 0;j<3; j++) 
      				energy += NHP[i][3*iAtom+j][iNH-1] * NHP[i][3*iAtom+j][iNH-1] * oneOverNHM[iNH-1];
	energy *=0.5;
	// add potential energy
	energy += paths->xNHTotal* paths->kT;
	return energy;
}
File: ./cchemilib/src/PathIntegral/LangevinThermostat.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include "Paths.h"
#include "../Utils/Constants.h"
#include "../Utils/QL.h"
#include "../Utils/Utils.h"

/* Refs :
Ceriotti et al., THE JOURNAL OF CHEMICAL PHYSICS 133, 124104 2010
*/
static void applyLangevinThermostat(Paths* paths);
/*********************************************************************************************************************/
void initLangevinThermostat(Paths* paths)
{
	int i,iAtom;
	int nAtoms = paths->molecules[0]->nAtoms;
	int nBeads = paths->nBeads;
	double sqrtnBeads =sqrt(1.0*nBeads);
	double* omegas; /* Normal mode frequencies */
	double* gammas; /* Langevin friction constants */
	if(paths->friction<=0) paths->friction = 1;

	omegas = newVectorDouble(nBeads);
	for(i = 0;i<nBeads; i++) omegas[i] = 2*paths->wp*sqrtnBeads*sin(i*M_PI/nBeads);

	gammas = newVectorDouble(nBeads);
	for(i = 0;i<nBeads; i++) gammas[i] =  paths->friction; /* 2*omegas[i] to be tested */

	paths->LTPMult  = newVectorDouble(nBeads);
	for(i = 0;i<nBeads; i++) paths->LTPMult[i] = exp(-paths->dt/2.0*gammas[i]); 
	//printf("alpha = %f\n",-paths->dt/2.0*gammas[0]); 

	paths->LTFMult  = newMatrixDouble(nBeads,nAtoms);
	for(i = 0;i<nBeads; i++) 
	for(iAtom = 0;iAtom<nAtoms; iAtom++) 
			paths->LTFMult[i][iAtom] = sqrt(paths->Mprim[i][iAtom]*paths->kT)*sqrt(1.0-paths->LTPMult[i]*paths->LTPMult[i]);

	freeVectorDouble(&omegas);
	freeVectorDouble(&gammas);
	paths->klass->applyThermostat = applyLangevinThermostat;
}
/*****************************************************************************************************************************/
static void applyLangevinThermostat(Paths* paths)
{
	int i,k,iAtom;
	int nAtoms = paths->molecules[0]->nAtoms;
	double*** P = paths->P;
	for(i = 0;i<paths->nBeads; i++) 
	{
	for(iAtom = 0;iAtom<nAtoms; iAtom++) 
	for(k = 0;k<3; k++) 
	{
		P[k][i][iAtom] =  P[k][i][iAtom]*paths->LTPMult[i] + paths->LTFMult[i][iAtom]*normal();
	}
//	paths->molecules[i]->klass->removeTranslationAndRotation(paths->molecules[i]);
	}
}

/**************************************************************************************************************************/
File: ./cchemilib/src/PathIntegral/WithoutTrans.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include "Paths.h"
#include "../Utils/Constants.h"
#include "../Utils/Utils.h"

static void calculateForcesWithoutTrans(Paths* paths);
static void applyOneStepWithoutTrans(Paths* paths);
static void momentToCartezian(Paths* paths);
static void initMasses(Paths* paths);
static void initMoments(Paths* paths);
static double getEKinVelocities(Paths* paths);
/*********************************************************************************************************************/
void initWithoutTrans(Paths* paths)
{
	initMasses(paths);
	initMoments(paths);

	paths->klass->calculateForces = calculateForcesWithoutTrans;
	paths->klass->applyOneStep = applyOneStepWithoutTrans;
	paths->klass->momentToCartezian = momentToCartezian ;
	paths->klass->getEKinVelocities = getEKinVelocities;
	paths->klass->calculateForces(paths);
	printf("End initWithoutTrans\n");
}
/*********************************************************************************************************************/
static void initMasses(Paths* paths)
{
	int i,iAtom;
	int nAtoms = paths->molecules[0]->nAtoms;
	int nBeads = paths->nBeads;

	paths->M = newMatrixDouble(nBeads,nAtoms);
	for(i = 0;i<paths->nBeads; i++) 
	for(iAtom = 0;iAtom<paths->molecules[i]->nAtoms; iAtom++) 
		paths->M[i][iAtom]  = paths->molecules[i]->atoms[iAtom].mass;

	paths->Mprim = newMatrixDouble(nBeads,nAtoms);
	for(i = 0;i<paths->nBeads; i++) 
	for(iAtom = 0;iAtom<paths->molecules[i]->nAtoms; iAtom++) 
		paths->Mprim[i][iAtom]  = paths->molecules[i]->atoms[iAtom].mass;
}
/*********************************************************************************************************************/
static void initMoments(Paths* paths)
{
	int i,k,iAtom;
	int nAtoms = paths->molecules[0]->nAtoms;
	int nBeads = paths->nBeads;

	paths->P = newCubeDouble(3,nBeads,nAtoms);
	for(k = 0;k<3; k++) 
	for(i = 0;i<paths->nBeads; i++) 
	for(iAtom = 0;iAtom<paths->molecules[i]->nAtoms; iAtom++) 
		paths->P[k][i][iAtom]  = paths->molecules[i]->atoms[iAtom].velocity[k]*paths->Mprim[i][iAtom];
}
/**************************************************************************************************************************/
static void applyOneStepWithoutTrans(Paths* paths)
{
	int iAtom,i,k;
	Molecule** mols;
	mols = paths->molecules;
	double*** P = paths->P;

	//paths->klass->applyThermostat(paths); // to be removed

	paths->klass->applyThermostat(paths); // should be apply 2 times
	//printAllMolecule(paths);
	for(i = 0;i<paths->nBeads; i++) 
	for(iAtom = 0;iAtom<paths->molecules[i]->nAtoms; iAtom++) 
	for(k = 0;k<3; k++) 
	{
		P[k][i][iAtom] += 0.5*paths->F[k][i][iAtom]*paths->dt;
		mols[i]->atoms[iAtom].coordinates[k] +=  P[k][i][iAtom]*paths->dt/paths->Mprim[i][iAtom];
	}
	paths->klass->calculateForces(paths);
	paths->klass->applyThermostat(paths);
	for(i = 0;i<paths->nBeads; i++) 
	for(iAtom = 0;iAtom<paths->molecules[i]->nAtoms; iAtom++) 
	for(k = 0;k<3; k++) 
	{
		P[k][i][iAtom] += 0.5*paths->F[k][i][iAtom]*paths->dt;
	}
	//printf("After the first step\n");
	//printAllMolecule(paths);
  
	//paths->klass->applyThermostat(paths);
	paths->klass->removeTranslationAndRotation(paths);
	paths->klass->computeEnergies(paths);
  
}
/*********************************************************************************************************************/
static void calculateForcesWithoutTrans(Paths* paths)
{
	double dR1[3];
	double dR2[3];
	int iAtom,i,iNext,iPrev;
	int k;
	int nAtoms = paths->molecules[0]->nAtoms;
	Molecule** mols;

	paths->klass->calculateGradient(paths);
	
	mols = paths->molecules;

	for (iAtom = 0; iAtom < nAtoms; iAtom++)
    	for (i = 0; i <paths->nBeads; i++)
	{
		iNext = paths->iNext[i];
		iPrev = paths->iPrev[i];
		//printf("i, IP, IM %d %d %d\n",i,iNext,iPrev);
		for(k=0;k<3;k++) dR1[k] = mols[iNext]->atoms[iAtom].coordinates[k]-mols[i]->atoms[iAtom].coordinates[k];
		for(k=0;k<3;k++) dR2[k] = mols[iPrev]->atoms[iAtom].coordinates[k]-mols[i]->atoms[iAtom].coordinates[k];
		//printf("dR1 = %f %f %f\n",dR1[0],dR1[1],dR1[2]);
		//printf("dR2 = %f %f %f\n",dR2[0],dR2[1],dR2[2]);
		for(k=0;k<3;k++) paths->F[k][i][iAtom] = paths->M[i][iAtom]*paths->wp2*(dR1[k]+dR2[k])
			-paths->oneOvernBeads*mols[i]->atoms[iAtom].gradient[k];
	}
}
/*****************************************************************************************************************************/
static void momentToCartezian(Paths* paths)
{
	int iAtom,i,k;
	Molecule** mols = paths->molecules;

    	for (i = 0; i<paths->nBeads; i++)
		for (iAtom = 0; iAtom < mols[i]->nAtoms; iAtom++)
			for(k = 0;k<3; k++) 
				mols[i]->atoms[iAtom].velocity[k] =  paths->P[k][i][iAtom]/paths->Mprim[i][iAtom];

	return;
}
/********************************************************************************/
/* Kinetic Velocities Energy Estimator*/
static double getEKinVelocities(Paths* paths)
{
	double ekin = 0.0;
	int iAtom,i,j;
	//double RC[3];
	double***P = paths->P;
	Molecule** mols = paths->molecules;
	double dR[3];
	int k;

	double invmass;
	ekin = 0;
	for(i = 0;i<paths->nBeads; i++) 
	for(iAtom = 0;iAtom< mols[i]->nAtoms; iAtom++) 
	{
		invmass =  1.0/paths->Mprim[i][iAtom];
		for ( j = 0; j < 3; j++)
			ekin += P[j][i][iAtom]*P[j][i][iAtom]*invmass;
	}

	for(i = 0;i<paths->nBeads; i++) 
	for(iAtom = 0;iAtom<paths->molecules[i]->nAtoms; iAtom++) 
	{
		double dot = 0;
		int iNext = paths->iNext[i];
		for(k = 0;k<3; k++) dR[k] = mols[i]->atoms[iAtom].coordinates[k]-mols[iNext]->atoms[iAtom].coordinates[k];
		for(k = 0;k<3; k++) dot += dR[k]*dR[k];
      		ekin -=  paths->M[i][iAtom]*paths->wp2 * dot;
	}
  	ekin *= 0.5;
  	return ekin;
}
File: ./cchemilib/src/PathIntegral/Paths.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include "Paths.h"
#include "LangevinThermostat.h"
#include "NoseHooverThermostat.h"
#include "QTBThermostat.h"
#include "NormalModeTrans.h"
#include "StagingTrans.h"
#include "WithoutTrans.h"

static void calculateGradient(Paths* paths);
void initPathsTemperature(Paths* paths, double newTemperature);
void resetPathsTemperature(Paths* paths, double newTemperature);
static void initThermostat(Paths* paths);
static void initTransformation(Paths* paths);
static void computeEnergies(Paths* paths);
static void initIndex(Paths* paths);
static void printPaths(Paths* paths,FILE* file);
static void getGradVPlusHarmonic(Paths* paths, int iBead, int iAtom, double G[]);
static void applyNoThermostat(Paths* paths);
static void initAllPointers(Paths* paths);
static void initVelocities(Paths* paths);
static void removeTranslation(Paths* paths);
static void removeRotation(Paths* paths);
static void removeTranslationAndRotation(Paths* paths);
/*********************************************************************************************************************/
Paths newPaths(
		ForceField* forceField,
		QuantumMechanicsModel* qmModel, 
		int updateFrequency, 
		double temperature, 
		double stepSize,
		PIMDThermostatType thermostat,
		PIMDTransformationType transformation,
		double friction,
		double omegaMax,
		int Nf,
		int nBeads,
		int nNH,
		int nNHSteps,
		int nSY,
		char* fileNameTraj,
		char* fileNameProp
)
{
	int i;
	int nAtoms = 0;
	double dt = stepSize * fsInAKMA;
	Paths opaths;
	Paths* paths = &opaths;
	paths->nBeads = nBeads;
	paths->kT = Kb*temperature;
	paths->temperature = temperature;
	initAllPointers(paths);
	if(forceField) 
	{
		nAtoms = forceField->molecule.nAtoms;
		paths->forceFields = malloc(paths->nBeads*sizeof(ForceField));
		for(i = 0;i<paths->nBeads; i++) 
			paths->forceFields[i] = copyForceField(forceField);
		paths->molecules = malloc(paths->nBeads*sizeof(Molecule*));
		for(i = 0;i<paths->nBeads; i++) 
			paths->molecules[i] = &paths->forceFields[i].molecule;
		paths->qmModels = NULL;
		

	}
	else if(qmModel) 
	{
		nAtoms = qmModel->molecule.nAtoms;
		paths->qmModels = malloc(paths->nBeads*sizeof(QuantumMechanicsModel));
		for(i = 0;i<paths->nBeads; i++) 
			paths->qmModels[i] = qmModel->klass->copy(qmModel);
		paths->molecules = malloc(paths->nBeads*sizeof(Molecule*));
		for(i = 0;i<paths->nBeads; i++) 
			paths->molecules[i] = &paths->qmModels[i].molecule;
		paths->forceFields = NULL;
	}
	else exit(1);
	paths->moleculeCentroid = paths->molecules[0]->klass->copy(paths->molecules[0]);
	initVelocities(paths);
	initIndex(paths);

	paths->friction = friction/fsInAKMA/1000;
	paths->nNH = nNH;
	paths->nNHSteps = nNHSteps;
	paths->nSY = nSY;
	paths->thermostat = thermostat;
	paths->transformation = transformation;
	paths->updateFrequency = updateFrequency;
	paths->dt = dt;
	paths->omegaMax= omegaMax;
	paths->Nf= Nf;

	initPathsTemperature(paths, paths->temperature);

	paths->oneOverNumberOfParticules = 1.0/nAtoms;
	paths->oneOvernBeads = 1.0/paths->nBeads;
	paths->oneOverNumberOfParticulesBeads= 1.0/(1.0*nAtoms*paths->nBeads);

	if(fileNameTraj) paths->fileTraj = fopen(fileNameTraj, "w");
	if(fileNameProp) paths->fileProp = fopen(fileNameProp, "w");

	paths->potentialEnergy = 0;
	paths->kineticEnergy = 0;
	paths->totalEnergy = 0;
	paths->dipole[0] = 0;
	paths->dipole[1] = 0;
	paths->dipole[2] = 0;

		
	paths->klass = malloc(sizeof(PathsClass));
	paths->klass->getGradVPlusHarmonic = getGradVPlusHarmonic;
	paths->klass->calculateGradient = calculateGradient;
	paths->klass->initThermostat = initThermostat;
	paths->klass->initTransformation = initTransformation;
	paths->klass->applyThermostat = applyNoThermostat;
	paths->klass->computeEnergies = computeEnergies;
	paths->klass->removeTranslation = removeTranslation;
	paths->klass->removeRotation = removeRotation;
	paths->klass->removeTranslationAndRotation = removeTranslationAndRotation;

	paths->klass->print = printPaths;
	paths->index = 0;
	paths->F = newCubeDouble(3,paths->nBeads,paths->molecules[0]->nAtoms);
	paths->klass->initTransformation(paths);// transformation before thermostat
	paths->klass->initThermostat(paths);
	paths->klass->calculateForces(paths);

	return opaths;
}
/*********************************************************************************************************************/
void freePaths(Paths* paths)
{
	int i;
	int nAtoms = paths->molecules[0]->nAtoms;
	if(paths->klass) free(paths->klass);
	if(paths->molecules) free(paths->molecules);
	if(paths->forceFields) 
	{
		if(paths->forceFields)
		for(i = 0;i<paths->nBeads; i++) 
			freeForceField(&paths->forceFields[i]);
		if(paths->forceFields) free(paths->forceFields);
		
	}
	if(paths->qmModels)
	{
		if(paths->qmModels)
		for(i = 0;i<paths->nBeads; i++) paths->qmModels[i].klass->free(&paths->qmModels[i]);
		if(paths->qmModels) free(paths->qmModels);
	}
	if(paths->M) freeMatrixDouble(&paths->M,paths->nBeads);
	if(paths->F) freeCubeDouble(&paths->F,3,paths->nBeads);
	if(paths->iNext) freeVectorInt(&paths->iNext);
	if(paths->iPrev) freeVectorInt(&paths->iPrev);
	if(paths->Mprim) freeMatrixDouble(&paths->Mprim,paths->nBeads);
	if(paths->O) freeMatrixDouble(&paths->O,paths->nBeads);
	if(paths->oneOverM) freeMatrixDouble(&paths->oneOverM,paths->nBeads);
	if(paths->LTFMult) freeMatrixDouble(&paths->LTFMult,paths->nBeads);
	if(paths->U) freeCubeDouble(&paths->U,3,paths->nBeads);
	if(paths->P) freeCubeDouble(&paths->P,3,paths->nBeads);
	if(paths->NHP) freeCubeDouble(&paths->NHP,paths->nBeads, 3*nAtoms);
	if(paths->NHF) freeCubeDouble(&paths->NHF,paths->nBeads, 3*nAtoms);
	if(paths->LTPMult) freeVectorDouble(&paths->LTPMult);
	if(paths->oneOverNHM) freeVectorDouble(&paths->oneOverNHM);
	if(paths->NHd) freeVectorDouble(&paths->NHd);
	if(paths->moleculeCentroid) paths->moleculeCentroid->klass->free(paths->moleculeCentroid);
}
/*********************************************************************************************************************/
void initPathsTemperature(Paths* paths, double newTemperature)
{
	int nAtoms = paths->molecules[0]->nAtoms;
	paths->kT = Kb*newTemperature;
	paths->temperature = newTemperature;
	//paths->wp = sqrt(1.0*paths->nBeads)*paths->kT/hbar/M_PI;
	//paths->wp = sqrt(1.0*paths->nBeads)*paths->kT/hbar/M_PI/2;
	paths->wp = sqrt(1.0*paths->nBeads)*paths->kT/hbar;
	paths->wp2 = paths->wp* paths->wp;

	//paths->numberOfPaticulesDimensionOver2Beta = paths->kT*1.5*nAtoms;
	paths->numberOfPaticulesDimensionOver2Beta = paths->kT*0.5*paths->molecules[0]->nFree;
	paths->numberOfPaticulesBeadsDimensionOver2Beta = 1.5*nAtoms*paths->nBeads*paths->kT;
}
/*********************************************************************************************************************/
void resetPathsTemperature(Paths* paths, double newTemperature)
{
	initPathsTemperature(paths, newTemperature);
	paths->klass->initThermostat(paths);
}
/*********************************************************************************************************************/
static void initIndex(Paths* paths)
{
	int i;
	int nBeads = paths->nBeads;

	paths->iNext = newVectorInt(nBeads);
	for(i = 0;i<nBeads; i++) paths->iNext[i]  = (i+1)%nBeads;
	paths->iPrev = newVectorInt(nBeads);
	for(i = 0;i<nBeads; i++) paths->iPrev[i]  = (i-1+nBeads)%nBeads;
}
/*********************************************************************************************************************/
static void calculateGradient(Paths* paths)
{
	int i;
	if(paths->forceFields) 
	for(i = 0;i<paths->nBeads; i++) paths->forceFields[i].klass->calculateGradient(&paths->forceFields[i]);
 
	if(paths->qmModels)
	for(i = 0;i<paths->nBeads; i++) paths->qmModels[i].klass->calculateGradient(&paths->qmModels[i]);
}
/*********************************************************************************************************************/
static 	void getGradVPlusHarmonic(Paths* paths, int iBead, int iAtom, double G[])
{
	int k;
	for(k=0;k<3;k++)
	G[k] = paths->molecules[iBead]->atoms[iAtom].gradient[k] 
	+ paths->M[iBead][iAtom]*
	 paths->wp2*
	paths->molecules[iBead]->atoms[iAtom].coordinates[k];
}
/*********************************************************************************************************************/
/*
static void printAllMolecule(Paths* paths)
{
	Molecule** mols = paths->molecules;
	int i;

	for(i = 0;i<paths->nBeads; i++) 
	{
		printf("Bead #%d\n",i);
		mols[i]->klass->print(mols[i],stdout);
	}
}
*/
/*********************************************************************************************************************/
static void initTransformation(Paths* paths)
{
	if(paths->transformation==PIMDTRANSFORMATIONSTAGING) initStagingTrans(paths);
	else if(paths->transformation==PIMDTRANSFORMATIONNORMALMODE) initNormalModeTrans(paths);
	else initWithoutTrans(paths);
}
/*********************************************************************************************************************/
static void initThermostat(Paths* paths)
{
	if(paths->thermostat==PIMDTHERMOSTATNONE) return;
	if(paths->thermostat==PIMDTHERMOSTATLANGEVIN) initLangevinThermostat(paths);
	if(paths->thermostat==PIMDTHERMOSTATNOSEHOOVER) initNoseHooverThermostat(paths);
	if(paths->thermostat==PIMDTHERMOSTATQTB) initQTBThermostat(paths);
}
/********************************************************************************/
/* Kinetic Virial Energy Estimator*/
static double getEKinVirial(Paths* paths)
{
	double ekin = 0.0;
	int iAtom,i,k;
	Molecule** mols = paths->molecules;
	for(i = 0;i<paths->nBeads; i++) 
	for(iAtom = 0;iAtom<mols[i]->nAtoms; iAtom++) 
	{
		for(k = 0;k<3; k++) ekin += mols[i]->atoms[iAtom].coordinates[k]*mols[i]->atoms[iAtom].gradient[k];
	}
  	ekin *= 0.5*paths->oneOvernBeads;
/*
	double ekin = 0.0;
	int iAtom,i,k;
	double dR[3];
	double RC[3];
	Molecule** mols = paths->molecules;
	int nAtoms = mols[0]->nAtoms;
	for(iAtom = 0;iAtom<nAtoms; iAtom++) 
	{
		for(k = 0;k<3; k++) RC[k] = 0;
		for(i = 0;i<paths->nBeads; i++) 
			for(k = 0;k<3; k++) RC[k] += mols[i]->atoms[iAtom].coordinates[k];

		for(k = 0;k<3; k++) RC[k] *= paths->oneOvernBeads;

		for(i = 0;i<paths->nBeads; i++) 
		{
			for(k = 0;k<3; k++) dR[k] = mols[i]->atoms[iAtom].coordinates[k]-RC[k];
			for(k = 0;k<3; k++) ekin +=dR[k]*mols[i]->atoms[iAtom].gradient[k];

		}
	}
  	ekin *= 0.5*paths->oneOvernBeads;
  	ekin += paths->numberOfPaticulesDimensionOver2Beta;

*/
  	return ekin;
}
/********************************************************************************/
/* Kinetic Primitive Energy Estimator*/
/*
static double getEKinPrimitive(Paths* paths)
{
	int iAtom,i,k;
	double dR[3];
	double ekin = 0.0;
	Molecule** mols = paths->molecules;

	for(i = 0;i<paths->nBeads; i++) 
	for(iAtom = 0;iAtom<paths->molecules[i]->nAtoms; iAtom++) 
	{
		double dot = 0;
		int iNext = paths->iNext[i];
		for(k = 0;k<3; k++) dR[k] = mols[i]->atoms[iAtom].coordinates[k]-mols[iNext]->atoms[iAtom].coordinates[k];
		for(k = 0;k<3; k++) dot += dR[k]*dR[k];
      		ekin += 0.5 * mols[i]->atoms[iAtom].mass*paths->wp2 * dot;
	}
  	ekin = paths->numberOfPaticulesBeadsDimensionOver2Beta - ekin;
	return ekin;
}
*/
/********************************************************************************/
static double getEKin(Paths* paths)
{
	//return paths->klass->getEKinVelocities(paths);
	if(paths->thermostat==PIMDTHERMOSTATQTB) return paths->klass->getEKinVelocities(paths);
	return getEKinVirial(paths);
}
/********************************************************************************/
static double getKelvin(Paths* paths)
{
	int nFree = paths->moleculeCentroid->nFree;
	if(nFree<1) return 0;
	return 2*getEKin(paths) / ( nFree * Kb);
}
/*********************************************************************************************************************/
static double getPotentialEnergy(Paths* paths)
{
	int i;
	double e = 0;
	Molecule** mols = paths->molecules;
	for(i=0;i<paths->nBeads;i++) e += mols[i]->potentialEnergy;
      	e *= paths->oneOvernBeads;
	return e;
}
/*********************************************************************************/
static void computeEnergies(Paths* paths)
{
	paths->kineticEnergy = getEKin(paths);
	paths->potentialEnergy = getPotentialEnergy(paths);
	paths->totalEnergy = paths->kineticEnergy + paths->potentialEnergy;
	paths->kelvin = getKelvin(paths);
}
/*********************************************************************************/
static void rescaleMoments(Paths* paths)
{
	double kelvin = getKelvin(paths);
	double scale = 1.0;
	Molecule** mols = paths->molecules;
	int i,j,iAtom;
	if(paths->temperature<=0) return;

	if(kelvin>0) scale = sqrt(paths->temperature/kelvin);
	if(kelvin<0) scale = -sqrt(-paths->temperature/kelvin);
#ifdef DEBUG
	printf("temp = %f kelvin = %f scale = %f\n",paths->temperature, kelvin, scale);
#endif
	paths->klass->momentToCartezian(paths);
	for(i = 0;i<paths->nBeads; i++) 
	for(iAtom = 0;iAtom<mols[i]->nAtoms; iAtom++) 
		for ( j = 0; j < 3; j++)
			paths->P[j][i][iAtom] *= scale;
}
/*********************************************************************************************************************/
static void newProperties(Paths* paths, char* comments)
{
	if( paths->fileProp == NULL) return;
	fprintf(paths->fileProp,"Time0(fs)\tTime(fs)\tTotal Energy(Kcal/mol)\tPotential Energy(kcal/mol)\tKinetic Energy(Kcal/mol)\tT(t) (K)\tTaver(K)\tsigma(T)(K)\tIndex");
	if(paths->thermostat==PIMDTHERMOSTATNOSEHOOVER) fprintf(paths->fileProp,"\tEtot+Etherm");
	if(comments) fprintf(paths->fileProp,"%s\n", comments);
	else fprintf(paths->fileProp,"\n");
}
/*********************************************************************************/
static void saveProperties(Paths* paths, int iStep0, int iStep, char* comments)
{
	double dt = paths->dt/(fsInAKMA);
	static double Ttot = 0;
	static double T2tot = 0;
	double Taver = 0;
	double T2aver = 0;

	double totalEnergy =  paths->totalEnergy;

	if( paths->fileProp == NULL) return;
	if(paths->thermostat==PIMDTHERMOSTATNOSEHOOVER)
	{
		double e = 0;
		// TO DO
		/*
		int i;
		double kT = paths->kT;
		e += paths->vNH[0]*paths->vNH[0]* paths->qNH[0]/2 + (paths->nFree)*kT* paths->xNH[0];
		for(i=1;i<MAXNH;i++) e += paths->vNH[i]*paths->vNH[i]* paths->qNH[i]/2 + kT* paths->xNH[i];
		*/
		e = getNHEnergy(paths);
		totalEnergy += e;
	}
	

	if(iStep==1)
	{
			Ttot = 0;
			T2tot = 0;
	}
	Ttot += paths->kelvin;
	T2tot += paths->kelvin*paths->kelvin;
	Taver = Ttot/iStep;
	T2aver = T2tot/iStep;


	fprintf(paths->fileProp,"%f\t%f\t%f\t\t%f\t\t\t%f\t\t\t%f\t%f\t%f\t%d\t", 
			(iStep0)*dt, 
			(iStep)*dt, 
			paths->totalEnergy,
			paths->potentialEnergy,
			paths->kineticEnergy,
			paths->kelvin,
			Taver,
			sqrt(fabs(T2aver-Taver*Taver)),
			paths->index
			 );
	if( paths->thermostat==PIMDTHERMOSTATNOSEHOOVER) fprintf(paths->fileProp,"%f\t",totalEnergy);
	if(comments) fprintf(paths->fileProp,"%s\n", comments);
	else fprintf(paths->fileProp,"\n");
}
/*********************************************************************************/
/*
static void resetGeometryCentroid(Paths* paths)
{
	int i,k,iAtom;
	Atom* atoms = paths->moleculeCentroid->atoms;

	for(iAtom = 0;iAtom<paths->moleculeCentroid->nAtoms; iAtom++) 
	for(k = 0;k<3; k++) 
		atoms[iAtom].coordinates[k] = 0.0;

	for(i = 0;i<paths->nBeads; i++) 
	for(iAtom = 0;iAtom<paths->molecules[i]->nAtoms; iAtom++) 
	for(k = 0;k<3; k++) 
		atoms[iAtom].coordinates[k] += paths->molecules[i]->atoms[iAtom].coordinates[k];

	for(iAtom = 0;iAtom<paths->molecules[i]->nAtoms; iAtom++) 
	for(k = 0;k<3; k++) 
		atoms[iAtom].coordinates[k] *= paths->oneOvernBeads;
}
*/
/*********************************************************************************/
/*
static void saveTrajectory(Paths* paths, int iStep)
{
	Molecule* mol = paths->moleculeCentroid;
	double dt = paths->dt/(fsInAKMA);
	int i;
	if( paths->fileTraj == NULL) return;
	// Get geometry from Devices

	resetGeometryCentroid(paths);
	paths->klass->computeEnergies(paths);
	fprintf(paths->fileTraj," %d %f %f %f %f nAtoms time(fs) TotalEnery(Kcal/mol) Kinetic Potential\n", 
			mol->nAtoms,
			 (iStep)*dt, 
			paths->totalEnergy,
			paths->kineticEnergy,
			paths->potentialEnergy
			 );
	fprintf(paths->fileTraj," %s\n", "Coord in Ang, Velocity in AKMA, time in fs");

	paths->klass->momentToCartezian(paths);
	for (i = 0; i < mol->nAtoms; i++)
	{
		fprintf(paths->fileTraj," %s %f %f %f %f %f %f %f %s %s %s %d %d\n", 
				mol->atoms[i].prop.symbol,
				mol->atoms[i].coordinates[0],
				mol->atoms[i].coordinates[1],
				mol->atoms[i].coordinates[2],
				mol->atoms[i].velocity[0],
				mol->atoms[i].velocity[1],
				mol->atoms[i].velocity[2],
				mol->atoms[i].charge,
				mol->atoms[i].mmType,
				mol->atoms[i].pdbType,
				mol->atoms[i].residueName,
				mol->atoms[i].residueNumber,
				mol->atoms[i].variable
				);
	}
}
*/
/*********************************************************************************************************************/
void	runPIMD(
		ForceField* forceField,
		QuantumMechanicsModel* qmModel, 
		int updateFrequency, 
		double heatTime, double equiTime, double runTime, double coolTime, 
		double heatTemperature, double equiTemperature, double runTemperature, double coolTemperature, 
		double stepSize,
		PIMDThermostatType thermostat,
		PIMDTransformationType transformation,
		double friction,
		double omegaMax,
		int Nf,
		int nBeads,
		int nNH,
		int nNHSteps,
		int nSY,
		char* fileNameTraj,
		char* fileNameProp
		)
{
	int i;
	char* str = NULL;
	int numberOfHeatSteps = 0;
	int numberOfEquiSteps = 0;
	int numberOfRunSteps = 0;
	int numberOfCoolSteps = 0;
	double currentTemp;
	int updateNumber = 0;
	int n0 = 0;
	double e0  = 0;
	double esum  = 0;
	double e2sum = 0;
	Paths opaths;
	Paths* paths = &opaths;

	if(qmModel && qmModel->molecule.nAtoms<1) return;
	if(forceField && forceField->molecule.nAtoms<1) return;


	currentTemp = heatTemperature/2;
	
	numberOfHeatSteps = heatTime/stepSize*1000;
	numberOfEquiSteps = equiTime/stepSize*1000;; 
	numberOfRunSteps = runTime/stepSize*1000;; 
	numberOfCoolSteps = coolTime/stepSize*1000;;


	currentTemp = heatTemperature;
	if(numberOfHeatSteps==0) currentTemp = equiTemperature; 
	if(numberOfHeatSteps==0 && numberOfEquiSteps==0 ) currentTemp = runTemperature; 
	if(numberOfHeatSteps==0 && numberOfEquiSteps==0 && numberOfRunSteps==0 ) currentTemp = coolTemperature; 

		fprintf(stdout,"gamma(ps^-1)\t\t\t= %f\n",friction*fsInAKMA*1000);
	opaths = newPaths( forceField, qmModel, updateFrequency, currentTemp, stepSize, thermostat, transformation, friction, omegaMax, Nf, nBeads, nNH, nNHSteps, nSY, fileNameTraj, fileNameProp);
		fprintf(stdout,"gamma(ps^-1)\t\t\t= %f\n",paths->friction*fsInAKMA*1000);

	paths->klass->calculateGradient(paths);
	paths->klass->print(paths,stdout);

	resetPathsTemperature(paths, currentTemp);
	rescaleMoments(paths);

	paths->klass->computeEnergies(paths);
	e0 = paths->potentialEnergy;
	printf("E0 = The first potential energy in kcal = %f\n",e0); 

	n0 = 0;
	newProperties(paths," ");
	updateNumber = paths->updateFrequency;
	for (i = 0; i < numberOfHeatSteps; i++ )
	{
		paths->klass->applyOneStep(paths);
		currentTemp = heatTemperature + ( runTemperature - heatTemperature ) * ( ( double )( i + 1 )/ numberOfHeatSteps );
		resetPathsTemperature(paths, currentTemp);
		rescaleMoments(paths);
		if (++updateNumber >= paths->updateFrequency )
		{
			if(str) free(str);
			str = strdup_printf(("MD Heating: %0.2f fs, T = %0.2f K T(t) = %0.2f Kin = %0.4f Pot =  %0.4f Tot =  %0.4f"), 
					i*stepSize, 
					paths->temperature, 
					paths->kelvin, 
					paths->kineticEnergy,
					paths->potentialEnergy,
					paths->totalEnergy
					);
			printf("%s\n",str);
			updateNumber = 0;
		}
		saveProperties(paths, n0+i+1, i+1," Heating");
	}

	updateNumber = paths->updateFrequency;
	n0 += numberOfHeatSteps;
	for (i = 0; i < numberOfEquiSteps; i++ )
	{
		paths->klass->applyOneStep(paths);
		//paths->klass->applyThermostat(paths);
		if (++updateNumber >= paths->updateFrequency )
		{
			if(str) free(str);
			str = strdup_printf(("MD Equilibrium: %0.2f fs, T = %0.2f K  T(t) = %0.2f K Kin = %0.4f Pot =  %0.4f Tot =  %0.4f"), 
					i*stepSize, 
					paths->temperature, 
					paths->kelvin, 
					paths->kineticEnergy,
					paths->potentialEnergy,
					paths->totalEnergy
					);
			printf("%s\n",str);
			updateNumber = 0;
		}
		saveProperties(paths, n0+i+1, i+1, " Equilibrium");
	}
	updateNumber = paths->updateFrequency;
	n0 += numberOfEquiSteps;
	esum  = 0;
	e2sum = 0;
	for (i = 0; i < numberOfRunSteps; i++ )
	{
		paths->klass->applyOneStep(paths);
		//paths->klass->applyThermostat(paths);
		esum  += paths->totalEnergy;
		e2sum += paths->totalEnergy*paths->totalEnergy;
		if (++updateNumber >= paths->updateFrequency )
		{
			if(str) free(str);
			str = strdup_printf(("MD Running: %0.2f fs, T = %0.2f K  T(t) = %8.2f K Kin = %0.4f Pot =  %0.4f Tot =  %0.4f Eav = %0.4f sigE = %0.4f Eav-E0(cm^-1) = %0.2f"), 
					i*stepSize, 
					paths->temperature, 
					paths->kelvin, 
					paths->kineticEnergy,
					paths->potentialEnergy,
					paths->totalEnergy,
					esum/(i+1),
					sqrt(fabs(e2sum/(i+1)-esum/(i+1)*esum/(i+1))),
					(esum/(i+1)-e0)*349.75511054
					);
			printf("%s\n",str);
			updateNumber = 0;
			//saveTrajectory(paths, i+1);
		}
		saveProperties(paths, n0+i+1, i+1," Running");
	}

	updateNumber = paths->updateFrequency;
	n0 += numberOfRunSteps;
	for (i = 0; i < numberOfCoolSteps; i++ )
	{
		currentTemp = runTemperature - ( runTemperature - coolTemperature ) * ( ( double )( i + 1 )/ numberOfCoolSteps );
		resetPathsTemperature(paths, currentTemp);
		rescaleMoments(paths);
		paths->klass->applyOneStep(paths);
		if (++updateNumber >= paths->updateFrequency )
		{
			if(str) free(str);
			str = strdup_printf(("MD Cooling: %0.2f fs, T = %0.2f K T(t) = %0.2f K Kin = %0.4f Pot =  %0.4f Tot =  %0.4f"), 
					i*stepSize, 
					paths->temperature, 
					paths->kelvin, 
					paths->kineticEnergy,
					paths->potentialEnergy,
					paths->totalEnergy
					);
			printf("%s\n",str);
			updateNumber = 0;
		}
		saveProperties(paths, n0+i+1, i+1," Cooling");
	}
	paths->klass->calculateGradient(paths);
	if(str) free(str);
	str = strdup_printf(("End of MD Simulation. Ekin = %f (Kcal/mol) EPot =  %0.4f ETot =  %0.4f T(t) = %0.2f"),
			paths->kineticEnergy,
			paths->potentialEnergy,
			paths->totalEnergy,
			paths->kelvin 
			); 
	printf("%s\n",str);
	free(str);
	if(paths->fileTraj)fclose(paths->fileTraj);
	if(paths->fileProp)fclose(paths->fileProp);
	freePaths(paths);
}
/**************************************************************************************************************************************/
static void printPaths(Paths* paths,FILE* file)
{
	int i;
	int iAtom = 0;
	Molecule* molecule = paths->moleculeCentroid;
	fprintf(file,"\n");
	fprintf(file,"*************** PIMD Parameters ************************************************************************************************\n");
	fprintf(file,"nBeads\t\t\t\t\t= %d\n",paths->nBeads);
	fprintf(file,"dt(fs)\t\t\t\t\t= %f\n",paths->dt/fsInAKMA);
	if(paths->thermostat==PIMDTHERMOSTATLANGEVIN)
	{
		fprintf(file,"Thermostat\t\t\t= %s\n","Langevin thermostat");
		fprintf(file,"Temperature\t\t\t= %f\n",paths->temperature);
		fprintf(file,"gamma(ps^-1)\t\t\t= %f\n",paths->friction*fsInAKMA*1000);
	}
	if(paths->thermostat==PIMDTHERMOSTATNOSEHOOVER)
	{
		fprintf(file,"Thermostat\t\t\t\t= %s\n","Nose-Hoover thermostat");
		fprintf(file,"Temperature\t\t\t\t= %f\n",paths->temperature);
		fprintf(file,"Length of the Nose-Hoover chain\t\t= %d\n",paths->nNH);
		fprintf(file,"Number of Nose-Hoover Steps\t\t= %d\n",paths->nNHSteps);
		fprintf(file,"Number of Suzuki-Yoshida weights\t= %d\n",paths->nSY);
	}
	if(paths->thermostat==PIMDTHERMOSTATQTB)
	{
		fprintf(file,"Thermostat\t\t\t\t= %s\n","Qauntum thermal Bath");
		fprintf(file,"Temperature\t\t\t\t= %f\n",paths->temperature);
		printf("Nf\t\t= %d\n",paths->Nf);
		printf("Number of QTB steps(M)\t\t= %d\n",paths->nQTBSteps);
		printf("dt(fs)\t\t= %f\n",paths->dt/fsInAKMA);
		printf("h(fs)\t\t= %f\n",paths->h/fsInAKMA);
		printf("gamma(ps^-1)\t= %f\n",paths->friction*fsInAKMA*1000);
		printf("omegaMax(cm^-1)\t= %f\n",paths->omegaMax);
	}
	if(paths->thermostat==PIMDTHERMOSTATNONE)
	{
		fprintf(file,"Thermostat\t\t\t\t= %s\n","None");
		fprintf(file,"Temperature\t\t\t\t= %f\n",paths->temperature);
	}
	if(paths->transformation==PIMDTRANSFORMATIONSTAGING)
	{
		fprintf(file,"Transformation\t\t\t\t= %s\n","Staging");
	}
	if(paths->transformation==PIMDTRANSFORMATIONNORMALMODE)
	{
		fprintf(file,"Transformation\t\t\t\t= %s\n","Normal Mode");
	}
	if(paths->transformation==PIMDTRANSFORMATIONNONE)
	{
		fprintf(file,"Transformation\t\t\t\t= %s\n","None");
	}
	fprintf(file,"wp(rad/ps)\t\t\t\t= %f\n",paths->wp*fsInAKMA*1000);
	fprintf(file,"nFree\t\t\t\t\t= %d\n", paths->moleculeCentroid->nFree);
	fprintf(file,"hbar (AKMA)\t\t\t\t= %f\n", hbar);
	for(i = 0;i<paths->nBeads; i++) 
	{
		fprintf(file,"Bead #\t\t= %d\n",i);
		fprintf(file,"%-6s %10s %10s %10s %10s %10s %10s %10s %10s %10s %10s %10s\n","Symbol","M","M'","X","Y","Z","Vx","Vy","Vz","Fx","Fy","Fz");
	for(iAtom = 0;iAtom<paths->molecules[i]->nAtoms; iAtom++) 
		fprintf(file,"%-6s %10.6f %10.6f %10.6f %10.6f %10.6f %10.6f %10.6f %10.6f %10.6f %10.6f %10.6f\n",
			molecule->atoms[iAtom].prop.symbol,
			paths->M[i][iAtom],
			paths->Mprim[i][iAtom],
			molecule->atoms[iAtom].coordinates[0],
			molecule->atoms[iAtom].coordinates[1],
			molecule->atoms[iAtom].coordinates[2],
			molecule->atoms[iAtom].velocity[0],
			molecule->atoms[iAtom].velocity[1],
			molecule->atoms[iAtom].velocity[2],
			paths->F[0][i][iAtom],
			paths->F[1][i][iAtom],
			paths->F[2][i][iAtom]
			);
	}
	fprintf(file,"********************************************************************************************************************************\n");
	fprintf(file,"\n");
}
/*****************************************************************************************************************************/
static void applyNoThermostat(Paths* paths)
{
}
/*********************************************************************************************************************/
static void initVelocities(Paths* paths)
{
	int i;
	//int k,iAtom;
	Molecule* molC = paths->moleculeCentroid;
	Molecule** mols = paths->molecules;
	molC->klass->setMaxwellVelocitiesIfNull(molC, paths->temperature);
	/*
        for ( i = 0; i < paths->nBeads; i++)
        for ( iAtom = 0; iAtom < mols[i]->nAtoms; iAtom++)
	for(k = 0;k<3; k++) 
                	mols[i]->atoms[iAtom].velocity[k] = molC->atoms[iAtom].velocity[k];
	*/
        for ( i = 0; i < paths->nBeads; i++) mols[i]->klass->setMaxwellVelocitiesIfNull(mols[i], paths->temperature);
        for ( i = 0; i < paths->nBeads; i++) mols[i]->klass->removeTranslationAndRotation(mols[i]);
}
/*****************************************************************************************************************************/
static void initAllPointers(Paths* paths)
{
	paths->fileTraj = NULL;
	paths->fileProp = NULL;
	paths->forceFields = NULL;
	paths->qmModels = NULL;
	paths->molecules = NULL;
	paths->moleculeCentroid = NULL;
	paths->M = NULL;
	paths->Mprim = NULL;
	paths->O = NULL;
	paths->F = NULL;
	paths->U = NULL;
	paths->P = NULL;

	paths->oneOverM = NULL;
	paths->iNext = NULL;
	paths->iPrev = NULL;

	paths->LTPMult = NULL;
	paths->LTFMult = NULL;

	paths->NHP = NULL;
	paths->NHF = NULL;
	paths->oneOverNHM = NULL;
	paths->NHd = NULL;
}
/*********************************************************************************/
static void removeTranslation(Paths* paths)
{
	double vtot[3] = {0,0,0};
	int i;
	int iAtom;
	int j;
	double tot = 0.0;
	double*** P = paths->P;

	if(!P) return;
	for ( i = 0; i < paths->nBeads; i++)
	{
		for ( iAtom = 0; iAtom < paths->molecules[i]->nAtoms; iAtom++)
		{
			tot += paths->Mprim[i][iAtom];
			for ( j = 0; j < 3; j++)
			{
				vtot[j] += P[j][i][iAtom];
			}
		}
	}

	for ( j = 0; j < 3; j++) vtot[j] /= tot;


	for ( i = 0; i < paths->nBeads; i++)
		for ( iAtom = 0; iAtom < paths->molecules[i]->nAtoms; iAtom++)
			for ( j = 0; j < 3; j++)
				P[j][i][iAtom] -= paths->Mprim[i][iAtom]*vtot[j];
}
/*********************************************************************************/
static void removeRotation(Paths* paths)
{
	double vtot[3] = {0,0,0};
	double cm[3] = {0,0,0};
	double L[3] = {0,0,0};
	int i;
	int iAtom;
	int j;
	int k;
	double mass = 1.0;
	double totMass = 0.0;
	double cdel[3];
	double vAng[3]={0,0,0};
	double tensor[3][3];
	double invTensor[3][3];
        double xx, xy,xz,yy,yz,zz;
	double*** P = paths->P;
	double*** U = paths->U;
	double n = 0;
	/* find the center of mass coordinates  and total velocity*/
	if(!U)
	{
		paths->molecules[0]->klass->removeRotationMoments(paths->molecules, paths->nBeads, paths->P);
		return;
	}

	for ( i = 0; i < paths->nBeads; i++)
	{
		for ( iAtom = 0; iAtom <  paths->molecules[i]->nAtoms; iAtom++)
		{
			mass = paths->Mprim[i][iAtom];
			totMass += mass;
			n++;
			for ( j = 0; j < 3; j++)
				cm[j] += mass*U[j][i][iAtom];
			for ( j = 0; j < 3; j++)
				vtot[j] += P[j][i][iAtom];
		}
	}


	for ( j = 0; j < 3; j++) cm[j] /= totMass;

	/*   compute the angular momentum  */
	for ( i = 0; i < paths->nBeads; i++)
	{
		for ( iAtom = 0; iAtom <  paths->molecules[i]->nAtoms; iAtom++)
		{
			mass = paths->Mprim[i][iAtom];
			for ( j = 0; j < 3; j++)
			L[j] += (
				U[(j+1)%3][i][iAtom]*P[(j+2)%3][i][iAtom]
			      - U[(j+2)%3][i][iAtom]*P[(j+1)%3][i][iAtom]
			      );
		}
	}
	for ( j = 0; j < 3; j++)
		L[j] -= (
			cm[(j+1)%3]*vtot[(j+2)%3]
		      - cm[(j+2)%3]*vtot[(j+1)%3]
			      );

	/* calculate and invert the inertia tensor */
	for ( k = 0; k < 3; k++)
	for ( j = 0; j < 3; j++)
		tensor[k][j] = 0;
	xx = 0;
	yy = 0;
	zz = 0;
	xy = 0;
	xz = 0;
	yz = 0;
	for ( i = 0; i < paths->nBeads; i++)
	{
		for ( iAtom = 0; iAtom <  paths->molecules[i]->nAtoms; iAtom++)
		{
			mass = paths->Mprim[i][iAtom];
			for ( j = 0; j < 3; j++)
				cdel[j] = U[j][i][iAtom]-cm[j];
			xx +=  cdel[0]*cdel[0]*mass;
			xy +=  cdel[0]*cdel[1]*mass;
			xz +=  cdel[0]*cdel[2]*mass;
			yy +=  cdel[1]*cdel[1]*mass;
			yz +=  cdel[1]*cdel[2]*mass;
			zz +=  cdel[2]*cdel[2]*mass;
		}
	}
	tensor[0][0] = yy+zz;
	tensor[1][0] = -xy;
	tensor[2][0] = -xz;
	tensor[0][1] = -xy;
	tensor[1][1] = xx+zz;
	tensor[2][1] = -yz;
	tensor[0][2] = -xz;
	tensor[1][2] = -yz;
	tensor[2][2] = xx+yy;
	if(InverseTensor(tensor,invTensor))
	{
		for ( j = 0; j < 3; j++)
		{
			vAng[j] = 0;
			for ( k = 0; k < 3; k++)
				vAng[j] += invTensor[j][k]*L[k];
		}
	}
	else
	if( paths->molecules[0]->nAtoms>1)
	{
		double U0[3];
		double U1[3];
		for ( j = 0; j < 3; j++)U0[j] = U[j][0][0];
		for ( j = 0; j < 3; j++)U1[j] = U[j][0][1];
		//printf("!!!!!!!!!!!I cannot invert the rotational Tensor : linear molecule!\n");
		computeAngularVelocitiesForALinearMolecule(U0, U1, tensor, L, vAng);
		//printf("Angular velocityibefore rotation = %f %f %f\n",vAng[0], vAng[1], vAng[2]);
	}
	/*  eliminate any rotation about the system center of mass */
	for ( i = 0; i < paths->nBeads; i++)
	{
		for ( iAtom = 0; iAtom <  paths->molecules[i]->nAtoms; iAtom++)
		{
			for ( j = 0; j < 3; j++)
				cdel[j] = U[j][i][iAtom]-cm[j];
			for ( j = 0; j < 3; j++)
				P[j][i][iAtom] += 
				(cdel[(j+1)%3]*vAng[(j+2)%3]-
				cdel[(j+2)%3]*vAng[(j+1)%3])
				*paths->Mprim[i][iAtom]
				;
		}
	}
}
/*********************************************************************************/
static void removeTranslationAndRotation(Paths* paths)
{
	if(paths->nBeads<1) return;
	paths->klass->removeTranslation(paths);
	paths->klass->removeRotation(paths);
}
File: ./cchemilib/src/PathIntegral/StagingTrans.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include "Paths.h"
#include "../Utils/Constants.h"
#include "../Utils/Utils.h"

static void calculateForcesStaging(Paths* paths);
static void RtoUStaging(Paths* paths);
static void UtoRStaging(Paths* paths);
static void applyOneStepStaging(Paths* paths);
static void momentToCartezianStaging(Paths* paths);
static void initMasses(Paths* paths);
static void initMoments(Paths* paths);
static double getEKinVelocities(Paths* paths);
/*********************************************************************************************************************/
void initStagingTrans(Paths* paths)
{
	int nAtoms = paths->molecules[0]->nAtoms;
	int nBeads = paths->nBeads;

  	/* Positions U */
	paths->U = newCubeDouble(3,nBeads,nAtoms);
	RtoUStaging(paths);

	initMasses(paths);
	initMoments(paths);

	paths->klass->calculateForces = calculateForcesStaging;
	paths->klass->applyOneStep = applyOneStepStaging;
	paths->klass->momentToCartezian = momentToCartezianStaging ;
	paths->klass->getEKinVelocities = getEKinVelocities;
	paths->klass->calculateForces(paths);
	printf("End initStagingTrans\n");
}
/*********************************************************************************************************************/
static void initMasses(Paths* paths)
{
	int i,iAtom;
	int nAtoms = paths->molecules[0]->nAtoms;
	int nBeads = paths->nBeads;

	paths->M  = newMatrixDouble(nBeads,nAtoms);
	for(iAtom = 0;iAtom<nAtoms; iAtom++) paths->M[0][iAtom]  = 0;
	for(i = 1;i<paths->nBeads; i++) 
	for(iAtom = 0;iAtom<nAtoms; iAtom++) 
		paths->M[i][iAtom]  = (i+1.0)/i*paths->molecules[i]->atoms[iAtom].mass;

	paths->Mprim  = newMatrixDouble(nBeads,nAtoms);
	for(iAtom = 0;iAtom<nAtoms; iAtom++) paths->Mprim[0][iAtom]  = paths->molecules[0]->atoms[iAtom].mass;

	for(i = 1;i<paths->nBeads; i++) 
	for(iAtom = 0;iAtom<nAtoms; iAtom++) 
		//paths->Mprim[i][iAtom]  =  paths->molecules[i]->atoms[iAtom].mass;
		paths->Mprim[i][iAtom]  = paths->M[i][iAtom];

}
/*********************************************************************************************************************/
static void initMoments(Paths* paths)
{
	int i,k,iAtom;
	int nAtoms = paths->molecules[0]->nAtoms;
	int nBeads = paths->nBeads;

	paths->P = newCubeDouble(3,nBeads,nAtoms);

	i = 0;
	for(iAtom = 0;iAtom<nAtoms; iAtom++) 
	for(k=0;k<3;k++)
		paths->P[k][i][iAtom] = paths->molecules[i]->atoms[iAtom].velocity[k]*paths->Mprim[i][iAtom];

	for(i = paths->nBeads - 1; i>0 ;  i--) 
	{
		int iN = paths->iNext[i];
		for(iAtom = 0;iAtom<nAtoms; iAtom++) 
		for(k=0;k<3;k++)
		{
			paths->P[k][i][iAtom] =
      			paths->molecules[i]->atoms[iAtom].velocity[k]*paths->Mprim[i][iAtom] 
			- i/(i + 1.0)*paths->molecules[iN]->atoms[iAtom].velocity[k]*paths->Mprim[iN][iAtom]
			- 1.0/(i + 1.0)*paths->P[k][0][iAtom];
		}
	}
}
/**************************************************************************************************************************/
static void applyOneStepStaging(Paths* paths)
{
	int iAtom,i,k;
	double*** P = paths->P;
	double*** U = paths->U;
	paths->klass->applyThermostat(paths); // 2 times

	for(i = 0;i<paths->nBeads; i++) 
	for(iAtom = 0;iAtom<paths->molecules[i]->nAtoms; iAtom++) 
	for(k = 0;k<3; k++) 
	{
		P[k][i][iAtom] += 0.5*paths->F[k][i][iAtom]*paths->dt;
		U[k][i][iAtom] +=  P[k][i][iAtom]*paths->dt/paths->Mprim[i][iAtom];
	}
	UtoRStaging(paths);
	paths->klass->calculateForces(paths);
	paths->klass->applyThermostat(paths);

	for(i = 0;i<paths->nBeads; i++) 
	for(iAtom = 0;iAtom<paths->molecules[i]->nAtoms; iAtom++) 
	for(k = 0;k<3; k++) 
	{
		P[k][i][iAtom] += 0.5*paths->F[k][i][iAtom]*paths->dt;
	}
  
	paths->klass->removeTranslationAndRotation(paths);
	paths->klass->computeEnergies(paths);
  
}

/**************************************************************************************************************************/
static void UtoRStaging(Paths* paths)
{
	int iAtom,i,k;
	Molecule** mols = paths->molecules;
	int nAtoms = paths->molecules[0]->nAtoms;
	for (iAtom = 0; iAtom < nAtoms; iAtom++)
	{
		// first bead
		i = 0;
		for(k = 0;k<3; k++) mols[i]->atoms[iAtom].coordinates[k] = paths->U[k][i][iAtom];
    		for (i = paths->nBeads-1; i > 0; i--)
		{
			int iN = paths->iNext[i];
			for(k = 0;k<3; k++) 
				mols[i]->atoms[iAtom].coordinates[k] = 
      				paths->U[k][i][iAtom] + i/(i + 1.0)* mols[iN]->atoms[iAtom].coordinates[k]
				+ 1.0/(i + 1.0)*paths->U[k][0][iAtom];
		}
	}
}
/**************************************************************************************************************************/
static void RtoUStaging(Paths* paths)
{
	int iAtom,i,k;
	Molecule** mols = paths->molecules;
	int nAtoms = paths->molecules[0]->nAtoms;
	for (iAtom = 0; iAtom < nAtoms; iAtom++)
	{
		i = 0;
		for(k = 0;k<3; k++) 
				paths->U[k][i][iAtom] = mols[i]->atoms[iAtom].coordinates[k];
    		for (i = paths->nBeads-1; i > 0; i--)
		{
			int iN = paths->iNext[i];
			for(k = 0;k<3; k++) 
      				paths->U[k][i][iAtom]  =
				mols[i]->atoms[iAtom].coordinates[k] 
				- i/(i + 1.0)* mols[iN]->atoms[iAtom].coordinates[k]
				- 1.0/(i + 1.0)*paths->U[k][0][iAtom];
		}
	}
}

/*********************************************************************************************************************/
static void calculateForcesStaging(Paths* paths)
{
  	double  gradVA[3];
  	double  gradVB[3];
	int iAtom,i;
	int k;
	int nAtoms = paths->molecules[0]->nAtoms;
	Molecule** mols = paths->molecules;

	paths->klass->calculateGradient(paths);

	for (iAtom = 0; iAtom < nAtoms; iAtom++)
	{
		for(k = 0;k<3; k++) gradVA[k] = 0;

    		for (i = 0; i <paths->nBeads; i++)
		{
		for(k = 0;k<3; k++) gradVA[k] += mols[i]->atoms[iAtom].gradient[k];
		}

		for(k=0;k<3;k++) paths->F[k][0][iAtom] = -paths->oneOvernBeads*gradVA[k];

		for(k = 0;k<3; k++) gradVB[k] = gradVA[k];

    		for (i = 1; i <paths->nBeads; i++)
		{
			for(k = 0;k<3; k++) gradVA[k] =  mols[i]->atoms[iAtom].gradient[k]+(i - 1.0)/i*gradVB[k];
			for(k=0;k<3;k++) paths->F[k][i][iAtom] = -paths->oneOvernBeads*gradVA[k];
			for(k=0;k<3;k++) paths->F[k][i][iAtom] += -paths->M[i][iAtom]*paths->wp2*paths->U[k][i][iAtom];
			for(k = 0;k<3; k++) gradVB[k] = gradVA[k];
		}
	}
}
/**************************************************************************************************************************/
static void momentToCartezianStaging(Paths* paths)
{
	int iAtom,i,k;
	Molecule** mols = paths->molecules;
	int nAtoms = paths->molecules[0]->nAtoms;
	double*** P = paths->P;

	for (iAtom = 0; iAtom < nAtoms; iAtom++)
	{
		// first bead
		i = 0;
		for(k = 0;k<3; k++) mols[i]->atoms[iAtom].velocity[k] = P[k][i][iAtom];
    		for (i = paths->nBeads-1; i > 0; i--)
		{
			int iN = paths->iNext[i];
			for(k = 0;k<3; k++) 
				mols[i]->atoms[iAtom].velocity[k] = 
      				P[k][i][iAtom] + i/(i + 1.0)* mols[iN]->atoms[iAtom].velocity[k]
				+ 1.0/(i + 1.0)*P[k][0][iAtom];
		}
	}
    	for (i = 0; i<paths->nBeads; i++)
	for (iAtom = 0; iAtom < nAtoms; iAtom++)
		for(k = 0;k<3; k++) mols[i]->atoms[iAtom].velocity[k] /= paths->Mprim[i][iAtom];
}
/********************************************************************************/
/* Kinetic Velocities Energy Estimator*/
static double getEKinVelocities(Paths* paths)
{
	double ekin = 0.0;
	int iAtom,i,j;
	//double RC[3];
	double***P = paths->P;
	double***U = paths->U;
	Molecule** mols = paths->molecules;
	int k;

	double invmass;
	ekin = 0;
	for(i = 0;i<paths->nBeads; i++) 
	for(iAtom = 0;iAtom< mols[i]->nAtoms; iAtom++) 
	{
		invmass =  1.0/paths->Mprim[i][iAtom];
		for ( j = 0; j < 3; j++)
			ekin += P[j][i][iAtom]*P[j][i][iAtom]*invmass;
	}

	for(i = 0;i<paths->nBeads; i++) 
	for(iAtom = 0;iAtom<paths->molecules[i]->nAtoms; iAtom++) 
	{
		double dot = 0;
		for(k = 0;k<3; k++) dot += U[k][i][iAtom]*U[k][i][iAtom];
      		ekin -=  paths->M[i][iAtom]*paths->wp2 * dot;
	}
  	ekin *= 0.5;
  	return ekin;
}
File: ./cchemilib/src/PathIntegral/QTBThermostat.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include "Paths.h"
#include "../Utils/Constants.h"
#include "../Utils/QL.h"
#include "../Utils/Utils.h"

/* Refs 
Jean-Louis Barrat , David Rodney
Portable implementation of a quantum thermal bath for molecular dynamics simulations
JOURNAL OF STATISTICAL PHYSICS 670, 144, (2011)
*/
static void updateQTB(Paths* paths);
static void resetQTB(Paths* paths);
static void computeThetaQTB(Paths* paths);
static void applyQTBThermostat(Paths* paths);
//static double gP(int P, double x);
//static double* compute_gP(int P, double xmax, int n, int ng);
static void removeTranslationAndRotationTheta(Paths* paths);
static void removeTranslationTheta(Paths* paths);
static void removeRotationTheta(Paths* paths);
//static void removeTranslationAndRotationThetaOneBead(Paths* paths, int i);
//static void removeTranslationThetaOneBead(Paths* paths, int i);
//static void removeRotationThetaOneBead(Paths* paths, int i);
static double* compute_gPTable(int P, double dx, int M);
static double interpol(int M, double* g, double dx, double x);
//static double* compute_fPTable(int P, double dx, int M);
/*********************************************************************************/
/* omegaMax in cm-1 */
void initQTBThermostat(Paths* paths)
{
	static double cmM1fsM1 = 2.99792458e-5;
	double Omegafs = paths->omegaMax*cmM1fsM1;/* fs^-1 */ 
	int nAtoms = paths->molecules[0]->nAtoms;
	
		fprintf(stdout,"gamma(ps^-1)\t\t\t= %f\n",paths->friction*fsInAKMA*1000);
	if(paths->Nf<1) paths->Nf = 50;

	//Omegafs *= sqrt(paths->nBeads);
	printf("wp(cm-1)=%f\n",paths->kT*2*paths->nBeads*349.75511054);
	//Omegafs += (paths->kT*2*paths->nBeads*349.75511054*cmM1fsM1);

	paths->h = 1/Omegafs*(fsInAKMA);
	//paths->h = paths->dt;
	paths->nQTBSteps = (int)(paths->h/paths->dt);
	if(paths->nQTBSteps<1) paths->nQTBSteps = 1;
	paths->h = paths->nQTBSteps *paths->dt;
	paths->omegaMax = 1.0/paths->h*(fsInAKMA)/cmM1fsM1; /* cm-1 */
	if(paths->friction<0) paths->friction = (1.0/ paths->h)/50;
		fprintf(stdout,"gamma(ps^-1)\t\t\t= %f\n",paths->friction*fsInAKMA*1000);
	
	paths->Ht = newMatrixDouble(paths->nBeads,2*paths->Nf);
	paths->theta = newMatrixDouble(paths->nBeads,3*nAtoms);
	paths->rnoise = newCubeDouble(paths->nBeads,3*nAtoms,2*paths->Nf);

	paths->gpQTB = 1/(1+paths->friction*paths->dt/2);
	paths->gmQTB = (1-paths->friction*paths->dt/2)*paths->gpQTB;

	printf("gpQTB=%f gmQTB=%f\n",paths->gpQTB,paths->gmQTB);
/*
	paths->gpQTB = 1.0;
	paths->gmQTB = (1-paths->friction*paths->dt/2)*paths->gpQTB;
	printf("gpQTB=%f gmQTB=%f\n",paths->gpQTB,paths->gmQTB);
*/
	//paths->gmQTB = exp(-paths->dt/2.0*paths->friction);
	//paths->gpQTB = 1/(1+paths->friction*paths->dt/2);
	//paths->gmQTB *= paths->gpQTB;
	//printf("gpQTB=%f gmQTB=%f\n",paths->gpQTB,paths->gmQTB);

	paths->iQTBStep = 0;

	paths->klass->applyThermostat = applyQTBThermostat;

	resetQTB(paths);
	printf("End initQTB\n");

}
/*****************************************************************************************************************************/
static void applyQTBThermostat(Paths* paths)
{
	int i,k,iAtom;
	int nAtoms = paths->molecules[0]->nAtoms;
	double*** P = paths->P;
	double*** F = paths->F;

	if((paths->iQTBStep+1)==2*paths->nQTBSteps){ updateQTB(paths); paths->iQTBStep = 0;}
	else paths->iQTBStep++;

	for(i = 0;i<paths->nBeads; i++) 
	{
	for(iAtom = 0;iAtom<nAtoms; iAtom++) 
	for(k = 0;k<3; k++) 
	{
		if((paths->iQTBStep+1)%2==0) F[k][i][iAtom] +=  paths->gpQTB*paths->theta[i][3*iAtom+k]-4*(1-paths->gmQTB)/(1+paths->gmQTB)/paths->dt*P[k][i][iAtom];
		else P[k][i][iAtom] +=  paths->gpQTB*paths->theta[i][3*iAtom+k]*0.5*paths->dt; 

/*
		if((paths->iQTBStep+1)%2==0)
			F[k][i][iAtom] =  paths->gpQTB*(F[k][i][iAtom]+paths->theta[i][3*iAtom+k])+2*(paths->gmQTB-1)/paths->dt*P[k][i][iAtom];
		else
			P[k][i][iAtom] +=  paths->gpQTB*paths->theta[i][3*iAtom+k]*0.5*paths->dt
			+  (paths->gpQTB-1)*F[k][i][iAtom]*0.5*paths->dt; 
*/
	}
	//paths->molecules[i]->klass->removeTranslationAndRotation(paths->molecules[i]);
	}

/*
	if((paths->iQTBStep+1)==paths->nQTBSteps){ updateQTB(paths); paths->iQTBStep = 0;}
	else paths->iQTBStep++;

	Molecule** mols = paths->molecules;
	for(i = 0;i<paths->nBeads; i++) 
	for(iAtom = 0;iAtom<paths->molecules[i]->nAtoms; iAtom++) 
	for(k = 0;k<3; k++) 
	{
		mols[i]->atoms[iAtom].coordinates[k] +=  P[k][i][iAtom]*paths->dt/paths->Mprim[i][iAtom]
		+ (F[k][i][iAtom]+paths->gpQTB*paths->theta[i][3*iAtom+k]-paths->friction*P[k][i][iAtom])
		   *paths->dt*paths->dt/2/paths->Mprim[i][iAtom];

		P[k][i][iAtom]  =  P[k][i][iAtom]*paths->gmQTB;
		P[k][i][iAtom] +=  paths->gpQTB*paths->theta[i][3*iAtom+k]*paths->dt/2;
		P[k][i][iAtom] +=  paths->gpQTB*paths->F[k][i][iAtom]*paths->dt/2;
	}
	paths->klass->calculateForces(paths);

	for(i = 0;i<paths->nBeads; i++) 
	for(iAtom = 0;iAtom<paths->molecules[i]->nAtoms; iAtom++) 
	for(k = 0;k<3; k++) 
	{
		P[k][i][iAtom] +=  paths->gpQTB*paths->theta[i][3*iAtom+k]*paths->dt/2;
		P[k][i][iAtom] +=  paths->gpQTB*paths->F[k][i][iAtom]*paths->dt/2;
	}
	//paths->klass->removeTranslationAndRotation(paths);
	//paths->klass->removeTranslation(paths);
	// used to compute energy
*/
/*
	for(i = 0;i<paths->nBeads; i++) 
	for(iAtom = 0;iAtom<paths->molecules[i]->nAtoms; iAtom++) 
	for(k = 0;k<3; k++) 
	{
		mols[i]->atoms[iAtom].gradient[k] -=  paths->gpQTB*paths->theta[i][3*iAtom+k];
	}
*/
}
/*********************************************************************************/
static void updateQTB(Paths* paths)
{
	int i,iAtom,j,k;
	int nAtoms = paths->molecules[0]->nAtoms;

	if(paths->temperature<=0) return;
	computeThetaQTB(paths);
	/* shift rnoise */

	for(i=0;i<paths->nBeads;i++)
	for(iAtom=0;iAtom<nAtoms;iAtom++)
	for(j=0;j<3;j++)
	for(k=0;k<2*paths->Nf-1;k++)
		 paths->rnoise[i][3*iAtom+j][k] = paths->rnoise[i][3*iAtom+j][k+1];

	/* add one value to the end */
	for(i=0;i<paths->nBeads;i++)
	for(iAtom=0;iAtom<nAtoms;iAtom++)
	for(j=0;j<3;j++)
		 paths->rnoise[i][3*iAtom+j][2*paths->Nf-1] = normal(); /* sqrt(h) in sigma */

}
/*********************************************************************************/
static void computeThetaQTB(Paths* paths)
{
	//double sigma=sqrt(2.*paths->friction*paths->kT/paths->h);
	double sigma=sqrt(2*paths->friction*paths->kT/paths->h);
	int i,iAtom,j,k;
	int nAtoms = paths->molecules[0]->nAtoms;

	/* thetaProg = thetaPaper*sigma/sqrt(m) */
	for(i=0;i<paths->nBeads;i++)
	for(iAtom=0;iAtom<nAtoms;iAtom++)
	for(j=0;j<3;j++)
	{
		paths->theta[i][3*iAtom+j] = 0.0;
		for(k=0;k<2*paths->Nf;k++)
			paths->theta[i][3*iAtom+j] += paths->rnoise[i][3*iAtom+j][2*paths->Nf-1-k]*paths->Ht[i][k];
			//paths->theta[i][3*iAtom+j] += paths->rnoise[0][3*iAtom+j][2*paths->Nf-1-k]*paths->Ht[i][k];
		paths->theta[i][3*iAtom+j] *= sigma*sqrt(paths->Mprim[i][iAtom]);
	}
	//for(i=0;i<paths->nBeads;i++)
	//	paths->molecules[i]->klass->removeTranslationAndRotationVectors(paths->molecules[i],paths->theta[i]);
	//paths->molecules[0]->klass->removeTranslationVectorsCluster(paths->molecules,paths->nBeads,paths->theta);
	removeTranslationAndRotationTheta(paths);
	//removeTranslationTheta(paths);
	//for(i=0;i<paths->nBeads;i++)
		//removeTranslationAndRotationThetaOneBead(paths, i);
		//removeTranslationThetaOneBead(paths, i);
	//removeTranslationTheta(paths);
	//removeRotationTheta(paths);
	//for(i=0;i<paths->nBeads;i++)
		//paths->molecules[i]->klass->removeRotationForce(paths->molecules[i],paths->theta[i]);
		//paths->molecules[i]->klass->removeTranslationForce(paths->molecules[i],paths->theta[i]);
}
/*********************************************************************************/
static void resetQTB(Paths* paths)
{
	double* Filter = NULL;
	int k;
	double hbarwOverkT;
	double hbarwOverkTk;
	double hbardwOverkT;
	int i,iAtom,j;
	double T;
	int nAtoms = paths->molecules[0]->nAtoms;
	double* gp;
	double dx;
	int M;
	double sini2;
	double x2xk2;
	double xk;
	double hwover2;

	paths->iQTBStep = 0;
	T = paths->temperature;
	if(T<=0) return;

	/* computing of Filter */
	/* Htild/sqrt(kT), sqrt(kT) in sigma */
	Filter = malloc((2*paths->Nf)*sizeof(double)); 
	/* h dOmega = pi /Nf */

	//hbardwOverkT = 1.0/(paths->Nf*paths->h*paths->kT);
	//hbardwOverkT = 1.0/(paths->Nf*paths->h*paths->kT*(paths->nBeads));
	hbardwOverkT = 1.0/(paths->Nf*paths->h*paths->kT);
	hbarwOverkTk = sqrt(hbardwOverkT*paths->Nf*hbardwOverkT*paths->Nf+4*paths->nBeads);
	M =  paths->Nf*10*paths->nBeads;
	dx = hbarwOverkTk/2/(M-1);
	gp = compute_gPTable(paths->nBeads, dx, M);
	//gp = compute_fPTable(paths->nBeads, dx, M);
	FILE* f =fopen("gP.txt","w");
	for(k=0;k<M;k++) fprintf(f,"%f %f\n",dx*k, gp[k]);
	fclose(f);
	f =fopen("F.txt","w");
	for(i=0;i<paths->nBeads;i++)
	{
		sini2 = sin(i*M_PI/paths->nBeads);
		sini2 = sini2*sini2;
		sini2 *= 4*paths->nBeads;
		sini2 *= paths->nBeads;
	for(k=0;k<2*paths->Nf;k++)
	{
		int kk= k-paths->Nf;
		int kp= abs(kk);
		printf("k=%d\n",k);
		if(kk==0) Filter[k] = 1.0;
		else
		{
			hbarwOverkT = kp*hbardwOverkT;
			hbarwOverkTk = sqrt(hbarwOverkT*hbarwOverkT+sini2);
			x2xk2 = hbarwOverkT/hbarwOverkTk;
			x2xk2 = x2xk2*x2xk2;
			xk = hbarwOverkTk/2;
			// gpTable
			Filter[k] = sqrt(interpol(M, gp, dx,xk)*x2xk2);
			// fPTable
			//Filter[k] = (interpol(M, gp, dx,xk)*sqrt(x2xk2));
			fprintf(f,"%f %f %f\n", xk, Filter[k], Filter[k]-1);
			//Filter[k] = 1.0;
			hwover2 = xk*paths->kT*paths->h*M_PI;
			//hwover2 = kk*M_PI/paths->Nf/2;
			Filter[k] *= (hwover2)/sin(hwover2);
			//Filter[k] *= (kk*M_PI/paths->Nf/2)/sin(kk*M_PI/paths->Nf/2);
		}
	}
	//for(k=0;k<2*paths->Nf;k++)  Filter[k] *= (sqrt(paths->nBeads));
	/* compute Ht */
	for(j=0;j<2*paths->Nf;j++)
	{
                paths->Ht[i][j] = 0;
		for(k=0; k<2*paths->Nf;k++)
                	paths->Ht[i][j] += Filter[k]*cos(M_PI*(k-paths->Nf)*(j-paths->Nf)*1.0/paths->Nf);
		
               	paths->Ht[i][j] /= 2*paths->Nf;
	}
	}
	fclose(f);
	free(Filter);
	free(gp);
	
	for(i=0;i<paths->nBeads;i++)
	for(iAtom=0;iAtom<nAtoms;iAtom++)
	for(j=0;j<3;j++)
	for(k=0;k<2*paths->Nf;k++)
		 paths->rnoise[i][3*iAtom+j][k] = normal();/* sqrt(h) is in sigma */

	computeThetaQTB(paths);

}
/*********************************************************************************/
static double h(double x)
{
	return x/tanh(x);
}
/*********************************************************************************/
/* Ref ! eq. 17, Ceriotti et al., J. Chem. Phys. 134, 084104 (2011)*/
/*
static double gP(int P, double x)
{
	static double* gold  = NULL;
	static double* g  = NULL;
	static double* xk  = NULL;
	static double* hk  = NULL;
	static int Pold = 0;
	double s;
	double sink;
	int k;
	double alpha = 1.0/P;
	double precision = 1e-8;
	int nMax = 10000;
	int n = 0;
	double norm;
	int j;
	double xx;

	return h(x/P);

	if(Pold ==0 || Pold != P) 
	{
		if(gold) free(gold);
		if(g) free(g);
		if(xk) free(xk);
		if(hk) free(hk);
		gold = malloc(P*sizeof(double));
		g = malloc(P*sizeof(double));
		xk = malloc(P*sizeof(double));
		hk = malloc(P*sizeof(double));
		Pold = P;
	}
	//return h(x/P);
	// i = 0, g = h for x/P, xk/P, k = 1..P-1
	printf("x = %f\n",x);
	xk[0] = x;
	for(k=1;k<P;k++)
	{
		sink  = P*sin(k*M_PI*alpha);
		xk[k] = sqrt(x*x+sink*sink); 
	}
	for(k=0;k<P;k++) gold[k] = h(xk[k]/P);
	for(k=0;k<P;k++) g[k] = gold[k];
	for(k=0;k<P;k++) hk[k] = h(xk[k]);

	n = 0;
	do{
		for(j=0;j<P;j++)
		{
			s = 0;
			for(k=1;k<P;k++)
			{
				xx = xk[j]/xk[k];
				s += gold[k]*xx*xx;
			}
			printf("s = %f\n",s);
			g[j] = alpha*(hk[j]-s)+(1-alpha)*gold[j]; 
		}
		printf("g0 = %f\n",g[0]);
		norm = 0;
		norm = (g[0]-gold[0])*(g[0]-gold[0]);
		norm = sqrt(norm);
		for(j=0;j<P;j++) printf("xk[%d] = %f g[%d]=%f\n",j,xk[j],j,g[j]);
		printf("n = %d norm = %0.12f\n",n,norm);
		for(j=0;j<P;j++) gold[j] = g[j];
		if(norm<precision) break;
		n++;
	}while(n<nMax);
	if(n==nMax)
	{
		
		fprintf(stdout,"Error : divergence in g function of the QTBThermostat.c\n");
		fprintf(stdout,"P = %d x = %f\n",P,x);
		exit(1);
	}
	return gold[0];
}
*/
/*********************************************************************************/
static double interpol(int M, double* g, double dx, double x)
{
	int i = (int)(x/dx)+1;
	double dxi;
	if(i<=0) return 1.0;
	if(i>=M-1) return g[M-1];
	dxi = x-dx*(i-1);
	return (g[i]-g[i-1])/dx*dxi+g[i-1];
}
/*********************************************************************************/
/*
static double* compute_gP(int P, double xmax, int n, int ng)
{
	static double* gold  = NULL;
	static double* g  = NULL;
	static double* x  = NULL;
	static double* hk  = NULL;
	double s;
	int k;
	double alpha = 1.0/P;
	double precision = 1e-8;
	int iterMax = 10000;
	double norm;
	int iter = 0;
	double xx;
	int nn = (int)(n*sqrt(xmax*xmax+P*P)/xmax);
	int M = 2*nn*ng;
	double dx = 2*sqrt(xmax*xmax+P*P)/(M-1);
	double** xk;
	double* gp;
	int i;
	double normold;

	gold = malloc(M*sizeof(double));
	g = malloc(M*sizeof(double));
	x = malloc(M*sizeof(double));
	hk = malloc(M*sizeof(double));
	xk = malloc(M*sizeof(double*));
	for(i=0;i<M;i++) xk[i] = malloc(P*sizeof(double));

	for(i=0;i<M;i++) x[i] = dx*i;

	for(i=0;i<M;i++) 
	for(k=0;k<P;k++)
	{
		// in ceriotti notation : Hceriotti = Htukerman*P
		xk[i][k] = sqrt(P)*sin(k*M_PI/P);
		xk[i][k] *= sqrt(P);
		xk[i][k] = xk[i][k]*xk[i][k];
		xk[i][k] = sqrt(x[i]*x[i]+xk[i][k]);
	}

	gold[0] = 1.0;
	for(i=1;i<M;i++) gold[i] = h(x[i]/P);
	for(i=0;i<M;i++) g[i] = gold[i];

	hk[0] = 1.0;
	for(i=1;i<M;i++) hk[i] = h(x[i]);

	iter = 0;
	normold = 1;
	do{
		for(i=0;i<M;i++)
		{
			s = 0;
			for(k=1;k<P;k++)
			{
				xx = x[i]/xk[i][k];
				s += interpol(M, gold, dx,xk[i][k])*xx*xx;
			}
			//printf("s = %f\n",s);
			g[i] = alpha*(hk[i]-s)+(1-alpha)*gold[i]; 
		}
		printf("g1 = %f\n",g[1]);
		norm = 0;
		for(i=0;i<M/2;i++) norm += (g[i]-gold[i])*(g[i]-gold[i]);
		norm = sqrt(norm/M*2);
		printf("norm = %0.12f\n",norm);
		fflush(stdout);
		if(norm>normold) alpha/=1.1;
		else for(i=0;i<M;i++) gold[i] = g[i];
		if(norm<precision) break;
		normold = norm;
		iter++;
	}while(iter<iterMax);
	if(iter==iterMax)
	{
		
		fprintf(stdout,"Error : divergence in g function of the QTBThermostat.c\n");
		exit(1);
	}
	free(g);
	free(x);
	free(hk);
	for(i=0;i<M;i++) free(xk[i]);
	free(xk);

	gp = malloc(n*sizeof(double));
	for(i=0;i<n;i++)
		gp[i] = interpol(M, gold, dx,i*xmax/(n-1));
	free(gold);

	return gp;
}
*/
/*********************************************************************************/
static double* compute_gPTable(int P, double dx, int M)
{
	static double* gold  = NULL;
	static double* g  = NULL;
	static double* x  = NULL;
	static double* hk  = NULL;
	double s;
	int k;
	double alpha = 1.0/P;
	double precision = 1e-8;
	int iterMax = 10000;
	double norm;
	int iter = 0;
	double xx;
	double** xk;
	int i;
	double normold;

	gold = malloc(M*sizeof(double));
	g = malloc(M*sizeof(double));
	x = malloc(M*sizeof(double));
	hk = malloc(M*sizeof(double));
	xk = malloc(M*sizeof(double*));
	for(i=0;i<M;i++) xk[i] = malloc(P*sizeof(double));

	for(i=0;i<M;i++) x[i] = dx*i;

	for(i=0;i<M;i++) 
	for(k=0;k<P;k++)
	{
		/* in ceriotti notation : Hceriotti = Htukerman*P */
		/* in ceriotti notation P not sqrt(P) */
		xk[i][k] = P*sin(k*M_PI/P);
		//xk[i][k] = sqrt(P)*sin(k*M_PI/P);
		xk[i][k] = xk[i][k]*xk[i][k];
		xk[i][k] = sqrt(fabs(x[i]*x[i]+xk[i][k]));
	}

	gold[0] = 1.0;
	for(i=1;i<M;i++) gold[i] = h(x[i]/P);
	for(i=0;i<M;i++) g[i] = gold[i];

	hk[0] = 1.0;
	for(i=1;i<M;i++) hk[i] = h(x[i]);

	iter = 0;
	normold = 1;
	do{
		for(i=0;i<M;i++)
		{
			s = 0;
			for(k=1;k<P;k++)
			{
				xx = x[i]/xk[i][k];
				s += interpol(M, gold, dx,xk[i][k])*xx*xx;
			}
			//printf("s = %f\n",s);
			g[i] = alpha*(hk[i]-s)+(1-alpha)*gold[i]; 
		}
		printf("g1 = %f\n",g[1]);
		norm = 0;
		//for(i=0;i<M/2;i++) norm += (g[i]-gold[i])*(g[i]-gold[i]);
		//norm = sqrt(norm/M*2);
		for(i=0;i<M;i++) norm += (g[i]-gold[i])*(g[i]-gold[i]);
		//norm = sqrt(norm/M);
		norm = sqrt(norm);
		printf("norm = %0.12f\n",norm);
		fflush(stdout);
		if(norm>normold) alpha/=1.1;
		else for(i=0;i<M;i++) gold[i] = g[i];
		if(norm<precision) break;
		normold = norm;
		iter++;
	}while(iter<iterMax);
	if(iter==iterMax)
	{
		
		fprintf(stdout,"Error : divergence in g function of the QTBThermostat.c\n");
		exit(1);
	}
	free(g);
	free(x);
	free(hk);
	for(i=0;i<M;i++) free(xk[i]);
	free(xk);

	return gold;
}
/*********************************************************************************/
/*
static double* compute_fPTable(int P, double dx, int M)
{
	static double* gold  = NULL;
	static double* g  = NULL;
	static double* x  = NULL;
	static double* hk  = NULL;
	double s;
	int k;
	double alpha = 1.0/P;
	double precision = 1e-8;
	int iterMax = 10000;
	double norm;
	int iter = 0;
	double xx;
	double** xk;
	int i;
	double normold;

	gold = malloc(M*sizeof(double));
	g = malloc(M*sizeof(double));
	x = malloc(M*sizeof(double));
	hk = malloc(M*sizeof(double));
	xk = malloc(M*sizeof(double*));
	for(i=0;i<M;i++) xk[i] = malloc(P*sizeof(double));

	for(i=0;i<M;i++) x[i] = dx*i;

	for(i=0;i<M;i++) 
	for(k=0;k<P;k++)
	{
		// in ceriotti notation : Hceriotti = Htukerman*P 
		// in ceriotti notation P not sqrt(P) 
		xk[i][k] = P*sin(k*M_PI/P);
		xk[i][k] = xk[i][k]*xk[i][k];
		xk[i][k] = sqrt(x[i]*x[i]+xk[i][k]);
	}

	gold[0] = 1.0;
	for(i=1;i<M;i++) gold[i] = sqrt(h(x[i]/P));
	for(i=0;i<M;i++) g[i] = gold[i];

	hk[0] = 1.0;
	for(i=1;i<M;i++) hk[i] = sqrt(h(x[i]));

	iter = 0;
	normold = 1;
	do{
		for(i=0;i<M;i++)
		{
			s = 0;
			for(k=1;k<P;k++)
			{
				xx = x[i]/xk[i][k];
				s += interpol(M, gold, dx,xk[i][k])*xx;
			}
			//printf("s = %f\n",s);
			g[i] = alpha*(hk[i]-s)+(1-alpha)*gold[i]; 
		}
		printf("g1 = %f\n",g[1]);
		norm = 0;
		//for(i=0;i<M/2;i++) norm += (g[i]-gold[i])*(g[i]-gold[i]);
		//norm = sqrt(norm/M*2);
		for(i=0;i<M;i++) norm += (g[i]-gold[i])*(g[i]-gold[i]);
		norm = sqrt(norm/M);
		printf("norm = %0.12f\n",norm);
		fflush(stdout);
		if(norm>normold) alpha/=1.1;
		else for(i=0;i<M;i++) gold[i] = g[i];
		if(norm<precision) break;
		normold = norm;
		iter++;
	}while(iter<iterMax);
	if(iter==iterMax)
	{
		
		fprintf(stdout,"Error : divergence in g function of the QTBThermostat.c\n");
		exit(1);
	}
	free(g);
	free(x);
	free(hk);
	for(i=0;i<M;i++) free(xk[i]);
	free(xk);

	return gold;
}
*/
/*********************************************************************************/
/* Theta is a force */
static void removeTranslationTheta(Paths* paths)
{
	double atot[3] = {0,0,0};
	int i;
	int iAtom;
	int j;
	double totMass = 0.0;
	double** theta = paths->theta;

	if(!theta) return;
	for ( i = 0; i < paths->nBeads; i++)
	{
		for ( iAtom = 0; iAtom < paths->molecules[i]->nAtoms; iAtom++)
		{
			double mass = paths->Mprim[i][iAtom];
			totMass += mass;
			for ( j = 0; j < 3; j++)
			{
				atot[j] += theta[i][3*iAtom+j];
			}
		}
	}

	for ( j = 0; j < 3; j++) atot[j] /= totMass;


	for ( i = 0; i < paths->nBeads; i++)
		for ( iAtom = 0; iAtom < paths->molecules[i]->nAtoms; iAtom++)
			for ( j = 0; j < 3; j++)
				theta[i][3*iAtom+j] -= paths->Mprim[i][iAtom]*atot[j];
}
/*********************************************************************************/
/* Theta is a force */
static void removeRotationTheta(Paths* paths)
{
	double ptot[3] = {0,0,0};
	double cm[3] = {0,0,0};
	double L[3] = {0,0,0};
	int i;
	int iAtom;
	int j;
	int k;
	double mass = 1.0;
	double totMass = 0.0;
	double cdel[3];
	double vAng[3]={0,0,0};
	double tensor[3][3];
	double invTensor[3][3];
        double xx, xy,xz,yy,yz,zz;
	//boolean linear = FALSE;
	double** theta = paths->theta;
	double*** U = paths->U;
	double n = 0;
	/* find the center of mass coordinates  and total velocity*/
	if(!U)
	{
		paths->molecules[0]->klass->removeRotationForceCluster(paths->molecules,paths->nBeads,paths->theta);
		return;
	}

	for ( i = 0; i < paths->nBeads; i++)
	{
		for ( iAtom = 0; iAtom <  paths->molecules[i]->nAtoms; iAtom++)
		{
			mass = paths->Mprim[i][iAtom];
			totMass += mass;
			n++;
			for ( j = 0; j < 3; j++)
				cm[j] += mass*U[j][i][iAtom];
			for ( j = 0; j < 3; j++)
				ptot[j] += theta[i][3*iAtom+j];
		}
	}


	for ( j = 0; j < 3; j++) cm[j] /= totMass;

	/*   compute the angular momentum  */
	for ( i = 0; i < paths->nBeads; i++)
	{
		for ( iAtom = 0; iAtom <  paths->molecules[i]->nAtoms; iAtom++)
		{
			mass = paths->Mprim[i][iAtom];
			for ( j = 0; j < 3; j++)
			L[j] += (
				U[(j+1)%3][i][iAtom]*theta[i][3*iAtom+(j+2)%3]
			      - U[(j+2)%3][i][iAtom]*theta[i][3*iAtom+(j+1)%3]
			      );
		}
	}
	for ( j = 0; j < 3; j++)
		L[j] -= (
			cm[(j+1)%3]*ptot[(j+2)%3]
		      - cm[(j+2)%3]*ptot[(j+1)%3]
			      );

	/* calculate and invert the inertia tensor */
	for ( k = 0; k < 3; k++)
	for ( j = 0; j < 3; j++)
		tensor[k][j] = 0;
	xx = 0;
	yy = 0;
	zz = 0;
	xy = 0;
	xz = 0;
	yz = 0;
	for ( i = 0; i < paths->nBeads; i++)
	{
		for ( iAtom = 0; iAtom <  paths->molecules[i]->nAtoms; iAtom++)
		{
			mass = paths->Mprim[i][iAtom];
			for ( j = 0; j < 3; j++)
				cdel[j] = U[j][i][iAtom]-cm[j];
			xx +=  cdel[0]*cdel[0]*mass;
			xy +=  cdel[0]*cdel[1]*mass;
			xz +=  cdel[0]*cdel[2]*mass;
			yy +=  cdel[1]*cdel[1]*mass;
			yz +=  cdel[1]*cdel[2]*mass;
			zz +=  cdel[2]*cdel[2]*mass;
		}
	}
	tensor[0][0] = yy+zz;
	tensor[1][0] = -xy;
	tensor[2][0] = -xz;
	tensor[0][1] = -xy;
	tensor[1][1] = xx+zz;
	tensor[2][1] = -yz;
	tensor[0][2] = -xz;
	tensor[1][2] = -yz;
	tensor[2][2] = xx+yy;
	if(InverseTensor(tensor,invTensor))
	{
		for ( j = 0; j < 3; j++)
		{
			vAng[j] = 0;
			for ( k = 0; k < 3; k++)
				vAng[j] += invTensor[j][k]*L[k];
		}
	}
	else
	if(paths->molecules[0]->nAtoms>1)
	{
		double U0[3];
		double U1[3];
		for ( j = 0; j < 3; j++)U0[j] = U[j][0][0];
		for ( j = 0; j < 3; j++)U1[j] = U[j][0][1];
		//printf("!!!!!!!!!!!I cannot invert the rotational Tensor : linear molecule!\n");
		computeAngularVelocitiesForALinearMolecule(U0, U1, tensor, L, vAng);
		//printf("Angular velocity before rotation = %f %f %f\n",vAng[0], vAng[1], vAng[2]);
		//linear = TRUE;
	}
	/*  eliminate any rotation about the system center of mass */
	for ( i = 0; i < paths->nBeads; i++)
	{
		for ( iAtom = 0; iAtom <  paths->molecules[i]->nAtoms; iAtom++)
		{
			for ( j = 0; j < 3; j++)
				cdel[j] = U[j][i][iAtom]-cm[j];
			for ( j = 0; j < 3; j++)
				theta[i][3*iAtom+j] += 
				(cdel[(j+1)%3]*vAng[(j+2)%3]-
				cdel[(j+2)%3]*vAng[(j+1)%3])
				*paths->Mprim[i][iAtom]
				;
		}
	}
/* Check */
/*
	for ( j = 0; j < 3; j++) L[j] = 0;
	for ( i = 0; i < paths->nBeads; i++)
	{
		for ( iAtom = 0; iAtom <  paths->molecules[i]->nAtoms; iAtom++)
		{
			mass = paths->Mprim[i][iAtom];
			for ( j = 0; j < 3; j++)
			L[j] += (
				U[(j+1)%3][i][iAtom]*theta[i][3*iAtom+(j+2)%3]
			      - U[(j+2)%3][i][iAtom]*theta[i][3*iAtom+(j+1)%3]
			      );
		}
	}
	for ( j = 0; j < 3; j++)
		L[j] -= (
			cm[(j+1)%3]*ptot[(j+2)%3]
		      - cm[(j+2)%3]*ptot[(j+1)%3]
			      );
	if(linear &&paths->molecules[0]->nAtoms>1)
	{
		double U0[3];
		double U1[3];
		for ( j = 0; j < 3; j++)U0[j] = U[j][0][0];
		for ( j = 0; j < 3; j++)U1[j] = U[j][0][1];
		computeAngularVelocitiesForALinearMolecule(U0, U1, tensor, L, vAng);
		printf("Linear molecule Angular velocity = %f %f %f\n",vAng[0], vAng[1], vAng[2]);
	}
	else
	{
		for ( j = 0; j < 3; j++)
		{
			vAng[j] = 0;
			for ( k = 0; k < 3; k++)
				vAng[j] += invTensor[j][k]*L[k];
		}
		printf("Angular velocity = %f %f %f\n",vAng[0], vAng[1], vAng[2]);
	}
*/
}
/*********************************************************************************/
static void removeTranslationAndRotationTheta(Paths* paths)
{
	if(paths->nBeads<1) return;
	removeTranslationTheta(paths);
	removeRotationTheta(paths);
}
/*********************************************************************************/
/* Theta is a force */
/*
static void removeTranslationThetaOneBead(Paths* paths, int i)
{
	double atot[3] = {0,0,0};
	int iAtom;
	int j;
	double totMass = 0.0;
	double** theta = paths->theta;

	if(!theta) return;
	{
		for ( iAtom = 0; iAtom < paths->molecules[i]->nAtoms; iAtom++)
		{
			totMass += paths->Mprim[i][iAtom];
			for ( j = 0; j < 3; j++)
			{
				atot[j] += theta[i][3*iAtom+j];
			}
		}
	}

	for ( j = 0; j < 3; j++) atot[j] /= totMass;


		for ( iAtom = 0; iAtom < paths->molecules[i]->nAtoms; iAtom++)
			for ( j = 0; j < 3; j++)
				theta[i][3*iAtom+j] -= paths->Mprim[i][iAtom]*atot[j];
}
*/
/*********************************************************************************/
/* Theta is a force */
/*
static void removeRotationThetaOneBead(Paths* paths, int i)
{
	double ptot[3] = {0,0,0};
	double cm[3] = {0,0,0};
	double L[3] = {0,0,0};
	int iAtom;
	int j;
	int k;
	double mass = 1.0;
	double totMass = 0.0;
	double cdel[3];
	double vAng[3]={0,0,0};
	double tensor[3][3];
	double invTensor[3][3];
        double xx, xy,xz,yy,yz,zz;
	//boolean linear = FALSE;
	double** theta = paths->theta;
	double*** U = paths->U;
	// find the center of mass coordinates  and total velocity
	if(!U)
	{
		paths->molecules[i]->klass->removeRotationForce(paths->molecules[i],paths->theta[i]);
		return;
	}

	{
		for ( iAtom = 0; iAtom <  paths->molecules[i]->nAtoms; iAtom++)
		{
			mass = paths->Mprim[i][iAtom];
			totMass += mass;
			for ( j = 0; j < 3; j++)
				cm[j] += mass*U[j][i][iAtom];
			for ( j = 0; j < 3; j++)
				ptot[j] += theta[i][3*iAtom+j];
		}
	}


	for ( j = 0; j < 3; j++) cm[j] /= totMass;

	//   compute the angular momentum 
	{
		for ( iAtom = 0; iAtom <  paths->molecules[i]->nAtoms; iAtom++)
		{
			mass = paths->Mprim[i][iAtom];
			for ( j = 0; j < 3; j++)
			L[j] += (
				U[(j+1)%3][i][iAtom]*theta[i][3*iAtom+(j+2)%3]
			      - U[(j+2)%3][i][iAtom]*theta[i][3*iAtom+(j+1)%3]
			      );
		}
	}
	for ( j = 0; j < 3; j++)
		L[j] -= (
			cm[(j+1)%3]*ptot[(j+2)%3]
		      - cm[(j+2)%3]*ptot[(j+1)%3]
			      );

	// calculate and invert the inertia tensor
	for ( k = 0; k < 3; k++)
	for ( j = 0; j < 3; j++)
		tensor[k][j] = 0;
	xx = 0;
	yy = 0;
	zz = 0;
	xy = 0;
	xz = 0;
	yz = 0;
	{
		for ( iAtom = 0; iAtom <  paths->molecules[i]->nAtoms; iAtom++)
		{
			mass = paths->Mprim[i][iAtom];
			for ( j = 0; j < 3; j++)
				cdel[j] = U[j][i][iAtom]-cm[j];
			xx +=  cdel[0]*cdel[0]*mass;
			xy +=  cdel[0]*cdel[1]*mass;
			xz +=  cdel[0]*cdel[2]*mass;
			yy +=  cdel[1]*cdel[1]*mass;
			yz +=  cdel[1]*cdel[2]*mass;
			zz +=  cdel[2]*cdel[2]*mass;
		}
	}
	tensor[0][0] = yy+zz;
	tensor[1][0] = -xy;
	tensor[2][0] = -xz;
	tensor[0][1] = -xy;
	tensor[1][1] = xx+zz;
	tensor[2][1] = -yz;
	tensor[0][2] = -xz;
	tensor[1][2] = -yz;
	tensor[2][2] = xx+yy;
	if(InverseTensor(tensor,invTensor))
	{
		for ( j = 0; j < 3; j++)
		{
			vAng[j] = 0;
			for ( k = 0; k < 3; k++)
				vAng[j] += invTensor[j][k]*L[k];
		}
	}
	else
	if(paths->molecules[0]->nAtoms>1)
	{
		double U0[3];
		double U1[3];
		for ( j = 0; j < 3; j++)U0[j] = U[j][0][0];
		for ( j = 0; j < 3; j++)U1[j] = U[j][0][1];
		printf("!!!!!!!!!!!I cannot invert the rotational Tensor : linear molecule!\n");
		computeAngularVelocitiesForALinearMolecule(U0, U1, tensor, L, vAng);
		//printf("Angular velocityibefore rotation = %f %f %f\n",vAng[0], vAng[1], vAng[2]);
		//linear = TRUE;
	}
	//  eliminate any rotation about the system center of mass 
	{
		for ( iAtom = 0; iAtom <  paths->molecules[i]->nAtoms; iAtom++)
		{
			for ( j = 0; j < 3; j++)
				cdel[j] = U[j][i][iAtom]-cm[j];
			for ( j = 0; j < 3; j++)
				theta[i][3*iAtom+j] += 
				(cdel[(j+1)%3]*vAng[(j+2)%3]-
				cdel[(j+2)%3]*vAng[(j+1)%3])
				*paths->Mprim[i][iAtom]
				;
		}
	}
}
*/
/*********************************************************************************/
/*
static void removeTranslationAndRotationThetaOneBead(Paths* paths, int i)
{
	if(paths->nBeads<1) return;
	removeTranslationThetaOneBead(paths,i);
	removeRotationThetaOneBead(paths,i);
}
*/
File: ./cchemilib/src/PathIntegral/NormalModeTrans.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include "Paths.h"
#include "../Utils/Constants.h"
#include "../Utils/QL.h"
#include "../Utils/Utils.h"

/* Refs :
Perez et al : THE JOURNAL OF CHEMICAL PHYSICS 130, 184105 2009
*/

static void calculateForcesNM(Paths* paths);
static void RtoUNM(Paths* paths);
static void UtoRNM(Paths* paths);
static void applyOneStepNormalMode(Paths* paths);
static void sortEigen(int n, double* lambda, double** vectors);
static void momentToCartezianNM(Paths* paths);
static void buildMatrixNormalModeTrans(Paths* paths);
static void initMassesPrim(Paths* paths);
static void initMoments(Paths* paths);
static double getEKinVelocities(Paths* paths);
/*********************************************************************************************************************/
void initNormalModeTrans(Paths* paths)
{
	buildMatrixNormalModeTrans(paths);
	initMassesPrim(paths);
  	/* Positions U */
	paths->U = newCubeDouble(3,paths->nBeads,paths->molecules[0]->nAtoms);
  	RtoUNM(paths);
	/* Moment P*/
	initMoments(paths);
	paths->klass->calculateForces = calculateForcesNM;
	paths->klass->applyOneStep = applyOneStepNormalMode;
	paths->klass->momentToCartezian = momentToCartezianNM;
	paths->klass->getEKinVelocities = getEKinVelocities;
	paths->klass->calculateForces(paths);
}
/*********************************************************************************************************************/
static void initMassesPrim(Paths* paths)
{
	int i,iAtom;
	int nBeads = paths->nBeads;
	int nAtoms = paths->molecules[0]->nAtoms;

	paths->Mprim = newMatrixDouble(nBeads,nAtoms);

	i = 0;
	for(iAtom = 0;iAtom<paths->molecules[i]->nAtoms; iAtom++) 
		paths->Mprim[i][iAtom]  = paths->molecules[i]->atoms[iAtom].mass;

	for(i = 1;i<paths->nBeads; i++) 
	for(iAtom = 0;iAtom<paths->molecules[i]->nAtoms; iAtom++) 
		paths->Mprim[i][iAtom]  = paths->M[i][iAtom];
		//paths->Mprim[i][iAtom]  = paths->molecules[i]->atoms[iAtom].mass;
}
/*****************************************************************************************************************************/
static void applyOneStepNormalMode(Paths* paths)
{
  
	int iAtom,i,k;
	double*** P = paths->P;
	double*** U = paths->U;

	paths->klass->applyThermostat(paths);// must be apply 2 times, time step = dt/2 in the thermostats

	for(i = 0;i<paths->nBeads; i++) 
	for(iAtom = 0;iAtom<paths->molecules[i]->nAtoms; iAtom++) 
	for(k = 0;k<3; k++) 
	{
		P[k][i][iAtom] += 0.5*paths->F[k][i][iAtom]*paths->dt;
		U[k][i][iAtom] +=  P[k][i][iAtom]*paths->dt/paths->Mprim[i][iAtom];
	}

	UtoRNM(paths);
	paths->klass->calculateForces(paths);
	paths->klass->applyThermostat(paths);

	for(i = 0;i<paths->nBeads; i++) 
	for(iAtom = 0;iAtom<paths->molecules[i]->nAtoms; iAtom++) 
	for(k = 0;k<3; k++) 
	{
		P[k][i][iAtom] += 0.5*paths->F[k][i][iAtom]*paths->dt;
	}
  
	paths->klass->removeTranslationAndRotation(paths);
	paths->klass->computeEnergies(paths);
}

/**************************************************************************************************************************/
static void UtoRNM(Paths* paths)
{
	int i,j,k,iAtom;
	Molecule** mols = paths->molecules;
	int nBeads = paths->nBeads;
	int nAtoms = paths->molecules[0]->nAtoms;
	for (iAtom = 0; iAtom < nAtoms; iAtom++)
	{
    		for (i = 0; i<nBeads; i++)
		{
			for(k = 0;k<3; k++) mols[i]->atoms[iAtom].coordinates[k] = 0.0;
    			for (j = 0; j<nBeads; j++)
			for(k = 0;k<3; k++)
				mols[i]->atoms[iAtom].coordinates[k] += paths->O[i][j]*paths->U[k][j][iAtom];

		}
	}
}
/**************************************************************************************************************************/
static void RtoUNM(Paths* paths)
{
	int i,j,k,iAtom;
	Molecule** mols = paths->molecules;
	int nAtoms = paths->molecules[0]->nAtoms;
	for (iAtom = 0; iAtom < nAtoms; iAtom++)
	{
    		for (i = 0; i<paths->nBeads; i++)
		{
			for(k = 0;k<3; k++) paths->U[k][i][iAtom] = 0.0;

    			for (j = 0; j<paths->nBeads; j++)
			for(k = 0;k<3; k++)
				paths->U[k][i][iAtom] += paths->O[j][i]*mols[j]->atoms[iAtom].coordinates[k] ;

			for(k = 0;k<3; k++) paths->U[k][i][iAtom] *= paths->oneOvernBeads;
		}
	}
/*
	// print O 
	printf("O = \n");
	for(i = 0;i<paths->nBeads; i++) 
	{
	for(j = 0;j<paths->nBeads; j++) 
	{
      		printf("%f ",paths->O[i][j]);
	}
	printf("\n");
	}
	printf("U = \n");
	printCubeDouble( paths->U, 3, paths->nBeads, nAtoms);
*/
}

/*********************************************************************************************************************/
static void calculateForcesNM(Paths* paths)
{
	int i,j,k,iAtom;
	int nAtoms = paths->molecules[0]->nAtoms;
	Molecule** mols = paths->molecules;

	paths->klass->calculateGradient(paths);

	for (iAtom = 0; iAtom < nAtoms; iAtom++)
	{
    		for (i = 0; i <paths->nBeads; i++)
		{
			for(k=0;k<3;k++) paths->F[k][i][iAtom] = 0;

    			for (j = 0; j <paths->nBeads; j++)
			for(k=0;k<3;k++) paths->F[k][i][iAtom] -= mols[j]->atoms[iAtom].gradient[k]*paths->O[j][i];

			for(k=0;k<3;k++) paths->F[k][i][iAtom] *= paths->oneOvernBeads;

			for(k=0;k<3;k++) paths->F[k][i][iAtom] -= paths->M[i][iAtom]*paths->wp2*paths->U[k][i][iAtom];
		}
	}
}
/*****************************************************************************/
static void sortEigen(int n, double* lambda, double** vectors)
{
	int i;
	int j;
	int k;
	double dum;
	if(n<1 || !lambda || !vectors) return;
	for(i=0;i<n;i++)
	{
		k = i;
		for(j=i+1;j<n;j++)
			if(lambda[j]<lambda[k]) k = j;
		if(k==i) continue;
		/* swap i and k vectors */
		dum = lambda[i];
		lambda[i] = lambda[k];
		lambda[k] = dum;
		for(j=0;j<n;j++)
		{
			dum =  vectors[j][i];
			vectors[j][i] = vectors[j][k];
			vectors[j][k] = dum;
		}
	}
}
/**************************************************************************************************************************/
static void momentToCartezianNM(Paths* paths)
{
	int i,j,k,iAtom;
	Molecule** mols = paths->molecules;
	int nBeads = paths->nBeads;
	int nAtoms = paths->molecules[0]->nAtoms;
	double*** P = paths->P;

	for (iAtom = 0; iAtom < nAtoms; iAtom++)
	{
    		for (i = 0; i<nBeads; i++)
		{
			for(k = 0;k<3; k++) mols[i]->atoms[iAtom].velocity[k] = 0.0;
    			for (j = 0; j<nBeads; j++)
			for(k = 0;k<3; k++)
				mols[i]->atoms[iAtom].velocity[k] += paths->O[i][j]*P[k][j][iAtom];
		}
	}

    	for (i = 0; i<paths->nBeads; i++)
	for (iAtom = 0; iAtom < nAtoms; iAtom++)
		for(k = 0;k<3; k++) mols[i]->atoms[iAtom].velocity[k] /= paths->Mprim[i][iAtom];
}
/**************************************************************************************************************************/
static void initMoments(Paths* paths)
{
	int i,j,k,iAtom;
	//Molecule** mols = paths->molecules;
	int nBeads = paths->nBeads;
	int nAtoms = paths->molecules[0]->nAtoms;

	double*** Q = newCubeDouble(3,paths->nBeads,nAtoms);
	paths->P = newCubeDouble(3,paths->nBeads,nAtoms);
	
	//printf("begin carttonm\n");
	for(k=0;k<3;k++)
	{
		for(i = 0;i<paths->nBeads; i++) 
		for(iAtom = 0;iAtom<paths->molecules[i]->nAtoms; iAtom++) 
			Q[k][i][iAtom]  = paths->molecules[i]->atoms[iAtom].velocity[k]*paths->Mprim[i][iAtom];
	}
	//printf("end carttonm 1\n");
	for(i = 0; i<nBeads ;  i++) 
	{
		for(iAtom = 0;iAtom<paths->molecules[i]->nAtoms; iAtom++) 
		for(k=0;k<3;k++) paths->P[k][i][iAtom]=  0.0;

		for(j = 0; j<nBeads ;  j++) 
		for(iAtom = 0;iAtom<paths->molecules[i]->nAtoms; iAtom++) 
		{
			for(k=0;k<3;k++)
			{
				 paths->P[k][i][iAtom] +=
      				paths->O[i][j]* paths->molecules[i]->atoms[iAtom].velocity[k]*paths->Mprim[i][iAtom];
			}
		}
		for(iAtom = 0;iAtom<paths->molecules[i]->nAtoms; iAtom++) 
		for(k=0;k<3;k++)
			paths->P[k][i][iAtom] *= paths->oneOvernBeads;
/*
		for(iAtom = 0;iAtom<paths->molecules[i]->nAtoms; iAtom++) 
		for(k=0;k<3;k++)
				paths->P[k][i][iAtom] =  0.0;
*/
	}
	freeCubeDouble(&Q,3, paths->nBeads);
}
/*********************************************************************************************************************/
static void buildMatrixNormalModeTrans(Paths* paths)
{
	int i,j,k,iAtom;
	int nAtoms = paths->molecules[0]->nAtoms;
	double* A;
	double* lambda;
	int nBeads = paths->nBeads;
	int n2Beads = paths->nBeads*(paths->nBeads+1)/2;
	double sqrtnBeads = sqrt(1.0*nBeads);

	A = newVectorDouble(n2Beads);
	k = 0;
	for(i = 0;i<nBeads; i++) 
	for(j = 0;j<=i; j++) A[k++] = 0;

	k = 0;
	for(i = 0;i<nBeads; i++) 
	for(j = 0;j<=i; j++) 
	{
      		if (i==j) A[k] = 2;
      		else if (i==j+1) A[k] = -1;
		k++;
	}
	k = n2Beads-nBeads;
	if(k!=0) A[k] = -1; // don't change it if nBeads = 1

	// print A 
	printf("A matrix for normal mode transformation\n");
	k = 0;
	for(i = 0;i<nBeads; i++) 
	{
	for(j = 0;j<=i; j++) 
	{
      		printf("%f ",A[k] );
		k++;
	}
	printf("\n");
	}
	lambda = newVectorDouble(nBeads);
	paths->O = newMatrixDouble(nBeads,nBeads);
	eigenQL(nBeads, A, lambda, paths->O);
	sortEigen(nBeads, lambda, paths->O);
	for(i = 0;i<nBeads; i++) lambda[i] *=nBeads;
	k = 0;
	printf("lambda\n");
	for(i = 0;i<nBeads; i++) 
      		printf("%f ",lambda[i] );
	printf("\n");
	printf("End eigenQL\n");
	freeVectorDouble(&A);
	if(paths->O[0][0]<0) sqrtnBeads = -sqrtnBeads;
	for(i = 0;i<nBeads; i++) 
	for(j = 0;j<nBeads; j++) 
		paths->O[i][j] *= sqrtnBeads;

	// print O 
	printf("Transormation matrix in normal mode\n");
	for(i = 0;i<nBeads; i++) 
	{
	for(j = 0;j<nBeads; j++) 
	{
      		printf("%f ",paths->O[i][j]);
	}
	printf("\n");
	}
	paths->M  = newMatrixDouble(nBeads,nAtoms);
	for(i = 0;i<paths->nBeads; i++) 
	for(iAtom = 0;iAtom<paths->molecules[i]->nAtoms; iAtom++) 
		paths->M[i][iAtom]  = fabs(lambda[i]*paths->molecules[i]->atoms[iAtom].mass);
	
	if(paths->nBeads==1)
		for(iAtom = 0;iAtom<paths->molecules[0]->nAtoms; iAtom++) paths->M[0][iAtom]  = 0;
	else
	if(paths->nBeads==2)
	{
		for(iAtom = 0;iAtom<paths->molecules[0]->nAtoms; iAtom++) paths->M[0][iAtom]  = 0;
		for(iAtom = 0;iAtom<paths->molecules[1]->nAtoms; iAtom++) paths->M[1][iAtom]  = 4*2;
		/*
		paths->O[0][0] = 1;
		paths->O[1][0] = 1;
		paths->O[0][1] = 1;
		paths->O[1][1] = -1;
		*/
	}

	freeVectorDouble(&lambda);
}
/********************************************************************************/
/* Kinetic Velocities Energy Estimator*/
static double getEKinVelocities(Paths* paths)
{
	double ekin = 0.0;
	int iAtom,i,j;
	//double RC[3];
	double***P = paths->P;
	double***U = paths->U;
	Molecule** mols = paths->molecules;
	int k;

	double invmass;
	ekin = 0;
	for(i = 0;i<paths->nBeads; i++) 
	for(iAtom = 0;iAtom< mols[i]->nAtoms; iAtom++) 
	{
		invmass =  1.0/paths->Mprim[i][iAtom];
		for ( j = 0; j < 3; j++)
			ekin += P[j][i][iAtom]*P[j][i][iAtom]*invmass;
	}

	for(i = 0;i<paths->nBeads; i++) 
	for(iAtom = 0;iAtom<paths->molecules[i]->nAtoms; iAtom++) 
	{
		double dot = 0;
		for(k = 0;k<3; k++) dot += U[k][i][iAtom]*U[k][i][iAtom];
      		ekin -=  paths->M[i][iAtom]*paths->wp2 * dot;
	}
  	ekin *= 0.5;
  	return ekin;
}
File: ./cchemilib/src/PathIntegral/PIMDDlg.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* QuantumMechanicsDlg.c */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>

#ifdef ENABLE_MPI
#include <mpi.h>
#endif

#include "../Utils/Utils.h"
#include "../Utils/Utils.h"
#include "../Utils/AtomsProp.h"
#include "../Utils/Constants.h"
#include "../Utils/Types.h"
#include "../Molecule/Molecule.h"
#include "../QuantumMechanics/QuantumMechanics.h"
#include "../MolecularMechanics/MolecularMechanics.h"
#include "../EmpriricalCorrections/HydrogenBondCorrection.h"
#include "../EmpriricalCorrections/DispersionCorrection.h"
#include "../PathIntegral/Paths.h"

/*****************************************************************************/
void setPIMDOptions(FILE* file, int* updateFrequency, 
double* heatTime, double*equiTime, double* runTime, double* coolTime, 
double* heatTemp,  double*equiTemp, double*runTemp, double*coolTemp, 
double* stepSize, PIMDThermostatType* thermostat, PIMDTransformationType* transformation, double* friction, double* omegaMax, int* Nf, int* nBeads, int* nNH, int* nNHSteps, int* nSY)
{
	int itmp;
	*updateFrequency = 5;
	readOneInt(file,"updateFrequency",updateFrequency);
	if(*updateFrequency<0) *updateFrequency = 0;

	*heatTime = 1;
	readOneReal(file,"heatTime",heatTime);
	*equiTime = 2;
	readOneReal(file,"equiTime",equiTime);
	*runTime = 10;
	readOneReal(file,"runTime",runTime);
	*coolTime = 10;
	readOneReal(file,"coolTime",coolTime);
	if(*heatTime<0) *heatTime = 1;
	if(*equiTime<0) *equiTime = 1;
	if(*runTime<0) *runTime = 1;
	if(*coolTime<0) *coolTime = 1;

	*heatTemp = 0;
	readOneReal(file,"heatTemp",heatTemp);
	*runTemp = 300;
	readOneReal(file,"runTemp",runTemp);
	*equiTemp = *runTemp;
	*coolTemp = *heatTemp;
	if(*heatTemp<0) *heatTemp = 0;
	if(*equiTemp<0) *runTemp = 300;
	if(*runTemp<0) *runTemp = 300;
	if(*coolTemp<0) *coolTemp = 0;

	*stepSize = 0.5;
	readOneReal(file,"stepSize",stepSize);
	if(*stepSize<0) *stepSize = 1.0;
	if(*stepSize>5) *stepSize = 5.0;

	*thermostat = PIMDTHERMOSTATNONE;
	if(readOneInt(file,"PIMDThermostat",&itmp))*thermostat = itmp;

	*transformation = PIMDTRANSFORMATIONNONE;
	if(readOneInt(file,"PIMDTransformation",&itmp))*transformation = itmp;


	*friction=-1;
	readOneReal(file,"friction",friction);

	*nBeads=4;
	readOneInt(file,"nBeads",nBeads);

	*nNH=1;
	readOneInt(file,"lengthOfNHChains",nNH);

	*nNHSteps=5;
	readOneInt(file,"nNHSteps",nNHSteps);

	*nSY=3;
	readOneInt(file,"nSuzukiYoshida",nSY);

	*omegaMax=4000;
	readOneReal(file,"omegaMax",omegaMax);
	*Nf=50;
	readOneInt(file,"Nf",Nf);
}
/****************************************************************************************************************/
void pathIntegralMDDlg(char* inputFileName)
{
	QuantumMechanicsModel qmModel; 
	ForceField forceField; 
	QuantumMechanicsModel* pqmModel = NULL; 
	ForceField* pforceField = NULL; 
	int updateFrequency = 1;
	double heatTime;
	double equiTime;
	double runTime;
	double coolTime; 
	double heatTemp; 
	double equiTemp; 
	double runTemp; 
	double coolTemp; 
	double stepSize;
	char* fileNameTraj = NULL;
	char* fileNameProp = NULL;
	double friction=-1;
	PIMDThermostatType thermostat;
	PIMDTransformationType transformation;
	char* dirName = NULL;
	Constraints constraints = NOCONSTRAINTS;
	Molecule mol = *(readMolecule(inputFileName,TRUE));
	char* mopacCommand = strdup("/opt/mopac/MOPAC2009");
	char* fireflyCommand = strdup("firefly");
	char* orcaCommand=strdup("orca");
	char* gaussianCommand = strdup("g09");
	char* genericCommand = strdup("runGeneric");
	FILE* file = fopen(inputFileName,"rb");
	char* model = NULL;
	char* QMKeys = NULL;
	int cnt;
	int nNH;
	int nNHSteps;
	int nSY;
	int nBeads;
	double omegaMax;
	int Nf;
	
	setPIMDOptions(file, &updateFrequency, 
		&heatTime, &equiTime, &runTime, &coolTime,
		&heatTemp, &runTemp, &equiTemp, &coolTemp, &stepSize, 
		&thermostat, &transformation, &friction, &omegaMax, &Nf, &nBeads, &nNH, &nNHSteps, &nSY);

	if(!readOneString(file,"Model",&model)) model = strdup("MM");
	if(!readOneString(file,"QMKeys",&QMKeys)) 
	{
		if(!strcmp(model,"MOPAC")) QMKeys = strdup("PM6-DH2");
		else QMKeys = strdup("AM1");
	}
	uppercase(model);
	readOneString(file,"mopacCommand",&mopacCommand);
	readOneString(file,"fireflyCommand",&fireflyCommand);
	readOneString(file,"orcaCommand",&orcaCommand);
	readOneString(file,"gaussianCommand",&gaussianCommand);
	readOneString(file,"genericCommand",&genericCommand);

	if(readOneInt(file,"Constraints",&cnt)) constraints = cnt;


	{
		char* suff = getSuffixNameFile(inputFileName);
		dirName = strdup(getenv("PWD"));
		fileNameTraj = strdup_printf("%s%s",suff, "Traj.gab");
		fileNameProp = strdup_printf("%s%s",suff, "Prop.txt");
		free(suff);
	}

	if(!strcmp(model,"MM"))
	{
		ForceFieldOptions forceFieldOptions;
		setForceFieldOptions(file, &forceFieldOptions);
		if(forceFieldOptions.type==AMBER) forceField = createAmberModel(&mol,forceFieldOptions, stdout);
		else if(forceFieldOptions.type==PAIRWISE) forceField = createPairWiseModel(&mol,forceFieldOptions, stdout);
		pforceField = &forceField;	
	}
	else 
	{
		if(!strcmp(model,"MOPAC")) qmModel = createMopacModel(&mol, QMKeys, dirName, mopacCommand, constraints,stdout);
		else if(!strcmp(model,"FIREFLY")) qmModel = createFireFlyModel(&mol, QMKeys,dirName, fireflyCommand, constraints,stdout);
		else if(!strcmp(model,"ORCA")) qmModel = createOrcaModel(&mol, QMKeys, dirName, orcaCommand, constraints, stdout);
		else if(!strcmp(model,"GAUSSIAN")) qmModel = createGaussianModel(&mol, QMKeys,dirName, gaussianCommand, constraints,stdout);
		else qmModel = createGenericModel(&mol, QMKeys, dirName, genericCommand, constraints, stdout);
		setH4Correction(file,&qmModel);
		readOneBoolean(file,"addD3Correction",&qmModel.addD3Correction);
		pqmModel = &qmModel;	
	}

	
	runPIMD(pforceField, pqmModel, 
		updateFrequency, heatTime, equiTime, runTime, coolTime, heatTemp, equiTemp, runTemp, coolTemp, stepSize, 
		thermostat, transformation, friction, omegaMax, Nf, nBeads, nNH, nNHSteps, nSY, fileNameTraj, fileNameProp);

	if(!strcmp(model,"MM")) freeForceField(&forceField);
	else qmModel.klass->free(&qmModel);

	free(dirName);
	fclose(file);
}
/********************************************************************************/
File: ./cchemilib/src/JobControl/Job.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* Job.c */

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <time.h>
#include <locale.h>
#include <string.h>

#include "Job.h"
#include "../Utils/Types.h"
#include "../Utils/Utils.h"
#include "../MolecularMechanics/MolecularMechanicsDlg.h"
#include "../QuantumMechanics/QuantumMechanicsDlg.h"
#include "../PathIntegral/PIMDDlg.h"
#include "../QuarticForceField/QFFnMR.h"
#include "../VPT2/VPT2.h"

typedef struct _JobLink  JobLink;
struct _JobLink
{
        char* type;
	void (*run)(char* inputFileName, char* model);
};
/******************************************************************************************/
Job newJob(char* inputFileName)
{
	Job job;
	job.inputFileName = strdup(inputFileName);
	return job;
}
/******************************************************************************************/
void freeJob(Job* job)
{
	if(job->inputFileName) free(job->inputFileName);
	job->inputFileName = NULL;
}
/******************************************************************************************/
static void runEnergy(char* inputFileName, char* model) 
{
	if(!strcmp(model,"MM")) molecularMechanicsEnergyDlg(inputFileName);
	else quantumMechanicsEnergyDlg(inputFileName);
}
static void runGradient(char* inputFileName, char* model) 
{
	if(!strcmp(model,"MM")) molecularMechanicsGradientDlg(inputFileName);
	else quantumMechanicsGradientDlg(inputFileName);
}
static void runMinimize(char* inputFileName, char* model) 
{
	if(!strcmp(model,"MM")) molecularMechanicsMinimizeDlg(inputFileName);
	else quantumMechanicsMinimizeDlg(inputFileName);
}
static void runOptFreq(char* inputFileName, char* model) 
{
	if(!strcmp(model,"MM")) molecularMechanicsOptFrequenciesDlg(inputFileName);
	else quantumMechanicsOptFrequenciesDlg(inputFileName);
}
static void runGenerateCChemIFilesForFrequencies(char* inputFileName, char* model) 
{
	generateCChemIFilesForFrequenciesDlg(inputFileName, FALSE);
}
static void runComputeFrequenciesFromFiles(char* inputFileName, char* model) 
{
	computeFrequenciesFromFilesDlg(inputFileName, FALSE);
}
static void runGenerateCChemIFilesForFrequenciesOneStep(char* inputFileName, char* model) 
{
	generateCChemIFilesForFrequenciesDlg(inputFileName, TRUE);
}
static void runComputeFrequenciesFromFilesOneStep(char* inputFileName, char* model) 
{
	computeFrequenciesFromFilesDlg(inputFileName, TRUE);
}
static void runGenerateCChemIGradFilesForFrequencies(char* inputFileName, char* model) 
{
	generateCChemIGradFilesForFrequenciesDlg(inputFileName, FALSE);
}
static void runComputeFrequenciesFromGradFiles(char* inputFileName, char* model) 
{
	computeFrequenciesFromGradFilesDlg(inputFileName, FALSE);
}
static void runGenerateCChemIGradFilesForFrequenciesOneStep(char* inputFileName, char* model) 
{
	generateCChemIGradFilesForFrequenciesDlg(inputFileName, TRUE);
}
static void runComputeFrequenciesFromGradFilesOneStep(char* inputFileName, char* model) 
{
	computeFrequenciesFromGradFilesDlg(inputFileName, TRUE);
}
static void runFrequencies(char* inputFileName, char* model) 
{
	if(!strcmp(model,"MM")) molecularMechanicsFrequenciesDlg(inputFileName);
	else quantumMechanicsFrequenciesDlg(inputFileName);
}
static void runComputeQFFFromEnergiesDipolesFile(char* inputFileName, char* model) 
{
	computeQFFFromEnergiesDipolesFile(inputFileName);
}
static void runComputeQFFFromFiles(char* inputFileName, char* model) 
{
	computeQFFFromFiles(inputFileName);
}
static void runGenerateQFFCChemIFilesForFrequencies(char* inputFileName, char* model) 
{
	generateQFFCChemIFilesForFrequencies(inputFileName);
}
static void runPathIntegralMD(char* inputFileName, char* model) 
{
	pathIntegralMDDlg(inputFileName);
}
static void runREMDConfo(char* inputFileName, char* model) 
{
	if(!strcmp(model,"MM")) molecularMechanicsDynamicsREMDConfoDlg(inputFileName);
	else quantumMechanicsREMDConfoDlg(inputFileName);
}
static void runRemoveSimilarConfo(char* inputFileName, char* model) 
{
	quantumMechanicsRemoveSimilarConfoDlg(inputFileName);
}
static void runGAConfo(char* inputFileName, char* model) 
{
	quantumMechanicsGAConfoDlg(inputFileName);
}
static void runMDConfo(char* inputFileName, char* model) 
{
	if(!strcmp(model,"MM")) molecularMechanicsDynamicsConfoDlg(inputFileName);
	else quantumMechanicsMolecularDynamicsConfoDlg(inputFileName);
}
static void runRandomConfo(char* inputFileName, char* model) 
{
	if(!strcmp(model,"MM")) molecularMechanicsRandomConfoDlg(inputFileName);
	else quantumMechanicsRandomConfoDlg(inputFileName);
}
static void runMD(char* inputFileName, char* model) 
{
	if(!strcmp(model,"MM")) molecularMechanicsDynamicsDlg(inputFileName);
	else quantumMechanicsMolecularDynamicsDlg(inputFileName);
}
static void runVPT2(char* inputFileName, char* model) 
{
	vpt2(inputFileName);
}
static void printListOfRunTypes(JobLink jobsList[], int nJobsList)
{
	int i;
	printf("available runType :\n");
	for(i=0;i<nJobsList;i++) printf("%s\n",jobsList[i].type);
}
/******************************************************************************************/
void runJob(Job* job) 
{
	char* inputFileName = job->inputFileName;
	FILE* file = NULL;
	char* runType = NULL;
	char* model = NULL;
	JobLink jobsList[] = {
		{"ENERGY", runEnergy}, 
		{"GRADIENT", runGradient},
		{"OPTIMIZATION", runMinimize},
		{"OPTFREQ", runOptFreq},
		{"GENERATEFILESFORFREQ", runGenerateCChemIFilesForFrequencies},
		{"COMPUTEFREQUENCIESFROMFILES", runComputeFrequenciesFromFiles},
		{"GENERATEFILESONESTEPFORFREQ", runGenerateCChemIFilesForFrequenciesOneStep},
		{"COMPUTEFREQUENCIESONESTEPFROMFILES", runComputeFrequenciesFromFilesOneStep},
		{"GENERATEGRADFILESFORFREQ", runGenerateCChemIGradFilesForFrequencies},
		{"COMPUTEFREQUENCIESFROMGRADFILES", runComputeFrequenciesFromGradFiles},
		{"GENERATEGRADFILESONESTEPFORFREQ", runGenerateCChemIGradFilesForFrequenciesOneStep},
		{"COMPUTEFREQUENCIESONESTEPFROMGRADFILES", runComputeFrequenciesFromGradFilesOneStep},
		{"FREQ", runFrequencies},
		{"COMPUTEQFFNMRFROMENERG", runComputeQFFFromEnergiesDipolesFile},
		{"COMPUTEQFFNMRFROMFILES", runComputeQFFFromFiles},
		{"GENERATEQFFNMRFILES", runGenerateQFFCChemIFilesForFrequencies},
		{"COMPUTEQFF2MRFROMENERG", runComputeQFFFromEnergiesDipolesFile},
		{"COMPUTEQFF2MRFROMFILES", runComputeQFFFromFiles},
		{"GENERATEQFF2MRFILES", runGenerateQFFCChemIFilesForFrequencies},
		{"PIMD", runPathIntegralMD},
		{"REMDCONFO", runREMDConfo},
		{"REMOVESIMILARCONFO", runRemoveSimilarConfo},
		{"MDCONFO", runMDConfo},
		{"RDCONFO", runRandomConfo},
		{"GACONFO", runGAConfo},
		{"MD",  runMD},
		{"VPT2", runVPT2}
	};
	int i;
	int nJobsList = sizeof(jobsList)/sizeof(JobLink);
	if(!inputFileName) exit(1);
	file = fopen(inputFileName, "r");
	if(!file)
	{
		printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		printf("Sorry, I cannot open the input file : %s\n",inputFileName);
		printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		exit(1);
	}
	if(!readOneString(file,"RunType",&runType)) runType = strdup("ENERGY");
	if(!readOneString(file,"Model",&model)) model = strdup("MM");
	uppercase(runType);
	uppercase(model);
	fclose(file);
	printf("----------------------------------------------------------\n");
	printf("runType=%s\n",runType);
	printf("model=%s\n",model);
	printf("----------------------------------------------------------\n");
	printf("\n");

	if(strstr(runType,"HELP"))printListOfRunTypes(jobsList,nJobsList);
	else
	for(i=0;i<nJobsList;i++) 
	{
		if(strstr(runType,jobsList[i].type))
		{
			jobsList[i].run(inputFileName, model);
			break;
		}
	}
	printf("\n");
}
File: ./cchemilib/src/QuarticForceField/QFFN2P2.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* QFFnMR.c */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <ctype.h>

#include "../Utils/Utils.h"
#include "../Utils/Types.h"
#include "../Utils/Constants.h"
#include "../Molecule/Molecule.h"

/********************************************************************************/
/********************************************************************************/
/**************** compute N2P2QFF using analytical method ***********************/
/********************************************************************************/
#ifdef HIGH_DERIVATIVES
#include "../InterfaceLibN2P2/InterfaceCChemIC.h"
/*****************************************************************************/
// eqs 26-29 : Mackie J. Chem. Phys. 142, 244107 (2015)
static double** getMatrixPartialDerivative(Molecule* mol)
{
// Translation and rotation vector are not needed for trans from cartesian to normal modes
// Omega bar is given by mol->vibration.modes[i].vectors[j][k]
	double** Otild = NULL;
	int i,j,k;
	if(mol->vibration.nModes<1) return Otild;
	if(mol->nAtoms<1) return Otild;
	Otild = malloc(mol->vibration.nModes*sizeof(double*));
	for(i=0;i< mol->vibration.nModes;i++)
		Otild[i] = malloc(3*mol->nAtoms*sizeof(double));

	for(i=0;i< mol->vibration.nModes;i++)
	{
		double mum12 = 1.0/sqrt(mol->vibration.modes[i].mass*AMUTOAU);
		for(k=0;k<mol->nAtoms;k++)  
		for(j=0;j<3;j++) 
			Otild[i][3*k+j] = mol->vibration.modes[i].vectors[j][k]*mum12;
	}
	return Otild;

}
/**************************************************************************************/
static FILE* newQFFAppendPre(char* inputFileName, Molecule* mol)
{

	char tmp[BSIZE];
	int nf = mol->vibration.nModes;
        char* fileNameOut = strdup_printf("%sQFF.txt",getSuffixNameFile(inputFileName));
        FILE* file = fopen(fileNameOut,"w");
        FILE* fileIn = fopen(inputFileName,"rb");
        fprintf(stdout,"QFF parameters saved in %s file\n", fileNameOut);


	while(!feof(fileIn))
      	{
                if(!fgets(tmp,BSIZE,fileIn))break;
		fprintf(file,"%s",tmp);
        }
	fclose(fileIn);

	sprintf(tmp, "#====================================================================================\n");
	fprintf(file,"%s", tmp);   
	sprintf(tmp,"%s",
		"# QFF constants calculated using analytical method implemented in modified version of N2P2 library\n"
		);
	fprintf(file,"%s",tmp);   
	sprintf(tmp, "#====================================================================================\n");
	fprintf(file,"%s",tmp);   

	fprintf(file,"%s","\n");
	fprintf(file,"%s","VPT2Model=GVPT2\n");   
	fprintf(file,"%s","# VPT2Model=DCPT2\n");   
	fprintf(file,"%s","# VPT2Model=HDCPT2\n");   
	fprintf(file,"%s","# alphaHDCPT2=1.0\n");   
	fprintf(file,"%s","# betaHDCPT2=5e5\n");   
	fprintf(file,"%s","\n");
	fprintf(file,"%s","PropModel=GVPT2\n");
	fprintf(file,"%s","# PropModel=HDCPT2\n");
	fprintf(file,"%s","# PropModel=DCPT2\n");
	fprintf(file,"%s","# alphaPropHDCPT2=1.0\n");
	fprintf(file,"%s","# betaPropHDCPT2=5e5\n");
	fprintf(file,"%s","# alphaPropHDCPT2=1.0\n");
	fprintf(file,"%s","# betaPropHDCPT2=5e5\n");
	fprintf(file,"%s","maxFrequencyDifferenceFermi=200\n");
	fprintf(file,"%s","MartinCutOff1=1.0\n");
	fprintf(file,"%s","MartinCutOff2=1.0\n");
	fprintf(file,"%s","# ZCutOff=0.08\n");
	fprintf(file,"%s","\n");
	sprintf(tmp, "#====================================================================================\n");
	fprintf(file,"%s",tmp);   

	fprintf(file,"%s","\n");   
	sprintf(tmp,"nFrequencies=%d\n",nf);
	fprintf(file,"%s",tmp);   
	sprintf(tmp,"nDim=%d\n",3);
	fprintf(file,"%s",tmp);   
	fprintf(file,"%s","\n");   

	return file;

}
static void QFFN2P2AppendEnergyDerivatives(FILE* file, Molecule* mol, int order, int method, char* HNNDir, double **Otild, int fourIndex)
{
	char tmp[BSIZE];
	double cfenergy = 1.0/(AUTOKCAL);
        double cflength = ANGTOBOHR;
        //double cfdipole = 1.0/(AUTODEB);

	double f1cchemiAu = cfenergy/cflength;
	double f2cchemiAu = f1cchemiAu/cflength;
	double f3cchemiAu = f2cchemiAu/cflength;
	double f4cchemiAu = f3cchemiAu/cflength;

	void* interfaceLibN2P2 = newInterfaceCChemI(HNNDir, cflength, cfenergy, 0);

	DerivativesIC* deriv;

	double f2cm1 = AUTOCM1;
	double f3cm1 = AUTOCM1*sqrt(AUTOCM1)*AUTOCM1;
	double f4cm1 = AUTOCM1*AUTOCM1*AUTOCM1;

	double f1conv = f1cchemiAu;
	double f2conv = f2cm1*f2cchemiAu;
	double f3conv = f3cm1*f3cchemiAu;
	double f4conv = f4cm1*f4cchemiAu;

	int nAtoms = mol->nAtoms;
	int i,j,k,l;
	int a,b,c,d;
	int ca,cb,cc,cd;
	int nf = mol->vibration.nModes;
	
	// Derivatives (in atomic unit) in cartezian coordinates
	deriv = interfaceCChemIComputeHighDerivatives(interfaceLibN2P2, mol, order, method);

	// eqs 26-29 : Mackie J. Chem. Phys. 142, 244107 (2015)
	// (3*nAtoms)(3*nAtoms) matrix

	// Derivatives in normal coordinates
	// Gradients
	if(order<2) return;

	sprintf(tmp,"#i Freq(cm-1)  Calc.Freq   dQ(Bohr)  Mass(amu)\tGradient[ H amu^(-1/2) Bohr^(-1)]\n");
	fprintf(file,"%s",tmp);   
	fprintf(file,"%s","Hessian\n");   
	for(i=0;i<nf;i++) 
	{
		double grad = 0 , f= 0, delta = 0;
		// Gradient
		grad = 0;
        	for(a=0;a<nAtoms;a++) for(ca=0;ca<3;ca++) 
		{
			int ia = 3*a+ca;
			grad +=  Otild[i][ia]*deriv->df[ia];
		}
		grad *= f1conv;
		// Quadratic
		f = 0;
        	for(a=0;a<nAtoms;a++) for(ca=0;ca<3;ca++) 
        	for(b=0;b<nAtoms;b++) for(cb=0;cb<3;cb++) 
		{
			int ia = 3*a+ca;
			int ib = 3*b+cb;
			double o = Otild[i][ia]*Otild[i][ib];
			if(ib>ia) { int t = ia; ia=ib; ib = t; }
			f += o*deriv->d2f[ia][ib];
		}
		f = f2conv*sqrt(fabs(f));
		sprintf(tmp,"%d %d %0.14f %0.14f %0.14f %0.14f\t%0.14f\n",i+1, i+1, mol->vibration.modes[i].frequency, 
				f, 
				delta, mol->vibration.modes[i].mass, grad);
		fprintf(file,"%s",tmp);   
	}
	fprintf(file,"%s","END\n\n");
	// Cubic
	if(order<3) return;
	sprintf(tmp,"# i\tj\tk\tReduced values [cm-1]\n");
	fprintf(file,"%s",tmp);   
	fprintf(file,"%s","Cubic\n");   
	for(i=0;i<nf;i++)
        {
                for(j=0;j<=i;j++)
                for(k=0;k<=j;k++)
                {
			double val = 0;
        		for(a=0;a<nAtoms;a++) for(ca=0;ca<3;ca++) 
        		for(b=0;b<nAtoms;b++) for(cb=0;cb<3;cb++) 
        		for(c=0;c<nAtoms;c++) for(cc=0;cc<3;cc++) 
			{
				int ia = 3*a+ca;
				int ib = 3*b+cb;
				int ic = 3*c+cc;
				double o = Otild[i][ia]*Otild[j][ib]*Otild[k][ic];
				if(ic>ib) { int t = ic; ic=ib; ib = t; }
				if(ib>ia) { int t = ib; ib=ia; ia = t; }
				if(ic>ib) { int t = ic; ic=ib; ib = t; }
				val += o*deriv->d3f[ia][ib][ic];
			}
			val *= f3conv/sqrt(mol->vibration.modes[i].frequency*mol->vibration.modes[j].frequency*mol->vibration.modes[k].frequency);
			if(fabs(val)<1e-12) continue;
			sprintf(tmp,"%d\t%d\t%d\t%14.6f\n",k+1, j+1, i+1, val);
			fprintf(file,"%s",tmp);   
                }
        }
	fprintf(file,"%s","END\n\n");
	//Quartic
	if(order<4) return;
	sprintf(tmp,"# i\tj\tk\tl\tReduced values [cm-1]\n");
	fprintf(file,"%s",tmp);   
	fprintf(file,"%s","Quartic\n");   
	for(i=0;i<nf;i++)
        {
                for(j=0;j<=i;j++)
                for(k=0;k<=j;k++)
                for(l=0;l<=k;l++)
		{
			if(!fourIndex && i!=j && i!=k && i!=l && j!=k && j!=l && k!=l) continue;
			double val = 0;
        		for(a=0;a<nAtoms;a++) for(ca=0;ca<3;ca++) 
        		for(b=0;b<nAtoms;b++) for(cb=0;cb<3;cb++) 
        		for(c=0;c<nAtoms;c++) for(cc=0;cc<3;cc++) 
        		for(d=0;d<nAtoms;d++) for(cd=0;cd<3;cd++) 
			{
				int ia = 3*a+ca;
				int ib = 3*b+cb;
				int ic = 3*c+cc;
				int id = 3*d+cd;
				double o = Otild[i][ia]*Otild[j][ib]*Otild[k][ic]*Otild[l][id];
				if(id>ic) { int t = id; id=ic; ic = t; }
				if(ic>ib) { int t = ic; ic=ib; ib = t; }
				if(ib>ia) { int t = ib; ib=ia; ia = t; }
				if(id>ic) { int t = id; id=ic; ic = t; }
				if(ic>ib) { int t = ic; ic=ib; ib = t; }
				if(id>ic) { int t = id; id=ic; ic = t; }
				val += o*deriv->d4f[ia][ib][ic][id];
			}
			val *= f4conv
			/sqrt(mol->vibration.modes[i].frequency*mol->vibration.modes[j].frequency*mol->vibration.modes[k].frequency*mol->vibration.modes[l].frequency);
			if(fabs(val)<1e-12) continue;
			sprintf(tmp,"%d\t%d\t%d\t%d\t%14.6f\n",l+1,k+1, j+1, i+1, val);
			fprintf(file,"%s",tmp);   
		}
        }
	fprintf(file,"%s","END\n\n");

}
/************************************************************************************************************/
static int readFirstDipolesInput(FILE* file, int nf, double** firstDipolesInput)
{
	int xyz;
	int nn=1;
	int i;
        double mu0 = 4*PI*1e-7;
        double eps0 = 1.0/(mu0*slight*slight);
        double   kmmolm1 = 4*PI*PI*PI*NAvogadro/3/hPlank/slight/4/PI/eps0*1e-3*100.0*8.47835267e-30*8.47835267e-30;/* 1e-3 m to km, 100 : cm-1 to m-1 */
	double f = 1.0/sqrt(kmmolm1);
	int numberOfFirstDipolesInput = 0;
	{
		rewind(file);
		if(goToStr(file, "First derivatives"))
		for(i=0;i<nf && nn==1 ;i++)
		{
			int xyz;
			for(xyz=0;xyz<3 && nn==1 ;xyz++)
				nn = fscanf(file,"%lf",&firstDipolesInput[i][xyz]);
			numberOfFirstDipolesInput += nn;
		}
		if(numberOfFirstDipolesInput != nf) numberOfFirstDipolesInput=0;
	}
	if(numberOfFirstDipolesInput != 0)
	for(i=0;i<nf;i++)
		for(xyz=0;xyz<3;xyz++)
			firstDipolesInput[i][xyz] *= f;

	return numberOfFirstDipolesInput;
}
/******************************************************************************************************************************/
static void QFFN2P2AppendDipoleDerivatives(char* inputFileName, FILE* file, Molecule* mol, int order, int method, char* HNNDir, double** Otild, int threeIndex)
{
	char tmp[BSIZE];

        double cflength = ANGTOBOHR;
        double cfdipole = 1.0/(AUTODEB);

	DerivativesIC** deriv = NULL;
	void* interfaceLibN2P2ES = NULL;
	double f1cm1 = sqrt(AUTOCM1);
	double f2cm1 = AUTOCM1;
	double f3cm1 = AUTOCM1*sqrt(AUTOCM1);

	double f1cchemiAu = cfdipole/cflength;
	double f2cchemiAu = f1cchemiAu/cflength;
	double f3cchemiAu = f2cchemiAu/cflength;

	double f1conv = f1cm1*f1cchemiAu;
	double f2conv = f2cm1*f2cchemiAu;
	double f3conv = f3cm1*f3cchemiAu;

	int nAtoms = mol->nAtoms;
	int i,j,k;
	int a,b,c;
	int ca,cb,cc;
	int nf = mol->vibration.nModes;
	int xyz;
	int numberOfFirstDipolesInput= 0;
	double **firstDipolesInput = NULL;
        FILE* fileIn = fopen(inputFileName,"rb");
	char txyz[]={'X','Y','Z'};

	if(nf>0)
	{
		firstDipolesInput = malloc(nf*sizeof(double*));
		for(i=0;i<nf;i++)
			firstDipolesInput[i] = malloc(3*sizeof(double));
		numberOfFirstDipolesInput =readFirstDipolesInput(fileIn, nf, firstDipolesInput);
	}

        interfaceLibN2P2ES = newInterfaceCChemIES(HNNDir, cflength, cfdipole, 0);
	
	// Derivatives (in atomic unit) in cartezian coordinates
	deriv = interfaceCChemIComputeDipoleHighDerivatives(interfaceLibN2P2ES, mol, order, method);

	// eqs 26-29 : Mackie J. Chem. Phys. 142, 244107 (2015)
	// (3*nAtoms)(3*nAtoms) matrix
	// Derivatives in normal coordinates
	// Gradients
	if(order<1) return;
	if(mol)
	{
		mol->klass->addFirstDerivativeToFile(mol, file);
	}
	if(numberOfFirstDipolesInput==0)
	{
		sprintf(tmp,"#xyz\ti\tValues[au cm^1/2]\n");
		fprintf(file,"%s",tmp);   
		fprintf(file,"%s","First derivatives\n");
		for(i=0;i<nf;i++)
		for(xyz=0;xyz<3;xyz++)
		{
			double val =  0;
        		for(a=0;a<nAtoms;a++) for(ca=0;ca<3;ca++) 
			{
				int ia = 3*a+ca;
				val +=  Otild[i][ia]*deriv[xyz]->df[ia];
			}
			val *=  f1conv;
			if(fabs(val)<1e-12) continue;
			sprintf(tmp,"%c\t%d\t%14.6f\n",txyz[xyz], i+1,val);
			fprintf(file,"%s",tmp);   
		}
		fprintf(file,"%s","END\n\n");
	}
	else
	{
		sprintf(tmp,"#xyz\ti\tInput values[au cm^1/2]\tCalculated values[au cm^1/2]\n");
		fprintf(file,"%s",tmp);   
		fprintf(file,"%s","First derivatives\n");
		for(i=0;i<nf;i++)
		for(xyz=0;xyz<3;xyz++)
		{
			double val =  0;
        		for(a=0;a<nAtoms;a++) for(ca=0;ca<3;ca++) 
			{
				int ia = 3*a+ca;
				val +=  Otild[i][ia]*deriv[xyz]->df[ia];
			}
			val *=  f1conv;
			if(fabs(firstDipolesInput[i][xyz])<1e-12) continue;
			sprintf(tmp,"%c\t%d\t%14.6f\t\t%14.6f\n",txyz[xyz], i+1,firstDipolesInput[i][xyz], val);
			fprintf(file,"%s",tmp);   
		}
		fprintf(file,"%s","END\n\n");
	}
	if( firstDipolesInput)
	{
		for(i=0;i<nf;i++) free(firstDipolesInput[i]);
		free(firstDipolesInput);
	}

	// Second derivatives
	if(order<2) return;
	sprintf(tmp,"#xyz\ti\tj\tValues[au cm]\n");
	fprintf(file,"%s",tmp);   
	fprintf(file,"%s","Second derivatives\n");
	for(i=0;i<nf;i++)
	for(j=0;j<nf;j++)
	for(xyz=0;xyz<3;xyz++)
	{
		double val = 0;
        	for(a=0;a<nAtoms;a++) for(ca=0;ca<3;ca++) 
        	for(b=0;b<nAtoms;b++) for(cb=0;cb<3;cb++) 
		{
			int ia = 3*a+ca;
			int ib = 3*b+cb;
			double  o = Otild[i][ia]*Otild[j][ib];
			if(ib>ia) { int t = ia; ia=ib; ib = t; }
			val += o*deriv[xyz]->d2f[ia][ib];
		}
		val *= f2conv;
		if(fabs(val)<1e-12) continue;
		sprintf(tmp,"%c\t%d\t%d\t%14.6f\n",txyz[xyz], i+1,j+1,val);
		fprintf(file,"%s",tmp);   
	}
	fprintf(file,"%s","END\n\n");


	// Cubic derivatives
	if(order<3) return;
	sprintf(tmp,"#xyz\ti\tj\tk\tValues[au cm^3/2]\n");
	fprintf(file,"%s",tmp);   
	fprintf(file,"%s","Cubic derivatives\n");
	for(i=0;i<nf;i++)
	for(j=0;j<nf;j++)
	for(k=0;k<nf;k++)
	for(xyz=0;xyz<3;xyz++)
        {
		double val = 0;
		if(!threeIndex && i!=j && i!=k && j!=k) continue;

        	for(a=0;a<nAtoms;a++) for(ca=0;ca<3;ca++) 
        	for(b=0;b<nAtoms;b++) for(cb=0;cb<3;cb++) 
        	for(c=0;c<nAtoms;c++) for(cc=0;cc<3;cc++) 
		{
			int ia = 3*a+ca;
			int ib = 3*b+cb;
			int ic = 3*c+cc;
			double o = Otild[i][ia]*Otild[j][ib]*Otild[k][ic];
			if(ic>ib) { int t = ic; ic=ib; ib = t; }
			if(ib>ia) { int t = ib; ib=ia; ia = t; }
			if(ic>ib) { int t = ic; ic=ib; ib = t; }
			val += o*deriv[xyz]->d3f[ia][ib][ic];
		}
		val *= f3conv;
		if(fabs(val)<1e-12) continue;
		sprintf(tmp,"%c\t%d\t%d\t%d\t%14.6f\n",txyz[xyz], i+1,j+1,k+1,val);
		fprintf(file,"%s",tmp);
        }
	fprintf(file,"%s","END\n\n");
}
char* computeN2P2QFFAnalyticDerivatives(char* inputFileName, Molecule* mol, int orderEnergy, int orderDipole, int method, char* HNNDir)
{
	char* fileNameOut = NULL;
	double **Otild = NULL;
	FILE* file = NULL;
	int fourIndex = 0;
	int threeIndex = 0;

	
	if(orderEnergy>=5) 
	{
		orderEnergy = 4;
		fourIndex = 1;
	}
	if(orderDipole>=4) 
	{
		orderDipole = 3;
		threeIndex = 1;
	}
	printf("numberOfFrequencies = %d\n", mol->vibration.nModes);
	Otild = getMatrixPartialDerivative(mol);

	printf("newQFFAppendPre\n");
	file =  newQFFAppendPre(inputFileName, mol);
	if(file) fileNameOut = strdup_printf("%sQFF.txt",getSuffixNameFile(inputFileName));
	printf("QFFN2P2AppendEnergyDerivatives\n");
	QFFN2P2AppendEnergyDerivatives(file, mol, orderEnergy, method, HNNDir, Otild, fourIndex);
	printf("QFFN2P2AppendDipoleDerivatives\n");
	QFFN2P2AppendDipoleDerivatives(inputFileName, file, mol, orderDipole, method, HNNDir, Otild, threeIndex);
	fclose(file);
	return fileNameOut;
}
/**********************************************************************************************************************/
#endif
File: ./cchemilib/src/QuarticForceField/QFFnMR.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* QFFnMR.c */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <ctype.h>

#include "../Utils/Utils.h"
#include "../Utils/Types.h"
#include "../Utils/Constants.h"
#include "../Molecule/Molecule.h"

/************************************************************************************************************/
typedef struct _NMRQFFDipole
{
	double values[3];
}NMRQFFDipole;

typedef struct _NMRQFF
{
	int numberOfFrequencies;
	double* gradients;
	double* frequencies;
	int numberOfFirstDipolesInput;
	int numberOfEnergies;
	int numberOfDipoles;
	double** firstDipolesInput;
	double* calculatedFrequencies;
	double* mass;
	double* delta;//[i:0..Nfreq]
	double V0;
	double **VI; // [i:0..Nfreq][0..5]
	double ***VIJ; // [i:0..Nfreq][j:0..Nfreq][0..3]
	double ***VI3J; // [i:0..Nfreq][j:0..Nfreq][0..3]
	double ****VIJK; // [i:0..Nfreq][j:0..Nfreq][[j:0..Nfreq][0..7]
	double *****VIJKL; // [i:0..Nfreq][j:0..Nfreq][j:0..Nfreq][j:0..Nfreq][0..16]

	double** cubicEnergies;//[i:0..Nfreq][j:0..Nfreq] for tiii, tiij
	double*** cubicEnergiesIJK;//[i:0..Nfreq][j:0..Nfreq][j:0..Nfreq] for tijk, i # j # k
	double** quarticEnergiesIIJJ;//[i:0..Nfreq][j:0..i-1] for uiijj
	double** quarticEnergiesIIIJ;//[i:0..Nfreq][j:0..Nfreq] for uiiij and uiiii
	double*** quarticEnergiesIIJK;//[i:0..Nfreq][j:0..Nfreq][k:0..Nfreq] for uiijk i # j # k
	double**** quarticEnergiesIJKL;//[i:0..Nfreq][j:0..Nfreq][k:0..Nfreq][l:0..Nfreq] for uijkl i # j # k # l

	double *dipole0; // [0..2] // 0..2 : x,y,z
	double ***dipolesI; // mu[i:0..Nfreq][0..5][0..2] // 0..2 : x,y,z
	double ****dipolesIJ; // mu[i:0..Nfreq][j:0..Nfreq][0..3][0..2] // 0..2 : x,y,z
	double ****dipolesI3J; // mu[i:0..Nfreq][j:0..Nfreq][0..3][0..2] // 0..2 : x,y,z
	double *****dipolesIJK; // mu[i:0..Nfreq][j:0..Nfreq][k:0..Nfreq][0..8][0..2] // 0..2 : x,y,z
	double** firstDipoles;//[i:0..Nfreq][0..2] 
	double*** secondDipoles;//[i:0..Nfreq][i:0..Nfreq][0..2] 
	double*** cubicDipoles;//[i:0..Nfreq][i:0..Nfreq][0..2] // diii, diij
	double**** cubicDipolesIJK;//[i:0..Nfreq][i:0..Nfreq][i:0..Nfreq][0..2] // dijk, i # j # k
	double*** quarticDipolesIIJJ;//[i:0..Nfreq][j:0..i-1][0..2] for diijj
	double*** quarticDipolesIIIJ;//[i:0..Nfreq][j:0..Nfreq][0..2] for diiij and diiii
	double**** quarticDipolesIIJK;//[i:0..Nfreq][j:0..Nfreq][k:0..Nfreq][0..2] for diijk i # j # j

	Molecule mol;
}NMRQFF;
static void computeQFFDerivativesEnergies(NMRQFF* qffConstants, int order, double* energies);
static void computeQFFDerivativesDipoles(NMRQFF* qffConstants, int order, double* dipoles[]);
static char* saveNMRQFFAppend(NMRQFF* qffConstants, char* inputFileName, Molecule* mol);
/************************************************************************************************************/
static void initnMRQFF0(NMRQFF* qffConstants, int nf)
{
	qffConstants->numberOfFrequencies = nf;
	qffConstants->numberOfFirstDipolesInput = 0;
	qffConstants->numberOfEnergies = 0;
	qffConstants->numberOfDipoles = 0;

	//printf("Begin initNMRQFF0 nf = %d\n",nf);

	qffConstants->frequencies = newVectorDouble(qffConstants->numberOfFrequencies);
        initVectorDouble(qffConstants->frequencies, qffConstants->numberOfFrequencies, 0.0);
	qffConstants->gradients = newVectorDouble(qffConstants->numberOfFrequencies);
        initVectorDouble(qffConstants->gradients, qffConstants->numberOfFrequencies, 0.0);
	//printf("End initgrad\n");
	qffConstants->calculatedFrequencies = newVectorDouble(qffConstants->numberOfFrequencies);
        initVectorDouble(qffConstants->calculatedFrequencies, qffConstants->numberOfFrequencies, 0.0);
	qffConstants->mass = newVectorDouble(qffConstants->numberOfFrequencies);
        initVectorDouble(qffConstants->mass, qffConstants->numberOfFrequencies, 0.0);
	qffConstants->delta = newVectorDouble(qffConstants->numberOfFrequencies);
        initVectorDouble(qffConstants->delta, qffConstants->numberOfFrequencies, 0.0);
	//printf("End initNMRQFF0\n");

	qffConstants->mol.nAtoms = 0;
	qffConstants->mol.atoms = NULL;

}
/************************************************************************************************************/
static void initnMRQFFEnergies(NMRQFF* qffConstants, int order)
{
	qffConstants->V0 = 0;
	qffConstants->VI = newMatrixDouble(qffConstants->numberOfFrequencies,6);
        initMatrixDouble(qffConstants->VI, qffConstants->numberOfFrequencies,6, 0.0);
	qffConstants->cubicEnergies = newMatrixDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies);
        initMatrixDouble(qffConstants->cubicEnergies, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies, 0.0);

	qffConstants->cubicEnergiesIJK = newCubeDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies);
        initCubeDouble(qffConstants->cubicEnergiesIJK, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies, 0.0);
	//printf("End initCubeDouble\n");

	qffConstants->quarticEnergiesIIJJ = newMatrixDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies);
        initMatrixDouble(qffConstants->quarticEnergiesIIJJ, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies, 0.0);
	qffConstants->quarticEnergiesIIIJ = newMatrixDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies);
        initMatrixDouble(qffConstants->quarticEnergiesIIIJ, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies, 0.0);
	qffConstants->quarticEnergiesIIJK = newCubeDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies);
        initCubeDouble(qffConstants->quarticEnergiesIIJK, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies, 0.0);

        qffConstants->quarticEnergiesIJKL = newQuarticDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies);
        initQuarticDouble(qffConstants->quarticEnergiesIJKL, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,0.0);
	//printf("End quarticEnergiesIIJK\n");

        qffConstants->VIJ = newCubeDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,4);
        initCubeDouble(qffConstants->VIJ, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,4,0.0);
        qffConstants->VI3J = newCubeDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,4);
        initCubeDouble(qffConstants->VI3J, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,4,0.0);

	//printf("Begin VIJK\n");
        qffConstants->VIJK =  NULL;
	if(order>=3)
	{
		// save VIJK in file
		/*
        	qffConstants->VIJK = newQuarticDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,8);
        	initQuarticDouble(qffConstants->VIJK, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,8,0.0);
		*/
	}
	//printf("End VIJK\n");

	//printf("Begin VIJKL\n");
        qffConstants->VIJKL = NULL;
	if(order>=4)
	{
        	qffConstants->VIJKL = newQuinticDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,16);
        	initQuinticDouble(qffConstants->VIJKL, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,16,0.0);
	}
	//printf("End VIJKL\n");
}
/************************************************************************************************************/
static void initnMRQFFDipoles(NMRQFF* qffConstants, int order)
{
	qffConstants->quarticDipolesIIJJ = newCubeDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,3);
        initCubeDouble(qffConstants->quarticDipolesIIJJ, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,3, 0.0);
	qffConstants->quarticDipolesIIIJ = newCubeDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,3);
        initCubeDouble(qffConstants->quarticDipolesIIIJ, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,3, 0.0);
        qffConstants->quarticDipolesIIJK = newQuarticDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,3);
        initQuarticDouble(qffConstants->quarticDipolesIIJK, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,3,0.0);
	//printf("End quarticDipolesIIJK\n");

	qffConstants->firstDipoles = newMatrixDouble(qffConstants->numberOfFrequencies,3);
        initMatrixDouble(qffConstants->firstDipoles, qffConstants->numberOfFrequencies,3, 0.0);

	qffConstants->firstDipolesInput = newMatrixDouble(qffConstants->numberOfFrequencies,3);
        initMatrixDouble(qffConstants->firstDipolesInput, qffConstants->numberOfFrequencies,3, 0.0);

        qffConstants->dipole0 = newVectorDouble(3);
        initVectorDouble(qffConstants->dipole0,3,0.0);

        qffConstants->dipolesI = newCubeDouble(qffConstants->numberOfFrequencies,6,3);
        initCubeDouble(qffConstants->dipolesI, qffConstants->numberOfFrequencies,6,3,0.0);

        qffConstants->secondDipoles = newCubeDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,3);
        initCubeDouble(qffConstants->secondDipoles, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,3,0.0);

        qffConstants->cubicDipoles = newCubeDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,3);
        initCubeDouble(qffConstants->cubicDipoles, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,3,0.0);

        qffConstants->cubicDipolesIJK = newQuarticDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,3);
        initQuarticDouble(qffConstants->cubicDipolesIJK, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,3,0.0);

        qffConstants->dipolesIJ = newQuarticDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,4,3);
        initQuarticDouble(qffConstants->dipolesIJ, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,4,3,0.0);

        qffConstants->dipolesI3J = newQuarticDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,4,3);
        initQuarticDouble(qffConstants->dipolesI3J, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,4,3,0.0);

	//printf("Begin dipolesIJK\n");
        qffConstants->dipolesIJK = NULL;
	if(order>=3)
	{
		//save in file
		/*
        	qffConstants->dipolesIJK = newQuinticDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,8,3);
        	initQuinticDouble(qffConstants->dipolesIJK, qffConstants->numberOfFrequencies, qffConstants->numberOfFrequencies, qffConstants->numberOfFrequencies,8,3,0.0);
		*/
	}
	//printf("End dipolesIJK\n");
}
/************************************************************************************************************/
/*
static void freeNMRQFF(NMRQFF* qffConstants)
{
	freeVectorDouble(&qffConstants->frequencies);
	freeVectorDouble(&qffConstants->gradients);
	freeVectorDouble(&qffConstants->calculatedFrequencies);
	freeVectorDouble(&qffConstants->mass);
	freeVectorDouble(&qffConstants->delta);
	freeMatrixDouble(&qffConstants->VI, qffConstants->numberOfFrequencies);
	freeMatrixDouble(&qffConstants->cubicEnergies, qffConstants->numberOfFrequencies);
	freeMatrixDouble(&qffConstants->quarticEnergiesIIJJ, qffConstants->numberOfFrequencies);
	freeMatrixDouble(&qffConstants->quarticEnergiesIIIJ, qffConstants->numberOfFrequencies);
	freeCubeDouble(&qffConstants->quarticDipolesIIJJ, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies);
	freeCubeDouble(&qffConstants->quarticDipolesIIIJ, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies);
	freeMatrixDouble(&qffConstants->firstDipoles, qffConstants->numberOfFrequencies);
	freeMatrixDouble(&qffConstants->firstDipolesInput, qffConstants->numberOfFrequencies);
	freeCubeDouble(&qffConstants->VIJ, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies);
	freeCubeDouble(&qffConstants->VI3J, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies);

	freeVectorDouble(&qffConstants->dipole0);
	freeCubeDouble(&qffConstants->dipolesI, qffConstants->numberOfFrequencies,6);
	freeCubeDouble(&qffConstants->secondDipoles, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies);
	freeCubeDouble(&qffConstants->cubicDipoles, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies);

	freeQuarticDouble(&qffConstants->dipolesIJ, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,4);
	freeQuarticDouble(&qffConstants->dipolesI3J, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,4);
}
*/
/********************************************************************************/
static void saveNMRQFF(NMRQFF* qffConstants, FILE* file)
{
	char tmp[BSIZE];
	int i,j;
	int nf = qffConstants->numberOfFrequencies;
	char txyz[]={'X','Y','Z'};
	int xyz;

	sprintf(tmp, "#====================================================================================\n");
	fprintf(file,"%s", tmp);   
	sprintf(tmp,"%s",
		"# nMR-QFF constants\n"
		"# See Yagi et al. J. Chem. Phys. 121, 1383 (2004)\n"
		);
	fprintf(file,"%s",tmp);   
	sprintf(tmp, "#====================================================================================\n");
	fprintf(file,"%s",tmp);   

	fprintf(file,"%s","\n");
	fprintf(file,"%s","VPT2Model=GVPT2\n");   
	fprintf(file,"%s","# VPT2Model=DCPT2\n");   
	fprintf(file,"%s","# VPT2Model=HDCPT2\n");   
	fprintf(file,"%s","# alphaHDCPT2=1.0\n");   
	fprintf(file,"%s","# betaHDCPT2=5e5\n");   
	fprintf(file,"%s","\n");
	fprintf(file,"%s","PropModel=GVPT2\n");
	fprintf(file,"%s","# PropModel=HDCPT2\n");
	fprintf(file,"%s","# PropModel=DCPT2\n");
	fprintf(file,"%s","# alphaPropHDCPT2=1.0\n");
	fprintf(file,"%s","# betaPropHDCPT2=5e5\n");
	fprintf(file,"%s","# alphaPropHDCPT2=1.0\n");
	fprintf(file,"%s","# betaPropHDCPT2=5e5\n");
	fprintf(file,"%s","maxFrequencyDifferenceFermi=200\n");
	fprintf(file,"%s","MartinCutOff1=1.0\n");
	fprintf(file,"%s","MartinCutOff2=1.0\n");
	fprintf(file,"%s","# ZCutOff=0.08\n");
	fprintf(file,"%s","\n");
	sprintf(tmp, "#====================================================================================\n");
	fprintf(file,"%s",tmp);   

	fprintf(file,"%s","\n");   
	sprintf(tmp,"nFrequencies=%d\n",nf);
	fprintf(file,"%s",tmp);   
	sprintf(tmp,"nDim=%d\n",3);
	fprintf(file,"%s",tmp);   
	fprintf(file,"%s","\n");   

	sprintf(tmp,"#i Freq(cm-1)  Calc.Freq   dQ(Bohr)  Mass(amu)\tGradient[ H amu^(-1/2) Bohr^(-1)]\n");
	fprintf(file,"%s",tmp);   
	fprintf(file,"%s","Hessian\n");   
	for(i=0;i<nf;i++) 
	{
		sprintf(tmp,"%d %d %0.14f %0.14f %0.14f %0.14f\t%0.14f\n",i+1, i+1, qffConstants->frequencies[i], 
				qffConstants->calculatedFrequencies[i], 
				qffConstants->delta[i], qffConstants->mass[i], qffConstants->gradients[i]);
		fprintf(file,"%s",tmp);   
	}
	fprintf(file,"%s","END\n\n");


	sprintf(tmp,"# i\tj\tk\tReduced values [cm-1]\n");
	fprintf(file,"%s",tmp);   
	fprintf(file,"%s","Cubic\n");   
	for(i=0;i<nf;i++)
        {
                for(j=0;j<nf;j++)
                {
			if(fabs(qffConstants->cubicEnergies[i][j])<1e-12) continue;
			sprintf(tmp,"%d\t%d\t%d\t%14.6f\n",i+1, i+1, j+1, qffConstants->cubicEnergies[i][j]);
			fprintf(file,"%s",tmp);   
                }
        }
	fprintf(file,"%s","END\n\n");


	sprintf(tmp,"# i\tj\tk\tl\tReduced values [cm-1]\n");
	fprintf(file,"%s",tmp);   
	fprintf(file,"%s","Quartic\n");   
	for(i=0;i<nf;i++)
        {
		for(j=0;j<=i;j++)
		{
			if(fabs(qffConstants->quarticEnergiesIIJJ[i][j])<1e-12) continue;
			sprintf(tmp,"%d\t%d\t%d\t%d\t%14.6f\n",i+1, i+1, j+1, j+1, qffConstants->quarticEnergiesIIJJ[i][j]);
			fprintf(file,"%s",tmp);   
		}
		for(j=0;j<nf;j++)
		{
			if(j==i) continue;
			if(fabs(qffConstants->quarticEnergiesIIIJ[i][j])<1e-12) continue;
			sprintf(tmp,"%d\t%d\t%d\t%d\t%14.6f\n",i+1, i+1, i+1, j+1, qffConstants->quarticEnergiesIIIJ[i][j]);
			fprintf(file,"%s",tmp);   
		}
        }
	fprintf(file,"%s","END\n\n");

	if(qffConstants->numberOfFirstDipolesInput==0)
	{
		sprintf(tmp,"#xyz\ti\tValues[au cm^1/2]\n");
		fprintf(file,"%s",tmp);   
		fprintf(file,"%s","First derivatives\n");
		for(i=0;i<nf;i++)
		for(xyz=0;xyz<3;xyz++)
		{
			if(fabs(qffConstants->firstDipoles[i][xyz])<1e-12) continue;
			sprintf(tmp,"%c\t%d\t%14.6f\n",txyz[xyz], i+1,qffConstants->firstDipoles[i][xyz]);
			fprintf(file,"%s",tmp);   
		}
		fprintf(file,"%s","END\n\n");
	}
	else
	{
		sprintf(tmp,"#xyz\ti\tInput values[au cm^1/2]\tCalculated values[au cm^1/2]\n");
		fprintf(file,"%s",tmp);   
		fprintf(file,"%s","First derivatives\n");
		for(i=0;i<nf;i++)
		for(xyz=0;xyz<3;xyz++)
		{
			if(fabs(qffConstants->firstDipolesInput[i][xyz])<1e-12) continue;
			sprintf(tmp,"%c\t%d\t%14.6f\t\t%14.6f\n",txyz[xyz], i+1,qffConstants->firstDipolesInput[i][xyz], qffConstants->firstDipoles[i][xyz]);
			fprintf(file,"%s",tmp);   
		}
		fprintf(file,"%s","END\n\n");
	}

	sprintf(tmp,"#xyz\ti\tj\tValues[au cm]\n");
	fprintf(file,"%s",tmp);   
	fprintf(file,"%s","Second derivatives\n");
	for(i=0;i<nf;i++)
	for(j=0;j<nf;j++)
	for(xyz=0;xyz<3;xyz++)
	{
		if(fabs(qffConstants->secondDipoles[i][j][xyz])<1e-12) continue;
		sprintf(tmp,"%c\t%d\t%d\t%14.6f\n",txyz[xyz], i+1,j+1,qffConstants->secondDipoles[i][j][xyz]);
		fprintf(file,"%s",tmp);   
	}
	fprintf(file,"%s","END\n\n");

	sprintf(tmp,"#xyz\ti\tj\tk\tValues[au cm^3/2]\n");
	fprintf(file,"%s",tmp);   
	fprintf(file,"%s","Cubic derivatives\n");
	for(i=0;i<nf;i++)
	for(j=0;j<nf;j++)
	for(xyz=0;xyz<3;xyz++)
	{
		if(fabs(qffConstants->cubicDipoles[i][j][xyz])<1e-12) continue;
		sprintf(tmp,"%c\t%d\t%d\t%d\t%14.6f\n",txyz[xyz], i+1,i+1,j+1,qffConstants->cubicDipoles[i][j][xyz]);
		fprintf(file,"%s",tmp);   
		if(i!=j)
		{
			sprintf(tmp,"%c\t%d\t%d\t%d\t%14.6f\n",txyz[xyz], i+1,j+1,i+1,qffConstants->cubicDipoles[i][j][xyz]);
			fprintf(file,"%s",tmp);   
			sprintf(tmp,"%c\t%d\t%d\t%d\t%14.6f\n",txyz[xyz], j+1,i+1,i+1,qffConstants->cubicDipoles[i][j][xyz]);
			fprintf(file,"%s",tmp);   
		}
	}
	fprintf(file,"%s","END\n\n");

}
/********************************************************************************/
static char* printnMRQFF(NMRQFF* qffConstants, char* inputFileName)
{
	char* fileNameOut = strdup_printf("%sQFF.txt",getSuffixNameFile(inputFileName));
	FILE* file = fopen(fileNameOut,"w");
	fprintf(stdout,"QFF parameters saved in %s file\n", fileNameOut);
	saveNMRQFF(qffConstants,file);
	fclose(file);
	return (fileNameOut);
}
/************************************************************************************************************/
static boolean readFrequenciesInitNMRQFF(FILE* file, NMRQFF* qffConstants)
{
	char t[BSIZE];
 	int nf = 0;
	boolean Ok = TRUE;
	int nn=1;
	double dum;
	int i;
	int order = 2;
	

	if(!goToStr(file, "Frequencies"))
	{
		fprintf(stderr,"I cannot read the harmonic frequencies\nChech your input file\n");
		return FALSE;
	}
	while(!feof(file))
	{
		if(!fgets(t,BSIZE,file))break;
		nn = sscanf(t,"%lf",&dum);
		if(nn<1) break;
		nf++;
	}
	if(nf==0)
	{
		fprintf(stderr,"I cannot read the harmonic frequencies\nChech your input file\n");
		return FALSE;
	}
	readOneInt(file,"QFFnModes",&order);
	initnMRQFF0(qffConstants,nf);
	rewind(file);
	goToStr(file, "Frequencies");
	for(i=0;i<nf;i++)
	{
		if(!fgets(t,BSIZE,file))break;
		nn = sscanf(t,"%lf",&qffConstants->frequencies[i]);
		if(nn<1) break;
	}
	qffConstants->numberOfFirstDipolesInput = 0;
	if(nn==1)
	{
		rewind(file);
		if(goToStr(file, "First derivatives"))
		for(i=0;i<nf && nn==1 ;i++)
		{
			int xyz;
			for(xyz=0;xyz<3 && nn==1 ;xyz++)
				nn = fscanf(file,"%lf",&qffConstants->firstDipolesInput[i][xyz]);
			qffConstants->numberOfFirstDipolesInput+= nn;
		}
		if(qffConstants->numberOfFirstDipolesInput != nf) qffConstants->numberOfFirstDipolesInput=0;
	}
	if(nn!=1) Ok = FALSE;
	return Ok;
}
/************************************************************************************************************/
static boolean readVectorRealQFF(FILE* file, char* tag, int n, double* values)
{
        char* TAG = NULL;
        int i=0;
	int nn = 0;
        if(!tag) return FALSE;
        if(!values) return FALSE;

        TAG = strdup(tag);
        uppercase(TAG);
        rewind(file);
	if(!goToStr(file, TAG)) 
	{
		fprintf(stderr,"I cannot find %s in our file\n",tag);
		if(TAG) free(TAG);
		return FALSE;
	}
	for(i=0;i<n;i++)
        {
		nn = fscanf(file,"%lf",&values[i]);
                if(nn!=1) break;
        }
	if(i!=n)
	{
		fprintf(stderr,"I cannot read %s\nCheck  the number of values\n",tag);
		return FALSE;
	}
	return TRUE;
}
/************************************************************************************************************/
static int getOrdre(int f, int nGeoms)
{
	int order = -1;
	if(nGeoms == 1 + 6*f) order = 1;
	if(nGeoms == 1 + 6*f+6*f*(f-1) ) order = 2;
	if(nGeoms == 1 + 6*f+6*f*(f-1) + 8*f*(f-1)*(f-2)/6 ) order = 3;
	if(nGeoms == 1 + 6*f+6*f*(f-1) + 8*f*(f-1)*(f-2)/6 + 16*f*(f-1)*(f-2)*(f-3)/24) order = 4;
	if(order<1)
	{
		printf("nModes = %d\n",order);
               	fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
               	fprintf(stderr,"Error, the number of files does not correspond to any known nMode (1,2,3,or4)\n");
               	fprintf(stderr,"Check the number of *QFF_*.gab files or the number of energies in your input file\n");
               	fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
               	exit(1);
	}
	return order;
}
/************************************************************************************************************/
static int readEnergiesAndDipoles(char* fileName, double* energies[], double* dipoles[])
{
	int n=1;
	int xyz;
        char* TAG = NULL;
	int nGeoms = 0;
	int index = 0;
	int nDipoles = 0;
	FILE* file = fopen(fileName,"rb");
        TAG = strdup("ENERGIES");
        uppercase(TAG);
        rewind(file);
	if(!goToStr(file, TAG)) 
	{
		fprintf(stderr,"I cannot find %s in our file\n",TAG);
		if(TAG) free(TAG);
		return FALSE;
	}

        // computes the number of geometries 
        nGeoms = 0;
        for(index=0; ;index++)
        {
		double e;
		n = fscanf(file,"%lf",&e);
                if(n<1) break;
                nGeoms++;
        }
        if(nGeoms<1)
        {
                fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
                fprintf(stderr,"I cannot read energies from %s file\n", fileName);
                fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
                exit(1);
        }
	printf("nGeoms = %d\n",nGeoms);
        rewind(file);
	goToStr(file, TAG);
        energies[0] = malloc(nGeoms*sizeof(double));
        for(index=0;index<nGeoms ;index++)
        {
		double e;
		n = fscanf(file,"%lf",&e);
                if(n<1) break;
                energies[0][index] = e;
        }
	free(TAG);
        TAG = strdup("DIPOLES");
        uppercase(TAG);
        rewind(file);
	if(!goToStr(file, TAG)) 
	{
		fprintf(stderr,"I cannot find %s in our file\n",TAG);
		if(TAG) free(TAG);
		return 0;
	}
	nDipoles = 0;
        for(index=0; ;index++)
        {
		double e;
		n = 1;
		for(xyz=0;xyz<3 && n==1;xyz++)
		{
			n = fscanf(file,"%lf",&e);
                	if(n<1) break;
			nDipoles++;
		}
		if(n<1) break;
        }
	nDipoles /= 3;
        if(nGeoms!=nDipoles)
        {
                fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
                fprintf(stderr,"Error : number of dipoles != number of geometries in %s file\n",fileName);
                fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
                exit(1);
        }
	printf("nDipoles  = %d\n",nDipoles);
        rewind(file);
	goToStr(file, TAG);
	for(xyz=0;xyz<3;xyz++) dipoles[xyz] = malloc(nGeoms*sizeof(double));
        for(index=0;index<nGeoms ;index++)
        {
		double e;
		n = 1;
		for(xyz=0;xyz<3 && n==1;xyz++)
		{
			n = fscanf(file,"%lf",&e);
                	if(n<1) break;
			dipoles[xyz][index] = e;
		}
		if(n<1) break;
        }
	fclose(file);
	return nGeoms;
}
/************************************************************************************************************/
static void computeGradients(NMRQFF* qffConstants)
{
 	int nf = qffConstants->numberOfFrequencies;
	int i;
	for(i=0;i<nf;i++)
	{
		double di = qffConstants->delta[i]*sqrt(qffConstants->mass[i]*AMUTOAU);
		qffConstants->gradients[i]=(
				+qffConstants->VI[i][0]+
				-9*qffConstants->VI[i][1]+
				+45*qffConstants->VI[i][2]+
				-45*qffConstants->VI[i][3]+
				+9*qffConstants->VI[i][4]
				-qffConstants->VI[i][5]
				)/(60.0*di);
	}
}
/************************************************************************************************************/
static void computeFrequencies(NMRQFF* qffConstants)
{
 	int nf = qffConstants->numberOfFrequencies;
	int i;
	for(i=0;i<nf;i++)
	{
		double di = qffConstants->delta[i]*qffConstants->delta[i]*AMUTOAU*qffConstants->mass[i];
		double f = 1/di/180;
		qffConstants->calculatedFrequencies[i]=AUTOCM1*sqrt(f*fabs((
		2*qffConstants->VI[i][0]+
		-27*qffConstants->VI[i][1]+
		+270*qffConstants->VI[i][2]+
		-490*qffConstants->V0+
		+270*qffConstants->VI[i][3]+
		-27*qffConstants->VI[i][4]+
		2*qffConstants->VI[i][5]
		)));
		/*
		qffConstants->calculatedFrequencies[i]=sqrt(fabs((
		  qffConstants->VI[i][2]
		- 2*qffConstants->V0
		+ qffConstants->VI[i][3]
		)
		/di))*AUTOCM1;
		*/
	}
}
/************************************************************************************************************/
static void computeCubicForces(NMRQFF* qffConstants)
{
 	int nf = qffConstants->numberOfFrequencies;
	int i,j,k;
	double f3cm1 = AUTOCM1*sqrt(AUTOCM1)*AUTOCM1;
	if(nf<1) return;
	// tiii

	for(i=0;i<nf;i++)
	{
		double mi = sqrt(qffConstants->mass[i]*AMUTOAU);
		double f = 1.0/(8.0*qffConstants->delta[i]*qffConstants->delta[i]*qffConstants->delta[i]*mi*mi*mi);
		f = f/qffConstants->frequencies[i]/sqrt(qffConstants->frequencies[i])*f3cm1;
		qffConstants->cubicEnergies[i][i] = f*(-qffConstants->VI[i][0]+8*qffConstants->VI[i][1]-13*qffConstants->VI[i][2]+13*qffConstants->VI[i][3]-8*qffConstants->VI[i][4]+qffConstants->VI[i][5]);
		/*
		double mi = sqrt(qffConstants->mass[i]);
		double f = 1.0/(2.0*qffConstants->delta[i]*qffConstants->delta[i]*qffConstants->delta[i]*mi*mi*mi);
		qffConstants->cubicEnergies[i][i] = f*(-1*qffConstants->VI[i][1]+2*qffConstants->VI[i][2]-2*qffConstants->VI[i][3]+1*qffConstants->VI[i][4]);
		*/
	}
	// tiij
	if(qffConstants->numberOfEnergies > 1+6*nf)
	for(i=0;i<nf;i++)
	{
		double fi = 1.0/(2.0*qffConstants->delta[i]*qffConstants->delta[i]*qffConstants->mass[i]*AMUTOAU);
		fi = fi/qffConstants->frequencies[i];
		for(j=0;j<nf;j++)
		{
			double fj,f;
			if(j==i) continue;
			fj = 1.0/(qffConstants->delta[j]*sqrt(qffConstants->mass[j]*AMUTOAU));
			fj = fj/sqrt(qffConstants->frequencies[j]);
			f = fi*fj*f3cm1;
			qffConstants->cubicEnergies[i][j] = f*(
				 (qffConstants->VIJ[i][j][0]+qffConstants->VIJ[i][j][2]-2*qffConstants->VI[j][2])
				-(qffConstants->VIJ[i][j][1]+qffConstants->VIJ[i][j][3]-2*qffConstants->VI[j][3])
			);

		}
	}
	// tijk , i # j # k
	if(qffConstants->numberOfEnergies > 1+6*nf*nf)
	{
	FILE* fileVIJK = fopen("VIJK.bin","rb");
	for(i=0;i<nf;i++)
	{
		double fi;
		fi = 1.0/(qffConstants->delta[i]*sqrt(qffConstants->mass[i]*AMUTOAU));
		fi = fi/sqrt(qffConstants->frequencies[i]);
		for(j=0;j<i;j++)
		{
			double fj;
			fj = 1.0/(qffConstants->delta[j]*sqrt(qffConstants->mass[j]*AMUTOAU));
			fj = fj/sqrt(qffConstants->frequencies[j]);
			for(k=0;k<j;k++)
			{
				double VIJK[8];
				int l;
				double fk,f;
				fk = 1.0/(qffConstants->delta[k]*sqrt(qffConstants->mass[k]*AMUTOAU));
				fk = fk/sqrt(qffConstants->frequencies[k]);
				f = fi*fj*fk/8;
				f =f*f3cm1;

				for(l=0;l<8;l++) fread(&VIJK[l], sizeof(double), 1, fileVIJK);
				/* VIJK */
				/* 0  deltas[j],   deltas[i],  deltas[k] */
				/* 1  deltas[j],   deltas[i], -deltas[k] */
				/* 2  deltas[j],  -deltas[i],  deltas[k] */
				/* 3  deltas[j],  -deltas[i], -deltas[k] */
				/* 4 -deltas[j],  deltas[i],  deltas[k] */
				/* 5 -deltas[j],  deltas[i], -deltas[k] */
				/* 6 -deltas[j], -deltas[i],  deltas[k] */
				/* 7 -deltas[j], -deltas[i], -deltas[k] */
				qffConstants->cubicEnergiesIJK[i][j][k] = f*(
				+VIJK[0]
				-VIJK[1]
				-VIJK[2]
				+VIJK[3]
				-VIJK[4]
				+VIJK[5]
				+VIJK[6]
				-VIJK[7]
				/*
				+qffConstants->VIJK[i][j][k][0]
				-qffConstants->VIJK[i][j][k][1]
				-qffConstants->VIJK[i][j][k][2]
				+qffConstants->VIJK[i][j][k][3]
				-qffConstants->VIJK[i][j][k][4]
				+qffConstants->VIJK[i][j][k][5]
				+qffConstants->VIJK[i][j][k][6]
				-qffConstants->VIJK[i][j][k][7]
				*/
				);
			}
		}
	}
	fclose(fileVIJK);
	}
}
/************************************************************************************************************/
static void computeQuarticForces(NMRQFF* qffConstants)
{
 	int nf = qffConstants->numberOfFrequencies;
	double f4cm1 = AUTOCM1*AUTOCM1*AUTOCM1;
	int i,j,k,l;
	if(nf<1) return;

	// uiiii
	for(i=0;i<nf;i++)
	{
		double mdi = sqrt(qffConstants->mass[i]*AMUTOAU)*qffConstants->delta[i];
		double f = 1.0/(6.0*mdi*mdi*mdi*mdi)*f4cm1;
		f = f/(qffConstants->frequencies[i]*qffConstants->frequencies[i]);
		qffConstants->quarticEnergiesIIJJ[i][i] = f*(
		-qffConstants->VI[i][0]
		+12*qffConstants->VI[i][1]
		-39*qffConstants->VI[i][2]
		+56*qffConstants->V0
		-39*qffConstants->VI[i][3]
		+12*qffConstants->VI[i][4]
		-qffConstants->VI[i][5]
		);
		/*
		double f = 1.0/(mdi*mdi*mdi*mdi)*f4cm1;
		f = f/(qffConstants->frequencies[i]*qffConstants->frequencies[i]);
		qffConstants->quarticEnergiesIIJJ[i][i] = f*(
		qffConstants->VI[i][1]
		-4*qffConstants->VI[i][2]
		+6*qffConstants->V0
		-4*qffConstants->VI[i][3]
		+qffConstants->VI[i][4]
		);
		*/
		qffConstants->quarticEnergiesIIIJ[i][i] = qffConstants->quarticEnergiesIIJJ[i][i];
	}
	// uiiij
	if(qffConstants->numberOfEnergies > 1+6*nf)
	for(i=0;i<nf;i++)
	{
		double mdi = sqrt(qffConstants->mass[i]*AMUTOAU)*qffConstants->delta[i];
		double fi = 1.0/(16.0*mdi*mdi*mdi);
		fi = fi/(qffConstants->frequencies[i]*sqrt(qffConstants->frequencies[i]));
		for(j=0;j<nf;j++)
		{
			double fj,f;
			if(j==i) continue;
			fj = 1.0/(qffConstants->delta[j]*sqrt(qffConstants->mass[j]*AMUTOAU));
			fj = fj/(sqrt(qffConstants->frequencies[j]));
			f = fi*fj*f4cm1;
			qffConstants->quarticEnergiesIIIJ[i][j] = f*(
				 (qffConstants->VI3J[i][j][0]-3*qffConstants->VIJ[i][j][0]+3*qffConstants->VIJ[i][j][2]-qffConstants->VI3J[i][j][2])
				-(qffConstants->VI3J[i][j][1]-3*qffConstants->VIJ[i][j][1]+3*qffConstants->VIJ[i][j][3]-qffConstants->VI3J[i][j][3])
			);
		}
	}
//printf("UIIJJ======================\n");
	// uiijj
	if(qffConstants->numberOfEnergies > 1+6*nf)
	for(i=0;i<nf;i++)
	{
		double mdi = qffConstants->mass[i]*AMUTOAU*qffConstants->delta[i]*qffConstants->delta[i];
		for(j=0;j<i;j++)
		{
			double mdj = qffConstants->mass[j]*AMUTOAU*qffConstants->delta[j]*qffConstants->delta[j];
			double f = 1.0/(mdi*mdj)*f4cm1;
			f = f/(qffConstants->frequencies[i]*qffConstants->frequencies[j]);

			qffConstants->quarticEnergiesIIJJ[i][j] = f*(
				   (qffConstants->VIJ[i][j][0]+qffConstants->VIJ[i][j][2]+qffConstants->VIJ[i][j][1]+qffConstants->VIJ[i][j][3])
				-2*(qffConstants->VI[i][2]+qffConstants->VI[i][3]+qffConstants->VI[j][2]+qffConstants->VI[j][3])
				+4*qffConstants->V0
			);
			qffConstants->quarticEnergiesIIJJ[j][i] = qffConstants->quarticEnergiesIIJJ[i][j];
		}
	}
	// uiijk i # j # k
	if(qffConstants->numberOfEnergies > 1+6*nf*nf)
	{
	FILE* fileVIJK = fopen("VIJK.bin","rb");
	for(i=0;i<nf;i++)
	{
		double mdi = sqrt(qffConstants->mass[i]*AMUTOAU)*qffConstants->delta[i];
		double fi = 1.0/(4.0*mdi*mdi);
		fi = fi/(qffConstants->frequencies[i]*sqrt(qffConstants->frequencies[i]));
		for(j=0;j<i;j++)
		{
			double fj;
			fj = 1.0/(qffConstants->delta[j]*sqrt(qffConstants->mass[j]*AMUTOAU));
			fj = fj/(sqrt(qffConstants->frequencies[j]));
			for(k=0;k<j;k++)
			{
				double VIJK[8];
				int l;
				double fk,f;
				fk = 1.0/(qffConstants->delta[k]*sqrt(qffConstants->mass[k]*AMUTOAU));
				fk = fk/(sqrt(qffConstants->frequencies[k]));
				f = fi*fj*fk*f4cm1;

				for(l=0;l<8;l++) fread(&VIJK[l], sizeof(double), 1, fileVIJK);
				/* VIJK */
				/* 0  deltas[j],   deltas[i],  deltas[k] */
				/* 1  deltas[j],   deltas[i], -deltas[k] */
				/* 2  deltas[j],  -deltas[i],  deltas[k] */
				/* 3  deltas[j],  -deltas[i], -deltas[k] */
				/* 4 -deltas[j],  deltas[i],  deltas[k] */
				/* 5 -deltas[j],  deltas[i], -deltas[k] */
				/* 6 -deltas[j], -deltas[i],  deltas[k] */
				/* 7 -deltas[j], -deltas[i], -deltas[k] */

				/* VIJ */
				/*  0  deltas[j],   deltas[i] */
				/*  1  deltas[j],  -deltas[i] */
				/*  2 -deltas[j],   deltas[i] */
				/*  3 -deltas[j],  -deltas[i] */
				qffConstants->quarticEnergiesIIJK[i][j][k] = 
				f*(
				+VIJK[0]
				-VIJK[2]
				-VIJK[1]
				+VIJK[3]
				+VIJK[4]
				-VIJK[6]
				-VIJK[5]
				+VIJK[7]
				/*
				+qffConstants->VIJK[i][j][k][0]
				-qffConstants->VIJK[i][j][k][2]
				-qffConstants->VIJK[i][j][k][1]
				+qffConstants->VIJK[i][j][k][3]
				+qffConstants->VIJK[i][j][k][4]
				-qffConstants->VIJK[i][j][k][6]
				-qffConstants->VIJK[i][j][k][5]
				+qffConstants->VIJK[i][j][k][7]
				*/
				-2*(qffConstants->VIJ[i][j][0] - qffConstants->VIJ[i][j][2] - qffConstants->VIJ[i][j][1] + qffConstants->VIJ[i][j][3])
				);
			}
		}
	}
	fclose(fileVIJK);
	}
	// uijkl i # j # k # l
	if(qffConstants->numberOfEnergies > 1+6*nf*nf+8*nf*(nf-1)*(nf-2)/6)
	for(i=0;i<nf;i++)
	{
		double fi;
		fi = 1.0/(qffConstants->delta[i]*sqrt(qffConstants->mass[i]*AMUTOAU));
		fi = fi/(sqrt(qffConstants->frequencies[i]));
		for(j=0;j<i;j++)
		{
			double fj;
			fj = 1.0/(qffConstants->delta[j]*sqrt(qffConstants->mass[j]*AMUTOAU));
			fj = fj/(sqrt(qffConstants->frequencies[j]));
			for(k=0;k<j;k++)
			{
				double fk;
				fk = 1.0/(qffConstants->delta[k]*sqrt(qffConstants->mass[k]*AMUTOAU));
				fk = fk/(sqrt(qffConstants->frequencies[k]));
				for(l=0;l<k;l++)
				{
				double fl,f;
				fl = 1.0/(qffConstants->delta[l]*sqrt(qffConstants->mass[l]*AMUTOAU));
				f = fi*fj*fk*fl*f4cm1;
				f = f/16.0;
				/* VIJKL */
				/* 0    deltas[j],   deltas[i],   deltas[k],  deltas[l] */ //+
				/* 1    deltas[j],   deltas[i],   deltas[k], -deltas[l] */ //-
				/* 2    deltas[j],   deltas[i],  -deltas[k],  deltas[l] */ //-
				/* 3    deltas[j],   deltas[i],  -deltas[k], -deltas[l] */ //+
				/* 4    deltas[j],  -deltas[i],   deltas[k],  deltas[l] */ //-
				/* 5    deltas[j],  -deltas[i],   deltas[k], -deltas[l] */ //+
				/* 6    deltas[j],  -deltas[i],  -deltas[k],  deltas[l] */ //+
				/* 7    deltas[j],  -deltas[i],  -deltas[k], -deltas[l] */ //-
				/* 8   -deltas[j],   deltas[i],   deltas[k],  deltas[l] */ //-
				/* 9   -deltas[j],   deltas[i],   deltas[k], -deltas[l] */ //+
				/* 10  -deltas[j],   deltas[i],  -deltas[k],  deltas[l] */ //+
				/* 11  -deltas[j],   deltas[i],  -deltas[k], -deltas[l] */ //-
				/* 12  -deltas[j],  -deltas[i],   deltas[k],  deltas[l] */ //+
				/* 13  -deltas[j],  -deltas[i],   deltas[k], -deltas[l] */ //-
				/* 14  -deltas[j],  -deltas[i],  -deltas[k],  deltas[l] */ //-
				/* 15  -deltas[j],  -deltas[i],  -deltas[k], -deltas[l] */ //+

				qffConstants->quarticEnergiesIJKL[i][j][k][l]= 
				f*(
				+qffConstants->VIJKL[i][j][k][l][0]
				-qffConstants->VIJKL[i][j][k][l][1]
				-qffConstants->VIJKL[i][j][k][l][2]
				+qffConstants->VIJKL[i][j][k][l][3]
				-qffConstants->VIJKL[i][j][k][l][4]
				+qffConstants->VIJKL[i][j][k][l][5]
				+qffConstants->VIJKL[i][j][k][l][6]
				-qffConstants->VIJKL[i][j][k][l][7]
				-qffConstants->VIJKL[i][j][k][l][8]
				+qffConstants->VIJKL[i][j][k][l][9]
				+qffConstants->VIJKL[i][j][k][l][10]
				-qffConstants->VIJKL[i][j][k][l][11]
				+qffConstants->VIJKL[i][j][k][l][12]
				-qffConstants->VIJKL[i][j][k][l][13]
				-qffConstants->VIJKL[i][j][k][l][14]
				+qffConstants->VIJKL[i][j][k][l][15]
				);
				}
			}
		}
	}
}
/************************************************************************************************************/
static void computeFirstDerivativesDipoles(NMRQFF* qffConstants)
{
 	int nf = qffConstants->numberOfFrequencies;
	int i;
	int xyz = 0;
	for(i=0;i<nf;i++)
	{
		double di = 60*qffConstants->delta[i]*sqrt(qffConstants->mass[i]*AMUTOAU);
		double f = 1/di;
		f =f*sqrt(AUTOCM1);
		for(xyz=0;xyz<3;xyz++)
			qffConstants->firstDipoles[i][xyz]=f*(
				+qffConstants->dipolesI[i][0][xyz]+
				-9*qffConstants->dipolesI[i][1][xyz]+
				+45*qffConstants->dipolesI[i][2][xyz]+
				-45*qffConstants->dipolesI[i][3][xyz]+
				+9*qffConstants->dipolesI[i][4][xyz]
				-qffConstants->dipolesI[i][5][xyz]
				);
	}
}
/************************************************************************************************************/
static void changeUnitInputFirstDerivativesDipoles(NMRQFF* qffConstants)
{
        double mu0 = 4*PI*1e-7;
        double eps0 = 1.0/(mu0*slight*slight);
        double   kmmolm1 = 4*PI*PI*PI*NAvogadro/3/hPlank/slight/4/PI/eps0*1e-3*100.0*8.47835267e-30*8.47835267e-30;/* 1e-3 m to km, 100 : cm-1 to m-1 */
	double f = 1.0/sqrt(kmmolm1);

        int nf = qffConstants->numberOfFrequencies;
        int i;
        int xyz = 0;
	if(qffConstants->numberOfFirstDipolesInput==0) return;
        for(i=0;i<nf;i++)
        {
                for(xyz=0;xyz<3;xyz++)
                        qffConstants->firstDipolesInput[i][xyz] *=f;
        }
}
/************************************************************************************************************/
static void computeSecondDerivativesDipoles(NMRQFF* qffConstants)
{
 	int nf = qffConstants->numberOfFrequencies;
	int i;
	int j;
	int xyz = 0;
	// dii
	for(i=0;i<nf;i++)
	{
		double di = qffConstants->delta[i]*qffConstants->delta[i]*AMUTOAU*qffConstants->mass[i];
		double f = 1/(180*di);
		f =f*(AUTOCM1);
		for(xyz=0;xyz<3;xyz++)
			qffConstants->secondDipoles[i][i][xyz]=f*(
				 2*qffConstants->dipolesI[i][0][xyz]
				-27*qffConstants->dipolesI[i][1][xyz]
				+270*qffConstants->dipolesI[i][2][xyz]
				-490*qffConstants->dipole0[xyz]
				+270*qffConstants->dipolesI[i][3][xyz]
				-27*qffConstants->dipolesI[i][4][xyz]
				+2*qffConstants->dipolesI[i][5][xyz]
				);
			/*
			qffConstants->secondDipoles[i][i][xyz]=180*f*(
				+qffConstants->dipolesI[i][2][xyz]
				-2*qffConstants->dipole0[xyz]
				+qffConstants->dipolesI[i][3][xyz]
				);
			*/
	}
	// dij
	if(qffConstants->numberOfEnergies > 1+6*nf)
	for(i=0;i<nf;i++)
	{
		double di = qffConstants->delta[i]*sqrt(qffConstants->mass[i]*AMUTOAU);
		for(j=0;j<nf;j++)
		{
			double dj = qffConstants->delta[j]*sqrt(qffConstants->mass[j]*AMUTOAU);
			double f = 1.0/(4.0*di*dj);
			if(i==j) continue;
			f =f*AUTOCM1;
			for(xyz=0;xyz<3;xyz++)
				qffConstants->secondDipoles[i][j][xyz]=f*(
				  qffConstants->dipolesIJ[i][j][0][xyz]
				- qffConstants->dipolesIJ[i][j][1][xyz]
				- qffConstants->dipolesIJ[i][j][2][xyz]
				+ qffConstants->dipolesIJ[i][j][3][xyz]
				);
			//for(xyz=0;xyz<3;xyz++)
				//qffConstants->secondDipoles[j][i][xyz]=qffConstants->secondDipoles[i][j][xyz];
		}
	}
}
/************************************************************************************************************/
static void computeCubicDerivativesDipoles(NMRQFF* qffConstants)
{
 	int nf = qffConstants->numberOfFrequencies;
	int i,j,k;
	int xyz;
	if(nf<1) return;
	// diii
	for(i=0;i<nf;i++)
	{
		double mi = sqrt(qffConstants->mass[i]*AMUTOAU);
		double f = 1.0/(8.0*qffConstants->delta[i]*qffConstants->delta[i]*qffConstants->delta[i]*mi*mi*mi);
		f =f*AUTOCM1*sqrt(AUTOCM1);
		for(xyz=0;xyz<3;xyz++)
			qffConstants->cubicDipoles[i][i][xyz] = f*
			(
			-   qffConstants->dipolesI[i][0][xyz]
			+8* qffConstants->dipolesI[i][1][xyz]
			-13*qffConstants->dipolesI[i][2][xyz]
			+13*qffConstants->dipolesI[i][3][xyz]
			-8* qffConstants->dipolesI[i][4][xyz]
			+   qffConstants->dipolesI[i][5][xyz]
			);
		//qffConstants->cubicDipoles[i][i][xyz] = f*(qffConstants->dipolesI[i][0][xyz]-3*qffConstants->dipolesI[i][2][xyz]+3*qffConstants->dipolesI[i][3][xyz]-qffConstants->dipolesI[i][5][xyz]);
	}
	// diij
	if(qffConstants->numberOfEnergies > 1+6*nf)
	for(i=0;i<nf;i++)
	{
		double fi = 1.0/(2.0*qffConstants->delta[i]*qffConstants->delta[i]*qffConstants->mass[i]*AMUTOAU);
		for(j=0;j<nf;j++)
		{
			double fj,f;
			if(j==i) continue;
			fj = 1.0/(qffConstants->delta[j]*sqrt(qffConstants->mass[j]*AMUTOAU));
			f = fi*fj;
			f =f*AUTOCM1*sqrt(AUTOCM1);
			for(xyz=0;xyz<3;xyz++)
				qffConstants->cubicDipoles[i][j][xyz] = f*(
				 (qffConstants->dipolesIJ[i][j][0][xyz]+qffConstants->dipolesIJ[i][j][2][xyz]-2*qffConstants->dipolesI[j][2][xyz])
				-(qffConstants->dipolesIJ[i][j][1][xyz]+qffConstants->dipolesIJ[i][j][3][xyz]-2*qffConstants->dipolesI[j][3][xyz])
			);
		}
	}
	// dijk , i # j # k
	if(qffConstants->numberOfEnergies > 1+6*nf*nf)
	{
	FILE* fileDIJK = fopen("DIJK.bin","rb");
	for(i=0;i<nf;i++)
	{
		double fi;
		fi = 1.0/(qffConstants->delta[i]*sqrt(qffConstants->mass[i]*AMUTOAU));
		for(j=0;j<i;j++)
		{
			double fj;
			fj = 1.0/(qffConstants->delta[j]*sqrt(qffConstants->mass[j]*AMUTOAU));
			for(k=0;k<j;k++)
			{
				double fk,f;
				fk = 1.0/(qffConstants->delta[k]*sqrt(qffConstants->mass[k]*AMUTOAU));
				f = fi*fj*fk/8;
				f =f*AUTOCM1*sqrt(AUTOCM1);
				/* VIJK */
				/* 0  deltas[j],   deltas[i],  deltas[k] */
				/* 1  deltas[j],   deltas[i], -deltas[k] */
				/* 2  deltas[j],  -deltas[i],  deltas[k] */
				/* 3  deltas[j],  -deltas[i], -deltas[k] */
				/* 4 -deltas[j],  deltas[i],  deltas[k] */
				/* 5 -deltas[j],  deltas[i], -deltas[k] */
				/* 6 -deltas[j], -deltas[i],  deltas[k] */
				/* 7 -deltas[j], -deltas[i], -deltas[k] */
				double dipolesIJK[8][3];
				int l;
				for(l=0;l<8;l++) 
				for(xyz=0;xyz<3;xyz++)
					fread(&dipolesIJK[l][xyz], sizeof(double), 1, fileDIJK);

				for(xyz=0;xyz<3;xyz++)
				{

				qffConstants->cubicDipolesIJK[i][j][k][xyz] = f*(
				+dipolesIJK[0][xyz]
				-dipolesIJK[1][xyz]
				-dipolesIJK[2][xyz]
				+dipolesIJK[3][xyz]
				-dipolesIJK[4][xyz]
				+dipolesIJK[5][xyz]
				+dipolesIJK[6][xyz]
				-dipolesIJK[7][xyz]
				/*
				+qffConstants->dipolesIJK[i][j][k][0][xyz]
				-qffConstants->dipolesIJK[i][j][k][1][xyz]
				-qffConstants->dipolesIJK[i][j][k][2][xyz]
				+qffConstants->dipolesIJK[i][j][k][3][xyz]
				-qffConstants->dipolesIJK[i][j][k][4][xyz]
				+qffConstants->dipolesIJK[i][j][k][5][xyz]
				+qffConstants->dipolesIJK[i][j][k][6][xyz]
				-qffConstants->dipolesIJK[i][j][k][7][xyz]
				*/
				);
				}
			}
		}
	}
	fclose(fileDIJK);
	for(j=0;j<nf;j++)
	{
		for(i=0;i<j;i++)
		{
			for(k=0;k<i;k++)
			{
				for(xyz=0;xyz<3;xyz++)
                		{
					qffConstants->cubicDipolesIJK[i][j][k][xyz] = qffConstants->cubicDipolesIJK[j][i][k][xyz];
					qffConstants->cubicDipolesIJK[i][k][j][xyz] = qffConstants->cubicDipolesIJK[j][i][k][xyz];
					qffConstants->cubicDipolesIJK[j][k][i][xyz] = qffConstants->cubicDipolesIJK[j][i][k][xyz];
					qffConstants->cubicDipolesIJK[k][i][j][xyz] = qffConstants->cubicDipolesIJK[j][i][k][xyz];
					qffConstants->cubicDipolesIJK[k][j][i][xyz] = qffConstants->cubicDipolesIJK[j][i][k][xyz];
                		}
			}
		}
	}
	}
}
/************************************************************************************************************/
static void computeQuarticDerivativesDipoles(NMRQFF* qffConstants)
{
 	int nf = qffConstants->numberOfFrequencies;
	int i,j,k;
	int xyz;
	if(nf<1) return;

	// diiii
	for(i=0;i<nf;i++)
	{
		double mdi = sqrt(qffConstants->mass[i]*AMUTOAU)*qffConstants->delta[i];
		double f = 1.0/(6*mdi*mdi*mdi*mdi);
		f =f*AUTOCM1*AUTOCM1;
		for(xyz=0;xyz<3;xyz++)
		{
			qffConstants->quarticDipolesIIJJ[i][i][xyz] = f*(
		   	-qffConstants->dipolesI[i][0][xyz]
		   	+12*qffConstants->dipolesI[i][1][xyz]
			-39*qffConstants->dipolesI[i][2][xyz]
			+56*qffConstants->dipole0[xyz]
			-39*qffConstants->dipolesI[i][3][xyz]
			+12*qffConstants->dipolesI[i][4][xyz]
			-qffConstants->dipolesI[i][5][xyz]);
			qffConstants->quarticDipolesIIIJ[i][i][xyz] = qffConstants->quarticDipolesIIJJ[i][i][xyz];
		}
	}
	// diiij
	if(qffConstants->numberOfEnergies > 1+6*nf)
	for(i=0;i<nf;i++)
	{
		double mdi = sqrt(qffConstants->mass[i]*AMUTOAU)*qffConstants->delta[i];
		double fi = 1.0/(16.0*mdi*mdi*mdi);
		for(j=0;j<nf;j++)
		{
			double fj,f;
			if(j==i) continue;
			fj = 1.0/(qffConstants->delta[j]*sqrt(qffConstants->mass[j]*AMUTOAU));
			f = fi*fj;
			f =f*AUTOCM1*AUTOCM1;
			for(xyz=0;xyz<3;xyz++)
				qffConstants->quarticDipolesIIIJ[i][j][xyz] = f*(
				 (	qffConstants->dipolesI3J[i][j][0][xyz]
					-3*qffConstants->dipolesIJ[i][j][0][xyz]
					+3*qffConstants->dipolesIJ[i][j][2][xyz]
					-qffConstants->dipolesI3J[i][j][2][xyz]
				)
				-(
					qffConstants->dipolesI3J[i][j][1][xyz]
					-3*qffConstants->dipolesIJ[i][j][1][xyz]
					+3*qffConstants->dipolesIJ[i][j][3][xyz]
					-qffConstants->dipolesI3J[i][j][3][xyz]
				)
				);
		}
	}
	// diijj
	if(qffConstants->numberOfEnergies > 1+6*nf)
	for(i=0;i<nf;i++)
	{
		double mdi = qffConstants->mass[i]*AMUTOAU*qffConstants->delta[i]*qffConstants->delta[i];
		for(j=0;j<i;j++)
		{
			double mdj = qffConstants->mass[j]*AMUTOAU*qffConstants->delta[j]*qffConstants->delta[j];
			double f = 1.0/(mdi*mdj);
			f =f*AUTOCM1*AUTOCM1;
			for(xyz=0;xyz<3;xyz++)
			{
				qffConstants->quarticDipolesIIJJ[i][j][xyz] = f*(
				   (
					qffConstants->dipolesIJ[i][j][0][xyz]
					+qffConstants->dipolesIJ[i][j][2][xyz]
					+qffConstants->dipolesIJ[i][j][1][xyz]
					+qffConstants->dipolesIJ[i][j][3][xyz]
				   )
				-2*(
					qffConstants->dipolesI[i][2][xyz]
					+qffConstants->dipolesI[i][3][xyz]
					+qffConstants->dipolesI[j][2][xyz]
					+qffConstants->dipolesI[j][3][xyz]
				)
				+4*qffConstants->dipole0[xyz]
				);
				qffConstants->quarticDipolesIIJJ[j][i][xyz] = qffConstants->quarticDipolesIIJJ[i][j][xyz];
			}
		}
	}
	// diijk i # j # k
	if(qffConstants->numberOfEnergies > 1+6*nf*nf)
	{
	FILE* fileDIJK = fopen("DIJK.bin","rb");
	for(i=0;i<nf;i++)
	{
		double mdi = sqrt(qffConstants->mass[i]*AMUTOAU)*qffConstants->delta[i];
		double fi = 1.0/(4.0*mdi*mdi);
		for(j=0;j<i;j++)
		{
			double fj;
			fj = 1.0/(qffConstants->delta[j]*sqrt(qffConstants->mass[j]*AMUTOAU));
			for(k=0;k<j;k++)
			{
				double fk,f;
				fk = 1.0/(qffConstants->delta[k]*sqrt(qffConstants->mass[k]*AMUTOAU));
				f = fi*fj*fk;
				f =f*AUTOCM1*AUTOCM1;
				/* quarticDipolesIIJK */
				/* 0  deltas[j],   deltas[i],  deltas[k] */
				/* 1  deltas[j],   deltas[i], -deltas[k] */
				/* 2  deltas[j],  -deltas[i],  deltas[k] */
				/* 3  deltas[j],  -deltas[i], -deltas[k] */
				/* 4 -deltas[j],  deltas[i],  deltas[k] */
				/* 5 -deltas[j],  deltas[i], -deltas[k] */
				/* 6 -deltas[j], -deltas[i],  deltas[k] */
				/* 7 -deltas[j], -deltas[i], -deltas[k] */

				/* dipolesIJ */
				/*  0  deltas[j],   deltas[i] */
				/*  1  deltas[j],  -deltas[i] */
				/*  2 -deltas[j],   deltas[i] */
				/*  3 -deltas[j],  -deltas[i] */
				for(xyz=0;xyz<3;xyz++)
				{
					double dipolesIJK[8];
					int l;
					for(l=0;l<8;l++) fread(&dipolesIJK[l], sizeof(double), 1, fileDIJK);

					qffConstants->quarticDipolesIIJK[i][j][k][xyz] = f*
					(
				 	+dipolesIJK[0]
				 	-dipolesIJK[2]
				 	-dipolesIJK[1]
				 	+dipolesIJK[3]
				 	+dipolesIJK[4]
				 	-dipolesIJK[6]
				 	-dipolesIJK[5]
				 	+dipolesIJK[7]
					/*
				 	+qffConstants->dipolesIJK[i][j][k][0][xyz]
				 	-qffConstants->dipolesIJK[i][j][k][2][xyz]
				 	-qffConstants->dipolesIJK[i][j][k][1][xyz]
				 	+qffConstants->dipolesIJK[i][j][k][3][xyz]
				 	+qffConstants->dipolesIJK[i][j][k][4][xyz]
				 	-qffConstants->dipolesIJK[i][j][k][6][xyz]
				 	-qffConstants->dipolesIJK[i][j][k][5][xyz]
				 	+qffConstants->dipolesIJK[i][j][k][7][xyz]
					*/
					-2*(
					+qffConstants->dipolesIJ[i][j][0][xyz]
					-qffConstants->dipolesIJ[i][j][2][xyz]
					-qffConstants->dipolesIJ[i][j][1][xyz]
					+qffConstants->dipolesIJ[i][j][3][xyz]
					)
					);
				}
			}
		}
	}
	fclose(fileDIJK);
	for(j=0;j<nf;j++)
	{
		for(i=0;i<j;i++)
		{
			for(k=0;k<i;k++)
			{
				for(xyz=0;xyz<3;xyz++)
                		{
					qffConstants->quarticDipolesIIJK[i][j][k][xyz] = qffConstants->quarticDipolesIIJK[j][i][k][xyz];
					qffConstants->quarticDipolesIIJK[i][k][j][xyz] = qffConstants->quarticDipolesIIJK[j][i][k][xyz];
					qffConstants->quarticDipolesIIJK[j][k][i][xyz] = qffConstants->quarticDipolesIIJK[j][i][k][xyz];
					qffConstants->quarticDipolesIIJK[k][i][j][xyz] = qffConstants->quarticDipolesIIJK[j][i][k][xyz];
					qffConstants->quarticDipolesIIJK[k][j][i][xyz] = qffConstants->quarticDipolesIIJK[j][i][k][xyz];
                		}
			}
		}
	}
	}
}
/************************************************************************************************************/
char* computeQFFFromEnergiesDipolesFile(char* fileName)
{
	NMRQFF* qffConstants;
	boolean Ok = TRUE;
	FILE* file = NULL;
	int nGeoms = 0;
	int order = 0;
	double* energies = NULL;
	double* dipoles[] = { NULL, NULL, NULL};
	char* fileNameOut = NULL;

 	file = fopen(fileName, "rb"); 
        if(!file) 
	{
		fprintf(stderr,"I cannot open the %s file\n",fileName);
		return FALSE;
	}

	qffConstants = (NMRQFF*) malloc(sizeof(NMRQFF));
	qffConstants->numberOfFrequencies = 0;
	Ok =  readFrequenciesInitNMRQFF(file, qffConstants);
	if(Ok) Ok = readVectorRealQFF(file, "Mass", qffConstants->numberOfFrequencies, qffConstants->mass);
	if(Ok) Ok = readVectorRealQFF(file, "Delta", qffConstants->numberOfFrequencies, qffConstants->delta);

	
	printf("Begin readEnergiesAndDipoles\n");
	nGeoms = readEnergiesAndDipoles(fileName, &energies, dipoles);
	printf("End readEnergiesAndDipoles\n");
	order =  getOrdre(qffConstants->numberOfFrequencies, nGeoms);
        qffConstants->numberOfEnergies = nGeoms;
	computeQFFDerivativesEnergies(qffConstants, order, energies);
	printf("Energ computeQFFDerivativesEnergies\n");
	computeQFFDerivativesDipoles(qffConstants, order, dipoles);
	printf("Energ computeQFFDerivativesDipoles\n");

	fileNameOut =  printnMRQFF(qffConstants, fileName);

	return fileNameOut;
}
/********************************************************************************/
static int readGradGabeditFile(Molecule* mol, char* inputFileName, int index, boolean readGrad)
{
        char* fileName = NULL;
        char* prefixName = NULL;
        int i=0;
	int xyz;

        if(!mol || mol->nAtoms<1) return 0;
        if(!inputFileName) return 0;

        prefixName = strdup_printf("%sQFF",getSuffixNameFile(inputFileName));

        fileName = strdup_printf("%s_%d.gab",prefixName,index);
	{
		FILE* file = fopen(fileName,"r");
		if(!file) return 0;
		fclose(file);
	}

	i = readEnergyAndDipoleFromGabeditFile(fileName, &mol->potentialEnergy, mol->dipole);
        //printf("FileName = %s E = %f D = %f %f %f\n", fileName, mol->potentialEnergy, mol->dipole[0],  mol->dipole[1],  mol->dipole[2]);
	if(readGrad) mol->klass->readGradientFromGabeditFile(mol, fileName);
        if(fileName) free(fileName);
	mol->potentialEnergy /= AUTOKCAL;
	for(xyz=0;xyz<3;xyz++)  mol->dipole[xyz] /=  AUTODEB;
        return i;
}
/*****************************************************************************/
static int readEnergiesAndDipolesQFFFromFiles(char* inputFileName, double* energies[], double* dipoles[])
{
	int xyz;
	int index;
	Molecule* mol;
	char* prefixName;
	char* fileName;
	int n;
	int nGeoms = 0;

	prefixName = strdup_printf("%sQFF",getSuffixNameFile(inputFileName));
        fileName = strdup_printf("%s_%d.gab",prefixName,0);

	printf("Reading molecule from %s file\n", fileName);
	mol = readMoleculeFromGabeditFile(fileName);
	if(!mol || mol->nAtoms<1) 
	{
		fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		fprintf(stderr," Error : I cannot read geometry from %s Gabedit file\n",fileName);
		fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		exit(1);
	}
	// computes the number of geometries 
	nGeoms = 0;
	for(index=0; ;index++)
	{
		n = readGradGabeditFile(mol, inputFileName, index, FALSE);
		if(n<1) break;
		nGeoms++;
	}
	if(nGeoms<1)
	{
               	fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
               	fprintf(stderr,"I cannot read energy and dipole from %sQFF*.gab gabedit files\n", inputFileName);
               	fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
               	exit(1);
	}
	energies[0] = malloc(nGeoms*sizeof(double));
	for(xyz=0;xyz<3;xyz++) dipoles[xyz] = malloc(nGeoms*sizeof(double));
	for(index=0;index<nGeoms ;index++)
	{
		n = readGradGabeditFile(mol, inputFileName, index, FALSE);
		if(n<1) break;
		energies[0][index] = mol->potentialEnergy;
		for(xyz=0;xyz<3;xyz++) dipoles[xyz][index] = mol->dipole[xyz];
	}
	return nGeoms;
}
/*****************************************************************************/
char* computeQFFFromFiles(char* inputFileName)
{
	int i;
	int index;
	Molecule* mol;
	char* prefixName;
	char* fileName;
	FILE* file  = NULL;
	char buffer[BSIZE];
	NMRQFF* qffConstants;
	int order = -1;
	double* energies = NULL;
	double* dipoles[] = {NULL, NULL, NULL};
	int f=0, nGeoms = 0;
	char* fileNameOut = NULL;

	prefixName = strdup_printf("%sQFF",getSuffixNameFile(inputFileName));
        fileName = strdup_printf("%s_%d.gab",prefixName,0);

	//printf("Reading molecule from %s file\n", fileName);
	mol = readMoleculeFromGabeditFile(fileName);
	if(!mol || mol->nAtoms<1) 
	{
		fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		fprintf(stderr," Error : I cannot read geometry from %s Gabedit file\n",fileName);
		fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		exit(1);
	}
	qffConstants = (NMRQFF*) malloc(sizeof(NMRQFF));
	qffConstants->numberOfFrequencies = 0;
	//printf("nAtoms = %d\n", mol->nAtoms);

	// compute number of modes. It is <= 3*mol->nAtoms
	for(i=1;i<=6*3*mol->nAtoms;i++)
	{
        	fileName = strdup_printf("%s_%d.ici",prefixName,i);
		//printf("fileName = %s\n", fileName);
		file = fopen(fileName,"r");
		while(file && !feof(file))
        	{
                	if(!fgets(buffer,BSIZE,file))break;
			//printf("buffer = %s\n", buffer);
                	if(strstr(buffer,"Mode:")) 
			{
				qffConstants->numberOfFrequencies++;
				break;
			}
		}
		if(file)fclose(file);
		else break;
		free(fileName);
	}
	qffConstants->numberOfFrequencies /= 6;
	//printf("numberOfFrequencies = %d\n", qffConstants->numberOfFrequencies);
	initnMRQFF0(qffConstants,qffConstants->numberOfFrequencies);

	index = 1;
	for(i=0;i<qffConstants->numberOfFrequencies;i++)
	{
        	fileName = strdup_printf("%s_%d.ici",prefixName,index);
		file = fopen(fileName,"r");
		while(file && !feof(file))
        	{
                	if(!fgets(buffer,BSIZE,file))break;
                	if(strstr(buffer,"Mode:")) 
			{
				double freq = 0;
				double mass = 0;
				double delta = 0;
				//#Mode: Freq= 625.021755910743 Mass= 1.043203662605 Q= Qeq + 0.644571737151 akI=0.000042
				sscanf(strstr(buffer,"Freq=")+strlen("Freq="),"%lf",&freq);
				sscanf(strstr(buffer,"Mass=")+strlen("Mass="),"%lf",&mass);
				sscanf(strstr(buffer,"Qeq +")+strlen("Qeq +"),"%lf",&delta);
				qffConstants->frequencies[i] = freq;
				qffConstants->mass[i] = mass;
				qffConstants->delta[i] = delta/3.0;
				break;
			}
		}
		fclose(file);
		free(fileName);
		index += 6;
	}
	nGeoms = readEnergiesAndDipolesQFFFromFiles(inputFileName, &energies, dipoles);
	f = qffConstants->numberOfFrequencies;
	order =  getOrdre(f, nGeoms);
        qffConstants->numberOfEnergies = nGeoms;
	computeQFFDerivativesEnergies(qffConstants, order, energies);
	//printf("Energ computeQFFDerivativesEnergies\n");
	computeQFFDerivativesDipoles(qffConstants, order, dipoles);
	//printf("Energ computeQFFDerivativesDipoles\n");

	fileNameOut = saveNMRQFFAppend(qffConstants, inputFileName,NULL);
	
	return fileNameOut;
}
/**********************************************************************************************************************/
void generateQFFCChemIFilesForFrequencies(char* inputFileName)
{
	Molecule* mol = readMolecule(inputFileName,TRUE);
	double delta = 0.5;
	boolean reducedCoordinates = TRUE;
	FILE* file = fopen(inputFileName,"rb");
	int order = 2;

	readOneBoolean(file,"QFFReducedCoordinates",&reducedCoordinates);
	readOneInt(file,"QFFnModes",&order);
	if(!reducedCoordinates) delta = 1e-2;
	readOneReal(file,"QFFDelta",&delta);
	fclose(file);
	printf("delta = %f ",delta);
	if(reducedCoordinates) printf("reducedCoordiantes\n");
	else printf(" Angshtrom\n");
	printf("nAtoms = %d\n",mol->nAtoms);
	printf("nModes = %d\n",mol->vibration.nModes);

	/*
	printf("seet test.gab\n");
	mol->klass->save(mol, "test.gab");
	*/

	mol->klass->generateQFFCChemIFiles(mol, inputFileName, delta,  reducedCoordinates, order);
	printf("order = %d\n",order);
	mol->klass->saveFirstDerivatives(inputFileName,mol);

	mol->klass->free(mol);
}
/**********************************************************************************************************************/
double*** getGeomsQFF(char* inputFileName, Molecule** molecule, int* pOrdre, double** pDeltas, int* nGeoms)
{
	Molecule* mol = readMolecule(inputFileName,TRUE);
	double delta = 0.5;
	boolean reducedCoordinates = TRUE;
	int order = 2;
	FILE* file = fopen(inputFileName,"rb");
	double*** geoms = NULL;

	readOneBoolean(file,"QFFReducedCoordinates",&reducedCoordinates);
	readOneInt(file,"QFFnModes",&order);
	if(!reducedCoordinates) delta = 1e-2;
	readOneReal(file,"QFFDelta",&delta);
	fclose(file);
	printf("delta = %f ",delta);
	if(reducedCoordinates) printf("reducedCoordiantes\n");
	else printf(" Angshtrom\n");
	printf("nAtoms = %d\n",mol->nAtoms);
	printf("nModes = %d\n",mol->vibration.nModes);

	/*
	printf("seet test.gab\n");
	mol->klass->save(mol, "test.gab");
	*/

	geoms = mol->klass->getGeomsQFF(mol, inputFileName, delta,  reducedCoordinates, order, pDeltas, nGeoms);
	*pOrdre = order;

	//mol->klass->free(mol);
	*molecule = mol;
	return geoms;
}
/********************************************************************************/
static char* saveNMRQFFAppend(NMRQFF* qffConstants, char* inputFileName, Molecule* mol)
{

	char tmp[BSIZE];
	int i,j,k,l;
	int nf = qffConstants->numberOfFrequencies;
	char txyz[]={'X','Y','Z'};
	int xyz;
        char* fileNameOut = strdup_printf("%sQFF.txt",getSuffixNameFile(inputFileName));
        FILE* file = fopen(fileNameOut,"w");
        FILE* fileIn = fopen(inputFileName,"rb");
        fprintf(stdout,"QFF parameters saved in %s file\n", fileNameOut);


	while(!feof(fileIn))
      	{
                if(!fgets(tmp,BSIZE,fileIn))break;
		fprintf(file,"%s",tmp);
        }
	fclose(fileIn);

	sprintf(tmp, "#====================================================================================\n");
	fprintf(file,"%s", tmp);   
	sprintf(tmp,"%s",
		"# nMR-QFF constants\n"
		"# See Yagi et al. J. Chem. Phys. 121, 1383 (2004)\n"
		);
	fprintf(file,"%s",tmp);   
	sprintf(tmp, "#====================================================================================\n");
	fprintf(file,"%s",tmp);   

	fprintf(file,"%s","\n");
	fprintf(file,"%s","VPT2Model=GVPT2\n");   
	fprintf(file,"%s","# VPT2Model=DCPT2\n");   
	fprintf(file,"%s","# VPT2Model=HDCPT2\n");   
	fprintf(file,"%s","# alphaHDCPT2=1.0\n");   
	fprintf(file,"%s","# betaHDCPT2=5e5\n");   
	fprintf(file,"%s","\n");
	fprintf(file,"%s","PropModel=GVPT2\n");
	fprintf(file,"%s","# PropModel=HDCPT2\n");
	fprintf(file,"%s","# PropModel=DCPT2\n");
	fprintf(file,"%s","# alphaPropHDCPT2=1.0\n");
	fprintf(file,"%s","# betaPropHDCPT2=5e5\n");
	fprintf(file,"%s","# alphaPropHDCPT2=1.0\n");
	fprintf(file,"%s","# betaPropHDCPT2=5e5\n");
	fprintf(file,"%s","maxFrequencyDifferenceFermi=200\n");
	fprintf(file,"%s","MartinCutOff1=1.0\n");
	fprintf(file,"%s","MartinCutOff2=1.0\n");
	fprintf(file,"%s","# ZCutOff=0.08\n");
	fprintf(file,"%s","\n");
	sprintf(tmp, "#====================================================================================\n");
	fprintf(file,"%s",tmp);   

	fprintf(file,"%s","\n");   
	sprintf(tmp,"nFrequencies=%d\n",nf);
	fprintf(file,"%s",tmp);   
	sprintf(tmp,"nDim=%d\n",3);
	fprintf(file,"%s",tmp);   
	fprintf(file,"%s","\n");   

	sprintf(tmp,"#i Freq(cm-1)  Calc.Freq   dQ(Bohr)  Mass(amu)\tGradient[ H amu^(-1/2) Bohr^(-1)]\n");
	fprintf(file,"%s",tmp);   
	fprintf(file,"%s","Hessian\n");   
	for(i=0;i<nf;i++) 
	{
		sprintf(tmp,"%d %d %0.14f %0.14f %0.14f %0.14f\t%0.14f\n",i+1, i+1, qffConstants->frequencies[i], 
				qffConstants->calculatedFrequencies[i], 
				qffConstants->delta[i], qffConstants->mass[i], qffConstants->gradients[i]);
		fprintf(file,"%s",tmp);   
	}
	fprintf(file,"%s","END\n\n");


	sprintf(tmp,"# i\tj\tk\tReduced values [cm-1]\n");
	fprintf(file,"%s",tmp);   
	fprintf(file,"%s","Cubic\n");   
	for(i=0;i<nf;i++)
        {
                for(j=0;j<nf;j++)
                {
			if(fabs(qffConstants->cubicEnergies[i][j])<1e-12) continue;
			sprintf(tmp,"%d\t%d\t%d\t%14.6f\n",i+1, i+1, j+1, qffConstants->cubicEnergies[i][j]);
			fprintf(file,"%s",tmp);   
                }
                for(j=0;j<i;j++)
                for(k=0;k<j;k++)
                {
			if(fabs(qffConstants->cubicEnergiesIJK[i][j][k])<1e-12) continue;
			sprintf(tmp,"%d\t%d\t%d\t%14.6f\n",i+1, j+1, k+1, qffConstants->cubicEnergiesIJK[i][j][k]);
			fprintf(file,"%s",tmp);   
                }
        }
	fprintf(file,"%s","END\n\n");


	sprintf(tmp,"# i\tj\tk\tl\tReduced values [cm-1]\n");
	fprintf(file,"%s",tmp);   
	fprintf(file,"%s","Quartic\n");   
	for(i=0;i<nf;i++)
        {
		for(j=0;j<=i;j++)
		{
			if(fabs(qffConstants->quarticEnergiesIIJJ[i][j])<1e-12) continue;
			sprintf(tmp,"%d\t%d\t%d\t%d\t%14.6f\n",i+1, i+1, j+1, j+1, qffConstants->quarticEnergiesIIJJ[i][j]);
			fprintf(file,"%s",tmp);   
		}
		for(j=0;j<nf;j++)
		{
			if(j==i) continue;
			if(fabs(qffConstants->quarticEnergiesIIIJ[i][j])<1e-12) continue;
			sprintf(tmp,"%d\t%d\t%d\t%d\t%14.6f\n",i+1, i+1, i+1, j+1, qffConstants->quarticEnergiesIIIJ[i][j]);
			fprintf(file,"%s",tmp);   
		}
                for(j=0;j<i;j++)
                for(k=0;k<j;k++)
		{
			if(fabs(qffConstants->quarticEnergiesIIJK[i][j][k])<1e-12) continue;
			sprintf(tmp,"%d\t%d\t%d\t%d\t%14.6f\n",i+1, i+1, j+1, k+1, qffConstants->quarticEnergiesIIJK[i][j][k]);
			fprintf(file,"%s",tmp);   
		}
                for(j=0;j<i;j++)
                for(k=0;k<j;k++)
                for(l=0;l<k;l++)
		{
			if(fabs(qffConstants->quarticEnergiesIJKL[i][j][k][l])<1e-12) continue;
			sprintf(tmp,"%d\t%d\t%d\t%d\t%14.6f\n",i+1, j+1, k+1, l+1, qffConstants->quarticEnergiesIJKL[i][j][k][l]);
			fprintf(file,"%s",tmp);   
		}
        }
	fprintf(file,"%s","END\n\n");

	if(mol)
	{
		mol->klass->addFirstDerivativeToFile(mol, file);
	}
	if(qffConstants->numberOfFirstDipolesInput==0)
	{
		sprintf(tmp,"#xyz\ti\tValues[au cm^1/2]\n");
		fprintf(file,"%s",tmp);   
		fprintf(file,"%s","First derivatives\n");
		for(i=0;i<nf;i++)
		for(xyz=0;xyz<3;xyz++)
		{
			if(fabs(qffConstants->firstDipoles[i][xyz])<1e-12) continue;
			sprintf(tmp,"%c\t%d\t%14.6f\n",txyz[xyz], i+1,qffConstants->firstDipoles[i][xyz]);
			fprintf(file,"%s",tmp);   
		}
		fprintf(file,"%s","END\n\n");
	}
	else
	{
		sprintf(tmp,"#xyz\ti\tInput values[au cm^1/2]\tCalculated values[au cm^1/2]\n");
		fprintf(file,"%s",tmp);   
		fprintf(file,"%s","First derivatives\n");
		for(i=0;i<nf;i++)
		for(xyz=0;xyz<3;xyz++)
		{
			if(fabs(qffConstants->firstDipolesInput[i][xyz])<1e-12) continue;
			sprintf(tmp,"%c\t%d\t%14.6f\t\t%14.6f\n",txyz[xyz], i+1,qffConstants->firstDipolesInput[i][xyz], qffConstants->firstDipoles[i][xyz]);
			fprintf(file,"%s",tmp);   
		}
		fprintf(file,"%s","END\n\n");
	}

	sprintf(tmp,"#xyz\ti\tj\tValues[au cm]\n");
	fprintf(file,"%s",tmp);   
	fprintf(file,"%s","Second derivatives\n");
	for(i=0;i<nf;i++)
	for(j=0;j<nf;j++)
	for(xyz=0;xyz<3;xyz++)
	{
		if(fabs(qffConstants->secondDipoles[i][j][xyz])<1e-12) continue;
		sprintf(tmp,"%c\t%d\t%d\t%14.6f\n",txyz[xyz], i+1,j+1,qffConstants->secondDipoles[i][j][xyz]);
		fprintf(file,"%s",tmp);   
	}
	fprintf(file,"%s","END\n\n");

	sprintf(tmp,"#xyz\ti\tj\tk\tValues[au cm^3/2]\n");
	fprintf(file,"%s",tmp);   
	fprintf(file,"%s","Cubic derivatives\n");
	for(i=0;i<nf;i++)
	for(j=0;j<nf;j++)
	for(xyz=0;xyz<3;xyz++)
	{
		if(fabs(qffConstants->cubicDipoles[i][j][xyz])<1e-12) continue;
		sprintf(tmp,"%c\t%d\t%d\t%d\t%14.6f\n",txyz[xyz], i+1,i+1,j+1,qffConstants->cubicDipoles[i][j][xyz]);
		fprintf(file,"%s",tmp);   
		if(i!=j)
		{
			sprintf(tmp,"%c\t%d\t%d\t%d\t%14.6f\n",txyz[xyz], i+1,j+1,i+1,qffConstants->cubicDipoles[i][j][xyz]);
			fprintf(file,"%s",tmp);   
			sprintf(tmp,"%c\t%d\t%d\t%d\t%14.6f\n",txyz[xyz], j+1,i+1,i+1,qffConstants->cubicDipoles[i][j][xyz]);
			fprintf(file,"%s",tmp);   
		}
	}
	fprintf(file,"%s","END\n\n");
        fclose(file);
	return fileNameOut;

}
/*****************************************************************************/
static void computeQFFDerivativesEnergies(NMRQFF* qffConstants, int order, double* energies)
{
	int i;
	int j;
	int k;
	int l;
	int index;
	boolean Ok = TRUE;

	initnMRQFFEnergies(qffConstants, order);

	index = 0;
        qffConstants->V0 =energies[index];

	for(j=0;j<qffConstants->numberOfFrequencies;j++)
	{
		int k = 0;
		index++;  /*  3*deltas[j], 0 */
		qffConstants->VI[j][k] = energies[index]; 

		index++; k++; /*  2*deltas[j], 0 */
		qffConstants->VI[j][k] = energies[index]; 

		index++; k++; /*  1*deltas[j], 0 */
		qffConstants->VI[j][k] = energies[index]; 

		index++; k++; /* -1*deltas[j], 0 */
		qffConstants->VI[j][k] = energies[index]; 

		index++; k++; /* -2*deltas[j], 0 */
		qffConstants->VI[j][k] = energies[index]; 
	
		index++; k++; /* -3*deltas[j], 0 */
		qffConstants->VI[j][k] = energies[index]; 
	}

	if(order>=2)
	for(j=0;j<qffConstants->numberOfFrequencies;j++)
	{
		for(i=0;i<j;i++)
		{
			int k;
			index++; /*  deltas[j],   deltas[i] */
                        k = 0;
			qffConstants->VIJ[j][i][k] = energies[index]; 

			index++;/*  deltas[j],  -deltas[i] */
                        k = 1; 
			qffConstants->VIJ[j][i][k] = energies[index]; 

			index++; /* -deltas[j],   deltas[i] */
                        k = 2; 
			qffConstants->VIJ[j][i][k] = energies[index]; 

			index++; /* -deltas[j],  -deltas[i] */
                        k = 3;
			qffConstants->VIJ[j][i][k] = energies[index]; 

                	qffConstants->VIJ[i][j][0] = qffConstants->VIJ[j][i][0];
                	qffConstants->VIJ[i][j][1] = qffConstants->VIJ[j][i][2];
                	qffConstants->VIJ[i][j][2] = qffConstants->VIJ[j][i][1];
                	qffConstants->VIJ[i][j][3] = qffConstants->VIJ[j][i][3];

		}
		for(i=0;i<qffConstants->numberOfFrequencies;i++)
		{
			int k;
			if(i==j) continue;
			index++; /*  deltas[j],  3*deltas[i] */
                        k = 0;
			qffConstants->VI3J[j][i][k] = energies[index]; 

			index++; /*  deltas[j], -3*deltas[i] */
                        k = 1; 
			qffConstants->VI3J[j][i][k] = energies[index]; 

			index++; /* -deltas[j],  3*deltas[i] */
                        k = 2; 
			qffConstants->VI3J[j][i][k] = energies[index]; 

			index++; /* -deltas[j], -3*deltas[i] */
                        k = 3;
			qffConstants->VI3J[j][i][k] = energies[index]; 
		}
	}
	if(order>=3)
	{
	FILE* fileVIJK = fopen("VIJK.bin","wb");
	for(j=0;j<qffConstants->numberOfFrequencies;j++)
	for(i=0;i<j;i++)
	for(k=0;k<i;k++)
	{
			int l = -1;
			index++; /*  deltas[j],   deltas[i],  deltas[k] */
			l++;
			fwrite(&energies[index], sizeof(double), 1, fileVIJK);
			//qffConstants->VIJK[j][i][k][l] = energies[index]; 

			index++; /*  deltas[j],   deltas[i],  -deltas[k] */
			l++;
			//qffConstants->VIJK[j][i][k][l] = energies[index]; 
			fwrite(&energies[index], sizeof(double), 1, fileVIJK);

			index++; /*  deltas[j],   -deltas[i],   deltas[k] */
			l++;
			//qffConstants->VIJK[j][i][k][l] = energies[index]; 
			fwrite(&energies[index], sizeof(double), 1, fileVIJK);

			index++; /*  deltas[j],   -deltas[i],   -deltas[k] */
			l++;
			//qffConstants->VIJK[j][i][k][l] = energies[index]; 
			fwrite(&energies[index], sizeof(double), 1, fileVIJK);

			index++; /*  -deltas[j],   deltas[i],  deltas[k] */
			l++;
			//qffConstants->VIJK[j][i][k][l] = energies[index]; 
			fwrite(&energies[index], sizeof(double), 1, fileVIJK);

			index++; /*  -deltas[j],   deltas[i],  -deltas[k] */
			l++;
			//qffConstants->VIJK[j][i][k][l] = energies[index]; 
			fwrite(&energies[index], sizeof(double), 1, fileVIJK);

			index++; /*  -deltas[j],   -deltas[i],   deltas[k] */
			l++;
			//qffConstants->VIJK[j][i][k][l] = energies[index]; 
			fwrite(&energies[index], sizeof(double), 1, fileVIJK);

			index++; /*  -deltas[j],   -deltas[i],   -deltas[k] */
			l++;
			//qffConstants->VIJK[j][i][k][l] = energies[index]; 
			fwrite(&energies[index], sizeof(double), 1, fileVIJK);

	}
	fclose(fileVIJK);
	}
	if(order>=4)
	for(j=0;j<qffConstants->numberOfFrequencies;j++)
	for(i=0;i<j;i++)
	for(k=0;k<i;k++)
	for(l=0;l<k;l++)
	{
			int n = 0;
			for(n=0;n<16;n++)
			{
				index++;
				qffConstants->VIJKL[j][i][k][l][n]= energies[index]; 
			}
	}

	free(energies);

	if(Ok) computeGradients(qffConstants);
	if(Ok) computeFrequencies(qffConstants);
	if(Ok) computeCubicForces(qffConstants);
	if(Ok) computeQuarticForces(qffConstants);
	//printf("Begin free\n");

	freeMatrixDouble(&qffConstants->VI, qffConstants->numberOfFrequencies);
	freeCubeDouble(&qffConstants->VIJ, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies);
	freeCubeDouble(&qffConstants->VI3J, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies);
	if(order>=3) freeQuarticDouble(&qffConstants->VIJK, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies, qffConstants->numberOfFrequencies);
	if(order>=4) freeQuinticDouble(&qffConstants->VIJKL, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies, qffConstants->numberOfFrequencies, qffConstants->numberOfFrequencies);
	//printf("End free\n");
}
/*****************************************************************************/
static void computeQFFDerivativesDipoles(NMRQFF* qffConstants, int order, double* dipoles[])
{
	int i;
	int j;
	int k;
	//int l;
	int index;
	int xyz;
	boolean Ok = TRUE;
	index = 0;

	initnMRQFFDipoles(qffConstants, order);

	for(xyz=0;xyz<3;xyz++) qffConstants->dipole0[xyz] = dipoles[xyz][index];


	for(j=0;j<qffConstants->numberOfFrequencies;j++)
	{
		int k = 0;
		index++;  /*  3*deltas[j], 0 */
		for(xyz=0;xyz<3;xyz++) qffConstants->dipolesI[j][k][xyz] = dipoles[xyz][index]; 

		index++; k++; /*  2*deltas[j], 0 */
		for(xyz=0;xyz<3;xyz++) qffConstants->dipolesI[j][k][xyz] = dipoles[xyz][index]; 

		index++; k++; /*  1*deltas[j], 0 */
		for(xyz=0;xyz<3;xyz++) qffConstants->dipolesI[j][k][xyz] = dipoles[xyz][index]; 

		index++; k++; /* -1*deltas[j], 0 */
		for(xyz=0;xyz<3;xyz++) qffConstants->dipolesI[j][k][xyz] = dipoles[xyz][index]; 

		index++; k++; /* -2*deltas[j], 0 */
		for(xyz=0;xyz<3;xyz++) qffConstants->dipolesI[j][k][xyz] = dipoles[xyz][index]; 
	
		index++; k++; /* -3*deltas[j], 0 */
		for(xyz=0;xyz<3;xyz++) qffConstants->dipolesI[j][k][xyz] = dipoles[xyz][index]; 
	}

	if(order>=2)
	for(j=0;j<qffConstants->numberOfFrequencies;j++)
	{
		for(i=0;i<j;i++)
		{
			int k;
			index++; /*  deltas[j],   deltas[i] */
                        k = 0;
			for(xyz=0;xyz<3;xyz++) qffConstants->dipolesIJ[j][i][k][xyz] = dipoles[xyz][index]; 

			index++;/*  deltas[j],  -deltas[i] */
                        k = 1; 
			for(xyz=0;xyz<3;xyz++) qffConstants->dipolesIJ[j][i][k][xyz] = dipoles[xyz][index]; 

			index++; /* -deltas[j],   deltas[i] */
                        k = 2; 
			for(xyz=0;xyz<3;xyz++) qffConstants->dipolesIJ[j][i][k][xyz] = dipoles[xyz][index]; 

			index++; /* -deltas[j],  -deltas[i] */
                        k = 3;
			for(xyz=0;xyz<3;xyz++) qffConstants->dipolesIJ[j][i][k][xyz] = dipoles[xyz][index]; 

			for(xyz=0;xyz<3;xyz++)
                	{
				qffConstants->dipolesIJ[i][j][0][xyz] = qffConstants->dipolesIJ[j][i][0][xyz];
				qffConstants->dipolesIJ[i][j][1][xyz] = qffConstants->dipolesIJ[j][i][2][xyz];
				qffConstants->dipolesIJ[i][j][2][xyz] = qffConstants->dipolesIJ[j][i][1][xyz];
				qffConstants->dipolesIJ[i][j][3][xyz] = qffConstants->dipolesIJ[j][i][3][xyz];
                	}

		}
		for(i=0;i<qffConstants->numberOfFrequencies;i++)
		{
			int k;
			if(i==j) continue;
			index++; /*  deltas[j],  3*deltas[i] */
                        k = 0;
			for(xyz=0;xyz<3;xyz++) qffConstants->dipolesI3J[j][i][k][xyz] = dipoles[xyz][index]; 

			index++; /*  deltas[j], -3*deltas[i] */
                        k = 1; 
			for(xyz=0;xyz<3;xyz++) qffConstants->dipolesI3J[j][i][k][xyz] = dipoles[xyz][index]; 

			index++; /* -deltas[j],  3*deltas[i] */
                        k = 2; 
			for(xyz=0;xyz<3;xyz++) qffConstants->dipolesI3J[j][i][k][xyz] = dipoles[xyz][index]; 

			index++; /* -deltas[j], -3*deltas[i] */
                        k = 3;
			for(xyz=0;xyz<3;xyz++) qffConstants->dipolesI3J[j][i][k][xyz] = dipoles[xyz][index]; 
		}
	}
	if(order>=3)
	{
	FILE* fileDIJK = fopen("DIJK.bin","wb");
	for(j=0;j<qffConstants->numberOfFrequencies;j++)
	{
		for(i=0;i<j;i++)
		for(k=0;k<i;k++)
		{
			int l = -1;
			index++; /*  deltas[j],   deltas[i],  deltas[k] */
			l++;
			//for(xyz=0;xyz<3;xyz++) qffConstants->dipolesIJK[j][i][k][l][xyz] = dipoles[xyz][index]; 
			for(xyz=0;xyz<3;xyz++) fwrite(&dipoles[xyz][index], sizeof(double), 1, fileDIJK);

			index++; /*  deltas[j],   deltas[i],  -deltas[k] */
			l++;
			//for(xyz=0;xyz<3;xyz++) qffConstants->dipolesIJK[j][i][k][l][xyz] = dipoles[xyz][index]; 
			for(xyz=0;xyz<3;xyz++) fwrite(&dipoles[xyz][index], sizeof(double), 1, fileDIJK);

			index++; /*  deltas[j],   -deltas[i],   deltas[k] */
			l++;
			//for(xyz=0;xyz<3;xyz++) qffConstants->dipolesIJK[j][i][k][l][xyz] = dipoles[xyz][index]; 
			for(xyz=0;xyz<3;xyz++) fwrite(&dipoles[xyz][index], sizeof(double), 1, fileDIJK);

			index++; /*  deltas[j],   -deltas[i],   -deltas[k] */
			l++;
			//for(xyz=0;xyz<3;xyz++) qffConstants->dipolesIJK[j][i][k][l][xyz] = dipoles[xyz][index]; 
			for(xyz=0;xyz<3;xyz++) fwrite(&dipoles[xyz][index], sizeof(double), 1, fileDIJK);

			index++; /*  -deltas[j],   deltas[i],  deltas[k] */
			l++;
			//for(xyz=0;xyz<3;xyz++) qffConstants->dipolesIJK[j][i][k][l][xyz] = dipoles[xyz][index]; 
			for(xyz=0;xyz<3;xyz++) fwrite(&dipoles[xyz][index], sizeof(double), 1, fileDIJK);

			index++; /*  -deltas[j],   deltas[i],  -deltas[k] */
			l++;
			//for(xyz=0;xyz<3;xyz++) qffConstants->dipolesIJK[j][i][k][l][xyz] = dipoles[xyz][index]; 
			for(xyz=0;xyz<3;xyz++) fwrite(&dipoles[xyz][index], sizeof(double), 1, fileDIJK);

			index++; /*  -deltas[j],   -deltas[i],   deltas[k] */
			l++;
			//for(xyz=0;xyz<3;xyz++) qffConstants->dipolesIJK[j][i][k][l][xyz] = dipoles[xyz][index]; 
			for(xyz=0;xyz<3;xyz++) fwrite(&dipoles[xyz][index], sizeof(double), 1, fileDIJK);

			index++; /*  -deltas[j],   -deltas[i],   -deltas[k] */
			l++;
			//for(xyz=0;xyz<3;xyz++) qffConstants->dipolesIJK[j][i][k][l][xyz] = dipoles[xyz][index]; 
			for(xyz=0;xyz<3;xyz++) fwrite(&dipoles[xyz][index], sizeof(double), 1, fileDIJK);

			/*
			for(xyz=0;xyz<3;xyz++)
                	{
				for(l=0;l<8;l++) qffConstants->dipolesIJK[i][j][k][l][xyz] = qffConstants->dipolesIJK[j][i][k][l][xyz];
				for(l=0;l<8;l++) qffConstants->dipolesIJK[i][k][j][l][xyz] = qffConstants->dipolesIJK[j][i][k][l][xyz];
				for(l=0;l<8;l++) qffConstants->dipolesIJK[j][k][i][l][xyz] = qffConstants->dipolesIJK[j][i][k][l][xyz];
				for(l=0;l<8;l++) qffConstants->dipolesIJK[k][i][j][l][xyz] = qffConstants->dipolesIJK[j][i][k][l][xyz];
				for(l=0;l<8;l++) qffConstants->dipolesIJK[k][j][i][l][xyz] = qffConstants->dipolesIJK[j][i][k][l][xyz];
                	}
			*/
		}
	}
	fclose(fileDIJK);
	}
	/*
	if(order>=4)
	for(j=0;j<qffConstants->numberOfFrequencies;j++)
	for(i=0;i<j;i++)
	for(k=0;k<i;k++)
	for(l=0;l<k;l++)
	{
			int n = 0;
			for(n=0;n<16;n++)
			{
				index++;
			}
	}
	*/
	for(xyz=0;xyz<3;xyz++) free(dipoles[xyz]);


	if(Ok) changeUnitInputFirstDerivativesDipoles(qffConstants);
	if(Ok) computeFirstDerivativesDipoles(qffConstants);
	if(Ok) computeSecondDerivativesDipoles(qffConstants);
	if(Ok) computeCubicDerivativesDipoles(qffConstants);
	if(Ok) computeQuarticDerivativesDipoles(qffConstants);

	freeVectorDouble(&qffConstants->dipole0);
	freeCubeDouble(&qffConstants->dipolesI, qffConstants->numberOfFrequencies,6);
	freeQuarticDouble(&qffConstants->dipolesIJ, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,4);
	freeQuarticDouble(&qffConstants->dipolesI3J, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,4);
	if(order>=3) freeQuinticDouble(&qffConstants->dipolesIJK, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies, 8);
}
/*****************************************************************************/
char* computeQFFDerivatives(char* inputFileName, Molecule* mol, int order, double* deltas, int nEnergies, double* energies, double* dipoles[])
{
	int i;
	NMRQFF* qffConstants;
	char* fileNameOut = NULL;

	qffConstants = (NMRQFF*) malloc(sizeof(NMRQFF));
	qffConstants->numberOfFrequencies = 0;
	printf("nAtoms = %d\n", mol->nAtoms);

	qffConstants->numberOfFrequencies = mol->vibration.nModes;
	printf("numberOfFrequencies = %d\n", qffConstants->numberOfFrequencies);
	initnMRQFF0(qffConstants,qffConstants->numberOfFrequencies);
	printf("End initnMRQFF0\n");

	for(i=0;i<qffConstants->numberOfFrequencies;i++)
	{
		qffConstants->frequencies[i] = mol->vibration.modes[i].frequency;
		qffConstants->mass[i] = mol->vibration.modes[i].mass;
		qffConstants->delta[i] = deltas[i];
	}

        qffConstants->numberOfEnergies = nEnergies;
	computeQFFDerivativesEnergies(qffConstants, order, energies);
	printf("Energ computeQFFDerivativesEnergies\n");
	computeQFFDerivativesDipoles(qffConstants, order, dipoles);
	printf("Energ computeQFFDerivativesDipoles\n");

	fileNameOut = saveNMRQFFAppend(qffConstants, inputFileName, mol);
	
	return fileNameOut;
}
File: ./cchemilib/src/QuarticForceField/QFFnMRMem.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* QFFnMR.c */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <ctype.h>

#include "../Utils/Utils.h"
#include "../Utils/Types.h"
#include "../Utils/Constants.h"
#include "../Molecule/Molecule.h"


/************************************************************************************************************/
typedef struct _NMRQFFDipole
{
	double values[3];
}NMRQFFDipole;

typedef struct _NMRQFF
{
	int numberOfFrequencies;
	double* gradients;
	double* frequencies;
	int numberOfFirstDipolesInput;
	int numberOfEnergies;
	int numberOfDipoles;
	double** firstDipolesInput;
	double* calculatedFrequencies;
	double* mass;
	double* delta;//[i:0..Nfreq]
	double V0;
	double **VI; // [i:0..Nfreq][0..5]
	double ***VIJ; // [i:0..Nfreq][j:0..Nfreq][0..3]
	double ***VI3J; // [i:0..Nfreq][j:0..Nfreq][0..3]
	double ****VIJK; // [i:0..Nfreq][j:0..Nfreq][[j:0..Nfreq][0..7]
	double *****VIJKL; // [i:0..Nfreq][j:0..Nfreq][j:0..Nfreq][j:0..Nfreq][0..16]

	double** cubicEnergies;//[i:0..Nfreq][j:0..Nfreq] for tiii, tiij
	double*** cubicEnergiesIJK;//[i:0..Nfreq][j:0..Nfreq][j:0..Nfreq] for tijk, i # j # k
	double** quarticEnergiesIIJJ;//[i:0..Nfreq][j:0..i-1] for uiijj
	double** quarticEnergiesIIIJ;//[i:0..Nfreq][j:0..Nfreq] for uiiij and uiiii
	double*** quarticEnergiesIIJK;//[i:0..Nfreq][j:0..Nfreq][k:0..Nfreq] for uiijk i # j # k
	double**** quarticEnergiesIJKL;//[i:0..Nfreq][j:0..Nfreq][k:0..Nfreq][l:0..Nfreq] for uijkl i # j # k # l

	double *dipole0; // [0..2] // 0..2 : x,y,z
	double ***dipolesI; // mu[i:0..Nfreq][0..5][0..2] // 0..2 : x,y,z
	double ****dipolesIJ; // mu[i:0..Nfreq][j:0..Nfreq][0..3][0..2] // 0..2 : x,y,z
	double ****dipolesI3J; // mu[i:0..Nfreq][j:0..Nfreq][0..3][0..2] // 0..2 : x,y,z
	double *****dipolesIJK; // mu[i:0..Nfreq][j:0..Nfreq][k:0..Nfreq][0..8][0..2] // 0..2 : x,y,z
	double** firstDipoles;//[i:0..Nfreq][0..2] 
	double*** secondDipoles;//[i:0..Nfreq][i:0..Nfreq][0..2] 
	double*** cubicDipoles;//[i:0..Nfreq][i:0..Nfreq][0..2] // diii, diij
	double**** cubicDipolesIJK;//[i:0..Nfreq][i:0..Nfreq][i:0..Nfreq][0..2] // dijk, i # j # k
	double*** quarticDipolesIIJJ;//[i:0..Nfreq][j:0..i-1][0..2] for diijj
	double*** quarticDipolesIIIJ;//[i:0..Nfreq][j:0..Nfreq][0..2] for diiij and diiii
	double**** quarticDipolesIIJK;//[i:0..Nfreq][j:0..Nfreq][k:0..Nfreq][0..2] for diijk i # j # j

	Molecule mol;
}NMRQFF;
static void computeQFFDerivativesEnergies(NMRQFF* qffConstants, int ordre, double* energies);
static void computeQFFDerivativesDipoles(NMRQFF* qffConstants, int ordre, double* dipoles[]);
static char* saveNMRQFFAppend(NMRQFF* qffConstants, char* inputFileName, Molecule* mol);
/************************************************************************************************************/
static void initnMRQFF0(NMRQFF* qffConstants, int nf)
{
	qffConstants->numberOfFrequencies = nf;
	qffConstants->numberOfFirstDipolesInput = 0;
	qffConstants->numberOfEnergies = 0;
	qffConstants->numberOfDipoles = 0;

	//printf("Begin initNMRQFF0 nf = %d\n",nf);

	qffConstants->frequencies = newVectorDouble(qffConstants->numberOfFrequencies);
        initVectorDouble(qffConstants->frequencies, qffConstants->numberOfFrequencies, 0.0);
	qffConstants->gradients = newVectorDouble(qffConstants->numberOfFrequencies);
        initVectorDouble(qffConstants->gradients, qffConstants->numberOfFrequencies, 0.0);
	//printf("End initgrad\n");
	qffConstants->calculatedFrequencies = newVectorDouble(qffConstants->numberOfFrequencies);
        initVectorDouble(qffConstants->calculatedFrequencies, qffConstants->numberOfFrequencies, 0.0);
	qffConstants->mass = newVectorDouble(qffConstants->numberOfFrequencies);
        initVectorDouble(qffConstants->mass, qffConstants->numberOfFrequencies, 0.0);
	qffConstants->delta = newVectorDouble(qffConstants->numberOfFrequencies);
        initVectorDouble(qffConstants->delta, qffConstants->numberOfFrequencies, 0.0);
	//printf("End initNMRQFF0\n");

	qffConstants->mol.nAtoms = 0;
	qffConstants->mol.atoms = NULL;

}
/************************************************************************************************************/
static void initnMRQFFEnergies(NMRQFF* qffConstants, int ordre)
{
	qffConstants->V0 = 0;
	qffConstants->VI = newMatrixDouble(qffConstants->numberOfFrequencies,6);
        initMatrixDouble(qffConstants->VI, qffConstants->numberOfFrequencies,6, 0.0);
	qffConstants->cubicEnergies = newMatrixDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies);
        initMatrixDouble(qffConstants->cubicEnergies, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies, 0.0);

	qffConstants->cubicEnergiesIJK = newCubeDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies);
        initCubeDouble(qffConstants->cubicEnergiesIJK, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies, 0.0);
	//printf("End initCubeDouble\n");

	qffConstants->quarticEnergiesIIJJ = newMatrixDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies);
        initMatrixDouble(qffConstants->quarticEnergiesIIJJ, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies, 0.0);
	qffConstants->quarticEnergiesIIIJ = newMatrixDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies);
        initMatrixDouble(qffConstants->quarticEnergiesIIIJ, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies, 0.0);
	qffConstants->quarticEnergiesIIJK = newCubeDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies);
        initCubeDouble(qffConstants->quarticEnergiesIIJK, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies, 0.0);

        qffConstants->quarticEnergiesIJKL = newQuarticDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies);
        initQuarticDouble(qffConstants->quarticEnergiesIJKL, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,0.0);
	//printf("End quarticEnergiesIIJK\n");

        qffConstants->VIJ = newCubeDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,4);
        initCubeDouble(qffConstants->VIJ, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,4,0.0);
        qffConstants->VI3J = newCubeDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,4);
        initCubeDouble(qffConstants->VI3J, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,4,0.0);

	//printf("Begin VIJK\n");
        qffConstants->VIJK =  NULL;
	if(ordre>=3)
	{
        	qffConstants->VIJK = newQuarticDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,8);
        	initQuarticDouble(qffConstants->VIJK, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,8,0.0);
	}
	//printf("End VIJK\n");

	//printf("Begin VIJKL\n");
        qffConstants->VIJKL = NULL;
	if(ordre>=4)
	{
        	qffConstants->VIJKL = newQuinticDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,16);
        	initQuinticDouble(qffConstants->VIJKL, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,16,0.0);
	}
	//printf("End VIJKL\n");
}
/************************************************************************************************************/
static void initnMRQFFDipoles(NMRQFF* qffConstants, int ordre)
{
	qffConstants->quarticDipolesIIJJ = newCubeDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,3);
        initCubeDouble(qffConstants->quarticDipolesIIJJ, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,3, 0.0);
	qffConstants->quarticDipolesIIIJ = newCubeDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,3);
        initCubeDouble(qffConstants->quarticDipolesIIIJ, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,3, 0.0);
        qffConstants->quarticDipolesIIJK = newQuarticDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,3);
        initQuarticDouble(qffConstants->quarticDipolesIIJK, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,3,0.0);
	//printf("End quarticDipolesIIJK\n");

	qffConstants->firstDipoles = newMatrixDouble(qffConstants->numberOfFrequencies,3);
        initMatrixDouble(qffConstants->firstDipoles, qffConstants->numberOfFrequencies,3, 0.0);

	qffConstants->firstDipolesInput = newMatrixDouble(qffConstants->numberOfFrequencies,3);
        initMatrixDouble(qffConstants->firstDipolesInput, qffConstants->numberOfFrequencies,3, 0.0);

        qffConstants->dipole0 = newVectorDouble(3);
        initVectorDouble(qffConstants->dipole0,3,0.0);

        qffConstants->dipolesI = newCubeDouble(qffConstants->numberOfFrequencies,6,3);
        initCubeDouble(qffConstants->dipolesI, qffConstants->numberOfFrequencies,6,3,0.0);

        qffConstants->secondDipoles = newCubeDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,3);
        initCubeDouble(qffConstants->secondDipoles, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,3,0.0);

        qffConstants->cubicDipoles = newCubeDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,3);
        initCubeDouble(qffConstants->cubicDipoles, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,3,0.0);

        qffConstants->cubicDipolesIJK = newQuarticDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,3);
        initQuarticDouble(qffConstants->cubicDipolesIJK, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,3,0.0);

        qffConstants->dipolesIJ = newQuarticDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,4,3);
        initQuarticDouble(qffConstants->dipolesIJ, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,4,3,0.0);

        qffConstants->dipolesI3J = newQuarticDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,4,3);
        initQuarticDouble(qffConstants->dipolesI3J, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,4,3,0.0);

	//printf("Begin dipolesIJK\n");
        qffConstants->dipolesIJK = NULL;
	if(ordre>=3)
	{
        	qffConstants->dipolesIJK = newQuinticDouble(qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,8,3);
        	initQuinticDouble(qffConstants->dipolesIJK, qffConstants->numberOfFrequencies, qffConstants->numberOfFrequencies, qffConstants->numberOfFrequencies,8,3,0.0);
	}
	//printf("End dipolesIJK\n");
}
/************************************************************************************************************/
static void freeNMRQFF(NMRQFF* qffConstants)
{
	freeVectorDouble(&qffConstants->frequencies);
	freeVectorDouble(&qffConstants->gradients);
	freeVectorDouble(&qffConstants->calculatedFrequencies);
	freeVectorDouble(&qffConstants->mass);
	freeVectorDouble(&qffConstants->delta);
	freeMatrixDouble(&qffConstants->VI, qffConstants->numberOfFrequencies);
	freeMatrixDouble(&qffConstants->cubicEnergies, qffConstants->numberOfFrequencies);
	freeMatrixDouble(&qffConstants->quarticEnergiesIIJJ, qffConstants->numberOfFrequencies);
	freeMatrixDouble(&qffConstants->quarticEnergiesIIIJ, qffConstants->numberOfFrequencies);
	freeCubeDouble(&qffConstants->quarticDipolesIIJJ, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies);
	freeCubeDouble(&qffConstants->quarticDipolesIIIJ, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies);
	freeMatrixDouble(&qffConstants->firstDipoles, qffConstants->numberOfFrequencies);
	freeMatrixDouble(&qffConstants->firstDipolesInput, qffConstants->numberOfFrequencies);
	freeCubeDouble(&qffConstants->VIJ, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies);
	freeCubeDouble(&qffConstants->VI3J, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies);

	freeVectorDouble(&qffConstants->dipole0);
	freeCubeDouble(&qffConstants->dipolesI, qffConstants->numberOfFrequencies,6);
	freeCubeDouble(&qffConstants->secondDipoles, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies);
	freeCubeDouble(&qffConstants->cubicDipoles, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies);

	freeQuarticDouble(&qffConstants->dipolesIJ, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,4);
	freeQuarticDouble(&qffConstants->dipolesI3J, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,4);
}
/********************************************************************************/
static void saveNMRQFF(NMRQFF* qffConstants, FILE* file)
{
	char tmp[BSIZE];
	int i,j;
	int nf = qffConstants->numberOfFrequencies;
	char txyz[]={'X','Y','Z'};
	int xyz;

	sprintf(tmp, "#====================================================================================\n");
	fprintf(file,"%s", tmp);   
	sprintf(tmp,"%s",
		"# nMR-QFF constants\n"
		"# See Yagi et al. J. Chem. Phys. 121, 1383 (2004)\n"
		);
	fprintf(file,"%s",tmp);   
	sprintf(tmp, "#====================================================================================\n");
	fprintf(file,"%s",tmp);   

	fprintf(file,"%s","\n");
	fprintf(file,"%s","VPT2Model=GVPT2\n");   
	fprintf(file,"%s","# VPT2Model=DCPT2\n");   
	fprintf(file,"%s","# VPT2Model=HDCPT2\n");   
	fprintf(file,"%s","# alphaHDCPT2=1.0\n");   
	fprintf(file,"%s","# betaHDCPT2=5e5\n");   
	fprintf(file,"%s","\n");
	fprintf(file,"%s","PropModel=GVPT2\n");
	fprintf(file,"%s","# PropModel=HDCPT2\n");
	fprintf(file,"%s","# PropModel=DCPT2\n");
	fprintf(file,"%s","# alphaPropHDCPT2=1.0\n");
	fprintf(file,"%s","# betaPropHDCPT2=5e5\n");
	fprintf(file,"%s","# alphaPropHDCPT2=1.0\n");
	fprintf(file,"%s","# betaPropHDCPT2=5e5\n");
	fprintf(file,"%s","maxFrequencyDifferenceFermi=200\n");
	fprintf(file,"%s","MartinCutOff1=1.0\n");
	fprintf(file,"%s","MartinCutOff2=1.0\n");
	fprintf(file,"%s","# ZCutOff=0.08\n");
	fprintf(file,"%s","\n");
	sprintf(tmp, "#====================================================================================\n");
	fprintf(file,"%s",tmp);   

	fprintf(file,"%s","\n");   
	sprintf(tmp,"nFrequencies=%d\n",nf);
	fprintf(file,"%s",tmp);   
	sprintf(tmp,"nDim=%d\n",3);
	fprintf(file,"%s",tmp);   
	fprintf(file,"%s","\n");   

	sprintf(tmp,"#i Freq(cm-1)  Calc.Freq   dQ(Bohr)  Mass(amu)\tGradient[ H amu^(-1/2) Bohr^(-1)]\n");
	fprintf(file,"%s",tmp);   
	fprintf(file,"%s","Hessian\n");   
	for(i=0;i<nf;i++) 
	{
		sprintf(tmp,"%d %d %0.14f %0.14f %0.14f %0.14f\t%0.14f\n",i+1, i+1, qffConstants->frequencies[i], 
				qffConstants->calculatedFrequencies[i], 
				qffConstants->delta[i], qffConstants->mass[i], qffConstants->gradients[i]);
		fprintf(file,"%s",tmp);   
	}
	fprintf(file,"%s","END\n\n");


	sprintf(tmp,"# i\tj\tk\tReduced values [cm-1]\n");
	fprintf(file,"%s",tmp);   
	fprintf(file,"%s","Cubic\n");   
	for(i=0;i<nf;i++)
        {
                for(j=0;j<nf;j++)
                {
			if(fabs(qffConstants->cubicEnergies[i][j])<1e-8) continue;
			sprintf(tmp,"%d\t%d\t%d\t%16.8f\n",i+1, i+1, j+1, qffConstants->cubicEnergies[i][j]);
			fprintf(file,"%s",tmp);   
                }
        }
	fprintf(file,"%s","END\n\n");


	sprintf(tmp,"# i\tj\tk\tl\tReduced values [cm-1]\n");
	fprintf(file,"%s",tmp);   
	fprintf(file,"%s","Quartic\n");   
	for(i=0;i<nf;i++)
        {
		for(j=0;j<=i;j++)
		{
			if(fabs(qffConstants->quarticEnergiesIIJJ[i][j])<1e-8) continue;
			sprintf(tmp,"%d\t%d\t%d\t%d\t%16.8f\n",i+1, i+1, j+1, j+1, qffConstants->quarticEnergiesIIJJ[i][j]);
			fprintf(file,"%s",tmp);   
		}
		for(j=0;j<nf;j++)
		{
			if(j==i) continue;
			if(fabs(qffConstants->quarticEnergiesIIIJ[i][j])<1e-8) continue;
			sprintf(tmp,"%d\t%d\t%d\t%d\t%16.8f\n",i+1, i+1, i+1, j+1, qffConstants->quarticEnergiesIIIJ[i][j]);
			fprintf(file,"%s",tmp);   
		}
        }
	fprintf(file,"%s","END\n\n");

	if(qffConstants->numberOfFirstDipolesInput==0)
	{
		sprintf(tmp,"#xyz\ti\tValues[au cm^1/2]\n");
		fprintf(file,"%s",tmp);   
		fprintf(file,"%s","First derivatives\n");
		for(i=0;i<nf;i++)
		for(xyz=0;xyz<3;xyz++)
		{
			if(fabs(qffConstants->firstDipoles[i][xyz])<1e-8) continue;
			sprintf(tmp,"%c\t%d\t%16.8f\n",txyz[xyz], i+1,qffConstants->firstDipoles[i][xyz]);
			fprintf(file,"%s",tmp);   
		}
		fprintf(file,"%s","END\n\n");
	}
	else
	{
		sprintf(tmp,"#xyz\ti\tInput values[au cm^1/2]\tCalculated values[au cm^1/2]\n");
		fprintf(file,"%s",tmp);   
		fprintf(file,"%s","First derivatives\n");
		for(i=0;i<nf;i++)
		for(xyz=0;xyz<3;xyz++)
		{
			if(fabs(qffConstants->firstDipolesInput[i][xyz])<1e-8) continue;
			sprintf(tmp,"%c\t%d\t%16.8f\t\t%16.8f\n",txyz[xyz], i+1,qffConstants->firstDipolesInput[i][xyz], qffConstants->firstDipoles[i][xyz]);
			fprintf(file,"%s",tmp);   
		}
		fprintf(file,"%s","END\n\n");
	}

	sprintf(tmp,"#xyz\ti\tj\tValues[au cm]\n");
	fprintf(file,"%s",tmp);   
	fprintf(file,"%s","Second derivatives\n");
	for(i=0;i<nf;i++)
	for(j=0;j<nf;j++)
	for(xyz=0;xyz<3;xyz++)
	{
		if(fabs(qffConstants->secondDipoles[i][j][xyz])<1e-8) continue;
		sprintf(tmp,"%c\t%d\t%d\t%16.8f\n",txyz[xyz], i+1,j+1,qffConstants->secondDipoles[i][j][xyz]);
		fprintf(file,"%s",tmp);   
	}
	fprintf(file,"%s","END\n\n");

	sprintf(tmp,"#xyz\ti\tj\tk\tValues[au cm^3/2]\n");
	fprintf(file,"%s",tmp);   
	fprintf(file,"%s","Cubic derivatives\n");
	for(i=0;i<nf;i++)
	for(j=0;j<nf;j++)
	for(xyz=0;xyz<3;xyz++)
	{
		if(fabs(qffConstants->cubicDipoles[i][j][xyz])<1e-8) continue;
		sprintf(tmp,"%c\t%d\t%d\t%d\t%16.8f\n",txyz[xyz], i+1,i+1,j+1,qffConstants->cubicDipoles[i][j][xyz]);
		fprintf(file,"%s",tmp);   
		if(i!=j)
		{
			sprintf(tmp,"%c\t%d\t%d\t%d\t%16.8f\n",txyz[xyz], i+1,j+1,i+1,qffConstants->cubicDipoles[i][j][xyz]);
			fprintf(file,"%s",tmp);   
			sprintf(tmp,"%c\t%d\t%d\t%d\t%16.8f\n",txyz[xyz], j+1,i+1,i+1,qffConstants->cubicDipoles[i][j][xyz]);
			fprintf(file,"%s",tmp);   
		}
	}
	fprintf(file,"%s","END\n\n");

}
/********************************************************************************/
static char* printnMRQFF(NMRQFF* qffConstants, char* inputFileName)
{
	char* fileNameOut = strdup_printf("%sQFF.txt",getSuffixNameFile(inputFileName));
	FILE* file = fopen(fileNameOut,"w");
	fprintf(stdout,"QFF parameters saved in %s file\n", fileNameOut);
	saveNMRQFF(qffConstants,file);
	fclose(file);
	return (fileNameOut);
}
/************************************************************************************************************/
static boolean readFrequenciesInitNMRQFF(FILE* file, NMRQFF* qffConstants)
{
	char t[BSIZE];
 	int nf = 0;
	boolean Ok = TRUE;
	int nn=1;
	double dum;
	int i;
	int ordre = 2;
	

	if(!goToStr(file, "Frequencies"))
	{
		fprintf(stderr,"I cannot read the harmonic frequencies\nChech your input file\n");
		return FALSE;
	}
	while(!feof(file))
	{
		if(!fgets(t,BSIZE,file))break;
		nn = sscanf(t,"%lf",&dum);
		if(nn<1) break;
		nf++;
	}
	if(nf==0)
	{
		fprintf(stderr,"I cannot read the harmonic frequencies\nChech your input file\n");
		return FALSE;
	}
	readOneInt(file,"QFFnModes",&ordre);
	initnMRQFF0(qffConstants,nf);
	rewind(file);
	goToStr(file, "Frequencies");
	for(i=0;i<nf;i++)
	{
		if(!fgets(t,BSIZE,file))break;
		nn = sscanf(t,"%lf",&qffConstants->frequencies[i]);
		if(nn<1) break;
	}
	qffConstants->numberOfFirstDipolesInput = 0;
	if(nn==1)
	{
		rewind(file);
		if(goToStr(file, "First derivatives"))
		for(i=0;i<nf && nn==1 ;i++)
		{
			int xyz;
			for(xyz=0;xyz<3 && nn==1 ;xyz++)
				nn = fscanf(file,"%lf",&qffConstants->firstDipolesInput[i][xyz]);
			qffConstants->numberOfFirstDipolesInput+= nn;
		}
		if(qffConstants->numberOfFirstDipolesInput != nf) qffConstants->numberOfFirstDipolesInput=0;
	}
	if(nn!=1) Ok = FALSE;
	return Ok;
}
/************************************************************************************************************/
static boolean readVectorRealQFF(FILE* file, char* tag, int n, double* values)
{
        char* TAG = NULL;
        int i=0;
	int nn = 0;
        if(!tag) return FALSE;
        if(!values) return FALSE;

        TAG = strdup(tag);
        uppercase(TAG);
        rewind(file);
	if(!goToStr(file, TAG)) 
	{
		fprintf(stderr,"I cannot find %s in our file\n",tag);
		if(TAG) free(TAG);
		return FALSE;
	}
	for(i=0;i<n;i++)
        {
		nn = fscanf(file,"%lf",&values[i]);
                if(nn!=1) break;
        }
	if(i!=n)
	{
		fprintf(stderr,"I cannot read %s\nCheck  the number of values\n",tag);
		return FALSE;
	}
	return TRUE;
}
/************************************************************************************************************/
static int getOrdre(int f, int nGeoms)
{
	int ordre = -1;
	if(nGeoms == 1 + 6*f) ordre = 1;
	if(nGeoms == 1 + 6*f+6*f*(f-1) ) ordre = 2;
	if(nGeoms == 1 + 6*f+6*f*(f-1) + 8*f*(f-1)*(f-2)/6 ) ordre = 3;
	if(nGeoms == 1 + 6*f+6*f*(f-1) + 8*f*(f-1)*(f-2)/6 + 16*f*(f-1)*(f-2)*(f-3)/24) ordre = 4;
	if(ordre<1)
	{
		printf("nModes = %d\n",ordre);
               	fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
               	fprintf(stderr,"Error, the number of files does not correspond to any known nMode (1,2,3,or4)\n");
               	fprintf(stderr,"Check the number of *QFF_*.gab files or the number of energies in your input file\n");
               	fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
               	exit(1);
	}
	return ordre;
}
/************************************************************************************************************/
static int readEnergiesAndDipoles(char* fileName, double* energies[], double* dipoles[])
{
	int n=1;
	int xyz;
        char* TAG = NULL;
	int nGeoms = 0;
	int index = 0;
	int nDipoles = 0;
	FILE* file = fopen(fileName,"rb");
        TAG = strdup("ENERGIES");
        uppercase(TAG);
        rewind(file);
	if(!goToStr(file, TAG)) 
	{
		fprintf(stderr,"I cannot find %s in our file\n",TAG);
		if(TAG) free(TAG);
		return FALSE;
	}

        // computes the number of geometries 
        nGeoms = 0;
        for(index=0; ;index++)
        {
		double e;
		n = fscanf(file,"%lf",&e);
                if(n<1) break;
                nGeoms++;
        }
        if(nGeoms<1)
        {
                fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
                fprintf(stderr,"I cannot read energies from %s file\n", fileName);
                fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
                exit(1);
        }
	printf("nGeoms = %d\n",nGeoms);
        rewind(file);
	goToStr(file, TAG);
        energies[0] = malloc(nGeoms*sizeof(double));
        for(index=0;index<nGeoms ;index++)
        {
		double e;
		n = fscanf(file,"%lf",&e);
                if(n<1) break;
                energies[0][index] = e;
        }
	free(TAG);
        TAG = strdup("DIPOLES");
        uppercase(TAG);
        rewind(file);
	if(!goToStr(file, TAG)) 
	{
		fprintf(stderr,"I cannot find %s in our file\n",TAG);
		if(TAG) free(TAG);
		return 0;
	}
	nDipoles = 0;
        for(index=0; ;index++)
        {
		double e;
		n = 1;
		for(xyz=0;xyz<3 && n==1;xyz++)
		{
			n = fscanf(file,"%lf",&e);
                	if(n<1) break;
			nDipoles++;
		}
		if(n<1) break;
        }
	nDipoles /= 3;
        if(nGeoms!=nDipoles)
        {
                fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
                fprintf(stderr,"Error : number of dipoles != number of geometries in %s file\n",fileName);
                fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
                exit(1);
        }
	printf("nDipoles  = %d\n",nDipoles);
        rewind(file);
	goToStr(file, TAG);
	for(xyz=0;xyz<3;xyz++) dipoles[xyz] = malloc(nGeoms*sizeof(double));
        for(index=0;index<nGeoms ;index++)
        {
		double e;
		n = 1;
		for(xyz=0;xyz<3 && n==1;xyz++)
		{
			n = fscanf(file,"%lf",&e);
                	if(n<1) break;
			dipoles[xyz][index] = e;
		}
		if(n<1) break;
        }
	fclose(file);
	return nGeoms;
}
/************************************************************************************************************/
static void computeGradients(NMRQFF* qffConstants)
{
 	int nf = qffConstants->numberOfFrequencies;
	int i;
	for(i=0;i<nf;i++)
	{
		double di = qffConstants->delta[i]*sqrt(qffConstants->mass[i]*AMUTOAU);
		qffConstants->gradients[i]=(
				+qffConstants->VI[i][0]+
				-9*qffConstants->VI[i][1]+
				+45*qffConstants->VI[i][2]+
				-45*qffConstants->VI[i][3]+
				+9*qffConstants->VI[i][4]
				-qffConstants->VI[i][5]
				)/(60.0*di);
	}
}
/************************************************************************************************************/
static void computeFrequencies(NMRQFF* qffConstants)
{
 	int nf = qffConstants->numberOfFrequencies;
	int i;
	for(i=0;i<nf;i++)
	{
		double di = qffConstants->delta[i]*qffConstants->delta[i]*AMUTOAU*qffConstants->mass[i];
		double f = 1/di/180;
		qffConstants->calculatedFrequencies[i]=AUTOCM1*sqrt(f*fabs((
		2*qffConstants->VI[i][0]+
		-27*qffConstants->VI[i][1]+
		+270*qffConstants->VI[i][2]+
		-490*qffConstants->V0+
		+270*qffConstants->VI[i][3]+
		-27*qffConstants->VI[i][4]+
		2*qffConstants->VI[i][5]
		)));
		/*
		qffConstants->calculatedFrequencies[i]=sqrt(fabs((
		  qffConstants->VI[i][2]
		- 2*qffConstants->V0
		+ qffConstants->VI[i][3]
		)
		/di))*AUTOCM1;
		*/
	}
}
/************************************************************************************************************/
static void computeCubicForces(NMRQFF* qffConstants)
{
 	int nf = qffConstants->numberOfFrequencies;
	int i,j,k;
	double f3cm1 = AUTOCM1*sqrt(AUTOCM1)*AUTOCM1;
	if(nf<1) return;
	// tiii

	for(i=0;i<nf;i++)
	{
		double mi = sqrt(qffConstants->mass[i]*AMUTOAU);
		double f = 1.0/(8.0*qffConstants->delta[i]*qffConstants->delta[i]*qffConstants->delta[i]*mi*mi*mi);
		f = f/qffConstants->frequencies[i]/sqrt(qffConstants->frequencies[i])*f3cm1;
		qffConstants->cubicEnergies[i][i] = f*(-qffConstants->VI[i][0]+8*qffConstants->VI[i][1]-13*qffConstants->VI[i][2]+13*qffConstants->VI[i][3]-8*qffConstants->VI[i][4]+qffConstants->VI[i][5]);
		/*
		double mi = sqrt(qffConstants->mass[i]);
		double f = 1.0/(2.0*qffConstants->delta[i]*qffConstants->delta[i]*qffConstants->delta[i]*mi*mi*mi);
		qffConstants->cubicEnergies[i][i] = f*(-1*qffConstants->VI[i][1]+2*qffConstants->VI[i][2]-2*qffConstants->VI[i][3]+1*qffConstants->VI[i][4]);
		*/
	}
	// tiij
	if(qffConstants->numberOfEnergies > 1+6*nf)
	for(i=0;i<nf;i++)
	{
		double fi = 1.0/(2.0*qffConstants->delta[i]*qffConstants->delta[i]*qffConstants->mass[i]*AMUTOAU);
		fi = fi/qffConstants->frequencies[i];
		for(j=0;j<nf;j++)
		{
			double fj,f;
			if(j==i) continue;
			fj = 1.0/(qffConstants->delta[j]*sqrt(qffConstants->mass[j]*AMUTOAU));
			fj = fj/sqrt(qffConstants->frequencies[j]);
			f = fi*fj*f3cm1;
			qffConstants->cubicEnergies[i][j] = f*(
				 (qffConstants->VIJ[i][j][0]+qffConstants->VIJ[i][j][2]-2*qffConstants->VI[j][2])
				-(qffConstants->VIJ[i][j][1]+qffConstants->VIJ[i][j][3]-2*qffConstants->VI[j][3])
			);

		}
	}
	// tijk , i # j # k
	if(qffConstants->numberOfEnergies > 1+6*nf*nf)
	for(i=0;i<nf;i++)
	{
		double fi;
		fi = 1.0/(qffConstants->delta[i]*sqrt(qffConstants->mass[i]*AMUTOAU));
		fi = fi/sqrt(qffConstants->frequencies[i]);
		for(j=0;j<i;j++)
		{
			double fj;
			fj = 1.0/(qffConstants->delta[j]*sqrt(qffConstants->mass[j]*AMUTOAU));
			fj = fj/sqrt(qffConstants->frequencies[j]);
			for(k=0;k<j;k++)
			{
				double fk,f;
				fk = 1.0/(qffConstants->delta[k]*sqrt(qffConstants->mass[k]*AMUTOAU));
				fk = fk/sqrt(qffConstants->frequencies[k]);
				f = fi*fj*fk/8;
				f =f*f3cm1;
				/* VIJK */
				/* 0  deltas[j],   deltas[i],  deltas[k] */
				/* 1  deltas[j],   deltas[i], -deltas[k] */
				/* 2  deltas[j],  -deltas[i],  deltas[k] */
				/* 3  deltas[j],  -deltas[i], -deltas[k] */
				/* 4 -deltas[j],  deltas[i],  deltas[k] */
				/* 5 -deltas[j],  deltas[i], -deltas[k] */
				/* 6 -deltas[j], -deltas[i],  deltas[k] */
				/* 7 -deltas[j], -deltas[i], -deltas[k] */
				qffConstants->cubicEnergiesIJK[i][j][k] = f*(
				+qffConstants->VIJK[i][j][k][0]
				-qffConstants->VIJK[i][j][k][1]
				-qffConstants->VIJK[i][j][k][2]
				+qffConstants->VIJK[i][j][k][3]
				-qffConstants->VIJK[i][j][k][4]
				+qffConstants->VIJK[i][j][k][5]
				+qffConstants->VIJK[i][j][k][6]
				-qffConstants->VIJK[i][j][k][7]
				);
			}
		}
	}
}
/************************************************************************************************************/
static void computeQuarticForces(NMRQFF* qffConstants)
{
 	int nf = qffConstants->numberOfFrequencies;
	double f4cm1 = AUTOCM1*AUTOCM1*AUTOCM1;
	int i,j,k,l;
	if(nf<1) return;

	// uiiii
	for(i=0;i<nf;i++)
	{
		double mdi = sqrt(qffConstants->mass[i]*AMUTOAU)*qffConstants->delta[i];
		double f = 1.0/(6.0*mdi*mdi*mdi*mdi)*f4cm1;
		f = f/(qffConstants->frequencies[i]*qffConstants->frequencies[i]);
		qffConstants->quarticEnergiesIIJJ[i][i] = f*(
		-qffConstants->VI[i][0]
		+12*qffConstants->VI[i][1]
		-39*qffConstants->VI[i][2]
		+56*qffConstants->V0
		-39*qffConstants->VI[i][3]
		+12*qffConstants->VI[i][4]
		-qffConstants->VI[i][5]
		);
		/*
		double f = 1.0/(mdi*mdi*mdi*mdi)*f4cm1;
		f = f/(qffConstants->frequencies[i]*qffConstants->frequencies[i]);
		qffConstants->quarticEnergiesIIJJ[i][i] = f*(
		qffConstants->VI[i][1]
		-4*qffConstants->VI[i][2]
		+6*qffConstants->V0
		-4*qffConstants->VI[i][3]
		+qffConstants->VI[i][4]
		);
		*/
		qffConstants->quarticEnergiesIIIJ[i][i] = qffConstants->quarticEnergiesIIJJ[i][i];
	}
	// uiiij
	if(qffConstants->numberOfEnergies > 1+6*nf)
	for(i=0;i<nf;i++)
	{
		double mdi = sqrt(qffConstants->mass[i]*AMUTOAU)*qffConstants->delta[i];
		double fi = 1.0/(16.0*mdi*mdi*mdi);
		fi = fi/(qffConstants->frequencies[i]*sqrt(qffConstants->frequencies[i]));
		for(j=0;j<nf;j++)
		{
			double fj,f;
			if(j==i) continue;
			fj = 1.0/(qffConstants->delta[j]*sqrt(qffConstants->mass[j]*AMUTOAU));
			fj = fj/(sqrt(qffConstants->frequencies[j]));
			f = fi*fj*f4cm1;
			qffConstants->quarticEnergiesIIIJ[i][j] = f*(
				 (qffConstants->VI3J[i][j][0]-3*qffConstants->VIJ[i][j][0]+3*qffConstants->VIJ[i][j][2]-qffConstants->VI3J[i][j][2])
				-(qffConstants->VI3J[i][j][1]-3*qffConstants->VIJ[i][j][1]+3*qffConstants->VIJ[i][j][3]-qffConstants->VI3J[i][j][3])
			);
		}
	}
	// uiijj
	if(qffConstants->numberOfEnergies > 1+6*nf)
	for(i=0;i<nf;i++)
	{
		double mdi = qffConstants->mass[i]*AMUTOAU*qffConstants->delta[i]*qffConstants->delta[i];
		double f = 1.0/(mdi*mdi)*f4cm1;
		f = f/(qffConstants->frequencies[i]*qffConstants->frequencies[i]);
		for(j=0;j<i;j++)
		{
			qffConstants->quarticEnergiesIIJJ[i][j] = f*(
				   (qffConstants->VIJ[i][j][0]+qffConstants->VIJ[i][j][2]+qffConstants->VIJ[i][j][1]+qffConstants->VIJ[i][j][3])
				-2*(qffConstants->VI[i][2]+qffConstants->VI[i][3]+qffConstants->VI[j][2]+qffConstants->VI[j][3])
				+4*qffConstants->V0
			);
			qffConstants->quarticEnergiesIIJJ[j][i] = qffConstants->quarticEnergiesIIJJ[i][j];
		}
	}
	// uiijk i # j # k
	if(qffConstants->numberOfEnergies > 1+6*nf*nf)
	for(i=0;i<nf;i++)
	{
		double mdi = sqrt(qffConstants->mass[i]*AMUTOAU)*qffConstants->delta[i];
		double fi = 1.0/(4.0*mdi*mdi);
		fi = fi/(qffConstants->frequencies[i]*sqrt(qffConstants->frequencies[i]));
		for(j=0;j<i;j++)
		{
			double fj;
			fj = 1.0/(qffConstants->delta[j]*sqrt(qffConstants->mass[j]*AMUTOAU));
			fj = fj/(sqrt(qffConstants->frequencies[j]));
			for(k=0;k<j;k++)
			{
				double fk,f;
				fk = 1.0/(qffConstants->delta[k]*sqrt(qffConstants->mass[k]*AMUTOAU));
				fk = fk/(sqrt(qffConstants->frequencies[k]));
				f = fi*fj*fk*f4cm1;
				/* VIJK */
				/* 0  deltas[j],   deltas[i],  deltas[k] */
				/* 1  deltas[j],   deltas[i], -deltas[k] */
				/* 2  deltas[j],  -deltas[i],  deltas[k] */
				/* 3  deltas[j],  -deltas[i], -deltas[k] */
				/* 4 -deltas[j],  deltas[i],  deltas[k] */
				/* 5 -deltas[j],  deltas[i], -deltas[k] */
				/* 6 -deltas[j], -deltas[i],  deltas[k] */
				/* 7 -deltas[j], -deltas[i], -deltas[k] */

				/* VIJ */
				/*  0  deltas[j],   deltas[i] */
				/*  1  deltas[j],  -deltas[i] */
				/*  2 -deltas[j],   deltas[i] */
				/*  3 -deltas[j],  -deltas[i] */
				qffConstants->quarticEnergiesIIJK[i][j][k] = 
				f*(
				+qffConstants->VIJK[i][j][k][0]
				-qffConstants->VIJK[i][j][k][2]
				-qffConstants->VIJK[i][j][k][1]
				+qffConstants->VIJK[i][j][k][3]
				+qffConstants->VIJK[i][j][k][4]
				-qffConstants->VIJK[i][j][k][6]
				-qffConstants->VIJK[i][j][k][5]
				+qffConstants->VIJK[i][j][k][7]
				-2*(qffConstants->VIJ[i][j][0] - qffConstants->VIJ[i][j][2] - qffConstants->VIJ[i][j][1] + qffConstants->VIJ[i][j][3])
				);
			}
		}
	}
	// uijkl i # j # k # l
	if(qffConstants->numberOfEnergies > 1+6*nf*nf+8*nf*(nf-1)*(nf-2)/6)
	for(i=0;i<nf;i++)
	{
		double fi;
		fi = 1.0/(qffConstants->delta[i]*sqrt(qffConstants->mass[i]*AMUTOAU));
		fi = fi/(sqrt(qffConstants->frequencies[i]));
		for(j=0;j<i;j++)
		{
			double fj;
			fj = 1.0/(qffConstants->delta[j]*sqrt(qffConstants->mass[j]*AMUTOAU));
			fj = fj/(sqrt(qffConstants->frequencies[j]));
			for(k=0;k<j;k++)
			{
				double fk;
				fk = 1.0/(qffConstants->delta[k]*sqrt(qffConstants->mass[k]*AMUTOAU));
				fk = fk/(sqrt(qffConstants->frequencies[k]));
				for(l=0;l<k;l++)
				{
				double fl,f;
				fl = 1.0/(qffConstants->delta[l]*sqrt(qffConstants->mass[l]*AMUTOAU));
				f = fi*fj*fk*fl*f4cm1;
				f = f/16.0;
				/* VIJKL */
				/* 0    deltas[j],   deltas[i],   deltas[k],  deltas[l] */ //+
				/* 1    deltas[j],   deltas[i],   deltas[k], -deltas[l] */ //-
				/* 2    deltas[j],   deltas[i],  -deltas[k],  deltas[l] */ //-
				/* 3    deltas[j],   deltas[i],  -deltas[k], -deltas[l] */ //+
				/* 4    deltas[j],  -deltas[i],   deltas[k],  deltas[l] */ //-
				/* 5    deltas[j],  -deltas[i],   deltas[k], -deltas[l] */ //+
				/* 6    deltas[j],  -deltas[i],  -deltas[k],  deltas[l] */ //+
				/* 7    deltas[j],  -deltas[i],  -deltas[k], -deltas[l] */ //-
				/* 8   -deltas[j],   deltas[i],   deltas[k],  deltas[l] */ //-
				/* 9   -deltas[j],   deltas[i],   deltas[k], -deltas[l] */ //+
				/* 10  -deltas[j],   deltas[i],  -deltas[k],  deltas[l] */ //+
				/* 11  -deltas[j],   deltas[i],  -deltas[k], -deltas[l] */ //-
				/* 12  -deltas[j],  -deltas[i],   deltas[k],  deltas[l] */ //+
				/* 13  -deltas[j],  -deltas[i],   deltas[k], -deltas[l] */ //-
				/* 14  -deltas[j],  -deltas[i],  -deltas[k],  deltas[l] */ //-
				/* 15  -deltas[j],  -deltas[i],  -deltas[k], -deltas[l] */ //+

				qffConstants->quarticEnergiesIJKL[i][j][k][l]= 
				f*(
				+qffConstants->VIJKL[i][j][k][l][0]
				-qffConstants->VIJKL[i][j][k][l][1]
				-qffConstants->VIJKL[i][j][k][l][2]
				+qffConstants->VIJKL[i][j][k][l][3]
				-qffConstants->VIJKL[i][j][k][l][4]
				+qffConstants->VIJKL[i][j][k][l][5]
				+qffConstants->VIJKL[i][j][k][l][6]
				-qffConstants->VIJKL[i][j][k][l][7]
				-qffConstants->VIJKL[i][j][k][l][8]
				+qffConstants->VIJKL[i][j][k][l][9]
				+qffConstants->VIJKL[i][j][k][l][10]
				-qffConstants->VIJKL[i][j][k][l][11]
				+qffConstants->VIJKL[i][j][k][l][12]
				-qffConstants->VIJKL[i][j][k][l][13]
				-qffConstants->VIJKL[i][j][k][l][14]
				+qffConstants->VIJKL[i][j][k][l][15]
				);
				}
			}
		}
	}
}
/************************************************************************************************************/
static void computeFirstDerivativesDipoles(NMRQFF* qffConstants)
{
 	int nf = qffConstants->numberOfFrequencies;
	int i;
	int xyz = 0;
	for(i=0;i<nf;i++)
	{
		double di = 60*qffConstants->delta[i]*sqrt(qffConstants->mass[i]*AMUTOAU);
		double f = 1/di;
		f =f*sqrt(AUTOCM1);
		for(xyz=0;xyz<3;xyz++)
			qffConstants->firstDipoles[i][xyz]=f*(
				+qffConstants->dipolesI[i][0][xyz]+
				-9*qffConstants->dipolesI[i][1][xyz]+
				+45*qffConstants->dipolesI[i][2][xyz]+
				-45*qffConstants->dipolesI[i][3][xyz]+
				+9*qffConstants->dipolesI[i][4][xyz]
				-qffConstants->dipolesI[i][5][xyz]
				);
	}
}
/************************************************************************************************************/
static void changeUnitInputFirstDerivativesDipoles(NMRQFF* qffConstants)
{
        double mu0 = 4*PI*1e-7;
        double eps0 = 1.0/(mu0*slight*slight);
        double   kmmolm1 = 4*PI*PI*PI*NAvogadro/3/hPlank/slight/4/PI/eps0*1e-3*100.0*8.47835267e-30*8.47835267e-30;/* 1e-3 m to km, 100 : cm-1 to m-1 */
	double f = 1.0/sqrt(kmmolm1);

        int nf = qffConstants->numberOfFrequencies;
        int i;
        int xyz = 0;
	if(qffConstants->numberOfFirstDipolesInput==0) return;
        for(i=0;i<nf;i++)
        {
                for(xyz=0;xyz<3;xyz++)
                        qffConstants->firstDipolesInput[i][xyz] *=f;
        }
}
/************************************************************************************************************/
static void computeSecondDerivativesDipoles(NMRQFF* qffConstants)
{
 	int nf = qffConstants->numberOfFrequencies;
	int i;
	int j;
	int xyz = 0;
	// dii
	for(i=0;i<nf;i++)
	{
		double di = qffConstants->delta[i]*qffConstants->delta[i]*AMUTOAU*qffConstants->mass[i];
		double f = 1/(180*di);
		f =f*(AUTOCM1);
		for(xyz=0;xyz<3;xyz++)
			qffConstants->secondDipoles[i][i][xyz]=f*(
				 2*qffConstants->dipolesI[i][0][xyz]
				-27*qffConstants->dipolesI[i][1][xyz]
				+270*qffConstants->dipolesI[i][2][xyz]
				-490*qffConstants->dipole0[xyz]
				+270*qffConstants->dipolesI[i][3][xyz]
				-27*qffConstants->dipolesI[i][4][xyz]
				+2*qffConstants->dipolesI[i][5][xyz]
				);
			/*
			qffConstants->secondDipoles[i][i][xyz]=180*f*(
				+qffConstants->dipolesI[i][2][xyz]
				-2*qffConstants->dipole0[xyz]
				+qffConstants->dipolesI[i][3][xyz]
				);
			*/
	}
	// dij
	if(qffConstants->numberOfEnergies > 1+6*nf)
	for(i=0;i<nf;i++)
	{
		double di = qffConstants->delta[i]*sqrt(qffConstants->mass[i]*AMUTOAU);
		for(j=0;j<nf;j++)
		{
			double dj = qffConstants->delta[j]*sqrt(qffConstants->mass[j]*AMUTOAU);
			double f = 1.0/(4.0*di*dj);
			if(i==j) continue;
			f =f*AUTOCM1;
			for(xyz=0;xyz<3;xyz++)
				qffConstants->secondDipoles[i][j][xyz]=f*(
				  qffConstants->dipolesIJ[i][j][0][xyz]
				- qffConstants->dipolesIJ[i][j][1][xyz]
				- qffConstants->dipolesIJ[i][j][2][xyz]
				+ qffConstants->dipolesIJ[i][j][3][xyz]
				);
			//for(xyz=0;xyz<3;xyz++)
				//qffConstants->secondDipoles[j][i][xyz]=qffConstants->secondDipoles[i][j][xyz];
		}
	}
}
/************************************************************************************************************/
static void computeCubicDerivativesDipoles(NMRQFF* qffConstants)
{
 	int nf = qffConstants->numberOfFrequencies;
	int i,j,k;
	int xyz;
	if(nf<1) return;
	// diii
	for(i=0;i<nf;i++)
	{
		double mi = sqrt(qffConstants->mass[i]*AMUTOAU);
		double f = 1.0/(8.0*qffConstants->delta[i]*qffConstants->delta[i]*qffConstants->delta[i]*mi*mi*mi);
		f =f*AUTOCM1*sqrt(AUTOCM1);
		for(xyz=0;xyz<3;xyz++)
			qffConstants->cubicDipoles[i][i][xyz] = f*
			(
			-   qffConstants->dipolesI[i][0][xyz]
			+8* qffConstants->dipolesI[i][1][xyz]
			-13*qffConstants->dipolesI[i][2][xyz]
			+13*qffConstants->dipolesI[i][3][xyz]
			-8* qffConstants->dipolesI[i][4][xyz]
			+   qffConstants->dipolesI[i][5][xyz]
			);
		//qffConstants->cubicDipoles[i][i][xyz] = f*(qffConstants->dipolesI[i][0][xyz]-3*qffConstants->dipolesI[i][2][xyz]+3*qffConstants->dipolesI[i][3][xyz]-qffConstants->dipolesI[i][5][xyz]);
	}
	// diij
	if(qffConstants->numberOfEnergies > 1+6*nf)
	for(i=0;i<nf;i++)
	{
		double fi = 1.0/(2.0*qffConstants->delta[i]*qffConstants->delta[i]*qffConstants->mass[i]*AMUTOAU);
		for(j=0;j<nf;j++)
		{
			double fj,f;
			if(j==i) continue;
			fj = 1.0/(qffConstants->delta[j]*sqrt(qffConstants->mass[j]*AMUTOAU));
			f = fi*fj;
			f =f*AUTOCM1*sqrt(AUTOCM1);
			for(xyz=0;xyz<3;xyz++)
				qffConstants->cubicDipoles[i][j][xyz] = f*(
				 (qffConstants->dipolesIJ[i][j][0][xyz]+qffConstants->dipolesIJ[i][j][2][xyz]-2*qffConstants->dipolesI[j][2][xyz])
				-(qffConstants->dipolesIJ[i][j][1][xyz]+qffConstants->dipolesIJ[i][j][3][xyz]-2*qffConstants->dipolesI[j][3][xyz])
			);
		}
	}
	// dijk , i # j # k
	if(qffConstants->numberOfEnergies > 1+6*nf*nf)
	for(i=0;i<nf;i++)
	{
		double fi;
		fi = 1.0/(qffConstants->delta[i]*sqrt(qffConstants->mass[i]*AMUTOAU));
		for(j=0;j<nf;j++)
		{
			double fj;
			fj = 1.0/(qffConstants->delta[j]*sqrt(qffConstants->mass[j]*AMUTOAU));
			if(i==j) continue;
			for(k=0;k<nf;k++)
			{
				double fk,f;
				int n = 0;
				if(i==j) n++;
				if(i==k) n++;
				if(j==k) n++;
				if(n>0) continue;
				fk = 1.0/(qffConstants->delta[k]*sqrt(qffConstants->mass[k]*AMUTOAU));
				f = fi*fj*fk/8;
				f =f*AUTOCM1*sqrt(AUTOCM1);
				/* VIJK */
				/* 0  deltas[j],   deltas[i],  deltas[k] */
				/* 1  deltas[j],   deltas[i], -deltas[k] */
				/* 2  deltas[j],  -deltas[i],  deltas[k] */
				/* 3  deltas[j],  -deltas[i], -deltas[k] */
				/* 4 -deltas[j],  deltas[i],  deltas[k] */
				/* 5 -deltas[j],  deltas[i], -deltas[k] */
				/* 6 -deltas[j], -deltas[i],  deltas[k] */
				/* 7 -deltas[j], -deltas[i], -deltas[k] */
				for(xyz=0;xyz<3;xyz++)
				qffConstants->cubicDipolesIJK[i][j][k][xyz] = f*(
				+qffConstants->dipolesIJK[i][j][k][0][xyz]
				-qffConstants->dipolesIJK[i][j][k][1][xyz]
				-qffConstants->dipolesIJK[i][j][k][2][xyz]
				+qffConstants->dipolesIJK[i][j][k][3][xyz]
				-qffConstants->dipolesIJK[i][j][k][4][xyz]
				+qffConstants->dipolesIJK[i][j][k][5][xyz]
				+qffConstants->dipolesIJK[i][j][k][6][xyz]
				-qffConstants->dipolesIJK[i][j][k][7][xyz]
				);
			}
		}
	}
}
/************************************************************************************************************/
static void computeQuarticDerivativesDipoles(NMRQFF* qffConstants)
{
 	int nf = qffConstants->numberOfFrequencies;
	int i,j,k;
	int xyz;
	if(nf<1) return;

	// diiii
	for(i=0;i<nf;i++)
	{
		double mdi = sqrt(qffConstants->mass[i]*AMUTOAU)*qffConstants->delta[i];
		double f = 1.0/(6*mdi*mdi*mdi*mdi);
		f =f*AUTOCM1*AUTOCM1;
		for(xyz=0;xyz<3;xyz++)
		{
			qffConstants->quarticDipolesIIJJ[i][i][xyz] = f*(
		   	-qffConstants->dipolesI[i][0][xyz]
		   	+12*qffConstants->dipolesI[i][1][xyz]
			-39*qffConstants->dipolesI[i][2][xyz]
			+56*qffConstants->dipole0[xyz]
			-39*qffConstants->dipolesI[i][3][xyz]
			+12*qffConstants->dipolesI[i][4][xyz]
			-qffConstants->dipolesI[i][5][xyz]);
			qffConstants->quarticDipolesIIIJ[i][i][xyz] = qffConstants->quarticDipolesIIJJ[i][i][xyz];
		}
	}
	// diiij
	if(qffConstants->numberOfEnergies > 1+6*nf)
	for(i=0;i<nf;i++)
	{
		double mdi = sqrt(qffConstants->mass[i]*AMUTOAU)*qffConstants->delta[i];
		double fi = 1.0/(16.0*mdi*mdi*mdi);
		for(j=0;j<nf;j++)
		{
			double fj,f;
			if(j==i) continue;
			fj = 1.0/(qffConstants->delta[j]*sqrt(qffConstants->mass[j]*AMUTOAU));
			f = fi*fj;
			f =f*AUTOCM1*AUTOCM1;
			for(xyz=0;xyz<3;xyz++)
				qffConstants->quarticDipolesIIIJ[i][j][xyz] = f*(
				 (	qffConstants->dipolesI3J[i][j][0][xyz]
					-3*qffConstants->dipolesIJ[i][j][0][xyz]
					+3*qffConstants->dipolesIJ[i][j][2][xyz]
					-qffConstants->dipolesI3J[i][j][2][xyz]
				)
				-(
					qffConstants->dipolesI3J[i][j][1][xyz]
					-3*qffConstants->dipolesIJ[i][j][1][xyz]
					+3*qffConstants->dipolesIJ[i][j][3][xyz]
					-qffConstants->dipolesI3J[i][j][3][xyz]
				)
				);
		}
	}
	// diijj
	if(qffConstants->numberOfEnergies > 1+6*nf)
	for(i=0;i<nf;i++)
	{
		double mdi = qffConstants->mass[i]*AMUTOAU*qffConstants->delta[i]*qffConstants->delta[i];
		double f = 1.0/(mdi*mdi);
		f =f*AUTOCM1*AUTOCM1;
		for(j=0;j<i;j++)
		{
			for(xyz=0;xyz<3;xyz++)
			{
				qffConstants->quarticDipolesIIJJ[i][j][xyz] = f*(
				   (
					qffConstants->dipolesIJ[i][j][0][xyz]
					+qffConstants->dipolesIJ[i][j][2][xyz]
					+qffConstants->dipolesIJ[i][j][1][xyz]
					+qffConstants->dipolesIJ[i][j][3][xyz]
				   )
				-2*(
					qffConstants->dipolesI[i][2][xyz]
					+qffConstants->dipolesI[i][3][xyz]
					+qffConstants->dipolesI[j][2][xyz]
					+qffConstants->dipolesI[j][3][xyz]
				)
				+4*qffConstants->dipole0[xyz]
				);
				qffConstants->quarticDipolesIIJJ[j][i][xyz] = qffConstants->quarticDipolesIIJJ[i][j][xyz];
			}
		}
	}
	// diijk i # j # k
	if(qffConstants->numberOfEnergies > 1+6*nf*nf)
	for(i=0;i<nf;i++)
	{
		double mdi = sqrt(qffConstants->mass[i]*AMUTOAU)*qffConstants->delta[i];
		double fi = 1.0/(4.0*mdi*mdi);
		for(j=0;j<nf;j++)
		{
			double fj;
			fj = 1.0/(qffConstants->delta[j]*sqrt(qffConstants->mass[j]*AMUTOAU));
			for(k=0;k<nf;k++)
			{
				double fk,f;
				int n = 0;
				if(i==j) n++;
				if(i==k) n++;
				if(j==k) n++;
				if(n>=2) continue;
				fk = 1.0/(qffConstants->delta[k]*sqrt(qffConstants->mass[k]*AMUTOAU));
				f = fi*fj*fk;
				f =f*AUTOCM1*AUTOCM1;
				/* quarticDipolesIIJK */
				/* 0  deltas[j],   deltas[i],  deltas[k] */
				/* 1  deltas[j],   deltas[i], -deltas[k] */
				/* 2  deltas[j],  -deltas[i],  deltas[k] */
				/* 3  deltas[j],  -deltas[i], -deltas[k] */
				/* 4 -deltas[j],  deltas[i],  deltas[k] */
				/* 5 -deltas[j],  deltas[i], -deltas[k] */
				/* 6 -deltas[j], -deltas[i],  deltas[k] */
				/* 7 -deltas[j], -deltas[i], -deltas[k] */

				/* dipolesIJ */
				/*  0  deltas[j],   deltas[i] */
				/*  1  deltas[j],  -deltas[i] */
				/*  2 -deltas[j],   deltas[i] */
				/*  3 -deltas[j],  -deltas[i] */
				for(xyz=0;xyz<3;xyz++)
					qffConstants->quarticDipolesIIJK[i][j][k][xyz] = f*
					(
				 	+qffConstants->dipolesIJK[i][j][k][0][xyz]
				 	-qffConstants->dipolesIJK[i][j][k][2][xyz]
				 	-qffConstants->dipolesIJK[i][j][k][1][xyz]
				 	+qffConstants->dipolesIJK[i][j][k][3][xyz]
				 	+qffConstants->dipolesIJK[i][j][k][4][xyz]
				 	-qffConstants->dipolesIJK[i][j][k][6][xyz]
				 	-qffConstants->dipolesIJK[i][j][k][5][xyz]
				 	+qffConstants->dipolesIJK[i][j][k][7][xyz]
					-2*(
					+qffConstants->dipolesIJ[i][j][0][xyz]
					-qffConstants->dipolesIJ[i][j][2][xyz]
					-qffConstants->dipolesIJ[i][j][1][xyz]
					+qffConstants->dipolesIJ[i][j][3][xyz]
					)
					);
			}
		}
	}
}
/************************************************************************************************************/
char* computeQFFFromEnergiesDipolesFile(char* fileName)
{
	NMRQFF* qffConstants;
	boolean Ok = TRUE;
	FILE* file = NULL;
	int nGeoms = 0;
	int ordre = 0;
	double* energies = NULL;
	double* dipoles[] = { NULL, NULL, NULL};
	char* fileNameOut = NULL;

 	file = fopen(fileName, "rb"); 
        if(!file) 
	{
		fprintf(stderr,"I cannot open the %s file\n",fileName);
		return FALSE;
	}

	qffConstants = (NMRQFF*) malloc(sizeof(NMRQFF));
	qffConstants->numberOfFrequencies = 0;
	Ok =  readFrequenciesInitNMRQFF(file, qffConstants);
	if(Ok) Ok = readVectorRealQFF(file, "Mass", qffConstants->numberOfFrequencies, qffConstants->mass);
	if(Ok) Ok = readVectorRealQFF(file, "Delta", qffConstants->numberOfFrequencies, qffConstants->delta);

	
	printf("Begin readEnergiesAndDipoles\n");
	nGeoms = readEnergiesAndDipoles(fileName, &energies, dipoles);
	printf("End readEnergiesAndDipoles\n");
	ordre =  getOrdre(qffConstants->numberOfFrequencies, nGeoms);
        qffConstants->numberOfEnergies = nGeoms;
	computeQFFDerivativesEnergies(qffConstants, ordre, energies);
	printf("Energ computeQFFDerivativesEnergies\n");
	computeQFFDerivativesDipoles(qffConstants, ordre, dipoles);
	printf("Energ computeQFFDerivativesDipoles\n");

	fileNameOut =  printnMRQFF(qffConstants, fileName);

	return fileNameOut;
}
/********************************************************************************/
static int readGradGabeditFile(Molecule* mol, char* inputFileName, int index, boolean readGrad)
{
        char* fileName = NULL;
        char* prefixName = NULL;
        int i=0;
	int xyz;

        if(!mol || mol->nAtoms<1) return 0;
        if(!inputFileName) return 0;

        prefixName = strdup_printf("%sQFF",getSuffixNameFile(inputFileName));

        fileName = strdup_printf("%s_%d.gab",prefixName,index);
	{
		FILE* file = fopen(fileName,"r");
		if(!file) return 0;
		fclose(file);
	}

	i = readEnergyAndDipoleFromGabeditFile(fileName, &mol->potentialEnergy, mol->dipole);
        //printf("FileName = %s E = %f D = %f %f %f\n", fileName, mol->potentialEnergy, mol->dipole[0],  mol->dipole[1],  mol->dipole[2]);
	if(readGrad) mol->klass->readGradientFromGabeditFile(mol, fileName);
        if(fileName) free(fileName);
	mol->potentialEnergy /= AUTOKCAL;
	for(xyz=0;xyz<3;xyz++)  mol->dipole[xyz] /=  AUTODEB;
        return i;
}
/*****************************************************************************/
static int readEnergiesAndDipolesQFFFromFiles(char* inputFileName, double* energies[], double* dipoles[])
{
	int xyz;
	int index;
	Molecule* mol;
	char* prefixName;
	char* fileName;
	int n;
	int nGeoms = 0;

	prefixName = strdup_printf("%sQFF",getSuffixNameFile(inputFileName));
        fileName = strdup_printf("%s_%d.gab",prefixName,0);

	printf("Reading molecule from %s file\n", fileName);
	mol = readMoleculeFromGabeditFile(fileName);
	if(!mol || mol->nAtoms<1) 
	{
		fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		fprintf(stderr," Error : I cannot read geometry from %s Gabedit file\n",fileName);
		fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		exit(1);
	}
	// computes the number of geometries 
	nGeoms = 0;
	for(index=0; ;index++)
	{
		n = readGradGabeditFile(mol, inputFileName, index, FALSE);
		if(n<1) break;
		nGeoms++;
	}
	if(nGeoms<1)
	{
               	fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
               	fprintf(stderr,"I cannot read energy and dipole from %sQFF*.gab gabedit files\n", inputFileName);
               	fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
               	exit(1);
	}
	energies[0] = malloc(nGeoms*sizeof(double));
	for(xyz=0;xyz<3;xyz++) dipoles[xyz] = malloc(nGeoms*sizeof(double));
	for(index=0;index<nGeoms ;index++)
	{
		n = readGradGabeditFile(mol, inputFileName, index, FALSE);
		if(n<1) break;
		energies[0][index] = mol->potentialEnergy;
		for(xyz=0;xyz<3;xyz++) dipoles[xyz][index] = mol->dipole[xyz];
	}
	return nGeoms;
}
/*****************************************************************************/
char* computeQFFFromFiles(char* inputFileName)
{
	int i;
	int index;
	Molecule* mol;
	char* prefixName;
	char* fileName;
	FILE* file  = NULL;
	char buffer[BSIZE];
	NMRQFF* qffConstants;
	int ordre = -1;
	double* energies = NULL;
	double* dipoles[] = {NULL, NULL, NULL};
	int f=0, nGeoms = 0;
	char* fileNameOut = NULL;

	prefixName = strdup_printf("%sQFF",getSuffixNameFile(inputFileName));
        fileName = strdup_printf("%s_%d.gab",prefixName,0);

	//printf("Reading molecule from %s file\n", fileName);
	mol = readMoleculeFromGabeditFile(fileName);
	if(!mol || mol->nAtoms<1) 
	{
		fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		fprintf(stderr," Error : I cannot read geometry from %s Gabedit file\n",fileName);
		fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		exit(1);
	}
	qffConstants = (NMRQFF*) malloc(sizeof(NMRQFF));
	qffConstants->numberOfFrequencies = 0;
	//printf("nAtoms = %d\n", mol->nAtoms);

	// compute number of modes. It is <= 3*mol->nAtoms
	for(i=1;i<=6*3*mol->nAtoms;i++)
	{
        	fileName = strdup_printf("%s_%d.ici",prefixName,i);
		//printf("fileName = %s\n", fileName);
		file = fopen(fileName,"r");
		while(file && !feof(file))
        	{
                	if(!fgets(buffer,BSIZE,file))break;
			//printf("buffer = %s\n", buffer);
                	if(strstr(buffer,"Mode:")) 
			{
				qffConstants->numberOfFrequencies++;
				break;
			}
		}
		if(file)fclose(file);
		else break;
		free(fileName);
	}
	qffConstants->numberOfFrequencies /= 6;
	//printf("numberOfFrequencies = %d\n", qffConstants->numberOfFrequencies);
	initnMRQFF0(qffConstants,qffConstants->numberOfFrequencies);

	index = 1;
	for(i=0;i<qffConstants->numberOfFrequencies;i++)
	{
        	fileName = strdup_printf("%s_%d.ici",prefixName,index);
		file = fopen(fileName,"r");
		while(file && !feof(file))
        	{
                	if(!fgets(buffer,BSIZE,file))break;
                	if(strstr(buffer,"Mode:")) 
			{
				double freq = 0;
				double mass = 0;
				double delta = 0;
				//#Mode: Freq= 625.021755910743 Mass= 1.043203662605 Q= Qeq + 0.644571737151 akI=0.000042
				sscanf(strstr(buffer,"Freq=")+strlen("Freq="),"%lf",&freq);
				sscanf(strstr(buffer,"Mass=")+strlen("Mass="),"%lf",&mass);
				sscanf(strstr(buffer,"Qeq +")+strlen("Qeq +"),"%lf",&delta);
				qffConstants->frequencies[i] = freq;
				qffConstants->mass[i] = mass;
				qffConstants->delta[i] = delta/3.0;
				break;
			}
		}
		fclose(file);
		free(fileName);
		index += 6;
	}
	nGeoms = readEnergiesAndDipolesQFFFromFiles(inputFileName, &energies, dipoles);
	f = qffConstants->numberOfFrequencies;
	ordre =  getOrdre(f, nGeoms);
        qffConstants->numberOfEnergies = nGeoms;
	computeQFFDerivativesEnergies(qffConstants, ordre, energies);
	//printf("Energ computeQFFDerivativesEnergies\n");
	computeQFFDerivativesDipoles(qffConstants, ordre, dipoles);
	//printf("Energ computeQFFDerivativesDipoles\n");

	fileNameOut = saveNMRQFFAppend(qffConstants, inputFileName,NULL);
	
	return fileNameOut;
}
/**********************************************************************************************************************/
void generateQFFCChemIFilesForFrequencies(char* inputFileName)
{
	Molecule* mol = readMolecule(inputFileName,TRUE);
	double delta = 0.5;
	boolean reducedCoordinates = TRUE;
	FILE* file = fopen(inputFileName,"rb");
	int ordre = 2;

	readOneBoolean(file,"QFFReducedCoordinates",&reducedCoordinates);
	readOneInt(file,"QFFnModes",&ordre);
	if(!reducedCoordinates) delta = 1e-2;
	readOneReal(file,"QFFDelta",&delta);
	fclose(file);
	printf("delta = %f ",delta);
	if(reducedCoordinates) printf("reducedCoordiantes\n");
	else printf(" Angshtrom\n");
	printf("nAtoms = %d\n",mol->nAtoms);
	printf("nModes = %d\n",mol->vibration.nModes);

	/*
	printf("seet test.gab\n");
	mol->klass->save(mol, "test.gab");
	*/

	mol->klass->generateQFFCChemIFiles(mol, inputFileName, delta,  reducedCoordinates, ordre);
	printf("ordre = %d\n",ordre);
	mol->klass->saveFirstDerivatives(inputFileName,mol);

	mol->klass->free(mol);
}
/**********************************************************************************************************************/
double*** getGeomsQFF(char* inputFileName, Molecule** molecule, int* pOrdre, double** pDeltas, int* nGeoms)
{
	Molecule* mol = readMolecule(inputFileName,TRUE);
	double delta = 0.5;
	boolean reducedCoordinates = TRUE;
	int ordre = 2;
	FILE* file = fopen(inputFileName,"rb");
	double*** geoms = NULL;

	readOneBoolean(file,"QFFReducedCoordinates",&reducedCoordinates);
	readOneInt(file,"QFFnModes",&ordre);
	if(!reducedCoordinates) delta = 1e-2;
	readOneReal(file,"QFFDelta",&delta);
	fclose(file);
	printf("delta = %f ",delta);
	if(reducedCoordinates) printf("reducedCoordiantes\n");
	else printf(" Angshtrom\n");
	printf("nAtoms = %d\n",mol->nAtoms);
	printf("nModes = %d\n",mol->vibration.nModes);

	/*
	printf("seet test.gab\n");
	mol->klass->save(mol, "test.gab");
	*/

	geoms = mol->klass->getGeomsQFF(mol, inputFileName, delta,  reducedCoordinates, ordre, pDeltas, nGeoms);
	*pOrdre = ordre;

	//mol->klass->free(mol);
	*molecule = mol;
	return geoms;
}
/********************************************************************************/
static char* saveNMRQFFAppend(NMRQFF* qffConstants, char* inputFileName, Molecule* mol)
{

	char tmp[BSIZE];
	int i,j,k,l;
	int nf = qffConstants->numberOfFrequencies;
	char txyz[]={'X','Y','Z'};
	int xyz;
        char* fileNameOut = strdup_printf("%sQFF.txt",getSuffixNameFile(inputFileName));
        FILE* file = fopen(fileNameOut,"w");
        FILE* fileIn = fopen(inputFileName,"rb");
        fprintf(stdout,"QFF parameters saved in %s file\n", fileNameOut);


	while(!feof(fileIn))
      	{
                if(!fgets(tmp,BSIZE,fileIn))break;
		fprintf(file,"%s",tmp);
        }
	fclose(fileIn);

	sprintf(tmp, "#====================================================================================\n");
	fprintf(file,"%s", tmp);   
	sprintf(tmp,"%s",
		"# nMR-QFF constants\n"
		"# See Yagi et al. J. Chem. Phys. 121, 1383 (2004)\n"
		);
	fprintf(file,"%s",tmp);   
	sprintf(tmp, "#====================================================================================\n");
	fprintf(file,"%s",tmp);   

	fprintf(file,"%s","\n");
	fprintf(file,"%s","VPT2Model=GVPT2\n");   
	fprintf(file,"%s","# VPT2Model=DCPT2\n");   
	fprintf(file,"%s","# VPT2Model=HDCPT2\n");   
	fprintf(file,"%s","# alphaHDCPT2=1.0\n");   
	fprintf(file,"%s","# betaHDCPT2=5e5\n");   
	fprintf(file,"%s","\n");
	fprintf(file,"%s","PropModel=GVPT2\n");
	fprintf(file,"%s","# PropModel=HDCPT2\n");
	fprintf(file,"%s","# PropModel=DCPT2\n");
	fprintf(file,"%s","# alphaPropHDCPT2=1.0\n");
	fprintf(file,"%s","# betaPropHDCPT2=5e5\n");
	fprintf(file,"%s","# alphaPropHDCPT2=1.0\n");
	fprintf(file,"%s","# betaPropHDCPT2=5e5\n");
	fprintf(file,"%s","maxFrequencyDifferenceFermi=200\n");
	fprintf(file,"%s","MartinCutOff1=1.0\n");
	fprintf(file,"%s","MartinCutOff2=1.0\n");
	fprintf(file,"%s","# ZCutOff=0.08\n");
	fprintf(file,"%s","\n");
	sprintf(tmp, "#====================================================================================\n");
	fprintf(file,"%s",tmp);   

	fprintf(file,"%s","\n");   
	sprintf(tmp,"nFrequencies=%d\n",nf);
	fprintf(file,"%s",tmp);   
	sprintf(tmp,"nDim=%d\n",3);
	fprintf(file,"%s",tmp);   
	fprintf(file,"%s","\n");   

	sprintf(tmp,"#i Freq(cm-1)  Calc.Freq   dQ(Bohr)  Mass(amu)\tGradient[ H amu^(-1/2) Bohr^(-1)]\n");
	fprintf(file,"%s",tmp);   
	fprintf(file,"%s","Hessian\n");   
	for(i=0;i<nf;i++) 
	{
		sprintf(tmp,"%d %d %0.14f %0.14f %0.14f %0.14f\t%0.14f\n",i+1, i+1, qffConstants->frequencies[i], 
				qffConstants->calculatedFrequencies[i], 
				qffConstants->delta[i], qffConstants->mass[i], qffConstants->gradients[i]);
		fprintf(file,"%s",tmp);   
	}
	fprintf(file,"%s","END\n\n");


	sprintf(tmp,"# i\tj\tk\tReduced values [cm-1]\n");
	fprintf(file,"%s",tmp);   
	fprintf(file,"%s","Cubic\n");   
	for(i=0;i<nf;i++)
        {
                for(j=0;j<nf;j++)
                {
			if(fabs(qffConstants->cubicEnergies[i][j])<1e-8) continue;
			sprintf(tmp,"%d\t%d\t%d\t%16.8f\n",i+1, i+1, j+1, qffConstants->cubicEnergies[i][j]);
			fprintf(file,"%s",tmp);   
                }
                for(j=0;j<i;j++)
                for(k=0;k<j;k++)
                {
			if(fabs(qffConstants->cubicEnergiesIJK[i][j][k])<1e-8) continue;
			sprintf(tmp,"%d\t%d\t%d\t%16.8f\n",i+1, j+1, k+1, qffConstants->cubicEnergiesIJK[i][j][k]);
			fprintf(file,"%s",tmp);   
                }
        }
	fprintf(file,"%s","END\n\n");


	sprintf(tmp,"# i\tj\tk\tl\tReduced values [cm-1]\n");
	fprintf(file,"%s",tmp);   
	fprintf(file,"%s","Quartic\n");   
	for(i=0;i<nf;i++)
        {
		for(j=0;j<=i;j++)
		{
			if(fabs(qffConstants->quarticEnergiesIIJJ[i][j])<1e-8) continue;
			sprintf(tmp,"%d\t%d\t%d\t%d\t%16.8f\n",i+1, i+1, j+1, j+1, qffConstants->quarticEnergiesIIJJ[i][j]);
			fprintf(file,"%s",tmp);   
		}
		for(j=0;j<nf;j++)
		{
			if(j==i) continue;
			if(fabs(qffConstants->quarticEnergiesIIIJ[i][j])<1e-8) continue;
			sprintf(tmp,"%d\t%d\t%d\t%d\t%16.8f\n",i+1, i+1, i+1, j+1, qffConstants->quarticEnergiesIIIJ[i][j]);
			fprintf(file,"%s",tmp);   
		}
                for(j=0;j<i;j++)
                for(k=0;k<j;k++)
		{
			if(fabs(qffConstants->quarticEnergiesIIJK[i][j][k])<1e-8) continue;
			sprintf(tmp,"%d\t%d\t%d\t%d\t%16.8f\n",i+1, i+1, j+1, k+1, qffConstants->quarticEnergiesIIJK[i][j][k]);
			fprintf(file,"%s",tmp);   
		}
                for(j=0;j<i;j++)
                for(k=0;k<j;k++)
                for(l=0;l<k;l++)
		{
			if(fabs(qffConstants->quarticEnergiesIJKL[i][j][k][l])<1e-8) continue;
			sprintf(tmp,"%d\t%d\t%d\t%d\t%16.8f\n",i+1, j+1, k+1, l+1, qffConstants->quarticEnergiesIJKL[i][j][k][l]);
			fprintf(file,"%s",tmp);   
		}
        }
	fprintf(file,"%s","END\n\n");

	if(mol)
	{
		mol->klass->addFirstDerivativeToFile(mol, file);
	}
	if(qffConstants->numberOfFirstDipolesInput==0)
	{
		sprintf(tmp,"#xyz\ti\tValues[au cm^1/2]\n");
		fprintf(file,"%s",tmp);   
		fprintf(file,"%s","First derivatives\n");
		for(i=0;i<nf;i++)
		for(xyz=0;xyz<3;xyz++)
		{
			if(fabs(qffConstants->firstDipoles[i][xyz])<1e-8) continue;
			sprintf(tmp,"%c\t%d\t%16.8f\n",txyz[xyz], i+1,qffConstants->firstDipoles[i][xyz]);
			fprintf(file,"%s",tmp);   
		}
		fprintf(file,"%s","END\n\n");
	}
	else
	{
		sprintf(tmp,"#xyz\ti\tInput values[au cm^1/2]\tCalculated values[au cm^1/2]\n");
		fprintf(file,"%s",tmp);   
		fprintf(file,"%s","First derivatives\n");
		for(i=0;i<nf;i++)
		for(xyz=0;xyz<3;xyz++)
		{
			if(fabs(qffConstants->firstDipolesInput[i][xyz])<1e-8) continue;
			sprintf(tmp,"%c\t%d\t%16.8f\t\t%16.8f\n",txyz[xyz], i+1,qffConstants->firstDipolesInput[i][xyz], qffConstants->firstDipoles[i][xyz]);
			fprintf(file,"%s",tmp);   
		}
		fprintf(file,"%s","END\n\n");
	}

	sprintf(tmp,"#xyz\ti\tj\tValues[au cm]\n");
	fprintf(file,"%s",tmp);   
	fprintf(file,"%s","Second derivatives\n");
	for(i=0;i<nf;i++)
	for(j=0;j<nf;j++)
	for(xyz=0;xyz<3;xyz++)
	{
		if(fabs(qffConstants->secondDipoles[i][j][xyz])<1e-8) continue;
		sprintf(tmp,"%c\t%d\t%d\t%16.8f\n",txyz[xyz], i+1,j+1,qffConstants->secondDipoles[i][j][xyz]);
		fprintf(file,"%s",tmp);   
	}
	fprintf(file,"%s","END\n\n");

	sprintf(tmp,"#xyz\ti\tj\tk\tValues[au cm^3/2]\n");
	fprintf(file,"%s",tmp);   
	fprintf(file,"%s","Cubic derivatives\n");
	for(i=0;i<nf;i++)
	for(j=0;j<nf;j++)
	for(xyz=0;xyz<3;xyz++)
	{
		if(fabs(qffConstants->cubicDipoles[i][j][xyz])<1e-8) continue;
		sprintf(tmp,"%c\t%d\t%d\t%d\t%16.8f\n",txyz[xyz], i+1,i+1,j+1,qffConstants->cubicDipoles[i][j][xyz]);
		fprintf(file,"%s",tmp);   
		if(i!=j)
		{
			sprintf(tmp,"%c\t%d\t%d\t%d\t%16.8f\n",txyz[xyz], i+1,j+1,i+1,qffConstants->cubicDipoles[i][j][xyz]);
			fprintf(file,"%s",tmp);   
			sprintf(tmp,"%c\t%d\t%d\t%d\t%16.8f\n",txyz[xyz], j+1,i+1,i+1,qffConstants->cubicDipoles[i][j][xyz]);
			fprintf(file,"%s",tmp);   
		}
	}
	fprintf(file,"%s","END\n\n");
        fclose(file);
	return fileNameOut;

}
/*****************************************************************************/
static void computeQFFDerivativesEnergies(NMRQFF* qffConstants, int ordre, double* energies)
{
	int i;
	int j;
	int k;
	int l;
	int index;
	boolean Ok = TRUE;

	initnMRQFFEnergies(qffConstants, ordre);

	index = 0;
        qffConstants->V0 =energies[index];

	for(j=0;j<qffConstants->numberOfFrequencies;j++)
	{
		int k = 0;
		index++;  /*  3*deltas[j], 0 */
		qffConstants->VI[j][k] = energies[index]; 

		index++; k++; /*  2*deltas[j], 0 */
		qffConstants->VI[j][k] = energies[index]; 

		index++; k++; /*  1*deltas[j], 0 */
		qffConstants->VI[j][k] = energies[index]; 

		index++; k++; /* -1*deltas[j], 0 */
		qffConstants->VI[j][k] = energies[index]; 

		index++; k++; /* -2*deltas[j], 0 */
		qffConstants->VI[j][k] = energies[index]; 
	
		index++; k++; /* -3*deltas[j], 0 */
		qffConstants->VI[j][k] = energies[index]; 
	}

	if(ordre>=2)
	for(j=0;j<qffConstants->numberOfFrequencies;j++)
	{
		for(i=0;i<j;i++)
		{
			int k;
			index++; /*  deltas[j],   deltas[i] */
                        k = 0;
			qffConstants->VIJ[j][i][k] = energies[index]; 

			index++;/*  deltas[j],  -deltas[i] */
                        k = 1; 
			qffConstants->VIJ[j][i][k] = energies[index]; 

			index++; /* -deltas[j],   deltas[i] */
                        k = 2; 
			qffConstants->VIJ[j][i][k] = energies[index]; 

			index++; /* -deltas[j],  -deltas[i] */
                        k = 3;
			qffConstants->VIJ[j][i][k] = energies[index]; 

                	qffConstants->VIJ[i][j][0] = qffConstants->VIJ[j][i][0];
                	qffConstants->VIJ[i][j][1] = qffConstants->VIJ[j][i][2];
                	qffConstants->VIJ[i][j][2] = qffConstants->VIJ[j][i][1];
                	qffConstants->VIJ[i][j][3] = qffConstants->VIJ[j][i][3];

		}
		for(i=0;i<qffConstants->numberOfFrequencies;i++)
		{
			int k;
			if(i==j) continue;
			index++; /*  deltas[j],  3*deltas[i] */
                        k = 0;
			qffConstants->VI3J[j][i][k] = energies[index]; 

			index++; /*  deltas[j], -3*deltas[i] */
                        k = 1; 
			qffConstants->VI3J[j][i][k] = energies[index]; 

			index++; /* -deltas[j],  3*deltas[i] */
                        k = 2; 
			qffConstants->VI3J[j][i][k] = energies[index]; 

			index++; /* -deltas[j], -3*deltas[i] */
                        k = 3;
			qffConstants->VI3J[j][i][k] = energies[index]; 
		}
	}
	if(ordre>=3)
	for(j=0;j<qffConstants->numberOfFrequencies;j++)
	for(i=0;i<j;i++)
	for(k=0;k<i;k++)
	{
			int l = -1;
			index++; /*  deltas[j],   deltas[i],  deltas[k] */
			l++;
			qffConstants->VIJK[j][i][k][l] = energies[index]; 

			index++; /*  deltas[j],   deltas[i],  -deltas[k] */
			l++;
			qffConstants->VIJK[j][i][k][l] = energies[index]; 

			index++; /*  deltas[j],   -deltas[i],   deltas[k] */
			l++;
			qffConstants->VIJK[j][i][k][l] = energies[index]; 

			index++; /*  deltas[j],   -deltas[i],   -deltas[k] */
			l++;
			qffConstants->VIJK[j][i][k][l] = energies[index]; 

			index++; /*  -deltas[j],   deltas[i],  deltas[k] */
			l++;
			qffConstants->VIJK[j][i][k][l] = energies[index]; 

			index++; /*  -deltas[j],   deltas[i],  -deltas[k] */
			l++;
			qffConstants->VIJK[j][i][k][l] = energies[index]; 

			index++; /*  -deltas[j],   -deltas[i],   deltas[k] */
			l++;
			qffConstants->VIJK[j][i][k][l] = energies[index]; 

			index++; /*  -deltas[j],   -deltas[i],   -deltas[k] */
			l++;
			qffConstants->VIJK[j][i][k][l] = energies[index]; 

	}
	if(ordre>=4)
	for(j=0;j<qffConstants->numberOfFrequencies;j++)
	for(i=0;i<j;i++)
	for(k=0;k<i;k++)
	for(l=0;l<k;l++)
	{
			int n = 0;
			for(n=0;n<16;n++)
			{
				index++;
				qffConstants->VIJKL[j][i][k][l][n]= energies[index]; 
			}
	}

	free(energies);

	if(Ok) computeGradients(qffConstants);
	if(Ok) computeFrequencies(qffConstants);
	if(Ok) computeCubicForces(qffConstants);
	if(Ok) computeQuarticForces(qffConstants);
	//printf("Begin free\n");

	freeMatrixDouble(&qffConstants->VI, qffConstants->numberOfFrequencies);
	freeCubeDouble(&qffConstants->VIJ, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies);
	freeCubeDouble(&qffConstants->VI3J, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies);
	if(ordre>=3) freeQuarticDouble(&qffConstants->VIJK, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies, qffConstants->numberOfFrequencies);
	if(ordre>=4) freeQuinticDouble(&qffConstants->VIJKL, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies, qffConstants->numberOfFrequencies, qffConstants->numberOfFrequencies);
	//printf("End free\n");
}
/*****************************************************************************/
static void computeQFFDerivativesDipoles(NMRQFF* qffConstants, int ordre, double* dipoles[])
{
	int i;
	int j;
	int k;
	//int l;
	int index;
	int xyz;
	boolean Ok = TRUE;
	index = 0;

	initnMRQFFDipoles(qffConstants, ordre);

	for(xyz=0;xyz<3;xyz++) qffConstants->dipole0[xyz] = dipoles[xyz][index];


	for(j=0;j<qffConstants->numberOfFrequencies;j++)
	{
		int k = 0;
		index++;  /*  3*deltas[j], 0 */
		for(xyz=0;xyz<3;xyz++) qffConstants->dipolesI[j][k][xyz] = dipoles[xyz][index]; 

		index++; k++; /*  2*deltas[j], 0 */
		for(xyz=0;xyz<3;xyz++) qffConstants->dipolesI[j][k][xyz] = dipoles[xyz][index]; 

		index++; k++; /*  1*deltas[j], 0 */
		for(xyz=0;xyz<3;xyz++) qffConstants->dipolesI[j][k][xyz] = dipoles[xyz][index]; 

		index++; k++; /* -1*deltas[j], 0 */
		for(xyz=0;xyz<3;xyz++) qffConstants->dipolesI[j][k][xyz] = dipoles[xyz][index]; 

		index++; k++; /* -2*deltas[j], 0 */
		for(xyz=0;xyz<3;xyz++) qffConstants->dipolesI[j][k][xyz] = dipoles[xyz][index]; 
	
		index++; k++; /* -3*deltas[j], 0 */
		for(xyz=0;xyz<3;xyz++) qffConstants->dipolesI[j][k][xyz] = dipoles[xyz][index]; 
	}

	if(ordre>=2)
	for(j=0;j<qffConstants->numberOfFrequencies;j++)
	{
		for(i=0;i<j;i++)
		{
			int k;
			index++; /*  deltas[j],   deltas[i] */
                        k = 0;
			for(xyz=0;xyz<3;xyz++) qffConstants->dipolesIJ[j][i][k][xyz] = dipoles[xyz][index]; 

			index++;/*  deltas[j],  -deltas[i] */
                        k = 1; 
			for(xyz=0;xyz<3;xyz++) qffConstants->dipolesIJ[j][i][k][xyz] = dipoles[xyz][index]; 

			index++; /* -deltas[j],   deltas[i] */
                        k = 2; 
			for(xyz=0;xyz<3;xyz++) qffConstants->dipolesIJ[j][i][k][xyz] = dipoles[xyz][index]; 

			index++; /* -deltas[j],  -deltas[i] */
                        k = 3;
			for(xyz=0;xyz<3;xyz++) qffConstants->dipolesIJ[j][i][k][xyz] = dipoles[xyz][index]; 

			for(xyz=0;xyz<3;xyz++)
                	{
				qffConstants->dipolesIJ[i][j][0][xyz] = qffConstants->dipolesIJ[j][i][0][xyz];
				qffConstants->dipolesIJ[i][j][1][xyz] = qffConstants->dipolesIJ[j][i][2][xyz];
				qffConstants->dipolesIJ[i][j][2][xyz] = qffConstants->dipolesIJ[j][i][1][xyz];
				qffConstants->dipolesIJ[i][j][3][xyz] = qffConstants->dipolesIJ[j][i][3][xyz];
                	}

		}
		for(i=0;i<qffConstants->numberOfFrequencies;i++)
		{
			int k;
			if(i==j) continue;
			index++; /*  deltas[j],  3*deltas[i] */
                        k = 0;
			for(xyz=0;xyz<3;xyz++) qffConstants->dipolesI3J[j][i][k][xyz] = dipoles[xyz][index]; 

			index++; /*  deltas[j], -3*deltas[i] */
                        k = 1; 
			for(xyz=0;xyz<3;xyz++) qffConstants->dipolesI3J[j][i][k][xyz] = dipoles[xyz][index]; 

			index++; /* -deltas[j],  3*deltas[i] */
                        k = 2; 
			for(xyz=0;xyz<3;xyz++) qffConstants->dipolesI3J[j][i][k][xyz] = dipoles[xyz][index]; 

			index++; /* -deltas[j], -3*deltas[i] */
                        k = 3;
			for(xyz=0;xyz<3;xyz++) qffConstants->dipolesI3J[j][i][k][xyz] = dipoles[xyz][index]; 
		}
	}
	if(ordre>=3)
	for(j=0;j<qffConstants->numberOfFrequencies;j++)
	for(i=0;i<j;i++)
	for(k=0;k<i;k++)
	{
			int l = -1;
			index++; /*  deltas[j],   deltas[i],  deltas[k] */
			l++;
			for(xyz=0;xyz<3;xyz++) qffConstants->dipolesIJK[j][i][k][l][xyz] = dipoles[xyz][index]; 

			index++; /*  deltas[j],   deltas[i],  -deltas[k] */
			l++;
			for(xyz=0;xyz<3;xyz++) qffConstants->dipolesIJK[j][i][k][l][xyz] = dipoles[xyz][index]; 

			index++; /*  deltas[j],   -deltas[i],   deltas[k] */
			l++;
			for(xyz=0;xyz<3;xyz++) qffConstants->dipolesIJK[j][i][k][l][xyz] = dipoles[xyz][index]; 

			index++; /*  deltas[j],   -deltas[i],   -deltas[k] */
			l++;
			for(xyz=0;xyz<3;xyz++) qffConstants->dipolesIJK[j][i][k][l][xyz] = dipoles[xyz][index]; 

			index++; /*  -deltas[j],   deltas[i],  deltas[k] */
			l++;
			for(xyz=0;xyz<3;xyz++) qffConstants->dipolesIJK[j][i][k][l][xyz] = dipoles[xyz][index]; 

			index++; /*  -deltas[j],   deltas[i],  -deltas[k] */
			l++;
			for(xyz=0;xyz<3;xyz++) qffConstants->dipolesIJK[j][i][k][l][xyz] = dipoles[xyz][index]; 

			index++; /*  -deltas[j],   -deltas[i],   deltas[k] */
			l++;
			for(xyz=0;xyz<3;xyz++) qffConstants->dipolesIJK[j][i][k][l][xyz] = dipoles[xyz][index]; 

			index++; /*  -deltas[j],   -deltas[i],   -deltas[k] */
			l++;
			for(xyz=0;xyz<3;xyz++) qffConstants->dipolesIJK[j][i][k][l][xyz] = dipoles[xyz][index]; 

			for(xyz=0;xyz<3;xyz++)
                	{
				for(l=0;l<8;l++) qffConstants->dipolesIJK[i][j][k][l][xyz] = qffConstants->dipolesIJK[j][i][k][l][xyz];
				for(l=0;l<8;l++) qffConstants->dipolesIJK[i][k][j][l][xyz] = qffConstants->dipolesIJK[j][i][k][l][xyz];
				for(l=0;l<8;l++) qffConstants->dipolesIJK[j][k][i][l][xyz] = qffConstants->dipolesIJK[j][i][k][l][xyz];
				for(l=0;l<8;l++) qffConstants->dipolesIJK[k][i][j][l][xyz] = qffConstants->dipolesIJK[j][i][k][l][xyz];
				for(l=0;l<8;l++) qffConstants->dipolesIJK[k][j][i][l][xyz] = qffConstants->dipolesIJK[j][i][k][l][xyz];
                	}

	}
	/*
	if(ordre>=4)
	for(j=0;j<qffConstants->numberOfFrequencies;j++)
	for(i=0;i<j;i++)
	for(k=0;k<i;k++)
	for(l=0;l<k;l++)
	{
			int n = 0;
			for(n=0;n<16;n++)
			{
				index++;
			}
	}
	*/
	for(xyz=0;xyz<3;xyz++) free(dipoles[xyz]);


	if(Ok) changeUnitInputFirstDerivativesDipoles(qffConstants);
	if(Ok) computeFirstDerivativesDipoles(qffConstants);
	if(Ok) computeSecondDerivativesDipoles(qffConstants);
	if(Ok) computeCubicDerivativesDipoles(qffConstants);
	if(Ok) computeQuarticDerivativesDipoles(qffConstants);

	freeVectorDouble(&qffConstants->dipole0);
	freeCubeDouble(&qffConstants->dipolesI, qffConstants->numberOfFrequencies,6);
	freeQuarticDouble(&qffConstants->dipolesIJ, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,4);
	freeQuarticDouble(&qffConstants->dipolesI3J, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,4);
	if(ordre>=3) freeQuinticDouble(&qffConstants->dipolesIJK, qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies,qffConstants->numberOfFrequencies, 8);
}
/*****************************************************************************/
char* computeQFFDerivatives(char* inputFileName, Molecule* mol, int ordre, double* deltas, int nEnergies, double* energies, double* dipoles[])
{
	int i;
	NMRQFF* qffConstants;
	char* fileNameOut = NULL;

	qffConstants = (NMRQFF*) malloc(sizeof(NMRQFF));
	qffConstants->numberOfFrequencies = 0;
	printf("nAtoms = %d\n", mol->nAtoms);

	qffConstants->numberOfFrequencies = mol->vibration.nModes;
	printf("numberOfFrequencies = %d\n", qffConstants->numberOfFrequencies);
	initnMRQFF0(qffConstants,qffConstants->numberOfFrequencies);
	printf("End initnMRQFF0\n");

	for(i=0;i<qffConstants->numberOfFrequencies;i++)
	{
		qffConstants->frequencies[i] = mol->vibration.modes[i].frequency;
		qffConstants->mass[i] = mol->vibration.modes[i].mass;
		qffConstants->delta[i] = deltas[i];
	}

        qffConstants->numberOfEnergies = nEnergies;
	computeQFFDerivativesEnergies(qffConstants, ordre, energies);
	printf("Energ computeQFFDerivativesEnergies\n");
	computeQFFDerivativesDipoles(qffConstants, ordre, dipoles);
	printf("Energ computeQFFDerivativesDipoles\n");

	fileNameOut = saveNMRQFFAppend(qffConstants, inputFileName, mol);
	freeNMRQFF(qffConstants);
	
	return fileNameOut;
}
/********************************************************************************/
File: ./cchemilib/src/QFFPot/QFFModel.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* QFFModel.c */
#include <math.h>
#include <time.h>
#include "../QFFPot/QFFModel.h"
#include "../Utils/Utils.h"
#include "../Utils/AtomsProp.h"
#include "../Utils/Constants.h"
#include "../Utils/QL.h"

//static boolean printMax = FALSE;
//static boolean printMax = TRUE;

static void readData(QFFModel* qffModel, char* geometryFileName, char* qffFileName);
static void computeEnergy(QFFModel* qffModel);
static void computeDipole(QFFModel* qffModel);
static void computeQ(QFFModel* qffModel);
static void computeNumericGradients(QFFModel* qffModel);
static void computeAnalyticGradients(QFFModel* qffModel);
static int computeFrequencies(QFFModel* qffModel);
static void compareFrequencies(QFFModel* qffModel,FILE* file);
static void compute(QFFModel* qffModel);
static void runAlea(QFFModel* qffModel);
static void convertToAU(QFFModel* qffModel);
static void convertToAU2(QFFModel* qffModel);
static void computeQFFParameters(QFFModel* qffModel);
/*****************************************************************************/
static void printModesAndVelocities(QFFModel* qffModel,FILE* file)
{
	int i;
	fprintf(file,"QValues\n");
	for(i=0;i<qffModel->vData.nFrequencies;i++)
		fprintf(file,"%d %0.10e\n", i+1, qffModel->Q[i]);
	fprintf(file,"END\n");
	fprintf(file,"QVelocities\n");
	for(i=0;i<qffModel->vData.nFrequencies;i++)
		fprintf(file,"%d %0.10e\n", i+1, qffModel->velocity[i]);
	fprintf(file,"END\n");
}
/*****************************************************************************/
static double getKineticEnergy(QFFModel* qffModel)
{
	double ekin = 0;
	int i;
	for(i=0;i<qffModel->vData.nFrequencies;i++)
	{
			double mass = 1.0; // Mass-weigted normal coordinates
			//mass = qffModel->vData.effectiveMasses[i]*AMUTOAU;// to be use with convertToAU2
			//mass = qffModel->vData.effectiveMasses[i];
	
			ekin += qffModel->velocity[i]*
			        qffModel->velocity[i]*
			        mass;
	}
	ekin /=2;
	return ekin;
}
/********************************************************************************/
static double getKelvin(QFFModel* qffModel)
{
	int nFree = qffModel->vData.nFrequencies;
	int i;
	for(i=0;i<qffModel->vData.nFrequencies;i++) if(!qffModel->variable[i]) nFree--;
	if(nFree<1) return 0;
	double kin = qffModel->klass->getKineticEnergy(qffModel);
	return 2*kin / ( nFree * KbInAU);
}
/*****************************************************************************/
static void scaleVelocities(QFFModel* qffModel, double temperature)
{
	double kelvin = qffModel->klass->getKelvin(qffModel);
	double scale = 1.0;
	int i;
	if(temperature<=0) return;
	if(kelvin<=0) return;

	scale = sqrt(temperature/kelvin);
#ifdef DEBUG
	printf("temp = %f kelvin = %f scale = %f\n",temperature, kelvin, scale);
#endif
	for(i=0;i<qffModel->vData.nFrequencies;i++)
		if(qffModel->variable[i]) qffModel->velocity[i] *= scale;
}
/*****************************************************************************/
static void setMaxwellVelocities(QFFModel* qffModel, double temperature)
{
	int i;
	for(i=0;i<qffModel->vData.nFrequencies;i++)
	{
        	if(!qffModel->variable[i]) qffModel->velocity[i] = 0.0;
		else
		{
			double mass = 1.0; // Mass-weigted normal coordinates
			double speed;
			//mass = qffModel->vData.effectiveMasses[i]*AMUTOAU;
			//mass = qffModel->vData.effectiveMasses[i];
			//fprintf(stderr,"mass = %f\n",mass);
			speed = maxwel(mass,temperature);
			qffModel->velocity[i]=speed*drandom();
		}
	}
	qffModel->klass->scaleVelocities(qffModel, temperature);
}
/*****************************************************************************/
static boolean setMaxwellVelocitiesIfNull(QFFModel* qffModel, double temperature)
{
	
	double ekin = qffModel->klass->getKineticEnergy(qffModel);

	fprintf(stderr,"Ekin0=%f\n",ekin);
	if(fabs(ekin)>1e-14) return FALSE;
	setMaxwellVelocities(qffModel, temperature);
	return TRUE;
}
/*****************************************************************************/
static void freeQFFModel(QFFModel* qffModel)
{
	int nAtoms = qffModel->molecule.nAtoms;

	qffModel->vData.klass->free(&qffModel->vData);
	qffModel->pData.klass->free(&qffModel->pData);

	freeVectorDouble(&qffModel->frequencies);
	freeVectorDouble(&qffModel->reducedMasses);
	freeVectorDouble(&qffModel->IRIntensities);
	freeVectorDouble(&qffModel->Q);
	freeMatrixDouble(&qffModel->modes, 3*nAtoms);
}
/*****************************************************************************/
static void convertToAU(QFFModel* qffModel)
{
	qffModel->vData.klass->convertToAU(&qffModel->vData);
	qffModel->pData.klass->convertToAU(&qffModel->pData);
}
/*****************************************************************************/
static void convertToAU2(QFFModel* qffModel)
{
	qffModel->vData.klass->convertToAU2(&qffModel->vData);
	qffModel->pData.klass->convertToAU2(&qffModel->pData);
}
/*****************************************************************************/
static void computeQFFParameters(QFFModel* qffModel)
{
	qffModel->vData.klass->computeQFFParameters(&qffModel->vData);
	//qffModel->pData.klass->computeQFFParameters(&qffModel->pData);// not yet implemented
}
/*****************************************************************************/
static void readData(QFFModel* qffModel, char* geometryFileName, char* qffFileName)
{
	FILE* inputFile;
	Molecule* molFit;
	Molecule* molRef;
	//double C[3];
	double u[3][3];

        inputFile = fopen(qffFileName,"rb");
	if(!inputFile)
	{
		fprintf(stderr, "==========================================================\n");
		fprintf(stderr, "Sorry, I cannot open the %s file\n", qffFileName);
		fprintf(stderr, "==========================================================\n");
		exit(1);
	}
	fclose(inputFile);
	if(geometryFileName != NULL)
	{
        inputFile = fopen(geometryFileName,"rb");
	if(!inputFile)
	{
		fprintf(stderr, "==========================================================\n");
		fprintf(stderr, "Sorry, I cannot open the %s file\n", geometryFileName);
		fprintf(stderr, "==========================================================\n");
		exit(1);
	}
	fclose(inputFile);
	}

	qffModel->vData.klass->readData(&qffModel->vData, qffFileName);
	qffModel->pData.klass->readData(&qffModel->pData, qffFileName);
	qffModel->molecule.klass->read(&qffModel->molecule, geometryFileName);
	if(qffModel->Q) free(qffModel->Q);
	qffModel->Q=NULL;
	qffModel->gradQ=NULL;
	qffModel->velocity=NULL;
	qffModel->variable=NULL;
	if(qffModel->vData.nFrequencies>0) qffModel->Q = malloc(qffModel->vData.nFrequencies*sizeof(double));
	if(qffModel->Q) computeQ(qffModel);
	qffModel->diffStep = 0.01;
	qffModel->typeCalcul = 0;
	qffModel->showWarning = FALSE;
	qffModel->numGradients = FALSE;
	qffModel->xyz = FALSE;
	readOneRealFromAFile(geometryFileName,"diffStep",&qffModel->diffStep);
	readOneIntFromAFile(geometryFileName,"typeCalcul",&qffModel->typeCalcul);
	readOneIntFromAFile(geometryFileName,"showWarning",&qffModel->showWarning);
	readOneIntFromAFile(geometryFileName,"numGradients",&qffModel->numGradients);
	readOneIntFromAFile(geometryFileName,"XYZ",&qffModel->xyz);
        qffModel->frequencies = NULL;
        qffModel->modes = NULL;
        qffModel->reducedMasses = NULL;
        qffModel->IRIntensities = NULL;
	if(qffModel->numGradients) qffModel->klass->computeGradients = computeNumericGradients;
	if(qffModel->vData.nFrequencies>0) 
	{
		int i;
		qffModel->gradQ = newVectorDouble(qffModel->vData.nFrequencies);
		initVectorDouble(qffModel->gradQ, qffModel->vData.nFrequencies, 0.0);
		qffModel->velocity = newVectorDouble(qffModel->vData.nFrequencies);
		qffModel->variable = malloc(qffModel->vData.nFrequencies*sizeof(boolean));
		for(i=0;i<qffModel->vData.nFrequencies;i++) qffModel->variable[i] = TRUE;
	}
	if(qffModel->Q) 
	{
		FILE* file = fopen(geometryFileName,"rb");
		readVectorReal(file,"QValues",qffModel->vData.nFrequencies, qffModel->Q);
		if(qffModel->velocity) readVectorReal(file,"QVelocities",qffModel->vData.nFrequencies, qffModel->velocity);
		fclose(file);
	}

	qffModel->klass->calculateGradient = qffModel->klass->computeGradients;

	//fprintf(stderr,"diffStep=%f\n",qffModel->diffStep);


	molRef = &qffModel->molecule;
	molFit = &qffModel->vData.molecule;

	molFit->klass->fit(molFit,molRef,u);
	//qffModel->vData.klass->rotModes(&qffModel->vData,u);

//	printf("End read readData\n");
}
/**********************************************************************/
static void computeQ(QFFModel* qffModel)
{
	int i,k,c;
	for(i=0;i<qffModel->vData.nFrequencies;i++) 
	{
		qffModel->Q[i] = 0.0;
		for(k=0;k<qffModel->molecule.nAtoms;k++)
		{
			for(c=0;c<3;c++)
			{
				double dx = qffModel->molecule.atoms[k].coordinates[c]-qffModel->vData.molecule.atoms[k].coordinates[c];
				//printf("iatom = %d dx = %f mi = %f mEffe = %f \n",k,dx,qffModel->vData.molecule.atoms[k].mass,qffModel->vData.effectiveMasses[i]);
				//printf("mode %d  atom = %d axis %d\n",i,k,c);
				//if(qffModel->vData.modes) printf("v=%f m=%f em=%f\n",qffModel->vData.modes[i][k][c],qffModel->vData.molecule.atoms[k].mass,qffModel->vData.effectiveMasses[i]);
				//else printf("mode=NULL\n");
				
				qffModel->Q[i] += qffModel->vData.MWModes[i][k][c]*dx;
			}
		}
	}
	// coordinates are in Ang in molecule
	for(i=0;i<qffModel->vData.nFrequencies;i++) 
				qffModel->Q[i] *= ANGTOBOHR;

}
/**********************************************************************/
static void computeEnergyXYZ(QFFModel* qffModel)
{
	int i,j,k,l;
	double E = 0;
	double E2 = 0;
	double E3 = 0;
	double E4 = 0;

	if(qffModel->Q) computeQ(qffModel);

	E2 = 0.0;
	for(i=0;i<qffModel->vData.nFrequencies;i++)
		E2 += qffModel->vData.hessian[i][i]*qffModel->Q[i]*qffModel->Q[i];
	E2 /= 2.0;

	E3 = 0.0;
	for(i=0;i<qffModel->vData.nFrequencies;i++)
	for(j=0;j<qffModel->vData.nFrequencies;j++)
	for(k=0;k<qffModel->vData.nFrequencies;k++)
		E3 += qffModel->vData.cubic[i][j][k]*qffModel->Q[i]*qffModel->Q[j]*qffModel->Q[k];
	E3 /= 6.0;

	E4 = 0.0;
	for(i=0;i<qffModel->vData.nFrequencies;i++)
	for(j=0;j<qffModel->vData.nFrequencies;j++)
	for(k=0;k<qffModel->vData.nFrequencies;k++)
	for(l=0;l<qffModel->vData.nFrequencies;l++)
		E4 += qffModel->vData.quartic[i][j][k][l]*qffModel->Q[i]*qffModel->Q[j]*qffModel->Q[k]*qffModel->Q[l];
	E4 /= 24.0;

	/*
	E3*=-1;
	E4*=-1;
	*/
	// TO REMOVE
	//E3 = 0;
        //E4 = 0;

	// in reduced form : use k instead Phi
	/*
	for(i=0;i<qffModel->vData.nFrequencies;i++)
	for(j=0;j<=i;j++)
	for(k=0;k<=j;k++)
		E += qffModel->vData.cubic[i][j][k]*qffModel->Q[i]*qffModel->Q[j]*qffModel->Q[k];

	for(i=0;i<qffModel->vData.nFrequencies;i++)
	for(j=0;j<=i;j++)
	for(k=0;k<=j;k++)
	for(l=0;l<=k;l++)
		E += qffModel->vData.quartic[i][j][k][l]*qffModel->Q[i]*qffModel->Q[j]*qffModel->Q[k]*qffModel->Q[l];
	*/

	//printf("E2=%0.12e E32=%0.12e E4=%0.12e\n",E2,E3,E4);

	E = E2 + E3 + E4;
	
	if(E<0) 
	{
		char symbol[100];
		fprintf(stderr,"%d\n",qffModel->molecule.nAtoms);
		fprintf(stderr,"Error E<0\n");
		for(k=0;k<qffModel->molecule.nAtoms;k++)
		{
			fprintf(stderr,"%s %f %f %f\n",
				symbol,
				qffModel->molecule.atoms[k].coordinates[0],
				qffModel->molecule.atoms[k].coordinates[1],
				qffModel->molecule.atoms[k].coordinates[2]);
			qffModel->molecule.atoms[k].prop = propAtomGet(symbol);
		}
		exit(1);
	}
	qffModel->molecule.potentialEnergy = E;
	//printf("E(cm^-1) = %0.12f\n",E);
}
/**********************************************************************/
/*
static boolean addWallEnergyQFF(QFFModel* qffModel)
{
	if(!qffModel) return FALSE;
	if(!(qffModel->molecule.wall.E0>0)) return FALSE;
	else{
		return TRUE;// TO REMOVE
		double E0 = qffModel->molecule.wall.E0;
		//double srho2 =1/(qffModel->molecule.wall.rho*qffModel->molecule.wall.rho);
		int n =qffModel->molecule.wall.n;
		int i;
		double energy = 0;
		for(i=0;i<qffModel->vData.nFrequencies;i++) 
		{
			double Qmax = 2.0*1/sqrt(sqrt(qffModel->vData.hessian[i][i]));
			double srho2 = 1/Qmax/Qmax;
			//energy += E0*pow(1-exp(-srho2*qffModel->Q[i]*qffModel->Q[i]),n);
			energy += E0*pow(1-exp(-srho2*qffModel->Q[i]*qffModel->Q[i]),n);
			fprintf(stderr,"mode %d Qmax = %f Q = %f\n",i+1, 1/sqrt(sqrt(qffModel->vData.hessian[i][i])),qffModel->Q[i]);
		}

		fprintf(stderr,"EWall=%0.10fEOld = %0.10f\n",energy,qffModel->molecule.potentialEnergy);
		qffModel->molecule.potentialEnergy += energy;
		return TRUE;
	}
}
*/
/**********************************************************************/
/*
static boolean addLEnergyQFF(QFFModel* qffModel)
{
	if(!qffModel) return FALSE;
	else{
		int j;
		for(j=0;j<qffModel->vData.nFrequencies;j++) 
		{
			double Qmax = 1/sqrt(sqrt(qffModel->vData.hessian[j][j]));
			if(qffModel->Q[j]<-Qmax || qffModel->Q[j]>Qmax)
			{
				int i;
				double E1MR = 0.0;
				double Qi;
				int c;
				int n;
				QFFPotParameters* qffPotParameters = qffModel->vData.qffPotParameters;
				int m;
				for(m=0;m<qffPotParameters->numberOf1MR;m++) 
				{
					i = qffPotParameters->qff1MR[m].numbers[0];
					n = qffPotParameters->qff1MR[m].numbers[1];
					Qi=1; for(c=0;c<n;c++) Qi*= qffModel->Q[i];
					E1MR +=  qffPotParameters->qff1MR[m].energy*Qi;
				}
				qffModel->molecule.potentialEnergy = E1MR;
				printf("i= %d Epot = %f Qi = %f Qmax  = %f\n",j,E1MR,qffModel->Q[j],Qmax);
				if(E1MR<0) exit(1);
				return TRUE;
			}
		}
		/ *
		int i;
		int k = 0;
		double energy = 0;
		for(i=0;i<qffModel->vData.nFrequencies;i++) 
		{
			double Qmax = 1/sqrt(sqrt(qffModel->vData.hessian[i][i]));
			QFFPotParameters* qffPotParameters = qffModel->vData.qffPotParameters;
			if(qffModel->Q[i]<-Qmax || qffModel->Q[i]>Qmax)
			{
				double Emax = 0;
				int m;
				int sign = 1;
				double xmin,xmax,x;
				double y, ymax;
				int l;
				k++;
				if(qffModel->Q[i]<-Qmax) sign = -1;
				for(m=0;m<qffPotParameters->numberOf1MR;m++) 
				{
					int j = qffPotParameters->qff1MR[m].numbers[0];
					int n = qffPotParameters->qff1MR[m].numbers[1];
					int c;
					double Qi=1; 
					if(i!=j) continue;
					for(c=0;c<n;c++) Qi*= qffModel->Q[j];
					Emax +=  qffPotParameters->qff1MR[m].energy*Qi;
				}
				printf("Emax = %f\n",Emax);
				ymax = Emax;
				y = 0;
				for(l=0;l<qffModel->vData.nFrequencies;l++) 
				{
					sign = 1;
					if(qffModel->Q[l]<0) sign = -1;
					xmax = Qmax*sign;
					xmin = 0.9*xmax;
					y += ymax*(qffModel->Q[l]-xmin)/(xmax-xmin);
				}
				energy += y;
				printf("i= %d Epot = %f Qi = %f Qmax  = %f\n",i,y,qffModel->Q[i],Qmax);
				if(Emax<0) exit(1);
				break;
			}
		}
		if(k>0) 
		{
			qffModel->molecule.potentialEnergy = energy;
			printf("Epot = %f\n",qffModel->molecule.potentialEnergy);
			return TRUE;
		}
		* /
		return FALSE;
	}
}
*/
/**********************************************************************/
static boolean computeEnergyQFF(QFFModel* qffModel)
{
	int i,j,k,l;
	int m;
	int n;
	int c;
	double Qi;
	double Qj;
	double Qk;
	double E = 0;
	double E1MR = 0;
	double E2MR = 0;
	double E3MR = 0;
	double E4MR = 0;
	//double f = qffModel->molecule.wall.rho;
	QFFPotParameters* qffPotParameters = qffModel->vData.qffPotParameters;
	double* QOld;

	if(!qffPotParameters) return FALSE;
//	if(addLEnergyQFF(qffModel)) return TRUE;

//	if((qffModel->molecule.wall.E0>0)) fprintf(stderr,"f=%0.12f\n",f);

	QOld = malloc(qffModel->vData.nFrequencies*sizeof(double));
	for(i=0;i<qffModel->vData.nFrequencies;i++) 
	{
		double Qmax = 1/sqrt(sqrt(qffModel->vData.hessian[i][i]));
		double srho2 =  qffModel->molecule.wall.rho*1/Qmax/Qmax;
		double f = exp(-srho2*qffModel->Q[i]*qffModel->Q[i]);
		if(srho2*qffModel->Q[i]*qffModel->Q[i]>100) f = 0;
		//printf("i=%d f = %f ex=%f srho2= %f Qmax = %f Qi = %f\n",i,f,srho2*qffModel->Q[i]*qffModel->Q[i],srho2,Qmax,qffModel->Q[i]);
		QOld[i] = qffModel->Q[i];
		qffModel->Q[i] *= f;
	}


	E1MR = 0.0;
	for(m=0;m<qffPotParameters->numberOf1MR;m++) 
	{
		i = qffPotParameters->qff1MR[m].numbers[0];
		n = qffPotParameters->qff1MR[m].numbers[1];
		Qi=1; for(c=0;c<n;c++) Qi*= qffModel->Q[i];
		E1MR +=  qffPotParameters->qff1MR[m].energy*Qi;
	}
	E2MR = 0.0;
	for(m=0;m<qffPotParameters->numberOf2MR;m++) 
	{
		i = qffPotParameters->qff2MR[m].numbers[0];
		j = qffPotParameters->qff2MR[m].numbers[1];
		n = qffPotParameters->qff2MR[m].numbers[2];
		if(n==-2)
		{
			// ii jj
			n = 2;
			Qi=1; for(c=0;c<n;c++) Qi *= qffModel->Q[i];
			Qj = qffModel->Q[j]*qffModel->Q[j];
			E2MR +=  qffPotParameters->qff2MR[m].energy*Qi*Qj;
		}
		else
		{
			Qi=1; for(c=0;c<n;c++) Qi *= qffModel->Q[i];
			Qj = qffModel->Q[j];
			E2MR +=  qffPotParameters->qff2MR[m].energy*Qi*Qj;
		}
	}
	E3MR = 0.0;
	for(m=0;m<qffPotParameters->numberOf3MR;m++) 
	{
		i = qffPotParameters->qff3MR[m].numbers[0];
		j = qffPotParameters->qff3MR[m].numbers[1];
		k = qffPotParameters->qff3MR[m].numbers[2];
		n = qffPotParameters->qff3MR[m].numbers[3];
		Qi=1; for(c=0;c<n;c++) Qi*= qffModel->Q[i];
		Qj = qffModel->Q[j];
		Qk = qffModel->Q[k];
		E3MR +=  qffPotParameters->qff3MR[m].energy*Qi*Qj*Qk;
	}
	E4MR = 0.0;
	for(m=0;m<qffPotParameters->numberOf4MR;m++) 
	{
		i = qffPotParameters->qff4MR[m].numbers[0];
		j = qffPotParameters->qff4MR[m].numbers[1];
		k = qffPotParameters->qff4MR[m].numbers[2];
		l = qffPotParameters->qff4MR[m].numbers[3];
		E4MR +=  qffPotParameters->qff4MR[m].energy*qffModel->Q[i]*qffModel->Q[j]*qffModel->Q[k]*qffModel->Q[l];
	}

	E =  E1MR + E2MR + E3MR + E4MR ;

	for(i=0;i<qffModel->vData.nFrequencies;i++) qffModel->Q[i] = QOld[i];
	free(QOld);

	qffModel->molecule.potentialEnergy = E;
	//addWallEnergyQFF(qffModel);
	//fprintf(stderr,"QFF: E(cm-1)=%f\n",E*AUTOCM1);
	//fprintf(stderr,"Q1=%f\n",qffModel->Q[0]);
	if(qffModel->molecule.potentialEnergy<0) 
	{
		fprintf(stderr,"Error E<0 : E = %f\n",qffModel->molecule.potentialEnergy);
		for(k=0;k<qffModel->vData.nFrequencies;k++)
		{
			fprintf(stderr,"Mode #%d Q=%0.10f\n",
				k+1,
				qffModel->Q[k]); 
		}
		exit(1);
	}
	return TRUE;
}
/**********************************************************************/
static void computeEnergyQ(QFFModel* qffModel)
{
	int i,j,k,l;
	double E = 0;
	double E2 = 0;
	double E3 = 0;
	double E4 = 0;
	if(computeEnergyQFF(qffModel)) return;

	E2 = 0.0;
	for(i=0;i<qffModel->vData.nFrequencies;i++)
		E2 += qffModel->vData.hessian[i][i]*qffModel->Q[i]*qffModel->Q[i];
	E2 /= 2.0;

	E3 = 0.0;
	for(i=0;i<qffModel->vData.nFrequencies;i++)
	for(j=0;j<qffModel->vData.nFrequencies;j++)
	for(k=0;k<qffModel->vData.nFrequencies;k++)
		E3 += qffModel->vData.cubic[i][j][k]*qffModel->Q[i]*qffModel->Q[j]*qffModel->Q[k];
	E3 /= 6.0;

	E4 = 0.0;
	for(i=0;i<qffModel->vData.nFrequencies;i++)
	for(j=0;j<qffModel->vData.nFrequencies;j++)
	for(k=0;k<qffModel->vData.nFrequencies;k++)
	for(l=0;l<qffModel->vData.nFrequencies;l++)
		E4 += qffModel->vData.quartic[i][j][k][l]*qffModel->Q[i]*qffModel->Q[j]*qffModel->Q[k]*qffModel->Q[l];
	E4 /= 24.0;

	E = E2 + E3 + E4;

	//fprintf(stderr,"E(cm-1)=%f\n",E*AUTOCM1);
	//fprintf(stderr,"Q1=%f\n",qffModel->Q[0]);
	if(E<0) 
	{
		fprintf(stderr,"Error E<0\n");
		for(k=0;k<qffModel->vData.nFrequencies;k++)
		{
			fprintf(stderr,"Mode #%d Q=%0.10f\n",
				k+1,
				qffModel->Q[k]); 
		}
		exit(1);
	}
	qffModel->molecule.potentialEnergy = E;
}
/**********************************************************************/
static void computeEnergy(QFFModel* qffModel)
{
	if(qffModel->xyz) computeEnergyXYZ(qffModel);
	else computeEnergyQ(qffModel);
}
/**********************************************************************/
/*
static void invGradientsXYZ(QFFModel* qffModel)
{
	int a,c;
	Molecule* mol = &qffModel->molecule;
        for(a=0;a<mol->nAtoms;a++)
        for(c=0;c<3;c++)
                mol->atoms[a].gradient[c] = - mol->atoms[a].gradient[c];
}
static void invGradientsQ(QFFModel* qffModel)
{
	int i ;
	for(i=0;i<qffModel->vData.nFrequencies;i++)
                qffModel->gradQ[i] = -qffModel->gradQ[i];
}
*/
/**********************************************************************/
static void computeAnalyticGradientsXYZ(QFFModel* qffModel)
{
        int i,j,k,l;
        int a;
	int c;
        Molecule* mol;
        int nAtoms;
	double dE2, dE3, dE4;

        if(!qffModel || qffModel->molecule.nAtoms<1) return;

//	printf("dx = %f\n",dx);
        mol = &qffModel->molecule;
        nAtoms = mol->nAtoms;

	//printf("Analytic\n");
        qffModel->klass->computeEnergy(qffModel);
        qffModel->klass->computeDipole(qffModel);
//	if(qffModel->molecule.potentialEnergy<0)return;

        for(a=0;a<nAtoms;a++)
        for(c=0;c<3;c++)
                mol->atoms[a].gradient[c] = 0.0;

        for(a=0;a<nAtoms;a++)
        for(c=0;c<3;c++)
	{
		dE2 = 0.0;
		for(i=0;i<qffModel->vData.nFrequencies;i++)
			dE2 += qffModel->vData.hessian[i][i]*qffModel->Q[i]*qffModel->vData.MWModes[i][a][c];
                mol->atoms[a].gradient[c] += dE2;
	}

        for(a=0;a<nAtoms;a++)
        for(c=0;c<3;c++)
	{
		dE3 = 0.0;
		for(i=0;i<qffModel->vData.nFrequencies;i++)
		for(j=0;j<qffModel->vData.nFrequencies;j++)
		for(k=0;k<qffModel->vData.nFrequencies;k++)
		{
			dE3 += qffModel->vData.cubic[i][j][k]*(
			qffModel->vData.MWModes[i][a][c]*qffModel->Q[j]*qffModel->Q[k]+
			qffModel->vData.MWModes[j][a][c]*qffModel->Q[k]*qffModel->Q[i]+
			qffModel->vData.MWModes[k][a][c]*qffModel->Q[i]*qffModel->Q[j]
			);
		}
		dE3 /= 6.0;
                mol->atoms[a].gradient[c] += dE3;
	}

        for(a=0;a<nAtoms;a++)
        for(c=0;c<3;c++)
	{
		dE4 = 0.0;
		for(i=0;i<qffModel->vData.nFrequencies;i++)
		for(j=0;j<qffModel->vData.nFrequencies;j++)
		for(k=0;k<qffModel->vData.nFrequencies;k++)
		for(l=0;l<qffModel->vData.nFrequencies;l++)
		{
			dE4 += qffModel->vData.quartic[i][j][k][l]*(
			qffModel->vData.MWModes[i][a][c]*qffModel->Q[j]*qffModel->Q[k]*qffModel->Q[l]+
			qffModel->vData.MWModes[j][a][c]*qffModel->Q[k]*qffModel->Q[l]*qffModel->Q[i]+
			qffModel->vData.MWModes[k][a][c]*qffModel->Q[l]*qffModel->Q[i]*qffModel->Q[j]+
			qffModel->vData.MWModes[l][a][c]*qffModel->Q[i]*qffModel->Q[j]*qffModel->Q[k]
			);
		}
		dE4 /= 24.0;
                mol->atoms[a].gradient[c] += dE4;
	}

        //printf("End computeGradientNumeric\n");
}
/*
static boolean addWallGradientsQFF(QFFModel* qffModel)
{

	if(!qffModel) return FALSE;
	if(!(qffModel->molecule.wall.E0>0)) return FALSE;
	else
	{
		double E0 = qffModel->molecule.wall.E0;
		double srho2 =1/(qffModel->molecule.wall.rho*qffModel->molecule.wall.rho);
		int n =qffModel->molecule.wall.n;
		//double energy = 0;
		int i;
		for(i=0;i<qffModel->vData.nFrequencies;i++) 
		{
			double r2 = qffModel->Q[i]*qffModel->Q[i];
			double ex = 0; 
			double exn = 0;
			ex = exp(-r2*srho2);
			exn = pow(1-ex,n-1);
			//energy += E0*exn*(1-ex);
			exn  = 2*n*srho2*exn*ex*E0;
	       	 	qffModel->gradQ[i] += qffModel->Q[i]*exn;
		}
		//printf("EWall=%f\n",energy);
		//return energy;
		return TRUE;
	}

}
*/
static boolean computeAnalyticGradientsQFF(QFFModel* qffModel)
{
	int i,j,k,l;
	int m;
	int n;
	int c;
	double Qi;
	QFFPotParameters* qffPotParameters = qffModel->vData.qffPotParameters;

	if(!qffPotParameters) return FALSE;
        qffModel->klass->computeEnergy(qffModel);
        qffModel->klass->computeDipole(qffModel);
        for(i=0;i<qffModel->vData.nFrequencies;i++) qffModel->gradQ[i]= 0.0;

	// 1MR
	for(m=0;m<qffPotParameters->numberOf1MR;m++) 
	{
		i = qffPotParameters->qff1MR[m].numbers[0];
		n = qffPotParameters->qff1MR[m].numbers[1];
		Qi=1; for(c=0;c<n-1;c++) Qi*= qffModel->Q[i];
		qffModel->gradQ[i] += qffPotParameters->qff1MR[m].grad*Qi;
	}

	//2MR
	for(m=0;m<qffPotParameters->numberOf2MR;m++) 
	{
		i = qffPotParameters->qff2MR[m].numbers[0];
		j = qffPotParameters->qff2MR[m].numbers[1];
		n = qffPotParameters->qff2MR[m].numbers[2];
		if(n==-2)
		{
			qffModel->gradQ[i] += qffPotParameters->qff2MR[m].grad*qffModel->Q[i]*qffModel->Q[j]*qffModel->Q[j];
			qffModel->gradQ[j] += qffPotParameters->qff2MR[m].grad*qffModel->Q[j]*qffModel->Q[i]*qffModel->Q[i];
		}
		else
		{
			Qi=1; for(c=0;c<n-1;c++) Qi*= qffModel->Q[i];
			qffModel->gradQ[i] += qffPotParameters->qff2MR[m].grad*Qi*qffModel->Q[j];
			Qi=1; for(c=0;c<n;c++) Qi*= qffModel->Q[i];
			qffModel->gradQ[j] += qffPotParameters->qff2MR[m].grad/n*Qi;
		}
	}
	//3MR
	for(m=0;m<qffPotParameters->numberOf3MR;m++) 
	{
		i = qffPotParameters->qff3MR[m].numbers[0];
		j = qffPotParameters->qff3MR[m].numbers[1];
		k = qffPotParameters->qff3MR[m].numbers[2];
		n = qffPotParameters->qff3MR[m].numbers[3];
		Qi=1; for(c=0;c<n-1;c++) Qi*= qffModel->Q[i];
		qffModel->gradQ[i] += qffPotParameters->qff3MR[m].grad*Qi*qffModel->Q[j]*qffModel->Q[k];
	}
	//4MR
	for(m=0;m<qffPotParameters->numberOf4MR;m++) 
	{
		i = qffPotParameters->qff4MR[m].numbers[0];
		j = qffPotParameters->qff4MR[m].numbers[1];
		k = qffPotParameters->qff4MR[m].numbers[2];
		l = qffPotParameters->qff4MR[m].numbers[3];
		qffModel->gradQ[i] += qffPotParameters->qff4MR[m].grad*qffModel->Q[j]*qffModel->Q[k]*qffModel->Q[l];
	}

	//addWallGradientsQFF(qffModel);

	/*
       fprintf(stderr,"End computeAnalyticGradientsQFF\n");
	for(i=0;i<qffModel->vData.nFrequencies;i++)
			fprintf(stderr,"Mode #%d Q=%0.10f grad=%0.10f\n", i+1, qffModel->Q[i],qffModel->gradQ[i]); 
	*/
	return TRUE;
}
/**********************************************************************/
static void computeAnalyticGradientsQ(QFFModel* qffModel)
{
        int i,j,k,l;
	double dE3, dE4;

	if(computeAnalyticGradientsQFF(qffModel)) return;
        if(!qffModel || qffModel->vData.nFrequencies<1) return;

	//printf("dx = %f\n",dx);

	//printf("Analytic\n");
        qffModel->klass->computeEnergy(qffModel);
        qffModel->klass->computeDipole(qffModel);
//	if(qffModel->molecule.potentialEnergy<0) return;

        for(i=0;i<qffModel->vData.nFrequencies;i++) qffModel->gradQ[i]= 0.0;

        for(i=0;i<qffModel->vData.nFrequencies;i++) 
		qffModel->gradQ[i] = qffModel->vData.hessian[i][i]*qffModel->Q[i];

        for(i=0;i<qffModel->vData.nFrequencies;i++) 
	{
		dE3 = 3*qffModel->vData.cubic[i][i][i]*qffModel->Q[i]*qffModel->Q[i];
		for(j=0;j<qffModel->vData.nFrequencies;j++)
			if(i!=j) dE3 += 2*(qffModel->vData.cubic[i][j][i]+qffModel->vData.cubic[i][i][j]+qffModel->vData.cubic[j][i][i])*qffModel->Q[j]*qffModel->Q[i];

		for(j=0;j<qffModel->vData.nFrequencies;j++)
		for(k=0;k<qffModel->vData.nFrequencies;k++)
		{
			if(i==j||i==k) continue;
			dE3 += (
				qffModel->vData.cubic[i][j][k]
				+qffModel->vData.cubic[j][i][k]
				+qffModel->vData.cubic[j][k][i]
				) *qffModel->Q[j]*qffModel->Q[k];
		}
		dE3 /= 6.0;
		qffModel->gradQ[i] += dE3;
	}

	for(i=0;i<qffModel->vData.nFrequencies;i++)
	{
		dE4 = 4*qffModel->vData.quartic[i][i][i][i]*qffModel->Q[i]*qffModel->Q[i]*qffModel->Q[i];
		for(j=0;j<qffModel->vData.nFrequencies;j++)
		if(i!=j) dE4 += 3*(	qffModel->vData.quartic[j][i][i][i]
					+qffModel->vData.quartic[i][j][i][i]
					+qffModel->vData.quartic[i][i][j][i]
					+qffModel->vData.quartic[i][i][i][j]
					)*qffModel->Q[i]*qffModel->Q[i]*qffModel->Q[j];

		for(j=0;j<qffModel->vData.nFrequencies;j++)
		for(k=0;k<qffModel->vData.nFrequencies;k++)
		{
			if(i==j||i==k) continue;
			dE4 += 2*(
					qffModel->vData.quartic[i][i][j][k]+
					qffModel->vData.quartic[i][j][i][k]+
					qffModel->vData.quartic[j][i][i][k]+
					qffModel->vData.quartic[i][j][k][i]+
					qffModel->vData.quartic[j][k][i][i]+
					qffModel->vData.quartic[j][i][k][i]
				   )*qffModel->Q[i]*qffModel->Q[j]*qffModel->Q[k];
		}

		for(j=0;j<qffModel->vData.nFrequencies;j++)
		for(k=0;k<qffModel->vData.nFrequencies;k++)
		for(l=0;l<qffModel->vData.nFrequencies;l++)
		{
			if(i==j||i==k|| i==l) continue;
			dE4 += 
				(
				qffModel->vData.quartic[i][j][k][l]+
				qffModel->vData.quartic[j][i][k][l]+
				qffModel->vData.quartic[j][k][i][l]+
				qffModel->vData.quartic[j][k][l][i]
				)*qffModel->Q[j]*qffModel->Q[k]*qffModel->Q[l];
		}
		dE4 /= 24.0;
		qffModel->gradQ[i] += dE4;
	}

	/*
       fprintf(stderr,"End computeAnalyticGradientsQ\n");
	for(i=0;i<qffModel->vData.nFrequencies;i++)
			fprintf(stderr,"Mode #%d Q=%0.10f grad=%0.10f\n", i+1, qffModel->Q[i],qffModel->gradQ[i]); 
	*/
}
static void computeAnalyticGradients(QFFModel* qffModel)
{

	if(qffModel->xyz) computeAnalyticGradientsXYZ(qffModel);
	else computeAnalyticGradientsQ(qffModel);
	/*
	if(qffModel->molecule.potentialEnergy<0)
	{
		if(qffModel->xyz)invGradientsXYZ(qffModel);
		else invGradientsQ(qffModel);
		qffModel->molecule.potentialEnergy *= -1;
	}
	*/
}
/**********************************************************************/
static void computeNumericGradientsXYZ(QFFModel* qffModel)
{
        int i;
        int k;
        Molecule* mol;
        int nAtoms;
        double Ep, Em;
        double dx;
	double conv = 1/ANGTOBOHR;

        if(!qffModel || qffModel->molecule.nAtoms<1) return;
        qffModel->klass->computeEnergy(qffModel);
        qffModel->klass->computeDipole(qffModel);
//	if(qffModel->molecule.potentialEnergy<0) return;

        dx = qffModel->diffStep;

	//printf("dx = %f\n",dx);
        mol = &qffModel->molecule;
        nAtoms = mol->nAtoms;
	//fprintf(stderr,"computeNumericGradients\n");

        for(i=0;i<nAtoms;i++)
        for(k=0;k<3;k++)
        {
		//printf("i=%d k = %d\n",i,k);
                mol->atoms[i].coordinates[k] += dx;
                qffModel->klass->computeEnergy(qffModel);
                Ep = mol->potentialEnergy;

                mol->atoms[i].coordinates[k] -= 2*dx;
                qffModel->klass->computeEnergy(qffModel);
                Em = mol->potentialEnergy;

                mol->atoms[i].gradient[k] = (Ep-Em)/dx/2*conv;
                mol->atoms[i].coordinates[k] += dx;
        }
        //printf("End computeGradientNumeric\n");
}
/**********************************************************************/
static void computeNumericGradientsQ(QFFModel* qffModel)
{
        int i;
        double Ep, Em;
        double dx;

        if(!qffModel || qffModel->vData.nFrequencies<1) return;
        qffModel->klass->computeEnergy(qffModel);
        qffModel->klass->computeDipole(qffModel);
//	if(qffModel->molecule.potentialEnergy<0) return;

        dx = qffModel->diffStep;

	printf("dx = %f\n",dx);
	//fprintf(stderr,"computeNumericGradientsQ\n");

        for(i=0;i<qffModel->vData.nFrequencies;i++)
        {
		//printf("i=%d k = %d\n",i,k);
		qffModel->Q[i] += dx;
                qffModel->klass->computeEnergy(qffModel);
                Ep = qffModel->molecule.potentialEnergy;

		qffModel->Q[i] -= 2*dx;
                qffModel->klass->computeEnergy(qffModel);
                Em =qffModel->molecule.potentialEnergy;
		qffModel->Q[i] += dx;

		qffModel->gradQ[i] =(Ep-Em)/dx/2;
        }
	/*
       fprintf(stderr,"End computeNumericGradientsQ\n");
	for(i=0;i<qffModel->vData.nFrequencies;i++)
			fprintf(stderr,"Mode #%d Q=%0.10f grad=%0.10f\n", i+1, qffModel->Q[i],qffModel->gradQ[i]); 
	*/
}
static void computeNumericGradients(QFFModel* qffModel)
{

	if(qffModel->xyz)computeNumericGradientsXYZ(qffModel);
	else computeNumericGradientsQ(qffModel);
	/*
	if(qffModel->molecule.potentialEnergy<0)
	{
		if(qffModel->xyz)invGradientsXYZ(qffModel);
		else invGradientsQ(qffModel);
		qffModel->molecule.potentialEnergy *= -1;
	}
	*/
}
/**********************************************************************/
static void computeDipole(QFFModel* qffModel)
{
	int i,j,k;
	int c;
	double dipole[3];
	for(c=0;c<3;c++) dipole[c] = qffModel->pData.zero[c];

	for(i=0;i<qffModel->vData.nFrequencies;i++)
	for(c=0;c<3;c++) dipole[c] += qffModel->pData.first[c][i]*qffModel->Q[i];

	for(i=0;i<qffModel->vData.nFrequencies;i++)
	for(j=0;j<qffModel->vData.nFrequencies;j++)
	for(c=0;c<3;c++) dipole[c] += 0.5*qffModel->pData.second[c][i][j]*qffModel->Q[i]*qffModel->Q[j];

	for(i=0;i<qffModel->vData.nFrequencies;i++)
	for(j=0;j<qffModel->vData.nFrequencies;j++)
	for(k=0;k<qffModel->vData.nFrequencies;k++)
	for(c=0;c<3;c++) dipole[c] += qffModel->pData.cubic[c][i][j][k]*qffModel->Q[i]*qffModel->Q[j]*qffModel->Q[k]/6;

	for(c=0;c<3;c++) qffModel->molecule.dipole[c] = dipole[c];
}
/*****************************************************************************/
static void copyGradients(Molecule* mol, double* g[])
{
	int i,k;
	if(!mol) return;
	for(i=0;i<mol->nAtoms;i++)
		for(k=0;k<3;k++)
			g[k][i] = mol->atoms[i].gradient[k];
}
/*****************************************************************************/
static void copyDipole(Molecule* mol, double d[])
{
	int k;
	if(!mol) return;
	for(k=0;k<3;k++)
		d[k] = mol->dipole[k];
}
/*****************************************************************************/
static void sortFrequencies(int nModes, double* frequencies, double** modes, double* reducedMasses, double* IRIntensities)
{
	int i;
	int j;
	int k;
	double dum;
	if(nModes<1 || !frequencies || !modes || !reducedMasses || !IRIntensities) return;
	for(i=0;i<nModes;i++)
	{
		k = i;
		for(j=i+1;j<nModes;j++)
			if(frequencies[j]<frequencies[k]) k = j;
		if(k==i) continue;
		/* swap i and k modes */
		dum = frequencies[i];
		frequencies[i] = frequencies[k];
		frequencies[k] = dum;
		dum = reducedMasses[i];
		reducedMasses[i] = reducedMasses[k];
		reducedMasses[k] = dum;
		dum = IRIntensities[i];
		IRIntensities[i] = IRIntensities[k];
		IRIntensities[k] = dum;
		for(j=0;j<nModes;j++)
		{
			dum =  modes[j][i];
			modes[j][i] = modes[j][k];
			modes[j][k] = dum;
		}
	}
}
/*****************************************************************************/
static int computeFrequencies(QFFModel* qffModel)
{
	int i;
	int j;
	int k;
	int c;
	int id,jd,index;
	double* F;
	double* gp[3];
	double* gm[3];
	double* dmuX[3];
	Molecule* mol;
	int nAtoms;
	double Dp[3];
	double Dm[3];
	double dx;
	double* frequencies; 
	double** modes; 
	double* reducedMasses; 
	double* IRIntensities;
	/* Intensities in 1 (D/Ang)^2 amu^-1 = 42.255 km/mol=171.65 cm^-2 atm^-1 at 0 C and 1 atm */
	/* Refs : D. Porezag and M. R. Pederson, Phys. Rev. B 54, 7830 (1996). and Y. Yamaguchi el al., J. Chem. Phys. 84,2262(1986)*/
	double AUTokmmolM1 = AUTODEB*AUTODEB*ANGTOBOHR*ANGTOBOHR*AMUTOAU*42.255;

	if(!qffModel || qffModel->molecule.nAtoms<1) return 0;
	dx = qffModel->diffStep;

	//fprintf(stderr,"diffStep of freq =%f\n",qffModel->diffStep);

	//printf("Begin calcul F\n");

	mol = &qffModel->molecule;
	nAtoms = mol->nAtoms;
	for(k=0;k<3;k++) gp[k] = malloc(nAtoms*sizeof(double));
	for(k=0;k<3;k++) gm[k] = malloc(nAtoms*sizeof(double));
	for(k=0;k<3;k++) dmuX[k] = malloc(3*nAtoms*sizeof(double));

	F = malloc(3*nAtoms*(3*nAtoms+1)/2*sizeof(double));

	//printf("End alloc calcul F\n");

	index = 0;
	for(i=0;i<nAtoms;i++)
	for(k=0;k<3;k++)
	{
		id=3*i+k;
		mol->atoms[i].coordinates[k] += dx;
		qffModel->klass->computeGradients(qffModel);
		copyGradients(mol, gp);
		qffModel->klass->computeDipole(qffModel);
		copyDipole(mol, Dp);

		mol->atoms[i].coordinates[k] -= 2*dx;
		qffModel->klass->computeGradients(qffModel);
		copyGradients(mol, gm);
		qffModel->klass->computeDipole(qffModel);
		copyDipole(mol, Dm);
		mol->atoms[i].coordinates[k] += dx;

		for(c = 0;c<3;c++) dmuX[c][id] = (Dp[c]-Dm[c])/dx/2/ANGTOBOHR;
		for(j=0;j<=i;j++)
		{
			double invm = 1.0/sqrt( mol->atoms[i].mass* mol->atoms[j].mass);
			invm/=AMUTOAU;
			for(c = 0;c<3;c++) 
			{
				jd = 3*j+c;
				if(jd>id) continue;
				index = jd + id*(id+1)/2;
				F[index] = (gp[c][j]-gm[c][j])/dx/2/ANGTOBOHR; 
				F[index] *= invm;
			}
		}
	}
	qffModel->klass->computeGradients(qffModel);
	qffModel->klass->computeDipole(qffModel);

	//printf("En calcul F\n");
	for(k=0;k<3;k++) free(gp[k]);
	for(k=0;k<3;k++) free(gm[k]);
	frequencies = malloc(3*nAtoms*sizeof(double));
	reducedMasses = malloc(3*nAtoms*sizeof(double));
	IRIntensities = malloc(3*nAtoms*sizeof(double));
	modes = malloc(3*nAtoms*sizeof(double*));
	for(i=0;i<3*nAtoms;i++) modes[i] = malloc(3*nAtoms*sizeof(double));

	eigenQL(3*nAtoms, F, frequencies, modes);
	free(F);
	/* convert in atomic unit  from kcal/Ang^2/amu */
	//for(i=0;i<3*nAtoms;i++) frequencies[i] *= 1.59360150e-03*0.529177*0.529177*5.48579911e-04; 
	/* convert frequencies in cm-1 */
	for(i=0;i<3*nAtoms;i++) 
		if( frequencies[i]>0) frequencies[i] = sqrt(frequencies[i])*AUTOCM1;
		else frequencies[i] = -sqrt(-frequencies[i])*AUTOCM1;

	/* compute the IR intensities */
	for(i=0;i<nAtoms;i++)
	for(k=0;k<3;k++)
	{
		int id=3*i+k;
		double IRI = 0;
		double D[3] = {0,0,0};
		int kp;
		for(c = 0;c<3;c++)
		for(j=0;j<nAtoms;j++)
		for(kp = 0;kp<3;kp++) 
		{
			int jd = 3*j+kp;
			double Lji = modes[jd][id];
			double a=dmuX[c][jd]*Lji/sqrt(mol->atoms[j].mass*AMUTOAU);
			D[c]+=a;
		}
		IRI = 0;
		for(c = 0;c<3;c++)  IRI+= D[c]*D[c];
		IRIntensities[id] = IRI;
	}
	for(k=0;k<3;k++) free(dmuX[k]);
	/* conversion in km/mol*/

	for(i=0;i<3*nAtoms;i++) IRIntensities[i] *= AUTokmmolM1;

	/* compute the reduced mass */
	for(i=0;i<3*nAtoms;i++) 
	{
		double m = 0;
		for(j=0;j<mol->nAtoms;j++)
		{
			double r2 = 0;
			for(c=0;c<3;c++) r2+= modes[3*j+c][i]*modes[3*j+c][i];
			m+= r2/(mol->atoms[j].mass); 
		}
		if(m<=0) m = 1;
		m = 1/m;
		for(j=0;j<mol->nAtoms;j++)
		{
			double r =sqrt(m)/sqrt(mol->atoms[j].mass);
			for(c=0;c<3;c++) modes[3*j+c][i]*=r;
		}

		reducedMasses[i] = m;
	}
	sortFrequencies(3*nAtoms, frequencies, modes, reducedMasses, IRIntensities);
	qffModel->frequencies = frequencies;
	qffModel->modes = modes;
	qffModel->reducedMasses = reducedMasses;
	qffModel->IRIntensities = IRIntensities;

	return 3*nAtoms;

}
/*****************************************************************************/
static void compareFrequencies(QFFModel* qffModel,FILE* file)
{
	int i,j,k,c;
	double diffFreq;
	double diffMass;
	double overlapModes;
	int nAtoms = qffModel->molecule.nAtoms;
	int ntr = 6;
	double sumDiffFreq=0;
	fprintf(file,"%22s %22s %22s %22s %22s %22s\n",
	"Calc. Freq. [cm^-1]","IR Int(km/mol)",  "Orig. Freq. [cm^-1]", "diffFreq[cm^-1]", "diffMass[amu]", "overlapModes");
	
	if(nAtoms<3) ntr=5;
	for(i=0;i<ntr;i++) fprintf(file,"%10.3lf Rot/Trans\n",qffModel->frequencies[i]);
	for(i=ntr;i<3*nAtoms;i++) 
	{
		j = i-ntr;
		diffFreq = qffModel->frequencies[i]-sqrt(qffModel->vData.hessian[j][j])*AUTOCM1;
		diffMass = qffModel->reducedMasses[i]-qffModel->vData.effectiveMasses[j];
		overlapModes = 0;
		for(k=0;k<nAtoms;k++) 
		for(c=0;c<3;c++) 
			overlapModes += qffModel->modes[3*k+c][i]*qffModel->vData.modes[j][k][c];
		fprintf(file,"%22.3lf ",qffModel->frequencies[i]);
		fprintf(file,"%22.3lf ",qffModel->IRIntensities[i]);
		fprintf(file,"%22.3lf ",sqrt(qffModel->vData.hessian[j][j])*AUTOCM1);
		fprintf(file,"%22.3lf ",diffFreq);
		fprintf(file,"%22.3lf ",diffMass);
		fprintf(file,"%22.3lf ",overlapModes);
		fprintf(file,"\n");
		sumDiffFreq += fabs(diffFreq);
	}
	if(3*nAtoms-ntr>0) fprintf(file,"\naveAbsDiff=%10.3lf\n",sumDiffFreq/(3*nAtoms-ntr));
	fprintf(file,"\n");

	
}
/*****************************************************************************/
static void compute(QFFModel* qffModel)
{
	if(qffModel->typeCalcul==0)
	{
		qffModel->klass->computeEnergy(qffModel);
		qffModel->klass->computeDipole(qffModel);
	}
	else if(qffModel->typeCalcul==1)
		qffModel->klass->computeGradients(qffModel);
	else 
	{
		qffModel->klass->computeFrequencies(qffModel);
		qffModel->klass->compareFrequencies(qffModel,stdout);
	}
}
static void runAlea(QFFModel* qffModel)
{
	int i,j;
	double max=50;
	srand((unsigned int)(time(NULL)));
	for(j=0;j<qffModel->vData.nFrequencies*1000;j++) 
	{
		for(i=0;i<qffModel->vData.nFrequencies;i++) 
			qffModel->Q[i] = 2*max*rand()/(double)RAND_MAX-max;
		qffModel->klass->compute(qffModel);
	}

}
/**********************************************************************/
QFFModel newQFFModel()
{
	QFFModel qffModel;
	qffModel.klass = malloc(sizeof(QFFModelClass));
	qffModel.klass->readData = readData;
	qffModel.klass->convertToAU = convertToAU;
	qffModel.klass->convertToAU2 = convertToAU2;
	qffModel.klass->computeQFFParameters = computeQFFParameters;
	qffModel.klass->free = freeQFFModel;
	qffModel.klass->computeEnergy = computeEnergy;
	qffModel.klass->computeGradients = computeAnalyticGradients;
	qffModel.klass->computeFrequencies = computeFrequencies;
	qffModel.klass->compareFrequencies = compareFrequencies;
	qffModel.klass->compute = compute;
	qffModel.klass->runAlea = runAlea;
	qffModel.klass->computeDipole = computeDipole;
	qffModel.klass->getKineticEnergy = getKineticEnergy;
	qffModel.klass->getKelvin = getKelvin;
	qffModel.klass->scaleVelocities = scaleVelocities;
	qffModel.klass->setMaxwellVelocities = setMaxwellVelocities;
	qffModel.klass->setMaxwellVelocitiesIfNull = setMaxwellVelocitiesIfNull;
	qffModel.klass->printModesAndVelocities = printModesAndVelocities;

	qffModel.vData = newQFFPotentialData(0,0);
	qffModel.pData = newQFFPropertiesData(0,0);
	qffModel.molecule = *(newMolecule());
	qffModel.Q=NULL;
//	printf("End newQFFModel\n");
	return qffModel;
}
/**********************************************************************/
File: ./cchemilib/src/QFFPot/QFFPotentialData.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* QFFPotentialData.c */
#include <math.h>
#include "../QFFPot/QFFPotentialData.h"
#include "../Utils/Utils.h"
#include "../Utils/AtomsProp.h"
#include "../Utils/Constants.h"
#include "../Utils/QL.h"

static void readData(QFFPotentialData* qffPotentialData, char* fileName);
static void convertToAU(QFFPotentialData* qffPotentialData);
static void convertToAU2(QFFPotentialData* qffPotentialData);
static void printData(QFFPotentialData* qffPotentialData);
static void freeQFFPotentialData(QFFPotentialData* qffPotentialData);
static void rotModes(QFFPotentialData* qffPotentialData, double u[3][3]);
static void computeQFFParameters(QFFPotentialData* qffPotentialData);
/**********************************************************************/
static void freeQFFPotentialData(QFFPotentialData* qffPotentialData)
{
	int nF = qffPotentialData->nFrequencies;
	int nAtoms = qffPotentialData->molecule.nAtoms;
	freeVectorDouble(&qffPotentialData->effectiveMasses);
	freeVectorDouble(&qffPotentialData->gradients);
	freeVectorDouble(&qffPotentialData->Be);
	freeMatrixDouble(&qffPotentialData->hessian, nF);
	freeCubeDouble(&qffPotentialData->modes, nF, nAtoms);
	freeCubeDouble(&qffPotentialData->MWModes, nF, nAtoms);
	freeCubeDouble(&qffPotentialData->cubic, nF, nF);
	freeCubeDouble(&qffPotentialData->coriolis, 3, nF);
	freeQuarticDouble(&qffPotentialData->quartic, nF, nF, nF);
}
/**********************************************************************/
QFFPotentialData newQFFPotentialData(int n, int nAtoms)
{
	QFFPotentialData qffPotentialData;
	qffPotentialData.klass = malloc(sizeof(QFFPotentialDataClass));
	qffPotentialData.klass->readData = readData;
	qffPotentialData.klass->convertToAU = convertToAU;
	qffPotentialData.klass->convertToAU2 = convertToAU2;
	qffPotentialData.klass->rotModes = rotModes;
	qffPotentialData.klass->free = freeQFFPotentialData;
	qffPotentialData.klass->print = printData;
	qffPotentialData.klass->computeQFFParameters = computeQFFParameters;
	qffPotentialData.nFrequencies = n;
	if(qffPotentialData.nFrequencies<=0) qffPotentialData.nFrequencies = 0;

	qffPotentialData.molecule = *(newMolecule());

	qffPotentialData.gradients = NULL;
	qffPotentialData.gradients = newVectorDouble(qffPotentialData.nFrequencies);
	initVectorDouble(qffPotentialData.gradients, qffPotentialData.nFrequencies, 0.0);

	qffPotentialData.hessian = newMatrixDouble(qffPotentialData.nFrequencies,qffPotentialData.nFrequencies);
	initMatrixDouble(qffPotentialData.hessian, qffPotentialData.nFrequencies, qffPotentialData.nFrequencies, 0.0);

	qffPotentialData.Be = newVectorDouble(3);
	initVectorDouble(qffPotentialData.Be, 3, 1.0);

	qffPotentialData.effectiveMasses = newVectorDouble(qffPotentialData.nFrequencies);
	initVectorDouble(qffPotentialData.effectiveMasses, qffPotentialData.nFrequencies, 1.0);

	qffPotentialData.cubic = newCubeDouble(qffPotentialData.nFrequencies, qffPotentialData.nFrequencies, qffPotentialData.nFrequencies);
	initCubeDouble(qffPotentialData.cubic, qffPotentialData.nFrequencies, qffPotentialData.nFrequencies, qffPotentialData.nFrequencies, 0.0);

	qffPotentialData.coriolis = newCubeDouble(3, qffPotentialData.nFrequencies, qffPotentialData.nFrequencies);
	initCubeDouble(qffPotentialData.coriolis, 3, qffPotentialData.nFrequencies, qffPotentialData.nFrequencies, 0.0);

	qffPotentialData.quartic = newQuarticDouble(qffPotentialData.nFrequencies, qffPotentialData.nFrequencies, qffPotentialData.nFrequencies, qffPotentialData.nFrequencies);
	initQuarticDouble(qffPotentialData.quartic, qffPotentialData.nFrequencies, qffPotentialData.nFrequencies, qffPotentialData.nFrequencies, qffPotentialData.nFrequencies, 0.0);

	qffPotentialData.modes = newCubeDouble(qffPotentialData.nFrequencies, nAtoms, 3);
	initCubeDouble(qffPotentialData.modes, qffPotentialData.nFrequencies, nAtoms, 3, 0.0);

	qffPotentialData.MWModes = newCubeDouble(qffPotentialData.nFrequencies, nAtoms, 3);
	initCubeDouble(qffPotentialData.MWModes, qffPotentialData.nFrequencies, nAtoms, 3, 0.0);
	qffPotentialData.qffPotParameters = NULL;

	return qffPotentialData;

}
/*****************************************************************************/
static void printQFFHessian(QFFPotentialData* qffPotentialData, char* fileName)
{
	FILE* file =fopen(fileName,"w");
	int n = qffPotentialData->nFrequencies;
	double cutoff = 1e-10;
	double** M = qffPotentialData->hessian;
	int i;
	for(i = 0;i<n; i++) 
	{
		if(fabs(M[i][i])>=cutoff)
      			fprintf(file,"%d %d %20.10f\n",i+1,i+1,M[i][i]);
	}
	fclose(file);
}
static void printQFFCubic(QFFPotentialData* qffPotentialData, char* fileName)
{
	FILE* file =fopen(fileName,"w");
	int n = qffPotentialData->nFrequencies;
	double cutoff = 1e-10;
	double*** M = qffPotentialData->cubic;
	int i,j,k;
	for(i = 0;i<n; i++) 
	{
		for(j = 0;j<n; j++) 
		for(k = 0;k<n; k++) 
			if(fabs(M[k][i][j])>=cutoff)
      			fprintf(file,"%d %d %d %20.10f\n",i+1,j+1,k+1,M[k][i][j]);
	}
	fclose(file);
}
static void printQFFCoriolis(QFFPotentialData* qffPotentialData, char* fileName)
{
	FILE* file =fopen(fileName,"w");
	int n = qffPotentialData->nFrequencies;
	int m = 3;
	double cutoff = 1e-10;
	double*** M = qffPotentialData->coriolis;
	int i,j,k;
	for(i = 0;i<n; i++) 
	{
		for(j = 0;j<n; j++) 
		for(k = 0;k<m; k++) 
			if(fabs(M[k][i][j])>=cutoff)
      			fprintf(file,"%d %d %d %20.10f\n",i+1,j+1,k+1,M[k][i][j]);
	}
	fclose(file);
}
static void printQFFRot(QFFPotentialData* qffPotentialData, char* fileName)
{
	FILE* file =fopen(fileName,"w");
	double cutoff = 1e-10;
	double* M = qffPotentialData->Be;
	int i;
	for(i = 0;i<3; i++) 
	{
		if(fabs(M[i])>=cutoff)
      			fprintf(file,"%d %20.10f\n",i+1,M[i]);
	}
	fclose(file);
}
static void printQFFQuartic(QFFPotentialData* qffPotentialData, char* fileName)
{
	FILE* file =fopen(fileName,"w");
	int i,j,k,l;
	double cutoff = 1e-10;
	double**** C = qffPotentialData->quartic;
	int n = qffPotentialData->nFrequencies;
	for(i = 0;i<n; i++) 
	{
		for(j = 0;j<n; j++) 
		{
			for(k = 0;k<n; k++) 
			{
				for(l = 0;l<n; l++) 
				if(fabs(C[i][j][k][l])>=cutoff)
      					fprintf(file,"%d %d %d %d %20.10f\n",i+1,j+1,k+1,l+1,C[i][j][k][l]);
			}
		}
	}
	fclose(file);
}
static void printQFFData(QFFPotentialData* qffPotentialData)
{
	printQFFHessian(qffPotentialData,"data.w");
	printQFFCubic(qffPotentialData,"data.f3");
	printQFFQuartic(qffPotentialData,"data.f4");
	printQFFRot(qffPotentialData,"data.b");
	printQFFCoriolis(qffPotentialData,"data.z");
}
/*****************************************************************************/
static void printModes(QFFPotentialData* qffPotentialData)
{
	printf("\n# imode iAtom xyz value\n");
	printf("Modes\n");
	printCubeDoubleCutOff(qffPotentialData->modes, qffPotentialData->nFrequencies, qffPotentialData->molecule.nAtoms, 3,-1);
	printf("END\n");
}
static void printGradients(QFFPotentialData* qffPotentialData)
{
	printf("\nGradients\n");
	printVectorDoubleCutOff(qffPotentialData->gradients, qffPotentialData->nFrequencies, 1e-10);
	printf("END\n");
}
static void printHessian(QFFPotentialData* qffPotentialData)
{
	printf("\nHessian\n");
	printMatrixDoubleCutOff(qffPotentialData->hessian, qffPotentialData->nFrequencies, qffPotentialData->nFrequencies,1e-10);
	printf("END\n");
}
static void printCubic(QFFPotentialData* qffPotentialData)
{
	printf("\nCubic\n");
	printCubeDoubleCutOff(qffPotentialData->cubic, qffPotentialData->nFrequencies, qffPotentialData->nFrequencies, qffPotentialData->nFrequencies,1e-10);
	printf("END\n");
}
static void printCoriolis(QFFPotentialData* qffPotentialData)
{
	printf("\nCoriolis\n");
	printCubeDoubleCutOff(qffPotentialData->coriolis, 3, qffPotentialData->nFrequencies, qffPotentialData->nFrequencies,1e-10);
	printf("END\n");
}
static void printRot(QFFPotentialData* qffPotentialData)
{
	printf("\nRotation constants\n");
	printVectorDoubleCutOff(qffPotentialData->Be, 3,1e-10);
	printf("END\n");
}
static void printQuartic(QFFPotentialData* qffPotentialData)
{
   printf("\nQuartic\n");
   printQuarticDoubleCutOff(qffPotentialData->quartic, qffPotentialData->nFrequencies, qffPotentialData->nFrequencies, qffPotentialData->nFrequencies, qffPotentialData->nFrequencies,1e-10);
	printf("END\n");
}
static void printData(QFFPotentialData* qffPotentialData)
{
	printModes(qffPotentialData);
	printGradients(qffPotentialData);
	printHessian(qffPotentialData);
	printCubic(qffPotentialData);
	printQuartic(qffPotentialData);
	printCoriolis(qffPotentialData);
	printRot(qffPotentialData);
	//printQFFData(qffPotentialData);
}
/*****************************************************************************/
static void convertToAU(QFFPotentialData* qffPotentialData)
{
	int i,j,k,l;
	int c;
	double conv = 1/AUTOCM1;
	double conv2 = conv*conv;
	double conv3 = conv2*sqrt(conv);
	double conv4 = conv2*conv;
	int nF = qffPotentialData->nFrequencies;
	double convAMUToAU = sqrt(AMUTOAU);
	
	/*
	conv2 *= convAMUToAU*convAMUToAU;
	conv3 *= convAMUToAU*convAMUToAU*convAMUToAU;
	conv4 *= convAMUToAU*convAMUToAU*convAMUToAU*convAMUToAU;
	// To convert in Hartree amu^-n/2 Bohr^-n
	*/

	//fprintf(stderr,"phi111 cm-1=%0.12e\n",qffPotentialData->cubic[1][1][1]);
	for(i=0;i<nF;i++)
	for(j=0;j<nF;j++)
	for(k=0;k<nF;k++)
		qffPotentialData->cubic[i][j][k] *=  conv3*sqrt(qffPotentialData->hessian[i][i]*qffPotentialData->hessian[j][j]*qffPotentialData->hessian[k][k]);

	for(i=0;i<nF;i++)
	for(j=0;j<nF;j++)
	for(k=0;k<nF;k++)
		qffPotentialData->cubic[i][j][k] =  getMaxCubicIJK( qffPotentialData->cubic, i, j, k);
	//fprintf(stderr,"phi111=%0.12e\n",qffPotentialData->cubic[1][1][1]);
	//exit(1);

	for(i=0;i<nF;i++)
	for(j=0;j<nF;j++)
	for(k=0;k<nF;k++)
	for(l=0;l<nF;l++)
		qffPotentialData->quartic[i][j][k][l] *=  conv4*sqrt(qffPotentialData->hessian[i][i]*qffPotentialData->hessian[j][j]*qffPotentialData->hessian[k][k]*qffPotentialData->hessian[l][l]);


	for(i=0;i<nF;i++)
	for(j=0;j<nF;j++)
	for(k=0;k<nF;k++)
	for(l=0;l<nF;l++)
		qffPotentialData->quartic[i][j][k][l] =  getMaxQuarticIJK( qffPotentialData->quartic,i,j,k,l);

	for(i=0;i<qffPotentialData->nFrequencies;i++)
		qffPotentialData->hessian[i][i] =  qffPotentialData->hessian[i][i]* qffPotentialData->hessian[i][i]*conv2;

	for(i=0;i<qffPotentialData->nFrequencies;i++)
	for(k=0;k<qffPotentialData->molecule.nAtoms;k++)
	for(c=0;c<3;c++)
		qffPotentialData->MWModes[i][k][c] *=  convAMUToAU;
}
/*****************************************************************************/
static void convertToAU2(QFFPotentialData* qffPotentialData)
{
	int i,j,k,l;
	int c;
	double conv = 1/AUTOCM1;
	double conv2 = conv*conv;
	double conv3 = conv2*sqrt(conv);
	double conv4 = conv2*conv;
	int nF = qffPotentialData->nFrequencies;
	double convAMUToAU = sqrt(AMUTOAU);
	
	conv2 *= convAMUToAU*convAMUToAU;
	conv3 *= convAMUToAU*convAMUToAU*convAMUToAU;
	conv4 *= convAMUToAU*convAMUToAU*convAMUToAU*convAMUToAU;
	// To convert in Hartree amu^-n/2 Bohr^-n

	//fprintf(stderr,"phi111 cm-1=%0.12e\n",qffPotentialData->cubic[1][1][1]);
	for(i=0;i<nF;i++)
	for(j=0;j<nF;j++)
	for(k=0;k<nF;k++)
		qffPotentialData->cubic[i][j][k] *=  conv3*sqrt(qffPotentialData->hessian[i][i]*qffPotentialData->hessian[j][j]*qffPotentialData->hessian[k][k]);

	for(i=0;i<nF;i++)
	for(j=0;j<nF;j++)
	for(k=0;k<nF;k++)
		qffPotentialData->cubic[i][j][k] =  getMaxCubicIJK( qffPotentialData->cubic, i, j, k);
	//fprintf(stderr,"phi111=%0.12e\n",qffPotentialData->cubic[1][1][1]);
	//exit(1);

	for(i=0;i<nF;i++)
	for(j=0;j<nF;j++)
	for(k=0;k<nF;k++)
	for(l=0;l<nF;l++)
		qffPotentialData->quartic[i][j][k][l] *=  conv4*sqrt(qffPotentialData->hessian[i][i]*qffPotentialData->hessian[j][j]*qffPotentialData->hessian[k][k]*qffPotentialData->hessian[l][l]);


	for(i=0;i<nF;i++)
	for(j=0;j<nF;j++)
	for(k=0;k<nF;k++)
	for(l=0;l<nF;l++)
		qffPotentialData->quartic[i][j][k][l] =  getMaxQuarticIJK( qffPotentialData->quartic,i,j,k,l);

	for(i=0;i<qffPotentialData->nFrequencies;i++)
		qffPotentialData->hessian[i][i] =  qffPotentialData->hessian[i][i]* qffPotentialData->hessian[i][i]*conv2;

	for(i=0;i<qffPotentialData->nFrequencies;i++)
	for(k=0;k<qffPotentialData->molecule.nAtoms;k++)
	for(c=0;c<3;c++)
		qffPotentialData->MWModes[i][k][c] *=  convAMUToAU;
}
/*****************************************************************************/
static void computeMWModes(QFFPotentialData* qffPotentialData)
{
	int i,k,c;
	int nF = qffPotentialData->nFrequencies;
	int nAtoms = qffPotentialData->molecule.nAtoms;
	for(i=0;i<nF;i++)
	for(k=0;k<nAtoms;k++)
	for(c=0;c<3;c++)
		qffPotentialData->MWModes[i][k][c] =  qffPotentialData->modes[i][k][c]*qffPotentialData->molecule.atoms[k].mass/sqrt(qffPotentialData->effectiveMasses[i]);
		//qffPotentialData->MWModes[i][k][c] =  qffPotentialData->modes[i][k][c]*sqrt(qffPotentialData->effectiveMasses[i]);
}
/*****************************************************************************/
static void rotModes(QFFPotentialData* qffPotentialData, double u[3][3])
{
	int i,k;
	int nF = qffPotentialData->nFrequencies;
	int nAtoms = qffPotentialData->molecule.nAtoms;
	double x,y,z;
	for(i=0;i<nF;i++)
	for(k=0;k<nAtoms;k++)
	{
		//qffPotentialData->MWModes[i][k][c] =  qffPotentialData->modes[i][k][c]*qffPotentialData->molecule.atoms[k].mass/sqrt(qffPotentialData->effectiveMasses[i]);
   		x = u[0][0] * qffPotentialData->MWModes[i][k][0] + u[0][1] * qffPotentialData->MWModes[i][k][1]  + u[0][2] * qffPotentialData->MWModes[i][k][2];
   		y = u[1][0] * qffPotentialData->MWModes[i][k][0] + u[1][1] * qffPotentialData->MWModes[i][k][1]  + u[1][2] * qffPotentialData->MWModes[i][k][2];
   		z = u[2][0] * qffPotentialData->MWModes[i][k][0] + u[2][1] * qffPotentialData->MWModes[i][k][1]  + u[2][2] * qffPotentialData->MWModes[i][k][2];

		qffPotentialData->MWModes[i][k][0] = x;
		qffPotentialData->MWModes[i][k][1] = y;
		qffPotentialData->MWModes[i][k][2] = z;
	}
}
/*****************************************************************************/
static void readData(QFFPotentialData* qffPotentialData, char* inputFileName)
{
	FILE* inputFile;
	Molecule mol = *(newMolecule());

        inputFile = fopen(inputFileName,"rb");
	if(!inputFile)
	{
		fprintf(stderr, "==========================================================\n");
		fprintf(stderr, "Sorry, I cannot opent the %s file\n", inputFileName);
		fprintf(stderr, "==========================================================\n");
		exit(1);
	}

	readOneInt(inputFile,"nFrequencies",&qffPotentialData->nFrequencies);
//	fprintf(stdout, "nFrequencies=%d\n", qffPotentialData->nFrequencies);
	fclose(inputFile);
	
	mol.klass->read(&mol, inputFileName);
	*qffPotentialData = newQFFPotentialData(qffPotentialData->nFrequencies,mol.nAtoms);
	mol.klass->free(&mol);

	qffPotentialData->molecule.klass->read(&qffPotentialData->molecule, inputFileName);
	if(qffPotentialData->molecule.nAtoms<1)
	{
		fprintf(stderr, "==========================================================\n");
		fprintf(stderr, "Sorry, I cannot read geometry from the %s file\n", inputFileName);
		fprintf(stderr, "==========================================================\n");
		exit(1);
	}

        inputFile = fopen(inputFileName,"rb");
	readVectorReal(inputFile,"Masses",qffPotentialData->nFrequencies, qffPotentialData->effectiveMasses);
	//fprintf(stderr,"Masse0 = %f\n",qffPotentialData->effectiveMasses[0]);

//	printf("nFrequencies=%d molecule.nAtoms=%d \n",qffPotentialData->nFrequencies, qffPotentialData->molecule.nAtoms);
	readCubeReal(inputFile,"Modes",qffPotentialData->nFrequencies, qffPotentialData->molecule.nAtoms, 3, qffPotentialData->modes);
	
	readVectorReal(inputFile,"Gradients",qffPotentialData->nFrequencies, qffPotentialData->gradients);/* qffPotentialData.gradients presently not used, min surface */
	readMatrixReal(inputFile,"Hessian",qffPotentialData->nFrequencies, qffPotentialData->nFrequencies, qffPotentialData->hessian);
	readCubeReal(inputFile,"Cubic",qffPotentialData->nFrequencies, qffPotentialData->nFrequencies, qffPotentialData->nFrequencies, qffPotentialData->cubic);
	readQuarticReal(inputFile,"Quartic",qffPotentialData->nFrequencies, qffPotentialData->nFrequencies, qffPotentialData->nFrequencies, qffPotentialData->nFrequencies, qffPotentialData->quartic);
	
	readVectorReal(inputFile,"Rotational",3, qffPotentialData->Be);
	readCubeReal(inputFile,"Coriolis",3, qffPotentialData->nFrequencies, qffPotentialData->nFrequencies, qffPotentialData->coriolis);
	//printData(qffPotentialData);
	//printQFFData(qffPotentialData);
	fclose(inputFile);
	computeMWModes(qffPotentialData);
}
/**********************************************************************/
static void computeQFFParameters(QFFPotentialData* qffPotentialData)
{
	int i,j,k,l;
	int nF = qffPotentialData->nFrequencies;
	QFFPotParameters* qffPotParameters = malloc(sizeof(QFFPotParameters));
	double cut = 1e-12;
	int m;
	

	// V1MR
	qffPotParameters->numberOf1MR = 0;
	qffPotParameters->qff1MR = NULL;
	for(i=0;i<nF;i++) if(fabs(qffPotentialData->hessian[i][i])>cut) qffPotParameters->numberOf1MR++;
	for(i=0;i<nF;i++) if(fabs(qffPotentialData->cubic[i][i][i])>cut) qffPotParameters->numberOf1MR++;
	for(i=0;i<nF;i++) if(fabs(qffPotentialData->quartic[i][i][i][i])>cut) qffPotParameters->numberOf1MR++;
	if(qffPotParameters->numberOf1MR>0) qffPotParameters->qff1MR= malloc(qffPotParameters->numberOf1MR*sizeof(QFFPotnMR));

	m = 0;
	for(i=0;i<nF;i++) if(fabs(qffPotentialData->hessian[i][i])>cut)
	{ 
		//fprintf(stderr,"H = %f\n",qffPotentialData->hessian[i][i]);
		qffPotParameters->qff1MR[m].numbers[0] = i;
		qffPotParameters->qff1MR[m].numbers[1] = 2;
		qffPotParameters->qff1MR[m].energy=0.5*qffPotentialData->hessian[i][i];
		qffPotParameters->qff1MR[m].grad=2*qffPotParameters->qff1MR[m].energy;
		m++;
	}
	for(i=0;i<nF;i++) if(fabs(qffPotentialData->cubic[i][i][i])>cut)
	{ 
		qffPotParameters->qff1MR[m].numbers[0] = i;
		qffPotParameters->qff1MR[m].numbers[1] = 3;
		qffPotParameters->qff1MR[m].energy=qffPotentialData->cubic[i][i][i]/6.0;
		qffPotParameters->qff1MR[m].grad=3*qffPotParameters->qff1MR[m].energy;
		m++;
	}
	for(i=0;i<nF;i++) if(fabs(qffPotentialData->quartic[i][i][i][i])>cut)
	{ 
		qffPotParameters->qff1MR[m].numbers[0] = i;
		qffPotParameters->qff1MR[m].numbers[1] = 4;
		qffPotParameters->qff1MR[m].energy=qffPotentialData->quartic[i][i][i][i]/24.0;
		qffPotParameters->qff1MR[m].grad=4*qffPotParameters->qff1MR[m].energy;
		m++;
	}
	

	// free Hessian

	// V2MR
	qffPotParameters->numberOf2MR = 0;
	qffPotParameters->qff2MR = NULL;
	for(i=0;i<nF;i++)
	for(j=0;j<nF;j++)
	{
		if(i==j) continue;
		if(fabs(qffPotentialData->cubic[i][i][j])>cut) qffPotParameters->numberOf2MR++;
		if(fabs(qffPotentialData->quartic[i][i][i][j])>cut) qffPotParameters->numberOf2MR++;
	}
	for(i=0;i<nF;i++)
	for(j=0;j<i;j++)
		if(fabs(qffPotentialData->quartic[i][i][j][j])>cut) qffPotParameters->numberOf2MR++;

	if(qffPotParameters->numberOf2MR>0) qffPotParameters->qff2MR= malloc(qffPotParameters->numberOf2MR*sizeof(QFFPotnMR));
	m = 0;
	for(i=0;i<nF;i++)
	for(j=0;j<nF;j++)
	{
		if(i==j) continue;
		if(fabs(qffPotentialData->cubic[i][i][j])>cut) 
		{
			qffPotParameters->qff2MR[m].numbers[0] = i;
			qffPotParameters->qff2MR[m].numbers[1] = j;
			qffPotParameters->qff2MR[m].numbers[2] = 2;
			qffPotParameters->qff2MR[m].energy=3*qffPotentialData->cubic[i][i][j]/6.0;
			qffPotParameters->qff2MR[m].grad=2*qffPotParameters->qff2MR[m].energy;
			m++;
		}
	}
	for(i=0;i<nF;i++)
	for(j=0;j<nF;j++)
	{
		if(i==j) continue;
		if(fabs(qffPotentialData->quartic[i][i][i][j])>cut)
		{
			qffPotParameters->qff2MR[m].numbers[0] = i;
			qffPotParameters->qff2MR[m].numbers[1] = j;
			qffPotParameters->qff2MR[m].numbers[2] = 3;
			qffPotParameters->qff2MR[m].energy=4*qffPotentialData->quartic[i][i][i][j]/24.0;
			qffPotParameters->qff2MR[m].grad=3*qffPotParameters->qff2MR[m].energy;
			m++;
		}
	}
	for(i=0;i<nF;i++)
	for(j=0;j<i;j++)
	{
		if(fabs(qffPotentialData->quartic[i][i][j][j])>cut)
		{
			qffPotParameters->qff2MR[m].numbers[0] = i;
			qffPotParameters->qff2MR[m].numbers[1] = j;
			qffPotParameters->qff2MR[m].numbers[2] = -2;
			qffPotParameters->qff2MR[m].energy=6*qffPotentialData->quartic[i][i][j][j]/24.0;
			qffPotParameters->qff2MR[m].grad=2*qffPotParameters->qff2MR[m].energy;
			m++;
		}
	}
	// V3MR
	qffPotParameters->numberOf3MR = 0;
	qffPotParameters->qff3MR = NULL;
	for(i=0;i<nF;i++)
	for(j=0;j<i;j++)
	for(k=0;k<j;k++)
	{
		if(fabs(qffPotentialData->cubic[i][j][k])>cut) qffPotParameters->numberOf3MR++;
	}
	for(i=0;i<nF;i++)
	for(j=0;j<nF;j++)
	for(k=0;k<j;k++)
	{
		if(i==j||i==k) continue;
		if(fabs(qffPotentialData->quartic[i][i][j][k])>cut) qffPotParameters->numberOf3MR++;
	}
	if(qffPotParameters->numberOf3MR>0) qffPotParameters->qff3MR= malloc(qffPotParameters->numberOf3MR*sizeof(QFFPotnMR));
	m = 0;
	for(i=0;i<nF;i++)
	for(j=0;j<i;j++)
	for(k=0;k<j;k++)
	{	
		if(fabs(qffPotentialData->cubic[i][j][k])>cut) 
		{
			qffPotParameters->qff3MR[m].numbers[0] = i;
			qffPotParameters->qff3MR[m].numbers[1] = j;
			qffPotParameters->qff3MR[m].numbers[2] = k;
			qffPotParameters->qff3MR[m].numbers[3] = 1;
			qffPotParameters->qff3MR[m].energy=6*qffPotentialData->cubic[i][j][k]/6.0;
			qffPotParameters->qff3MR[m].grad=qffPotParameters->qff3MR[m].energy;
			m++;
		}
	}
	for(i=0;i<nF;i++)
	for(j=0;j<nF;j++)
	for(k=0;k<j;k++)
	{
		if(i==j||i==k) continue;
		if(fabs(qffPotentialData->quartic[i][i][j][k])>cut)
		{
			qffPotParameters->qff3MR[m].numbers[0] = i;
			qffPotParameters->qff3MR[m].numbers[1] = j;
			qffPotParameters->qff3MR[m].numbers[2] = k;
			qffPotParameters->qff3MR[m].numbers[3] = 2;
			qffPotParameters->qff3MR[m].energy=6*2*qffPotentialData->quartic[i][i][j][k]/24.0;
			qffPotParameters->qff3MR[m].grad=2*qffPotParameters->qff3MR[m].energy;
			m++;
		}
	}
	// free Cubic

	qffPotParameters->numberOf4MR = 0;
	qffPotParameters->qff4MR = NULL;
	for(i=0;i<nF;i++)
	for(j=0;j<i;j++)
	for(k=0;k<j;k++)
	for(l=0;l<k;l++)
	{
		if(fabs(qffPotentialData->quartic[i][j][k][l])>cut) qffPotParameters->numberOf4MR++;
	}

	if(qffPotParameters->numberOf4MR>0) qffPotParameters->qff4MR= malloc(qffPotParameters->numberOf4MR*sizeof(QFFPotnMR));
	m = 0;
	for(i=0;i<nF;i++)
	for(j=0;j<i;j++)
	for(k=0;k<j;k++)
	for(l=0;l<k;l++)
	{
		if(fabs(qffPotentialData->quartic[i][j][k][l])>cut)
		{
			qffPotParameters->qff4MR[m].numbers[0] = i;
			qffPotParameters->qff4MR[m].numbers[1] = j;
			qffPotParameters->qff4MR[m].numbers[2] = k;
			qffPotParameters->qff4MR[m].numbers[3] = l;
			qffPotParameters->qff4MR[m].energy=24*qffPotentialData->quartic[i][j][k][l]/24.0;
			qffPotParameters->qff4MR[m].grad=qffPotParameters->qff4MR[m].energy;
			m++;
		}
	}
	qffPotentialData->qffPotParameters = qffPotParameters;
}
File: ./cchemilib/src/QFFPot/QFFPropertiesData.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* QFFProperties.c */
#include <math.h>
#include "../QFFPot/QFFModel.h"
#include "../Utils/Utils.h"
#include "../Utils/AtomsProp.h"
#include "../Utils/Constants.h"
#include "../Utils/QL.h"

//static boolean printMax = FALSE;

static void readData(QFFPropertiesData* qffPropertiesData, char* fileName);
static void convertToAU(QFFPropertiesData* qffPropertiesData);
static void convertToAU2(QFFPropertiesData* qffPropertiesData);
static void printData(QFFPropertiesData* qffPropertiesData);
static void freeQFFPropertiesData(QFFPropertiesData* qffPropertiesData);
/**********************************************************************/
static void freeQFFPropertiesData(QFFPropertiesData* qffPropertiesData)
{
	int nF = qffPropertiesData->nFrequencies;
	int nDim = qffPropertiesData->nDim;

	freeVectorDouble(&qffPropertiesData->zero);
	freeMatrixDouble(&qffPropertiesData->first, nDim);
	freeCubeDouble(&qffPropertiesData->second, nDim, nF);
	freeQuarticDouble(&qffPropertiesData->cubic, nDim, nF, nF);
}
/**********************************************************************/
/**********************************************************************/
/* PCCP, 2014, 16, 1759-1787, page 1763-4 */
/* CPL, 496 (2010) 157161 */
/**********************************************************************/
QFFPropertiesData newQFFPropertiesData(int nDim, int n)
{
	QFFPropertiesData qffPropertiesData;
	qffPropertiesData.klass = malloc(sizeof(QFFPropertiesDataClass));
	qffPropertiesData.klass->readData = readData;
	qffPropertiesData.klass->convertToAU = convertToAU;
	qffPropertiesData.klass->convertToAU2 = convertToAU2;
	qffPropertiesData.klass->free = freeQFFPropertiesData;
	qffPropertiesData.klass->print = printData;
	qffPropertiesData.nFrequencies = n;
	qffPropertiesData.nDim = nDim;
	if(qffPropertiesData.nFrequencies<=0) qffPropertiesData.nFrequencies = 0;
	if(qffPropertiesData.nDim<=0) qffPropertiesData.nDim = 0;
	if(qffPropertiesData.nDim>6) qffPropertiesData.nDim = 6;

	qffPropertiesData.first = NULL;
	qffPropertiesData.first = newMatrixDouble(qffPropertiesData.nDim,qffPropertiesData.nFrequencies);
	initMatrixDouble(qffPropertiesData.first, qffPropertiesData.nDim, qffPropertiesData.nFrequencies, 0.0);

        qffPropertiesData.zero = newVectorDouble(qffPropertiesData.nDim);
        initVectorDouble(qffPropertiesData.zero, qffPropertiesData.nDim, 0.0);

	qffPropertiesData.second = newCubeDouble(qffPropertiesData.nDim, qffPropertiesData.nFrequencies,qffPropertiesData.nFrequencies);
	initCubeDouble(qffPropertiesData.second, qffPropertiesData.nDim, qffPropertiesData.nFrequencies, qffPropertiesData.nFrequencies, 0.0);

	qffPropertiesData.cubic = newQuarticDouble(qffPropertiesData.nDim, qffPropertiesData.nFrequencies, qffPropertiesData.nFrequencies, qffPropertiesData.nFrequencies);
	initQuarticDouble(qffPropertiesData.cubic, qffPropertiesData.nDim, qffPropertiesData.nFrequencies, qffPropertiesData.nFrequencies, qffPropertiesData.nFrequencies, 0.0);
	return qffPropertiesData;
}
/*****************************************************************************/
static void printFirst(QFFPropertiesData* qffPropertiesData)
{
	printf("\nFirst derivatives\n");
	printMatrixDoubleCutOff(qffPropertiesData->first, qffPropertiesData->nDim, qffPropertiesData->nFrequencies, 1e-10);
	printf("END\n\n");
}
static void printSecond(QFFPropertiesData* qffPropertiesData)
{
	printf("\nSecond derivatives\n");
	printCubeDoubleCutOff(qffPropertiesData->second, qffPropertiesData->nDim, qffPropertiesData->nFrequencies, qffPropertiesData->nFrequencies,1e-10);
	printf("END\n\n");
}
static void printCubic(QFFPropertiesData* qffPropertiesData)
{
	printf("\nCubic derivatives\n");
	printQuarticDoubleCutOff(qffPropertiesData->cubic, qffPropertiesData->nDim, qffPropertiesData->nFrequencies, qffPropertiesData->nFrequencies, qffPropertiesData->nFrequencies,1e-10);
	printf("END\n\n");
}
static void printData(QFFPropertiesData* qffPropertiesData)
{
	printFirst(qffPropertiesData);
	printSecond(qffPropertiesData);
	printCubic(qffPropertiesData);
}
/*****************************************************************************/
static void convertToAU(QFFPropertiesData* qffPropertiesData)
{
	double conv = sqrt(1/AUTOCM1);
	double conv1 = conv;
	double conv2 = conv*conv;
	double conv3 = conv*conv*conv;
	int i,j,k,c;
	int nF =  qffPropertiesData->nFrequencies;

	for(i=0;i<nF;i++)
	for(c=0;c<3;c++) qffPropertiesData->first[c][i]*=conv1;

	for(i=0;i<nF;i++)
	for(j=0;j<nF;j++)
	for(c=0;c<3;c++) qffPropertiesData->second[c][i][j]*=conv2;

	for(i=0;i<nF;i++)
	for(j=0;j<nF;j++)
	for(k=0;k<nF;k++)
	for(c=0;c<3;c++) qffPropertiesData->cubic[c][i][j][k]*=conv3;

}
/*****************************************************************************/
static void convertToAU2(QFFPropertiesData* qffPropertiesData)
{
	double conv = sqrt(1/AUTOCM1);
	double conv1 = conv;
	double conv2 = conv*conv;
	double conv3 = conv*conv*conv;
       	double convAMUToAU = sqrt(AMUTOAU);
	int i,j,k,c;
	int nF =  qffPropertiesData->nFrequencies;

        conv1 *= convAMUToAU;
        conv2 *= convAMUToAU*convAMUToAU;
        conv3 *= convAMUToAU*convAMUToAU*convAMUToAU;

	for(i=0;i<nF;i++)
	for(c=0;c<3;c++) qffPropertiesData->first[c][i]*=conv1;

	for(i=0;i<nF;i++)
	for(j=0;j<nF;j++)
	for(c=0;c<3;c++) qffPropertiesData->second[c][i][j]*=conv2;

	for(i=0;i<nF;i++)
	for(j=0;j<nF;j++)
	for(k=0;k<nF;k++)
	for(c=0;c<3;c++) qffPropertiesData->cubic[c][i][j][k]*=conv3;

}
/*****************************************************************************/
static void readData(QFFPropertiesData* qffPropertiesData, char* inputFileName)
{
	FILE* inputFile;
        inputFile = fopen(inputFileName,"rb");
	if(!inputFile)
	{
		fprintf(stderr, "==========================================================\n");
		fprintf(stderr, "Sorry, I cannot opent the %s file\n", inputFileName);
		fprintf(stderr, "==========================================================\n");
		exit(1);
	}
	readOneInt(inputFile,"nFrequencies",&qffPropertiesData->nFrequencies);
//	fprintf(stdout, "nFrequencies=%d\n", qffPropertiesData->nFrequencies);
	readOneInt(inputFile,"nDim",&qffPropertiesData->nDim);
//	fprintf(stdout, "nDim=%d\n", qffPropertiesData->nDim);
	if(qffPropertiesData->nDim<=0)
	{
		fprintf(stderr, "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		fprintf(stderr, "I cannot read properties qffPropertiesData from input file : nDim=%d\n", qffPropertiesData->nDim);
		fprintf(stderr, "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n");
		exit(1);
	}
	*qffPropertiesData = newQFFPropertiesData(qffPropertiesData->nDim, qffPropertiesData->nFrequencies);

	readVectorReal(inputFile,"Zero",qffPropertiesData->nDim, qffPropertiesData->zero);
	readMatrixReal(inputFile,"First Derivatives",qffPropertiesData->nDim, qffPropertiesData->nFrequencies, qffPropertiesData->first);
	readCubeReal(inputFile,"Second Derivatives",qffPropertiesData->nDim, qffPropertiesData->nFrequencies, qffPropertiesData->nFrequencies, qffPropertiesData->second);
	readQuarticReal(inputFile,"Cubic Derivatives", qffPropertiesData->nDim, qffPropertiesData->nFrequencies, qffPropertiesData->nFrequencies, qffPropertiesData->nFrequencies, qffPropertiesData->cubic);

	//printData(qffPropertiesData);

}
File: ./cchemilib/src/QFFPot/QFFMD.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* QFFMD.c  */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <time.h>
#ifdef ENABLE_MPI
#include <mpi.h>
#endif

#include "../Utils/Utils.h"
#include "../Utils/AtomsProp.h"
#include "../Utils/Constants.h"
#include "../Utils/Types.h"
#include "../QFFPot/QFFModel.h"
#include "../QFFPot/QFFMD.h"


/*********************************************************************************/
static void initMD(QFFMD* molecularDynamics, double temperature, double stepSize, MDIntegratorType integratorType, MDThermostatType thermostat, double friction, double omegaMax, int Nf, double collide, double qNH, char* fileNameTraj, char* fileNameProp, int numberOfRunSteps, int index);
static void berendsen(QFFMD* molecularDynamics);
static void scaleV(QFFMD* molecularDynamics);
static void bussi(QFFMD* molecularDynamics);
static void andersen(QFFMD* molecularDynamics);
static void nose_hoover(QFFMD* molecularDynamics);
static void rescaleVelocities(QFFMD* molecularDynamics);
static void computeEnergies(QFFMD* molecularDynamics);
static void applyOneStep(QFFMD* molecularDynamics, int iStep);
static void applyThermostat(QFFMD* molecularDynamics);
static void applyVerlet(QFFMD* molecularDynamics);
static void applyBeeman(QFFMD* molecularDynamics);
static void applyStochastic(QFFMD* molecularDynamics);
static void applyQTB(QFFMD* molecularDynamics);
static void updateQTB(QFFMD* molecularDynamics);
static void resetQTB(QFFMD* molecularDynamics);
static void applyLangevin(QFFMD* molecularDynamics);
static void updateLangevin(QFFMD* molecularDynamics);
static void resetLangevin(QFFMD* molecularDynamics);
static void newProperties(QFFMD* molecularDynamics, char* comments);
static void saveProperties(QFFMD* molecularDynamics, int iStep0, int iStep, char* comments);
static void saveTrajectory(QFFMD* molecularDynamics, int iStep);
static double getEKin(QFFMD* molecularDynamics);
static double getKelvin(QFFMD* molecularDynamics);
/*****************************************************************************************************************/
static boolean createNewInputFile(QFFModel* qffModel,char* inputFileName, int iStep)
{
	char t[BSIZE];
	FILE* fileIn = NULL;
	FILE* fileOut = NULL;
	char* fileNameMD = NULL;
        char* suff = getSuffixNameFile(inputFileName);
        fileNameMD = strdup_printf("%s_%d.ici",suff, iStep);
        free(suff);
	fileIn = fopen(inputFileName,"rb");
	fileOut = fopen(fileNameMD,"w");
        free(fileNameMD);
	if(!fileIn) return FALSE;
	if(!fileOut) return FALSE;
	qffModel->klass->printModesAndVelocities(qffModel,fileOut);
	while(!feof(fileIn))
	{
	 	if(!fgets(t,BSIZE,fileIn)) break;
		deleteFirstSpaces(t);
		if(t[0]!='#' && mystrcasestr(t,"integrator"))
		{
			sprintf(t,"integrator = 0\n");
		}
		if(t[0]!='#' && mystrcasestr(t,"equiTime"))
		{
			sprintf(t,"equiTime = 0\n");
		}
		if(t[0]!='#' && mystrcasestr(t,"numberOfGeometries"))
		{
			sprintf(t,"#numberOfGeometries=10\n");
		}
		fprintf(fileOut,"%s",t);
	}
	fclose(fileIn);
	fclose(fileOut);
	return TRUE;
}
/*****************************************************************************************************************/
void	runQFFMD(
		QFFMD* molecularDynamics, QFFModel* qffModel, 
		int updateFrequency, 
		double heatTime, double equiTime, double runTime, double coolTime, 
		double heatTemperature, double equiTemperature, double runTemperature, double coolTemperature, 
		double stepSize,
		MDIntegratorType integratorType,
		MDThermostatType thermostat,
		double friction,
		double omegaMax,
		int Nf,
		double collide,
		double qNH,
		int numberOfGeometries,
		char* fileNameTraj,
		char* fileNameProp,
		char* inputFileName
		)
{
	int i;
	char* str = NULL;
        double gradientNorm = 0;
	int numberOfHeatSteps = 0;
	int numberOfEquiSteps = 0;
	int numberOfRunSteps = 0;
	int numberOfCoolSteps = 0;
	double currentTemp;
	int updateNumber = 0;
	int n0 = 0;
	double e0  = 0;
	double esum  = 0;
	double e2sum = 0;
	int iSel = 0;
	int stepSel = 1;
	FILE* logfile = stdout;
        char* suff = getSuffixNameFile(inputFileName);
	int j;
	/* 
	 *  physical constants in SI units
	 *   ------------------------------
	 *      Kb = 1.380662 E-23 J/K
	 *      Na = 6.022045 E23  1/mol
	 *      e = 1.6021892 E-19 C
	 *      eps = 8.85418782 E-12 F/m
	 *                       
	 *      1 Kcal = 4184.0 J
	 *      1 amu = 1.6605655 E-27 Kg
	 *      1 A = 1.0 E-10 m
	 *                                       
	 *       Internally, Atomic units are used:
	 *                                        
	*/ 

	/* fprintf(logfile,"basname = %s\n",g_path_get_basename(fileNameTraj));*/

	if(qffModel->molecule.nAtoms<1) return;

	molecularDynamics->qffModel = qffModel;
	molecularDynamics->numberOfModes = qffModel->vData.nFrequencies;
	molecularDynamics->updateFrequency = updateFrequency;

	currentTemp = heatTemperature/2;
	
	numberOfHeatSteps = heatTime/stepSize*1000;
	numberOfEquiSteps = equiTime/stepSize*1000;; 
	numberOfRunSteps = runTime/stepSize*1000;; 
	numberOfCoolSteps = coolTime/stepSize*1000;;

	if(numberOfGeometries>2) stepSel = numberOfRunSteps/(numberOfGeometries-1)+1;
        else stepSel = numberOfRunSteps;



	currentTemp = heatTemperature;
	if(numberOfHeatSteps==0) currentTemp = equiTemperature; 
	if(numberOfHeatSteps==0 && numberOfEquiSteps==0 ) currentTemp = runTemperature; 
	if(numberOfHeatSteps==0 && numberOfEquiSteps==0 && numberOfRunSteps==0 ) currentTemp = coolTemperature; 

	initMD(molecularDynamics,currentTemp,stepSize,integratorType, thermostat, friction, omegaMax, Nf, collide, qNH, fileNameTraj, fileNameProp, numberOfRunSteps,0);
	molecularDynamics->qffModel->klass->calculateGradient(molecularDynamics->qffModel);

	molecularDynamics->temperature = heatTemperature;
	if( numberOfHeatSteps>0) rescaleVelocities(molecularDynamics);

	computeEnergies(molecularDynamics);
	//e0 = molecularDynamics->potentialEnergy;
	e0 = 0; // Qi=0;
	fprintf(logfile,"E0 = The first potential energy in AU = %f\n",e0); 
	if( numberOfHeatSteps>0) molecularDynamics->qffModel->klass->printModesAndVelocities(molecularDynamics->qffModel,stdout);



	currentTemp = heatTemperature;
	n0 = 0;
	newProperties(molecularDynamics," ");
	/*newProperties(molecularDynamics," ----> Heating");*/
	for (i = 0; i < numberOfHeatSteps; i++ )
	{
		molecularDynamics->temperature = currentTemp;
		applyOneStep(molecularDynamics,i);
		currentTemp = heatTemperature + ( runTemperature - heatTemperature ) *
				( ( double )( i + 1 )/ numberOfHeatSteps );
		molecularDynamics->temperature = currentTemp;
		rescaleVelocities(molecularDynamics);
		if (++updateNumber >= molecularDynamics->updateFrequency )
		{
			if(str) free(str);
			str = strdup_printf(("MD Heating: %0.2f fs, T = %0.2f K T(t) = %0.2f Kin = %0.4f Pot =  %0.4f Tot =  %0.4f"), 
					i*stepSize, 
					molecularDynamics->temperature, 
					molecularDynamics->kelvin, 
					molecularDynamics->kineticEnergy,
					molecularDynamics->potentialEnergy,
					molecularDynamics->totalEnergy
					);
			//redrawMolecule(&molecularDynamics->qffModel->molecule,str);
			fprintf(logfile,"%s\n",str);
			updateNumber = 0;
		}
		saveProperties(molecularDynamics, n0+i+1, i+1," Heating");
	}

	currentTemp = equiTemperature;
	molecularDynamics->temperature = currentTemp;
	if( numberOfHeatSteps>0) rescaleVelocities(molecularDynamics);
	updateNumber = molecularDynamics->updateFrequency;
	n0 += numberOfHeatSteps;
	/* newProperties(molecularDynamics," ----> Equilibrium");*/
	if(numberOfEquiSteps>0) molecularDynamics->qffModel->klass->printModesAndVelocities(molecularDynamics->qffModel,stdout);
	for (i = 0; i < numberOfEquiSteps; i++ )
	{
		molecularDynamics->temperature = currentTemp;
		applyOneStep(molecularDynamics,i);
		molecularDynamics->temperature = currentTemp;
		applyThermostat(molecularDynamics);
		if (++updateNumber >= molecularDynamics->updateFrequency )
		{
			if(str) free(str);
			str = strdup_printf(("MD Equilibrium: %0.2f fs, T = %0.2f K  T(t) = %0.2f K Kin = %0.4f Pot =  %0.4f Tot =  %0.4f"), 
					i*stepSize, 
					molecularDynamics->temperature, 
					molecularDynamics->kelvin, 
					molecularDynamics->kineticEnergy,
					molecularDynamics->potentialEnergy,
					molecularDynamics->totalEnergy
					);
			//redrawMolecule(&molecularDynamics->qffModel->molecule,str);
			fprintf(logfile,"%s\n",str);
			updateNumber = 0;
		}
		saveProperties(molecularDynamics, n0+i+1, i+1, " Equilibrium");
	}
	updateNumber = molecularDynamics->updateFrequency;

	currentTemp = runTemperature;
	molecularDynamics->temperature = currentTemp;
	/* rescaleVelocities(molecularDynamics);*/
	updateNumber = molecularDynamics->updateFrequency;
	n0 += numberOfEquiSteps;
	/* newProperties(molecularDynamics," ----> Runing");*/
	iSel = -1;
	if(numberOfGeometries>0)
	{
		iSel++;
		for(j=0;j<146;j++) fprintf(logfile,"-"); fprintf(logfile,"\n");
		if(str) free(str);
		str = strdup_printf("Geometry selected Potential energy(kcal) =  %0.4 f; File %s_%d.ici created ", molecularDynamics->potentialEnergy,suff,iSel);
		fprintf(logfile,"%s\n",str);
		fflush(logfile);
		for(j=0;j<146;j++) fprintf(logfile,"-"); fprintf(logfile,"\n");
		createNewInputFile(molecularDynamics->qffModel,inputFileName, iSel);
		// save cchemi file for iSel
	}
	esum  = 0;
	e2sum = 0;
	if(numberOfRunSteps>0) molecularDynamics->qffModel->klass->printModesAndVelocities(molecularDynamics->qffModel,stdout);
	for (i = 0; i < numberOfRunSteps; i++ )
	{
		molecularDynamics->temperature = currentTemp;
		applyOneStep(molecularDynamics,i);
		applyThermostat(molecularDynamics);
		esum  += molecularDynamics->totalEnergy;
		e2sum += molecularDynamics->totalEnergy*molecularDynamics->totalEnergy;
		if (++updateNumber >= molecularDynamics->updateFrequency )
		{
			if(str) free(str);
			str = strdup_printf(("MD Running: %0.2f fs, T = %0.2f K  T(t) = %8.2f K Kin = %0.4f Pot =  %0.4f Tot =  %0.4f Eav = %0.4f sigE = %0.4f Eav-E0(cm^-1) = %0.2f"), 
					i*stepSize, 
					molecularDynamics->temperature, 
					molecularDynamics->kelvin, 
					molecularDynamics->kineticEnergy,
					molecularDynamics->potentialEnergy,
					molecularDynamics->totalEnergy,
					esum/(i+1),
					sqrt(fabs(e2sum/(i+1)-esum/(i+1)*esum/(i+1))),
					(esum/(i+1)-e0)*349.75511054
					);
			//redrawMolecule(&molecularDynamics->qffModel->molecule,str);
			fprintf(logfile,"%s\n",str);
			updateNumber = 0;
			saveTrajectory(molecularDynamics, i+1);
		}
		if(numberOfGeometries>0 && (i+1)%stepSel==0 && (iSel+1)<numberOfGeometries)
                {
			iSel++;
			for(j=0;j<146;j++) fprintf(logfile,"-"); fprintf(logfile,"\n");
			if(str) free(str);
			str = strdup_printf("Geometry selected Potential energy(kcal) =  %0.4 f; File %s_%d.ici created ", molecularDynamics->potentialEnergy,suff,iSel);
			fprintf(logfile,"%s\n",str);
			fflush(logfile);
			for(j=0;j<146;j++) fprintf(logfile,"-"); fprintf(logfile,"\n");
			createNewInputFile(molecularDynamics->qffModel,inputFileName, iSel);
		// save cchemi file for iSel
                }

		saveProperties(molecularDynamics, n0+i+1, i+1," Running");
	}
	if(numberOfGeometries>0 && (iSel+1)<numberOfGeometries)
	{
		iSel++;
		for(j=0;j<146;j++) fprintf(logfile,"-"); fprintf(logfile,"\n");
		if(str) free(str);
		str = strdup_printf("Geometry selected Potential energy(kcal) =  %0.4 f; File %s_%d.ici created ", molecularDynamics->potentialEnergy,suff,iSel);
		fprintf(logfile,"%s\n",str);
		fflush(logfile);
		for(j=0;j<146;j++) fprintf(logfile,"-"); fprintf(logfile,"\n");
		createNewInputFile(molecularDynamics->qffModel,inputFileName, iSel);
	// save cchemi file for iSel
	}
	if(numberOfCoolSteps>0) molecularDynamics->qffModel->klass->printModesAndVelocities(molecularDynamics->qffModel,stdout);
	updateNumber = molecularDynamics->updateFrequency;
	n0 += numberOfRunSteps;
	/* newProperties(molecularDynamics," ----> Cooling");*/
	for (i = 0; i < numberOfCoolSteps; i++ )
	{
		currentTemp = runTemperature - ( runTemperature - coolTemperature ) * 
				( ( double )( i + 1 )/ numberOfCoolSteps );
		molecularDynamics->temperature = currentTemp;
		rescaleVelocities(molecularDynamics);
		molecularDynamics->temperature = currentTemp;
		applyOneStep(molecularDynamics,i);
		if (++updateNumber >= molecularDynamics->updateFrequency )
		{
			if(str) free(str);
			str = strdup_printf(("MD Cooling: %0.2f fs, T = %0.2f K T(t) = %0.2f K Kin = %0.4f Pot =  %0.4f Tot =  %0.4f"), 
					i*stepSize, 
					molecularDynamics->temperature, 
					molecularDynamics->kelvin, 
					molecularDynamics->kineticEnergy,
					molecularDynamics->potentialEnergy,
					molecularDynamics->totalEnergy
					);
			//redrawMolecule(&molecularDynamics->qffModel->molecule,str);
			fprintf(logfile,"%s\n",str);
			updateNumber = 0;
		}
		saveProperties(molecularDynamics, n0+i+1, i+1," Cooling");
	}
	molecularDynamics->qffModel->klass->calculateGradient(molecularDynamics->qffModel);
        gradientNorm = 0;
	for (i = 0; i < molecularDynamics->numberOfModes; i++)
                        gradientNorm += 
				molecularDynamics->qffModel->gradQ[i] * 
				molecularDynamics->qffModel->gradQ[i]; 

        gradientNorm = sqrt( gradientNorm );
	if(str) free(str);
	str = strdup_printf(("End of MD Simulation. Gradient = %f Ekin = %f (Kcal/mol) EPot =  %0.4f ETot =  %0.4f T(t) = %0.2f"),
			(double)gradientNorm*AUTOKCAL,
			molecularDynamics->kineticEnergy,
			molecularDynamics->potentialEnergy,
			molecularDynamics->totalEnergy,
			molecularDynamics->kelvin 
			); 
	//redrawMolecule(&molecularDynamics->qffModel->molecule,str);
	fprintf(logfile,"%s\n",str);
	if(numberOfGeometries>0)
        {
        	char* suff = getSuffixNameFile(inputFileName);
		for(i=0;i<146;i++) fprintf(logfile,"="); fprintf(logfile,"\n");
		if(str) free(str);
		str = strdup_printf("See %s_*.ici created files",suff);
		free(suff);
		fprintf(logfile,"%s\n",str);
		for(i=0;i<146;i++) fprintf(logfile,"="); fprintf(logfile,"\n");
	
	}
	free(str);
	free(suff);
	molecularDynamics->qffModel->klass->printModesAndVelocities(molecularDynamics->qffModel,stdout);
	if(molecularDynamics->fileTraj)fclose(molecularDynamics->fileTraj);
	if(molecularDynamics->fileProp)fclose(molecularDynamics->fileProp);
	freeQFFMD(molecularDynamics);
}
/*********************************************************************************/
static void initNH(QFFMD* molecularDynamics, double qNH)
{
	int i;

	if(molecularDynamics->thermostat != NOSEHOOVER) return;
	for(i=0;i<MAXNH;i++)
	{
		molecularDynamics->xNH[i] = 0;
		molecularDynamics->vNH[i] = 0;
		molecularDynamics->qNH[i] = qNH;
		molecularDynamics->gNH[i] = 0;
	}
}
/*********************************************************************************/
static void initSD(QFFMD* molecularDynamics, double friction)
{
	if(friction<0) friction = 40;
	molecularDynamics->friction = friction/(fsInAU)/1000;

	molecularDynamics->positionFriction = NULL;
	molecularDynamics->velocityFriction = NULL;
	molecularDynamics->accelarationFriction = NULL;
	molecularDynamics->gamma = NULL;
	molecularDynamics->positionRandom = NULL;
	molecularDynamics->velocityRandom = NULL;

	if(molecularDynamics->integratorType != STOCHASTIC) return;

	molecularDynamics->positionFriction = malloc(molecularDynamics->numberOfModes *sizeof(double)); 
	molecularDynamics->velocityFriction = malloc(molecularDynamics->numberOfModes *sizeof(double)); 
	molecularDynamics->accelarationFriction = malloc(molecularDynamics->numberOfModes *sizeof(double)); 
	molecularDynamics->gamma = malloc(molecularDynamics->numberOfModes *sizeof(double)); 

	molecularDynamics->positionRandom = malloc(molecularDynamics->numberOfModes *sizeof(double)); 

	molecularDynamics->velocityRandom = malloc(molecularDynamics->numberOfModes *sizeof(double)); 

}
/*********************************************************************************/
static void compteThetaQTB(QFFMD* molecularDynamics)
{
	//double sigma=sqrt(2.*molecularDynamics->friction*KbInAU*molecularDynamics->temperature/molecularDynamics->h);
	double sigma=sqrt(6.*molecularDynamics->friction*KbInAU*molecularDynamics->temperature/molecularDynamics->h);
	int i,k;

	/* thetaProg = thetaPaper*sigma/sqrt(m) */
	for(i=0;i<molecularDynamics->numberOfModes;i++)
	{
		double mass = 1.0; // Mass-weigted normal coordinates
		//mass = molecularDynamics->qffModel->vData.effectiveMasses[i]*AMUTOAU; // to be use with convertTOAU2
		//mass = molecularDynamics->qffModel->vData.effectiveMasses[i]; 
		molecularDynamics->theta[i] = 0.0;
		for(k=0;k<2*molecularDynamics->Nf;k++)
			molecularDynamics->theta[i] += molecularDynamics->rnoise[i][2*molecularDynamics->Nf-1-k]*molecularDynamics->Ht[k];
		molecularDynamics->theta[i] *= sigma/sqrt(mass);
	}
}
/*********************************************************************************/
static void resetQTB(QFFMD* molecularDynamics)
{
	double* Filter = NULL;
	int k;
	double hbarwOverkT;
	double hbardwOverkT;
	int i,j;
	double T;
	

	if(molecularDynamics->integratorType != QTB) return;
	T = molecularDynamics->temperature;
	if(T<=0) return;

	/* computing of Filter */
	/* Htild/sqrt(kT), sqrt(kT) in sigma */
	Filter = malloc((2*molecularDynamics->Nf)*sizeof(double)); 
	/* h dOmega = pi /Nf */
	hbardwOverkT = 1.0/(molecularDynamics->Nf*molecularDynamics->h*KbInAU*T);
	for(k=0;k<2*molecularDynamics->Nf;k++)
	{
		int kk= k-molecularDynamics->Nf;
		if(kk==0) Filter[k] = 1.0;
		else
		{
			hbarwOverkT = fabs(kk)*hbardwOverkT;
			Filter[k] = sqrt(hbarwOverkT*(0.5+1./(exp(hbarwOverkT)-1.0)));
			//Filter[k] = 1.0; // to test classic
			Filter[k] *= (kk*M_PI/molecularDynamics->Nf/2)/sin(kk*M_PI/molecularDynamics->Nf/2);
		}
	}
	/* compute Ht */
	for(j=0;j<2*molecularDynamics->Nf;j++)
	{
                molecularDynamics->Ht[j] = 0;
		for(k=0; k<2*molecularDynamics->Nf;k++)
                	molecularDynamics->Ht[j] += Filter[k]*cos(M_PI*(k-molecularDynamics->Nf)*(j-molecularDynamics->Nf)*1.0/molecularDynamics->Nf);
		
               	molecularDynamics->Ht[j] /= 2*molecularDynamics->Nf;
	}
	free(Filter);
	
	for(i=0;i<molecularDynamics->numberOfModes;i++)
	for(k=0;k<2*molecularDynamics->Nf;k++)
		 molecularDynamics->rnoise[i][k] = normal();/* sqrt(h) is in sigma */

	compteThetaQTB(molecularDynamics);

}
/*********************************************************************************/
/* omegaMax in cm-1 */
static void initQTB(QFFMD* molecularDynamics, double omegaMax, double friction, int Nf)
{
/* Refs 
Jean-Louis Barrat , David Rodney
Portable implementation of a quantum thermal bath for molecular dynamics simulations
JOURNAL OF STATISTICAL PHYSICS 670, 144, (2011)
*/
	static double cmM1fsM1 = 2.99792458e-5;
	double Omegafs = omegaMax*cmM1fsM1;/* fs^-1 */ 
	int i;
	
	//printf("==========> dt(fs)\t\t= %f\n",molecularDynamics->dt/fsInAU);

	if(Nf<1) Nf = 50;

	molecularDynamics->Ht = NULL;
	molecularDynamics->theta = NULL;
	molecularDynamics->rnoise = NULL;
	molecularDynamics->Nf = 0;
	molecularDynamics->M = 0;

	if(molecularDynamics->integratorType != QTB) return;

	molecularDynamics->Nf = Nf;
	molecularDynamics->h = 1/Omegafs*(fsInAU);
	molecularDynamics->M = (int)(molecularDynamics->h/molecularDynamics->dt);
	if(molecularDynamics->M<1) molecularDynamics->M = 1;
	molecularDynamics->h = molecularDynamics->M *molecularDynamics->dt;
	omegaMax = 1.0/molecularDynamics->h*(fsInAU)/cmM1fsM1; /* cm-1 */
	if(friction<0) molecularDynamics->friction = (1.0/ molecularDynamics->h)/50;
	else molecularDynamics->friction = friction/1000.0/(fsInAU);

	molecularDynamics->Ht = malloc((2*Nf)*sizeof(double)); 
	molecularDynamics->theta = malloc(molecularDynamics->numberOfModes *sizeof(double)); 
	molecularDynamics->rnoise = malloc(molecularDynamics->numberOfModes *sizeof(double*)); 
	for(i=0;i<molecularDynamics->numberOfModes;i++)
		molecularDynamics->rnoise[i] = malloc((2*Nf)*sizeof(double)); 
	

	printf("\n");
	printf("*************** QTB Parameters ******************************************************************\n");
	printf("Nf\t\t= %d\n",molecularDynamics->Nf);
	printf("M\t\t= %d\n",molecularDynamics->M);
	printf("dt(fs)\t\t= %f\n",molecularDynamics->dt/(fsInAU));
	printf("h(fs)\t\t= %f\n",molecularDynamics->h/(fsInAU));
	printf("gamma(ps^-1)\t= %f\n",molecularDynamics->friction*fsInAU*1000);
	printf("omegaMax(cm^-1)\t= %f\n",omegaMax);
	printf("*************************************************************************************************\n");
	printf("\n");

	resetQTB(molecularDynamics);

}
/*********************************************************************************/
static void updateQTB(QFFMD* molecularDynamics)
{
	int i,k;

	if(molecularDynamics->temperature<=0) return;
	compteThetaQTB(molecularDynamics);
	/* shift rnoise */
	for(i=0;i<molecularDynamics->numberOfModes;i++)
	for(k=0;k<2*molecularDynamics->Nf-1;k++)
		 molecularDynamics->rnoise[i][k] = molecularDynamics->rnoise[i][k+1];

	/* add one value to the end */
	for(i=0;i<molecularDynamics->numberOfModes;i++)
		 molecularDynamics->rnoise[i][2*molecularDynamics->Nf-1] = normal(); /* sqrt(h) in sigma */

}
/*********************************************************************************/
static void resetLangevin(QFFMD* molecularDynamics)
{
	if(molecularDynamics->integratorType != LANGEVIN) return;
	updateLangevin(molecularDynamics);
}
/*********************************************************************************/
/* omegaMax in cm-1 */
static void initLangevin(QFFMD* molecularDynamics, double friction)
{
	if(molecularDynamics->integratorType != LANGEVIN) return;

	if(friction<0) friction = 40;
	molecularDynamics->friction = friction/1000/(fsInAU);
	molecularDynamics->theta = malloc(3*molecularDynamics->numberOfModes *sizeof(double)); 
	
	printf("\n");
	printf("*************** Langevin Parameters ******************************************************************\n");
	printf("dt(fs)\t\t= %f\n",molecularDynamics->dt/(fsInAU));
	printf("gamma(ps^-1)\t= %f\n",molecularDynamics->friction*fsInAU*1000);
	printf("*************************************************************************************************\n");
	printf("\n");

	resetLangevin(molecularDynamics);

}
/*********************************************************************************/
static void updateLangevin(QFFMD* molecularDynamics)
{
	int i;
	double sigma;
	/* update theta */
	/* thetaProg = thetaPaper*sigma/sqrt(m) */
	if(molecularDynamics->integratorType != LANGEVIN) return;
	sigma=sqrt(6.*molecularDynamics->friction*KbInAU*molecularDynamics->temperature/molecularDynamics->dt);
	for(i=0;i<molecularDynamics->numberOfModes;i++)
	{
		double mass = 1.0; // Mass-weigted normal coordinates
		//mass = molecularDynamics->qffModel->vData.effectiveMasses[i]*AMUTOAU;
		//mass = molecularDynamics->qffModel->vData.effectiveMasses[i];
		molecularDynamics->theta[i] = normal();
		molecularDynamics->theta[i] *= sigma/sqrt(mass);
	}
}
/*********************************************************************************/
static void initMD(QFFMD* molecularDynamics, double temperature, double stepSize, MDIntegratorType integratorType, MDThermostatType thermostat, double friction, double omegaMax, int Nf, double collide, double qNH, char* fileNameTraj, char* fileNameProp, int numberOfRunSteps, int index)
{
	int i;
	double dt = stepSize * fsInAU;

	//printf("----------> stepSize(fs)\t\t= %f\n",stepSize);
	//printf("----------> dt(fs)\t\t= %f\n",dt/fsInAU);

	molecularDynamics->collide = collide;
	molecularDynamics->potentialEnergy = 0;
	molecularDynamics->kineticEnergy = 0;
	molecularDynamics->totalEnergy = 0;
	molecularDynamics->kelvin = 0;
	molecularDynamics->temperature = temperature;
	molecularDynamics->thermostat = NONE;

	molecularDynamics->integratorType = integratorType;
	molecularDynamics->thermostat = thermostat;
	molecularDynamics->fileTraj = NULL;
	molecularDynamics->fileProp = NULL;
	molecularDynamics->index = index;

	molecularDynamics->nFree = molecularDynamics->numberOfModes;
	for(i=0;i<molecularDynamics->numberOfModes;i++) if(!molecularDynamics->qffModel->variable[i]) molecularDynamics->nFree--;

	molecularDynamics->a = malloc(molecularDynamics->numberOfModes *sizeof(double)); 

	molecularDynamics->aold = NULL;
	if(molecularDynamics->integratorType==BEEMAN)
	{
		molecularDynamics->aold = malloc(molecularDynamics->numberOfModes *sizeof(double)); 
	}
	molecularDynamics->coordinatesOld = NULL;
	molecularDynamics->moved = NULL;
	molecularDynamics->update = NULL;
	if(molecularDynamics->qffModel->molecule.constraints!=NOCONSTRAINTS)
	{
		molecularDynamics->coordinatesOld = malloc(molecularDynamics->numberOfModes *sizeof(double)); 
		molecularDynamics->moved = malloc(molecularDynamics->numberOfModes *sizeof(boolean)); 
		molecularDynamics->update = malloc(molecularDynamics->numberOfModes *sizeof(boolean)); 

	}
	if(fileNameTraj)
	{
 		molecularDynamics->fileTraj = fopen(fileNameTraj, "w");
		if(molecularDynamics->fileTraj != NULL)
		{
			fprintf(molecularDynamics->fileTraj,"[Gabedit Format]\n");
			fprintf(molecularDynamics->fileTraj,"\n");
			fprintf(molecularDynamics->fileTraj,"[MD]\n");
			if(molecularDynamics->updateFrequency>0) numberOfRunSteps/=molecularDynamics->updateFrequency;
			fprintf(molecularDynamics->fileTraj," %d\n",numberOfRunSteps);
		}
	}
	if(fileNameProp)
	{
 		molecularDynamics->fileProp = fopen(fileNameProp, "w");
	}

	/* srand ( (unsigned)time (NULL));*/
	
	molecularDynamics->dt = dt;
	molecularDynamics->dt_2 = dt/2.0;
	molecularDynamics->dt_4 = dt/4.0;
	molecularDynamics->dt2_2 = dt*dt/2;;
	molecularDynamics->dt_8 = dt/8.0;
	molecularDynamics->dt2_8 = dt*dt/8.0;

	initSD(molecularDynamics, friction);
	initNH(molecularDynamics,qNH);
	initQTB(molecularDynamics,omegaMax, friction, Nf);
	initLangevin(molecularDynamics,friction);


	molecularDynamics->qffModel->klass->calculateGradient(molecularDynamics->qffModel);
	for ( i = 0; i < molecularDynamics->numberOfModes; i++)
	{
		double mass = 1.0; // Mass-weigted normal coordinates
		//mass = molecularDynamics->qffModel->vData.effectiveMasses[i]*AMUTOAU;
		//mass = molecularDynamics->qffModel->vData.effectiveMasses[i];
		molecularDynamics->a[i] = -molecularDynamics->qffModel->gradQ[i]/mass;
		if(molecularDynamics->aold) molecularDynamics->aold[i]  = molecularDynamics->a[i];
	}
	if(molecularDynamics->qffModel->klass->setMaxwellVelocitiesIfNull(molecularDynamics->qffModel, temperature)) rescaleVelocities(molecularDynamics);
#ifdef DEBUG
	printf("nfree =%d\n",molecularDynamics->nFree);
#endif
}
/*********************************************************************************/
static void rescaleVelocities(QFFMD* molecularDynamics)
{
	/* berendsen(molecularDynamics);*/
	scaleV(molecularDynamics);
	resetQTB(molecularDynamics);
	resetLangevin(molecularDynamics);
}
/*********************************************************************************/
static void scaleV(QFFMD* molecularDynamics)
{
	int i;
	double ekin = 0;
	double kelvin = 0;
	int nfree = molecularDynamics->nFree;
	double scale = 1.0;
	if(molecularDynamics->temperature<=0) return;
	if(nfree<1) return;
	for ( i = 0; i < molecularDynamics->numberOfModes; i++)
	{
		double mass = 1.0; // Mass-weigted normal coordinates
		//mass = molecularDynamics->qffModel->vData.effectiveMasses[i]*AMUTOAU;
		//mass = molecularDynamics->qffModel->vData.effectiveMasses[i];
		ekin += molecularDynamics->qffModel->velocity[i]*molecularDynamics->qffModel->velocity[i]*mass;
	}
	/*
	ekin /= 2;
	kelvin = 2* ekin / ( nfree * KbInAU);
	*/
	kelvin = ekin / ( nfree * KbInAU);
	scale = sqrt(molecularDynamics->temperature/kelvin);
#ifdef DEBUG
	printf("temp = %f kelvin = %f scale = %f\n",molecularDynamics->temperature, kelvin, scale);
#endif
	for ( i = 0; i < molecularDynamics->numberOfModes; i++)
		if(molecularDynamics->qffModel->variable[i])
			molecularDynamics->qffModel->velocity[i] *= scale;
}
/*********************************************************************************/
static void berendsen(QFFMD* molecularDynamics)
{
	int i;
	double ekin = 0;
	double kelvin = 0;
	int nfree = molecularDynamics->nFree;
	double scale = 1.0;
	double dt = molecularDynamics->dt;
	double tautemp = 1.0/(molecularDynamics->collide)*1000*fsInAU;
	if(molecularDynamics->temperature<=0) return;
	if(nfree<1) return;
	for ( i = 0; i < molecularDynamics->numberOfModes; i++)
	{
		double mass = 1.0; // Mass-weigted normal coordinates
		//mass = molecularDynamics->qffModel->vData.effectiveMasses[i]*AMUTOAU;
		//mass = molecularDynamics->qffModel->vData.effectiveMasses[i];
		ekin += molecularDynamics->qffModel->velocity[i]*molecularDynamics->qffModel->velocity[i]*mass;
	}
	/*
	ekin /= 2;
	kelvin = 2* ekin / ( nfree * KbInAU);
	*/
	kelvin = ekin / ( nfree * KbInAU);
	/* if(tautemp>dt) tautemp = dt;*/
	scale = sqrt(1.0 + (dt/tautemp)*(molecularDynamics->temperature/kelvin-1.0));
#ifdef DEBUG
	printf("temp = %f kelvin = %f scale = %f\n",molecularDynamics->temperature, kelvin, scale);
#endif
	for ( i = 0; i < molecularDynamics->numberOfModes; i++)
		if(molecularDynamics->qffModel->variable[i])
			molecularDynamics->qffModel->velocity[i] *= scale;
}
/*********************************************************************************/
static void andersen(QFFMD* molecularDynamics)
{
	int i;
	double tau = 1.0/molecularDynamics->collide*1000*fsInAU; /* in fs */
	double rate;
	if(molecularDynamics->temperature<=0) return;
	if(molecularDynamics->numberOfModes<1) return;

	rate = molecularDynamics->dt / tau;
	rate /= pow(molecularDynamics->nvariables,2.0/3.0);

	for ( i = 0; i < molecularDynamics->numberOfModes; i++)
	{
		double trial = drandom();
		double mass = 1.0;
		//mass = molecularDynamics->qffModel->vData.effectiveMasses[i]*AMUTOAU;
		//mass = molecularDynamics->qffModel->vData.effectiveMasses[i];
		if(trial<rate)
		{
			double speed = sqrt(KbInAU* molecularDynamics->temperature/mass);
                	double pnorm = normal();
			molecularDynamics->qffModel->velocity[i] = pnorm*speed;
		}
	}
}
/*********************************************************************************/
static void bussi(QFFMD* molecularDynamics)
{
	int nfree = molecularDynamics->nFree;
	double scale = 1.0;
	double dt = molecularDynamics->dt;
	double tautemp = 1.0/(molecularDynamics->collide)*1000*fsInAU;
        double c = exp(-dt/tautemp);
	double ekin = getEKin(molecularDynamics);
	double kelvin = 2*ekin / ( nfree * KbInAU);
	double d = (1.0-c) * (molecularDynamics->temperature/kelvin) / (nfree);
	double r = normal ();
	double si = 0.0;
	double s = 0.0;
	int i;
	if(molecularDynamics->temperature<=0) return;
	if(nfree<1) return;
        for(i=0;i<nfree-1;i++)
	{
            si = normal ();
            s += si*si;
	}
	scale = c + (s+r*r)*d + 2.0*r*sqrt(c*d);
	scale = sqrt(scale);
	if (r+sqrt(c/d)<0)  scale = -scale;
	for ( i = 0; i < molecularDynamics->numberOfModes; i++)
		if(molecularDynamics->qffModel->variable[i])
			molecularDynamics->qffModel->velocity[i] *= scale;
}
/*********************************************************************************/
static void nose_hoover(QFFMD* molecularDynamics)
{
	int nfree = molecularDynamics->nFree;
	double scale = 1.0;
	double ekin = getEKin(molecularDynamics);
	double kT = KbInAU* molecularDynamics->temperature;
	int i;
	if(molecularDynamics->temperature<=0) return;
	if(nfree<1) return;
	molecularDynamics->gNH[1] = (molecularDynamics->qNH[0]*molecularDynamics->vNH[0]*molecularDynamics->vNH[0]-kT) / molecularDynamics->qNH[1];
	//printf("gNH = %f\n",molecularDynamics->gNH[1]);
	molecularDynamics->vNH[1] = molecularDynamics->vNH[1] + molecularDynamics->gNH[1]*molecularDynamics->dt_4;
	molecularDynamics->vNH[0] = molecularDynamics->vNH[0] * exp(-molecularDynamics->vNH[1]*molecularDynamics->dt_8);
	molecularDynamics->gNH[0] = (2.0*ekin-molecularDynamics->nFree*kT) / molecularDynamics->qNH[0];
	molecularDynamics->vNH[0] = molecularDynamics->vNH[0] + molecularDynamics->gNH[0]*molecularDynamics->dt_4;
	molecularDynamics->vNH[0] = molecularDynamics->vNH[0] * exp(-molecularDynamics->vNH[1]*molecularDynamics->dt_8);
	molecularDynamics->xNH[0] = molecularDynamics->xNH[0] + molecularDynamics->vNH[0]*molecularDynamics->dt_2;
	molecularDynamics->xNH[1] = molecularDynamics->xNH[1] + molecularDynamics->vNH[1]*molecularDynamics->dt_2;
	//printf("vnH0 = %f\n",molecularDynamics->vNH[0]);
	scale = exp(-molecularDynamics->vNH[0]*molecularDynamics->dt_2);
	//printf("scale = %f\n",scale);
	for ( i = 0; i < molecularDynamics->numberOfModes; i++)
			molecularDynamics->qffModel->velocity[i] *= scale;
	ekin = ekin * scale * scale;
	molecularDynamics->vNH[0] = molecularDynamics->vNH[0] * exp(-molecularDynamics->vNH[1]*molecularDynamics->dt_8);
	molecularDynamics->gNH[0] = (2.0*ekin-nfree*kT) /  molecularDynamics->qNH[0];
	molecularDynamics->vNH[0] = molecularDynamics->vNH[0] + molecularDynamics->gNH[0]*molecularDynamics->dt_4;
	molecularDynamics->vNH[0] = molecularDynamics->vNH[0] * exp(-molecularDynamics->vNH[1]*molecularDynamics->dt_8);
	molecularDynamics->gNH[1] = ( molecularDynamics->qNH[0]*molecularDynamics->vNH[0]*molecularDynamics->vNH[0]-kT) /  molecularDynamics->qNH[1];
	molecularDynamics->vNH[1] = molecularDynamics->vNH[1] + molecularDynamics->gNH[1]*molecularDynamics->dt_4;

}
/*********************************************************************************/
static void newAccelaration(QFFMD* molecularDynamics)
{
	int i;
	molecularDynamics->qffModel->klass->calculateGradient(molecularDynamics->qffModel);
	for ( i = 0; i < molecularDynamics->numberOfModes; i++)
	{
		double mass =  1.0;
		//mass = molecularDynamics->qffModel->vData.effectiveMasses[i]*AMUTOAU;
		//mass = molecularDynamics->qffModel->vData.effectiveMasses[i];
		if(molecularDynamics->aold)
				molecularDynamics->aold[i]  = molecularDynamics->a[i];

			molecularDynamics->a[i] = -molecularDynamics->qffModel->gradQ[i]/mass;
	}
}
/*********************************************************************************/
static void computeEnergies(QFFMD* molecularDynamics)
{
	molecularDynamics->kineticEnergy = getEKin(molecularDynamics);
	molecularDynamics->potentialEnergy = molecularDynamics->qffModel->molecule.potentialEnergy;
	molecularDynamics->totalEnergy = molecularDynamics->kineticEnergy + molecularDynamics->potentialEnergy;
	molecularDynamics->kelvin = getKelvin(molecularDynamics);

/* convert in kcal/mol*/
	molecularDynamics->kineticEnergy *= AUTOKCAL;
	molecularDynamics->potentialEnergy *= AUTOKCAL; 
	molecularDynamics->totalEnergy *= AUTOKCAL;
}
/*********************************************************************************/
static void applyThermostat(QFFMD* molecularDynamics)
{
	if(molecularDynamics->integratorType == STOCHASTIC) return;
	if(molecularDynamics->integratorType == QTB) return;
	if(molecularDynamics->integratorType == LANGEVIN) return;
	if(molecularDynamics->thermostat == ANDERSEN) andersen(molecularDynamics);
	if(molecularDynamics->thermostat == BERENDSEN) berendsen(molecularDynamics);
	if(molecularDynamics->thermostat == BUSSI) bussi(molecularDynamics);
}
/*********************************************************************************/
static void applyOneStep(QFFMD* molecularDynamics, int iStep)
{
	if(molecularDynamics->integratorType == VERLET) applyVerlet(molecularDynamics);
	else if(molecularDynamics->integratorType == BEEMAN) applyBeeman(molecularDynamics);
	else if(molecularDynamics->integratorType == STOCHASTIC) applyStochastic(molecularDynamics);
	else if(molecularDynamics->integratorType == LANGEVIN) 
	{
		updateLangevin(molecularDynamics);
		applyLangevin(molecularDynamics);
	}
	else {
		if((iStep+1)%molecularDynamics->M==0) updateQTB(molecularDynamics);
		applyQTB(molecularDynamics);
	}
	computeEnergies(molecularDynamics);
	/*
	printTranslation(molecularDynamics);
	printRotation(molecularDynamics);
	*/

}
/*********************************************************************************/
static void applyConstraintsFirstPortion(QFFMD* quantumMechanicsMD)
{
	int i;
	QFFModel* qffModel = quantumMechanicsMD->qffModel;

	if(qffModel->molecule.constraints==NOCONSTRAINTS) return;
	for (i = 0; i <  quantumMechanicsMD->numberOfModes; i++)
	if(!quantumMechanicsMD->qffModel->variable[i])
	{
		qffModel->velocity[i] = 0.0;
		qffModel->Q[i] =  quantumMechanicsMD->coordinatesOld[i];
	}

}
/*********************************************************************************/
static void applyConstraintsSecondPortion(QFFMD* quantumMechanicsMD)
{
	int i;
	QFFModel* qffModel = quantumMechanicsMD->qffModel;

	if(qffModel->molecule.constraints==NOCONSTRAINTS) return;
	for (i = 0; i <  quantumMechanicsMD->numberOfModes; i++)
	if(!quantumMechanicsMD->qffModel->variable[i])
	{
		qffModel->velocity[i] = 0.0;
		qffModel->Q[i] =  quantumMechanicsMD->coordinatesOld[i];
	}
}
/*********************************************************************************/
static void applyVerlet(QFFMD* molecularDynamics)
{
	int i;

	if(molecularDynamics->qffModel->molecule.constraints!=NOCONSTRAINTS)
	for (i = 0; i < molecularDynamics->numberOfModes; i++)
				molecularDynamics->coordinatesOld[i]= molecularDynamics->qffModel->Q[i];

	for (i = 0; i < molecularDynamics->numberOfModes; i++)
	{
		if(!molecularDynamics->qffModel->variable[i]) continue;

		{
			molecularDynamics->qffModel->Q[i] += 
				molecularDynamics->qffModel->velocity[i] * molecularDynamics->dt +
				molecularDynamics->a[i]*molecularDynamics->dt2_2;	
		}
			molecularDynamics->qffModel->velocity[i] += molecularDynamics->a[i] * molecularDynamics->dt_2;
	}

	applyConstraintsFirstPortion(molecularDynamics);
	if(molecularDynamics->thermostat==NOSEHOOVER) nose_hoover(molecularDynamics);

	newAccelaration(molecularDynamics);

	for (i = 0; i < molecularDynamics->numberOfModes; i++)
		if(molecularDynamics->qffModel->variable[i])
			molecularDynamics->qffModel->velocity[i] += molecularDynamics->a[i] * molecularDynamics->dt_2;
	applyConstraintsSecondPortion(molecularDynamics);
}
/*********************************************************************************/
static void applyBeeman(QFFMD* molecularDynamics)
{
	int i;
	double terms;
	if(molecularDynamics->qffModel->molecule.constraints!=NOCONSTRAINTS)
	for (i = 0; i < molecularDynamics->numberOfModes; i++)
				molecularDynamics->coordinatesOld[i]= molecularDynamics->qffModel->Q[i];

	for (i = 0; i < molecularDynamics->numberOfModes; i++)
	{
		if(!molecularDynamics->qffModel->variable[i]) continue;

			terms = 5.0*molecularDynamics->a[i]-molecularDynamics->aold[i];

		{
			molecularDynamics->qffModel->Q[i] += 
				molecularDynamics->qffModel->velocity[i] * molecularDynamics->dt +
				terms*molecularDynamics->dt2_8;	
		}
			molecularDynamics->qffModel->velocity[i] += terms * molecularDynamics->dt_8;
	}

	applyConstraintsFirstPortion(molecularDynamics);
	if(molecularDynamics->thermostat==NOSEHOOVER) nose_hoover(molecularDynamics);

	newAccelaration(molecularDynamics);

	for (i = 0; i < molecularDynamics->numberOfModes; i++)
		if(molecularDynamics->qffModel->variable[i])
			molecularDynamics->qffModel->velocity[i] += (3.0*molecularDynamics->a[i]+molecularDynamics->aold[i]) * molecularDynamics->dt_8;
	applyConstraintsSecondPortion(molecularDynamics);
}
/*********************************************************************************/
static void newProperties(QFFMD* molecularDynamics, char* comments)
{
	if( molecularDynamics->fileProp == NULL) return;
	fprintf(molecularDynamics->fileProp,"Time0(fs)\tTime(fs)\tTotal Energy(Kcal/mol)\tPotential Energy(Hartree)\tKinetic Energy(Hartree)\tT(t) (K)\tTaver(K)\tsigma(T)(K)\tIndex\tmuX\tmuY\tmuZ");
	if(molecularDynamics->thermostat==NOSEHOOVER) fprintf(molecularDynamics->fileProp,"\tEtot+Etherm");
	if(comments) fprintf(molecularDynamics->fileProp,"%s\n", comments);
	else fprintf(molecularDynamics->fileProp,"\n");
}
/*********************************************************************************/
static void saveProperties(QFFMD* molecularDynamics, int iStep0, int iStep, char* comments)
{
	double dt = molecularDynamics->dt/(fsInAU);
	static double Ttot = 0;
	static double T2tot = 0;
	double Taver = 0;
	double T2aver = 0;
	double totalEnergy =  molecularDynamics->totalEnergy;

	if( molecularDynamics->thermostat==NOSEHOOVER)
	{
		int i;
		double kT = KbInAU* molecularDynamics->temperature;
		double e = molecularDynamics->vNH[0]*molecularDynamics->vNH[0]* molecularDynamics->qNH[0]/2 + (molecularDynamics->nFree)*kT* molecularDynamics->xNH[0];
		for(i=1;i<MAXNH;i++) e += molecularDynamics->vNH[i]*molecularDynamics->vNH[i]* molecularDynamics->qNH[i]/2 + kT* molecularDynamics->xNH[i];
		
		totalEnergy += e;
	}

	if( molecularDynamics->fileProp == NULL) return;
	if(iStep==1)
	{
			Ttot = 0;
			T2tot = 0;
	}
	Ttot += molecularDynamics->kelvin;
	T2tot += molecularDynamics->kelvin*molecularDynamics->kelvin;
	Taver = Ttot/iStep;
	T2aver = T2tot/iStep;


	fprintf(molecularDynamics->fileProp,"%f\t%f\t%f\t\t%f\t\t\t%f\t\t\t%f\t%f\t%f\t%d\t", 
			(iStep0)*dt, 
			(iStep)*dt, 
			molecularDynamics->totalEnergy,
			molecularDynamics->potentialEnergy,
			molecularDynamics->kineticEnergy,
			molecularDynamics->kelvin,
			Taver,
			sqrt(fabs(T2aver-Taver*Taver)),
			molecularDynamics->index
			 );
	fprintf(molecularDynamics->fileProp,"%f\t%f\t%f\t", 
			molecularDynamics->qffModel->molecule.dipole[0]*AUTODEB, 
			molecularDynamics->qffModel->molecule.dipole[1]*AUTODEB, 
			molecularDynamics->qffModel->molecule.dipole[2]*AUTODEB);
	if( molecularDynamics->thermostat==NOSEHOOVER) fprintf(molecularDynamics->fileProp,"%f\t",totalEnergy);
	if(comments) fprintf(molecularDynamics->fileProp,"%s\n", comments);
	else fprintf(molecularDynamics->fileProp,"\n");
}
/*********************************************************************************/
static void saveTrajectory(QFFMD* molecularDynamics, int iStep)
{
	double dt = molecularDynamics->dt/(fsInAU);
	if( molecularDynamics->fileTraj == NULL) return;

	fprintf(molecularDynamics->fileTraj,"%d %f %f %f %f %f %f %f nModes, time(fs) TotalEnery(Hartree) Kinetic Potential, Dipole in AU\n", 
			molecularDynamics->numberOfModes,
			 (iStep)*dt, 
			molecularDynamics->totalEnergy,
			molecularDynamics->kineticEnergy,
			molecularDynamics->potentialEnergy,
			molecularDynamics->qffModel->molecule.dipole[0],
			molecularDynamics->qffModel->molecule.dipole[1],
			molecularDynamics->qffModel->molecule.dipole[2]
			 );
}

/**********************************************************************/
void	freeQFFMD(QFFMD* molecularDynamics)
{

	molecularDynamics->qffModel = NULL;
	molecularDynamics->numberOfModes = 0;
	molecularDynamics->updateFrequency = 0;
	if(molecularDynamics->a)
	{
		free(molecularDynamics->a);
	}
	if(molecularDynamics->aold)
	{
		free(molecularDynamics->aold);
	}
	if(molecularDynamics->coordinatesOld)
	{
		free(molecularDynamics->coordinatesOld);
	}
	if(molecularDynamics->moved) free(molecularDynamics->moved);
	if(molecularDynamics->update) free(molecularDynamics->update);
	if(molecularDynamics->positionFriction) free(molecularDynamics->positionFriction);
	if(molecularDynamics->velocityFriction) free(molecularDynamics->velocityFriction);
	if(molecularDynamics->accelarationFriction) free(molecularDynamics->accelarationFriction);
	if(molecularDynamics->gamma) free(molecularDynamics->gamma);
	if(molecularDynamics->positionRandom) free(molecularDynamics->positionRandom);
	if(molecularDynamics->velocityRandom) free(molecularDynamics->velocityRandom);
	if(molecularDynamics->Ht) free(molecularDynamics->Ht);
	if(molecularDynamics->theta) free(molecularDynamics->theta);
	if(molecularDynamics->rnoise)
	{
		int i;
		for(i=0;i<molecularDynamics->numberOfModes;i++)
			if(molecularDynamics->rnoise[i]) free(molecularDynamics->rnoise[i]);
		free(molecularDynamics->rnoise);
	}
}
/********************************************************************************/
static double getEKin(QFFMD* molecularDynamics)
{
	double ekin = 0;
	int i;
	for ( i = 0; i < molecularDynamics->numberOfModes; i++)
	{
		double mass = 1.0; // Mass-weigted normal coordinates
		//mass = molecularDynamics->qffModel->vData.effectiveMasses[i]*AMUTOAU;
		//mass = molecularDynamics->qffModel->vData.effectiveMasses[i];
		ekin += molecularDynamics->qffModel->velocity[i]*molecularDynamics->qffModel->velocity[i]*mass;
	}
	return ekin/2;
}
/********************************************************************************/
static double getKelvin(QFFMD* molecularDynamics)
{
	int nfree = molecularDynamics->nFree;
	/* printf("nfree = %d\n",nfree);*/
	if(nfree<1) return 0;
	return 2*getEKin(molecularDynamics) / ( nfree * KbInAU);
}
/********************************************************************************/
/*
     literature references:

     M. P. Allen, "Brownian Dynamics Simulation of a Chemical
     Reaction in Solution", Molecular Physics, 40, 1073-1087 (1980)

     F. Guarnieri and W. C. Still, "A Rapidly Convergent Simulation
     Method: Mixed Monte Carlo / Stochastic Dynamics", Journal of
     Computational Chemistry, 15, 1302-1310 (1994)
*/
/*********************************************************************************/
static void getsFrictionalAndRandomForce(QFFMD* molecularDynamics)
{
	double* gamma = molecularDynamics->gamma;
	double* positionFriction = molecularDynamics->positionFriction;
	double* velocityFriction = molecularDynamics->velocityFriction;
	double* accelarationFriction = molecularDynamics->accelarationFriction;
	double* positionRandom = molecularDynamics->positionRandom;
	double* velocityRandom = molecularDynamics->velocityRandom;
	double dt = molecularDynamics->dt;
	
	int n = molecularDynamics->numberOfModes;

	int i;
	double gdt;
	double egdt;
	double ktm = 0;
	double pterm;
	double vterm;
        double psig;
        double vsig;
        double rho;
        double rhoc;
	double pnorm;
	double vnorm;

	for(i=0;i<n;i++)
        	gamma[i] = molecularDynamics->friction;

	/* printf(" friction = %f\n", molecularDynamics->friction);*/
	for(i=0;i<n;i++)
	{
		double mass = 1.0; // Mass-weigted normal coordinates
		//mass = molecularDynamics->qffModel->vData.effectiveMasses[i]*AMUTOAU;
		//mass = molecularDynamics->qffModel->vData.effectiveMasses[i];
		gdt = gamma[i] * dt;
		/* printf("gdt = %f\n",gdt);*/
		if (gdt <= 0.0)
		{
               		positionFriction[i] = 1.0;
			velocityFriction[i] = dt;
			accelarationFriction[i] = 0.5 * dt * dt;
			{
                  		positionRandom[i] = 0.0;
                  		velocityRandom[i] = 0.0;
			}
		}
            	else
		{
			/* analytical expressions when friction coefficient is large */
               		if (gdt>=0.05)
			{
                  		egdt = exp(-gdt);
                  		positionFriction[i] = egdt;
                  		velocityFriction[i] = (1.0-egdt) / gamma[i];
                  		accelarationFriction[i] = (dt-velocityFriction[i]) / gamma[i];
                  		pterm = 2.0*gdt - 3.0 + (4.0-egdt)*egdt;
                  		vterm = 1.0 - egdt*egdt;
                  		rho = (1.0-egdt)*(1.0-egdt) / sqrt(pterm*vterm);
			}
			/* use series expansions when friction coefficient is small */
			else
			{
                  		double gdt2 = gdt * gdt;
                  		double gdt3 = gdt * gdt2;
                  		double gdt4 = gdt2 * gdt2;
                  		double gdt5 = gdt2 * gdt3;
                  		double gdt6 = gdt3 * gdt3;
                  		double gdt7 = gdt3 * gdt4;
                  		double gdt8 = gdt4 * gdt4;
                  		double gdt9 = gdt4 * gdt5;
                  		accelarationFriction[i] = (gdt2/2.0 - gdt3/6.0 + gdt4/24.0
                               	- gdt5/120.0 + gdt6/720.0
                               	- gdt7/5040.0 + gdt8/40320.0
                               	- gdt9/362880.0) / gamma[i]/gamma[i];
                  		velocityFriction[i] = dt - gamma[i]*accelarationFriction[i];
                  		positionFriction[i] = 1.0 - gamma[i]*velocityFriction[i];
                  		pterm = 2.0*gdt3/3.0 - gdt4/2.0
                            	+ 7.0*gdt5/30.0 - gdt6/12.0
                            	+ 31.0*gdt7/1260.0 - gdt8/160.0
                            	+ 127.0*gdt9/90720.0;
                  		vterm = 2.0*gdt - 2.0*gdt2 + 4.0*gdt3/3.0
                            	- 2.0*gdt4/3.0 + 4.0*gdt5/15.0
                            	- 4.0*gdt6/45.0 + 8.0*gdt7/315.0
                            	- 2.0*gdt8/315.0 + 4.0*gdt9/2835.0;
                  		rho = sqrt(3.0) * (0.5 - 3.0*gdt/16.0
                            	- 17.0*gdt2/1280.0
                            	+ 17.0*gdt3/6144.0
                            	+ 40967.0*gdt4/34406400.0
                            	- 57203.0*gdt5/275251200.0
                            	- 1429487.0*gdt6/13212057600.0);
			}
		
               		ktm = KbInAU * molecularDynamics->temperature / mass;
               		psig = sqrt(ktm*pterm) / gamma[i];
               		vsig = sqrt(ktm*vterm);
               		rhoc = sqrt(1.0 - rho*rho);
			{
                		pnorm = normal();
             			vnorm = normal ();
				positionRandom[i] = psig * pnorm;
                  		velocityRandom[i] = vsig * (rho*pnorm+rhoc*vnorm);
			}
		}
	}
}
/*********************************************************************************/
static void applyStochastic(QFFMD* molecularDynamics)
{
	double* positionFriction = molecularDynamics->positionFriction;
	double* velocityFriction = molecularDynamics->velocityFriction;
	double* accelarationFriction = molecularDynamics->accelarationFriction;
	double* positionRandom = molecularDynamics->positionRandom;
	double* velocityRandom = molecularDynamics->velocityRandom;
	double*a = molecularDynamics->a;
	
	int n = molecularDynamics->numberOfModes;
	int i;
	double * Q = molecularDynamics->qffModel->Q;

	getsFrictionalAndRandomForce(molecularDynamics);

	if(molecularDynamics->qffModel->molecule.constraints!=NOCONSTRAINTS)
	for (i = 0; i < n; i++)
				molecularDynamics->coordinatesOld[i]= molecularDynamics->qffModel->Q[i];

	for(i=0;i<n;i++)
	{
		if(!molecularDynamics->qffModel->variable[i]) continue;
		Q[i] += molecularDynamics->qffModel->velocity[i]*velocityFriction[i] + a[i]*accelarationFriction[i] + positionRandom[i];
		molecularDynamics->qffModel->velocity[i] = molecularDynamics->qffModel->velocity[i]*positionFriction[i] + 0.5*a[i]*velocityFriction[i];
	}

	applyConstraintsFirstPortion(molecularDynamics);

	newAccelaration(molecularDynamics);

	for (i = 0; i < n; i++)
		if(molecularDynamics->qffModel->molecule.atoms[i].variable)
			molecularDynamics->qffModel->velocity[i] += 0.5*a[i]*velocityFriction[i] + velocityRandom[i];
	applyConstraintsSecondPortion(molecularDynamics);
	computeEnergies(molecularDynamics);
}
/*********************************************************************************/
static void applyQTB(QFFMD* molecularDynamics)
{
	
	int n = molecularDynamics->numberOfModes;
	int i;
	double gp = 1/(1+molecularDynamics->friction*molecularDynamics->dt_2);
	double gm = (1-molecularDynamics->friction*molecularDynamics->dt_2)*gp;

	/* printf("gm = %f gp =%f\n",gm,gp);*/
	if(molecularDynamics->qffModel->molecule.constraints!=NOCONSTRAINTS)
	for (i = 0; i < n; i++)
				molecularDynamics->coordinatesOld[i]= molecularDynamics->qffModel->Q[i];

	for (i = 0; i < n; i++)
		if(molecularDynamics->qffModel->variable[i])
		{
			molecularDynamics->qffModel->Q[i] += 
			molecularDynamics->qffModel->velocity[i]*molecularDynamics->dt +
			(molecularDynamics->a[i]+molecularDynamics->theta[i]-molecularDynamics->qffModel->velocity[i]*molecularDynamics->friction)*molecularDynamics->dt2_2;	
		}
	for (i = 0; i < n; i++)
		if(molecularDynamics->qffModel->variable[i])
			molecularDynamics->qffModel->velocity[i] = 
			gm*molecularDynamics->qffModel->velocity[i] +
			gp*(molecularDynamics->a[i]+molecularDynamics->theta[i])*molecularDynamics->dt_2;
            
	applyConstraintsFirstPortion(molecularDynamics);

	newAccelaration(molecularDynamics);

	for (i = 0; i < n; i++)
		if(molecularDynamics->qffModel->variable[i])
			molecularDynamics->qffModel->velocity[i] += gp*(molecularDynamics->a[i]+molecularDynamics->theta[i])*molecularDynamics->dt_2;

	applyConstraintsSecondPortion(molecularDynamics);
	computeEnergies(molecularDynamics);
}
/*********************************************************************************/
static void applyLangevin(QFFMD* molecularDynamics)
{
	
	int n = molecularDynamics->numberOfModes;
	int i;
	double gp = 1/(1+molecularDynamics->friction*molecularDynamics->dt_2);
	double gm = (1-molecularDynamics->friction*molecularDynamics->dt_2)*gp;

	/* printf("gm = %f gp =%f\n",gm,gp);*/
	if(molecularDynamics->qffModel->molecule.constraints!=NOCONSTRAINTS)
	for (i = 0; i < n; i++)
				molecularDynamics->coordinatesOld[i]= molecularDynamics->qffModel->Q[i];

	for (i = 0; i < n; i++)
		if(molecularDynamics->qffModel->variable[i])
		{
			molecularDynamics->qffModel->Q[i] += 
			molecularDynamics->qffModel->velocity[i]*molecularDynamics->dt +
			(molecularDynamics->a[i]+molecularDynamics->theta[i]-molecularDynamics->qffModel->velocity[i]*molecularDynamics->friction)*molecularDynamics->dt2_2;	
		}
	for (i = 0; i < n; i++)
		if(molecularDynamics->qffModel->variable[i])
			molecularDynamics->qffModel->velocity[i] = 
			gm*molecularDynamics->qffModel->velocity[i] +
			gp*(molecularDynamics->a[i]+molecularDynamics->theta[i])*molecularDynamics->dt_2;
            
	applyConstraintsFirstPortion(molecularDynamics);

	newAccelaration(molecularDynamics);

	for (i = 0; i < n; i++)
		if(molecularDynamics->qffModel->variable[i])
			molecularDynamics->qffModel->velocity[i] += gp*(molecularDynamics->a[i]+molecularDynamics->theta[i])*molecularDynamics->dt_2;

	applyConstraintsSecondPortion(molecularDynamics);
	computeEnergies(molecularDynamics);
}
/*********************************************************************************/
void QFFMDDlg(char* inputFileName)
{
	QFFModel qffModel; 
	QFFMD molecularDynamics;
	int updateFrequency = 1;
	double heatTime;
	double equiTime;
	double runTime;
	double coolTime; 
	double heatTemp; 
	double equiTemp; 
	double runTemp; 
	double coolTemp; 
	double stepSize;
	MDIntegratorType integrator = VERLET;
	char* fileNameTraj = NULL;
	char* fileNameProp = NULL;
	double friction=-1;
	double omegaMax = 4000;
	int Nf = 50;
	double collide = 20;
	double qNH = 20;
	MDThermostatType thermostat = NONE;
	char* dirName = NULL;
	FILE* file = fopen(inputFileName,"rb");
	int numberOfGeometries = 0;

	setMDOptions(file, &updateFrequency, 
		&heatTime, &equiTime, &runTime, &coolTime,
		&heatTemp, &runTemp, &equiTemp, &coolTemp, &stepSize, 
		&integrator, &thermostat, &friction, &omegaMax, &Nf, &collide,&qNH);


	{
		char* suff = getSuffixNameFile(inputFileName);
		dirName = strdup(getenv("PWD"));
		fileNameTraj = strdup_printf("%s%s",suff, "Traj.gab");
		fileNameProp = strdup_printf("%s%s",suff, "Prop.txt");
		free(suff);
	}
	readOneInt(file,"numberOfGeometries",&numberOfGeometries);
	fclose(file);


	qffModel = newQFFModel();
	qffModel.klass->readData(&qffModel, inputFileName, inputFileName);
	//qffModel.klass->convertToAU2(&qffModel);
	qffModel.klass->convertToAU(&qffModel);
	qffModel.klass->computeQFFParameters(&qffModel);
	qffModel.molecule.constraints = NOCONSTRAINTS;

	runQFFMD(&molecularDynamics, &qffModel,
		updateFrequency, heatTime, equiTime, runTime, coolTime, heatTemp, equiTemp, runTemp, coolTemp, stepSize, 
		integrator, thermostat, friction, omegaMax, Nf, collide, qNH, numberOfGeometries, fileNameTraj, fileNameProp,inputFileName);

	qffModel.klass->free(&qffModel);
	free(dirName);
}
File: ./cchemilib/src/EmpriricalCorrections/HydrogenBondCorrection.c
/* HydrogenBondCorrection.c */
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* Reference: J. Rezac, P. Hobza J. Chem. Theory Comput. 8, 141-151 (2012)*/

#ifndef OS_WIN32
#include <unistd.h>
#endif

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#ifdef ENABLE_MPI
#include <mpi.h>
#endif

#include "HydrogenBondCorrection.h"
#include "../Utils/Constants.h"
#include "../Utils/Utils.h"

static int setDefParameters(HyhrogenBondCorrectionParameters* parameters, char* method);
static void printParameters(HyhrogenBondCorrectionParameters* parameters, FILE* file);
/**********************************************************************/
static void printDefParameters(char* method, FILE* file)
{
	HyhrogenBondCorrectionParameters pars;
	setDefParameters(&pars, method);
	printParameters(&pars, file);
}
/**********************************************************************/
static int setDefParameters(HyhrogenBondCorrectionParameters* parameters, char* method)
{
	sprintf(parameters->method,"%s",method);
/* cutoffs */
	parameters->HB_R_CUTOFF = 5.5;
	parameters->HB_R_0 = 1.5;
	parameters->MAX_XH_BOND=1.15;

	if(strstr(method,"PM6"))
	{
/* H4 repulsion*/
		parameters->para_OH_O = 2.32;
		parameters->para_OH_N = 3.10;
		parameters->para_NH_O = 1.07;
		parameters->para_NH_N = 2.01;
		parameters->multiplier_WH_O = 0.42;
		parameters->multiplier_COO = 1.41;
		parameters->multiplier_NH4 = 3.61;
/* HH repulsion*/
		parameters->HH_REPULSION_k = 0.4;
		parameters->HH_REPULSION_e = 12.7;
		parameters->HH_REPULSION_r0 = 2.3;
	}
	else if(strstr(method,"SCC-DFTB"))
	{
/* H4 repulsion*/
		parameters->para_OH_O = 1.11;
		parameters->para_OH_N = 2.58;
		parameters->para_NH_O = 0.80;
		parameters->para_NH_N = 2.01;
		parameters->multiplier_WH_O = 1.32;
		parameters->multiplier_COO = 1.22;
		parameters->multiplier_NH4 = 2.33;
/* HH repulsion*/
		parameters->HH_REPULSION_k = 0.4;
		parameters->HH_REPULSION_e = 12.7;
		parameters->HH_REPULSION_r0 = 2.3;
	}
	else if(strstr(method,"RM1"))
	{
/* H4 repulsion*/
		parameters->para_OH_O = 3.76;
		parameters->para_OH_N = 3.90;
		parameters->para_NH_O = 3.14;
		parameters->para_NH_N = 2.95;
		parameters->multiplier_WH_O = 0.94;
		parameters->multiplier_COO = 1.10;
		parameters->multiplier_NH4 = 1.21;
/* HH repulsion*/
		parameters->HH_REPULSION_k = 0.4;
		parameters->HH_REPULSION_e = 12.7;
		parameters->HH_REPULSION_r0 = 2.3;
	}
	else if(strstr(method,"OM3"))
	{
/* H4 repulsion*/
		parameters->para_OH_O = 1.95;
		parameters->para_OH_N = 1.64;
		parameters->para_NH_O = 0.93;
		parameters->para_NH_N = 1.35;
		parameters->multiplier_WH_O = 0.50;
		parameters->multiplier_COO = 1.63;
		parameters->multiplier_NH4 = 0.9;
/* HH repulsion*/
		parameters->HH_REPULSION_k = 0.4;
		parameters->HH_REPULSION_e = 12.7;
		parameters->HH_REPULSION_r0 = 2.3;
	}
	else if(strstr(method,"AM1"))
	{
/* H4 repulsion*/
		parameters->para_OH_O = 4.89;
		parameters->para_OH_N = 6.23;
		parameters->para_NH_O = 2.54;
		parameters->para_NH_N = 4.56;
		parameters->multiplier_WH_O = 0.49;
		parameters->multiplier_COO = 1.08;
		parameters->multiplier_NH4 = 2.78;
/* HH repulsion*/
		parameters->HH_REPULSION_k = 0.4;
		parameters->HH_REPULSION_e = 12.7;
		parameters->HH_REPULSION_r0 = 2.3;
	}
	else if(strstr(method,"PM3"))
	{
/* H4 repulsion*/
		parameters->para_OH_O = 2.71;
		parameters->para_OH_N = 4.37;
		parameters->para_NH_O = 2.29;
		parameters->para_NH_N = 3.86;
		parameters->multiplier_WH_O = 0.91;
		parameters->multiplier_COO = 0.89;
		parameters->multiplier_NH4 = 2.54;
/* HH repulsion*/
		parameters->HH_REPULSION_k = 0.4;
		parameters->HH_REPULSION_e = 12.7;
		parameters->HH_REPULSION_r0 = 2.3;
	}
	else if(strstr(method,"MM"))
	{
	// copie from PM3
/* H4 repulsion*/
		parameters->para_OH_O = 2.71;
		parameters->para_OH_N = 4.37;
		parameters->para_NH_O = 2.29;
		parameters->para_NH_N = 3.86;
		parameters->multiplier_WH_O = 0.91;
		parameters->multiplier_COO = 0.89;
		parameters->multiplier_NH4 = 2.54;
/* HH repulsion*/
		parameters->HH_REPULSION_k = 0.4;
		parameters->HH_REPULSION_e = 12.7;
		parameters->HH_REPULSION_r0 = 2.3;
	}
	else
	{
		fprintf(stderr,"I cannot set HB parameters, method %s is unknown\n"
	 	"The known methods are : SCC-DFTB, OM3, PM6, AM1, RM1, PM3\n"
		,method
		);
		fprintf(stderr,"You can also give your parameters using an input file\n"
	 	"Required parameters : OH_O, OH_N, NH_O, NH_N, WH_O, COO, NH4\n"
		"Format of file \n"
		"OH_O= value1\n"
		"OH_N= value2\n"
		"NH_O= value3\n"
		"NH_N= value4\n"
		"WH_O= value5\n"
		"COO= value5\n"
		"NH4= value7\n"
		);
		fprintf(stderr,"Here are the default parameters for several method\n");
		printDefParameters("SCC-DFTB", stderr);
		printDefParameters("OM3", stderr);
		printDefParameters("PM6", stderr);
		printDefParameters("AM1", stderr);
		printDefParameters("RM1", stderr);
		printDefParameters("PM3", stderr);
		exit(1);
		return 1;
	}
	printParameters(parameters, stdout);
	return 0;
}
/****************************************************************************************************/
/* H-H repulsion calculation*/
static double getHHRep(HyhrogenBondCorrectionParameters* parameters, Molecule* molecule, boolean addGradient)
{
	double e_corr_sum = 0; 
	int i, j, k;
	double r;
	double d_rad;
	double g[3];

	// Iterate over H atoms twice
	for(i=0;i<molecule->nAtoms;i++)
	{
		if( molecule->atoms[i].prop.atomicNumber == HYDROGEN)
		for (j = 0; j < i; j++)
		{ 
			if ( molecule->atoms[j].prop.atomicNumber == HYDROGEN)
			{
				r = getDistance(&molecule->atoms[i],&molecule->atoms[j]);
				e_corr_sum += parameters->HH_REPULSION_k * (1.0 - 1.0/(1.0 + exp(-parameters->HH_REPULSION_e *(r/parameters->HH_REPULSION_r0 - 1.0))));

			if (addGradient)
				{
				d_rad = (1.0 / pow(1.0 + exp(- parameters->HH_REPULSION_e*(r/ parameters->HH_REPULSION_r0-1.0)), 2) *  parameters->HH_REPULSION_e/ parameters->HH_REPULSION_r0 * exp(- parameters->HH_REPULSION_e*(r/ parameters->HH_REPULSION_r0-1.0))) *  parameters->HH_REPULSION_k;

				for(k=0;k<3;k++) g[k] =  (molecule->atoms[i].coordinates[k]-molecule->atoms[j].coordinates[k])/ r* d_rad;

				for(k=0;k<3;k++) molecule->atoms[i].gradient[k] -= g[k];
				for(k=0;k<3;k++) molecule->atoms[j].gradient[k] += g[k];
				}
			}
		}
	}
	return e_corr_sum;
}
/*********************************************************************************************************************/
static double getCovalentRadii(int z)
{
// Covalent radii (indexed by proton number), zero -> not available
static const double covalent_radii[119] = {0.0, 0.37, 0.32, 1.34, 0.9, 0.82, 0.77, 
	0.75, 0.73, 0.71, 0.69, 1.54, 1.3, 1.18, 1.11, 1.06, 1.02, 0.99, 0.97,
	1.96, 1.74, 1.44, 1.36, 1.25, 1.27, 1.39, 1.25, 1.26, 1.21, 1.38, 1.31,
	1.26, 1.22, 1.19, 1.16, 1.14, 1.1, 2.11, 1.92, 1.62, 1.48, 1.37, 1.45,
	1.56, 1.26, 1.35, 1.31, 1.53, 1.48, 1.44, 1.41, 1.38, 1.35, 1.33, 1.3,
	2.25, 1.98, 1.69, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
	0.0, 0.0, 1.6, 1.5, 1.38, 1.46, 1.59, 1.28, 1.37, 1.28, 1.44, 1.49, 0.0,
	0.0, 1.46, 0.0, 0.0, 1.45, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
	0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
	0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
	return covalent_radii[z];

}
/*********************************************************************************************************************/
/* Continuous valence contribution of a pair of atoms*/
static double cvalence_contribution(Atom* a, Atom* b)
{
	double r;
	double ri, rj;
	double r0, r1;
	double x;
	int ia = a->prop.atomicNumber;
	int ib = b->prop.atomicNumber;
	ri = getCovalentRadii(ia);
	rj = getCovalentRadii(ib);
	r0 = ri + rj;
	r1 = r0 * 1.6;
	r = getDistance(a,b);
	if (r == 0.0) return 0.0;
	if (r >= r1) return 0.0;
	if (r <= r0) return 1.0;
	x = (r - r0) / (r1 - r0);
	return 1.0 - (-20.0*pow(x,7) + 70.0*pow(x,6) -84.0*pow(x,5) + 35.0*pow(x,4));
}

/*********************************************************************************************************************/
/* Continuous valence contribution of a pair of atoms - derivative in the internal COOrdinate */
static double cvalence_contribution_d(Atom* a, Atom* b)
{
	double r;
	double ri, rj;
	double r0, r1;
	double x;
	int ia = a->prop.atomicNumber;
	int ib = b->prop.atomicNumber;
	ri = getCovalentRadii(ia);
	rj = getCovalentRadii(ib);
	r0 = ri + rj;
	r1 = r0 * 1.6;
	r = getDistance(a,b);
	if (r == 0.0) return 0.0;
	if (r >= r1) return 0.0;
	if (r <= r0) return 0.0;
	x = (r - r0) / (r1 - r0);
	return -(-140.0*pow(x,6) + 420.0*pow(x,5) - 420.0*pow(x,4) + 140.0*pow(x,3)) / (r1 - r0);
}
/*********************************************************************************************************************/
/* addVectorToGrad */
void addVectorToGrad(Molecule* molecule, int i, double add[], double factor)
{
	int c;
	for(c=0;c<3;c++) molecule->atoms[i].gradient[c] += add[c]*factor;
}
/**********************************************************************************************************/
/* H4 correction calculation*/
static double getH4(HyhrogenBondCorrectionParameters* parameters, Molecule* molecule, boolean addGradient)
{
	double e_corr_sum = 0;

	/* H-bond description*/
	int d_i, a_i, h_i; /* donor, acceptor, hydrogen indices*/
	double rda; /* donor-acceptor distance*/
	double rdh, rah;
	double angle;


	/* Energy terms:*/
	double e_para = 0;
	double e_bond_switch;
	double e_radial;
	double e_angular;
	double e_scale_w;
	double e_scale_chd;
	double e_scale_cha;
	double e_corr; 

	/* Derivatives*/
	double d_radial;
	double d_radial_d[3];
	double d_radial_a[3];

	double d_angular;
	double d_angular_d[3];
	double d_angular_h[3];
	double d_angular_a[3];

	double d_bs;
	double d_bs_d[3];
	double d_bs_a[3];
	double d_bs_h[3];

	double g[3];

	/* Scaling derivatives*/
	double sign_wat = 1;

	int o1;
	int o2;
	int cc;

	double cv_O1 = 0;
	double cv_O2 = 0;
	double cv_cc = 0;

	double f_O1;
	double f_O2;
	double f_cc;

	int i, j, k, c; 
	double rih, rjh;
	double x, xd, xd2, a, d;
	double slope, v, fv, fv2;
	double rdhs, ravgs;
	double factor;

	for(i=0;i<molecule->nAtoms;i++)
	{
		if( molecule->atoms[i].prop.atomicNumber == NITROGEN || molecule->atoms[i].prop.atomicNumber == OXYGEN)
		{
		for (j = 0; j < i; j++)
		{ 
		if( molecule->atoms[j].prop.atomicNumber == NITROGEN || molecule->atoms[j].prop.atomicNumber == OXYGEN)
		{
			// Calculate donor-acceptor distance
			rda = getDistance(&molecule->atoms[i],&molecule->atoms[j]);
			// Continue only WHen in range WHere correction acts
			if (rda > parameters->HB_R_0 && rda < parameters->HB_R_CUTOFF)
			{
				// Iterate over hydrogens
				for(h_i=0;h_i<molecule->nAtoms;h_i++)
				{ 
					if ( molecule->atoms[h_i].prop.atomicNumber == HYDROGEN)
					{
					// Distances to hydrogen
					rih = getDistance(&molecule->atoms[i],&molecule->atoms[h_i]);

					rjh = getDistance(&molecule->atoms[j],&molecule->atoms[h_i]);
					angle = M_PI - getAngle(&molecule->atoms[i], &molecule->atoms[h_i], &molecule->atoms[j])*(1/RADTODEG);
					if (angle < M_PI/2) {
						// filterd out everything but corrected H-bonds
						// Determine donor and acceptor - donor is the closer one
						if (rih <= rjh)
						{
							d_i = i;
							a_i = j;
							rdh = rih;
							rah = rjh;
						}
						else
						{
							d_i = j;
							a_i = i;
							rdh = rjh;
							rah = rih;
						}

						// Radial term
						e_radial = -0.00303407407407313510 * pow(rda,7) +
						            0.07357629629627092382 * pow(rda,6) +
						           -0.70087111111082800452 * pow(rda,5) +
						            3.25309629629461749545 * pow(rda,4) +
						           -7.20687407406838786983 * pow(rda,3) +
						            5.31754666665572184314 * pow(rda,2) +
						            3.40736000001102778967 * rda +
						           -4.68512000000450434811;

						// Radial gradient
						if (addGradient)
						{
							// In rDA COOrdinate
							d_radial = -0.02123851851851194655 * pow(rda,6) +
							            0.44145777777762551519 * pow(rda,5) +
							           -3.50435555555413991158 * pow(rda,4) +
							           13.01238518517846998179 * pow(rda,3) +
							          -21.62062222220516360949 * pow(rda,2) +
							           10.63509333331144368628 * rda +
							            3.40736000001102778967;

							// Cartesian gradients on D and A atoms
							for(k=0;k<3;k++)
								d_radial_d[k] = (molecule->atoms[d_i].coordinates[k] - molecule->atoms[a_i].coordinates[k])/rda * d_radial;

							for(k=0;k<3;k++) d_radial_a[k] = -d_radial_d[k];
						}

						// Angular term
						a = angle/(M_PI/2.0);
						x = -20.0*pow(a,7) + 70.0*pow(a,6) - 84.0*pow(a,5) + 35.0*pow(a,4);
						e_angular = 1.0 - x*x;

						// Angular gradient
						if (addGradient)
						{
							xd = (-140.0*pow(a,6) + 420.0*pow(a,5) - 420.0*pow(a,4) + 140.0*pow(a,3)) / (M_PI/2.0);
							d_angular = -xd * 2.0 * x;

							// Dot product of bond vectors
							d = (molecule->atoms[d_i].coordinates[0] - molecule->atoms[h_i].coordinates[0])
							    *(molecule->atoms[a_i].coordinates[0] - molecule->atoms[h_i].coordinates[0]) + 
							    (molecule->atoms[d_i].coordinates[1] - molecule->atoms[h_i].coordinates[1])
							    *(molecule->atoms[a_i].coordinates[1] - molecule->atoms[h_i].coordinates[1]) + 
							    (molecule->atoms[d_i].coordinates[2] - molecule->atoms[h_i].coordinates[2])
							    *(molecule->atoms[a_i].coordinates[2] - molecule->atoms[h_i].coordinates[2]);

							x = -d_angular / sqrt(1.0 - (d*d) / (rdh*rdh) / (rah*rah));
							
							// Donor atom
							for(k=0;k<3;k++)
							d_angular_d[k] = x * -((molecule->atoms[a_i].coordinates[k] - molecule->atoms[h_i].coordinates[k])/rdh/rah 
 									- (molecule->atoms[d_i].coordinates[k] - molecule->atoms[h_i].coordinates[k])*d/pow(rdh,3)/rah);
							// Acceptor atom
							for(k=0;k<3;k++)
							d_angular_a[k] = x * -((molecule->atoms[d_i].coordinates[k] - molecule->atoms[h_i].coordinates[k])/rdh/rah 
 									- (molecule->atoms[a_i].coordinates[k] - molecule->atoms[h_i].coordinates[k])*d/pow(rah,3)/rdh);

							// Hydrogen
							for(k=0;k<3;k++)
							d_angular_h[k] = -d_angular_d[k] - d_angular_a[k];
						}

						// Energy coefficient
						if ( molecule->atoms[d_i].prop.atomicNumber == OXYGEN &&  molecule->atoms[a_i].prop.atomicNumber == OXYGEN)     
														e_para = parameters->para_OH_O;
						if ( molecule->atoms[d_i].prop.atomicNumber == OXYGEN &&  molecule->atoms[a_i].prop.atomicNumber == NITROGEN)     
														e_para = parameters->para_OH_N;
						if ( molecule->atoms[d_i].prop.atomicNumber == NITROGEN &&  molecule->atoms[a_i].prop.atomicNumber == OXYGEN)     
														e_para = parameters->para_NH_O;
						if ( molecule->atoms[d_i].prop.atomicNumber == NITROGEN &&  molecule->atoms[a_i].prop.atomicNumber == NITROGEN)     
														e_para = parameters->para_NH_N;
						// Bond switching
						if (rdh > 1.15)
						{
							rdhs = rdh - 1.15;
							ravgs = 0.5*rdh + 0.5*rah - 1.15;
							x = rdhs/ravgs;
							e_bond_switch = 1.0-(-20.0*pow(x,7) + 70.0*pow(x,6) - 84.0*pow(x,5) + 35.0*pow(x,4));

							// Gradient
							if (addGradient)
							{
								d_bs = -(-140.0*pow(x,6) + 420.0*pow(x,5) - 420.0*pow(x,4) + 140.0*pow(x,3));

								xd = d_bs / ravgs;
								xd2 = 0.5 * d_bs * -x / ravgs;

								for(k=0;k<3;k++)
								d_bs_d[k] = (molecule->atoms[d_i].coordinates[k] - molecule->atoms[h_i].coordinates[k])/rdh * xd 
									+ (molecule->atoms[d_i].coordinates[k] - molecule->atoms[h_i].coordinates[k])/rdh * xd2;

								for(k=0;k<3;k++)
									d_bs_a[k] = (molecule->atoms[a_i].coordinates[k] - molecule->atoms[h_i].coordinates[k])/rah * xd2;

								for(k=0;k<3;k++) d_bs_h[k] = -d_bs_d[k] + -d_bs_a[k];
							}
						} 
						else
						 {
							// No switching, no gradient
							e_bond_switch = 1.0;
							if (addGradient)
							{
								for(k=0;k<3;k++) d_bs_d[k] = 0;
								for(k=0;k<3;k++) d_bs_a[k] = 0;
								for(k=0;k<3;k++) d_bs_h[k] = 0;
							}
						}
						// Water scaling
						e_scale_w = 1.0;
						if ( molecule->atoms[d_i].prop.atomicNumber == OXYGEN &&  molecule->atoms[a_i].prop.atomicNumber == OXYGEN)
						{
							// Count hydrogens and other atoms in vicinity
							double hydrogens = 0.0;
							double others = 0.0;
							for (k = 0; k < molecule->nAtoms; k++) 
							{
								if ( molecule->atoms[k].prop.atomicNumber  == HYDROGEN)
								{
									hydrogens += cvalence_contribution(& molecule->atoms[d_i],&molecule->atoms[k]);
								} else 
								{
									others += cvalence_contribution(&molecule->atoms[d_i],&molecule->atoms[k]);
								}
							}

							// If it is water
							if (hydrogens >= 1.0 )
							{
								sign_wat = 1.0;
								slope = parameters->multiplier_WH_O - 1.0;
								v = hydrogens;
								fv = 0.0;
								if (v > 1.0 && v <= 2.0)
								{
									fv = v - 1.0;
									sign_wat = 1.0;
								}
								if (v > 2.0 && v < 3.0)
								{
									fv = 3.0 - v;
									sign_wat = -1.0;
								}
								fv2 = 1.0 - others;
								if (fv2 < 0.0) fv2 = 0.0;
								e_scale_w = 1.0 + slope * fv * fv2;
							}
						}

						// Charged groups
						e_scale_chd = 1.0;
						e_scale_cha = 1.0;

						// Scaled groups: NR4+
						if (1 && molecule->atoms[d_i].prop.atomicNumber == NITROGEN)
						{
							slope = parameters->multiplier_NH4 - 1.0;
							v = 0.0;
							for (k = 0; k <  molecule->nAtoms; k++) v += cvalence_contribution(&molecule->atoms[d_i],&molecule->atoms[k]);
							if (v > 3.0) v = v - 3.0; else v = 0.0;
							e_scale_chd = 1.0 + slope * v;
						}

						// Scaled groups: COO-
						f_O1 = 0.0;
						f_O2 = 0.0;
						f_cc = 0.0;

						o1 = a_i;
						o2 = -1;
						cc = -1;
						if (molecule->atoms[a_i].prop.atomicNumber == OXYGEN)
						{
							slope = parameters->multiplier_COO - 1.0;

							// Search for closest C atom
							double cdist = 9.9e9;
							cv_O1 = 0.0;
							for (k = 0; k <  molecule->nAtoms; k++)
							{
								v = cvalence_contribution(& molecule->atoms[o1],&molecule->atoms[k]);
								cv_O1 += v; // Sum O1 valence
								if (v > 0.0 && molecule->atoms[k].prop.atomicNumber == CARBON && getDistance(&molecule->atoms[o1], &molecule->atoms[k]) < cdist) {
									cdist =  getDistance(&molecule->atoms[o1], &molecule->atoms[k]);
									cc = k;
								}
							}

							// If C found, look for the second O
							if (cc != -1) {
								double odist = 9.9e9;
								cv_cc = 0.0;
								for (k = 0; k <  molecule->nAtoms; k++)
								{
									v = cvalence_contribution(&molecule->atoms[cc],&molecule->atoms[k]);
									cv_cc += v;
									if (v > 0.0 && k != o1 &&molecule->atoms[k].prop.atomicNumber == OXYGEN && getDistance(&molecule->atoms[cc], &molecule->atoms[k]) < odist) {
										odist = getDistance(&molecule->atoms[cc], &molecule->atoms[k]);
										o2 = k;
									}
								}
							}


							// O1-C-O2 triad:
							if (o2 != -1) {
								// Get O2 valence
								cv_O2 = 0.0;
								for (k = 0; k <  molecule->nAtoms; k++)
										cv_O2 += cvalence_contribution(&molecule->atoms[o2], &molecule->atoms[k]);

								f_O1 = 1.0 - fabs(1.0 - cv_O1);
								if (f_O1 < 0.0) f_O1 = 0.0;

								f_O2 = 1.0 - fabs(1.0 - cv_O2);
								if (f_O2 < 0.0) f_O2 = 0.0;

								f_cc = 1.0 - fabs(3.0 - cv_cc);
								if (f_cc < 0.0) f_cc = 0.0;

								e_scale_cha = 1.0 + slope * f_O1 * f_O2 * f_cc;
							}

						}

						// Final energy
						e_corr = e_para * e_radial * e_angular * e_bond_switch * e_scale_w * e_scale_chd * e_scale_cha;
						e_corr_sum += e_corr;
				
						// Total gradient
						// radial
						factor = e_para * e_angular * e_bond_switch * e_scale_w * e_scale_chd * e_scale_cha;
						addVectorToGrad(molecule,d_i, d_radial_d, factor);
						addVectorToGrad(molecule,a_i, d_radial_a, factor);

						// angular
						factor =  e_para * e_radial * e_bond_switch * e_scale_w * e_scale_chd * e_scale_cha;
						addVectorToGrad(molecule,d_i, d_angular_d, factor);
						addVectorToGrad(molecule,a_i, d_angular_a, factor);
						addVectorToGrad(molecule,h_i, d_angular_h, factor);
						// bond_switch
						factor =   e_para * e_radial * e_angular * e_scale_w * e_scale_chd * e_scale_cha;
						addVectorToGrad(molecule,d_i, d_bs_d, factor);
						addVectorToGrad(molecule,a_i, d_bs_a, factor);
						addVectorToGrad(molecule,h_i, d_bs_h, factor);
						// water scaling
						if (addGradient && e_scale_w != 1.0) 
						{
							slope = parameters->multiplier_WH_O - 1.0;
							for (k = 0; k <  molecule->nAtoms; k++)
							{ 
								if (k != d_i) 
								{
									x = getDistance(&molecule->atoms[d_i], &molecule->atoms[k]);
									if (molecule->atoms[k].prop.atomicNumber == HYDROGEN) 
									{
									xd = cvalence_contribution_d(&molecule->atoms[d_i], &molecule->atoms[k]) * sign_wat;
									for(c=0;c<3;c++) g[c] =(molecule->atoms[d_i].coordinates[c]-molecule->atoms[k].coordinates[c]) * -xd/x * slope;

									addVectorToGrad(molecule, d_i, g, -e_para * e_radial * e_angular * e_bond_switch * e_scale_chd * e_scale_cha);
									addVectorToGrad(molecule, k, g, e_para * e_radial * e_angular * e_bond_switch * e_scale_chd * e_scale_cha);
									}
									else 
									{
									xd = cvalence_contribution_d(&molecule->atoms[d_i], &molecule->atoms[k]);
									for(c=0;c<3;c++) g[c] =(molecule->atoms[d_i].coordinates[c]-molecule->atoms[k].coordinates[c]) * xd/x * slope;
									addVectorToGrad(molecule, d_i, g, -e_para * e_radial * e_angular * e_bond_switch * e_scale_chd * e_scale_cha);
									addVectorToGrad(molecule, k, g, e_para * e_radial * e_angular * e_bond_switch * e_scale_chd * e_scale_cha);
									}
								}
							}
						}
						// scaled groups: NR4+
						if (addGradient && e_scale_chd != 1.0) 
						{
							slope = parameters->multiplier_NH4 - 1.0;
							for (k = 0; k <  molecule->nAtoms; k++)
							{ 
								if (k != d_i)
								{
									x = getDistance(&molecule->atoms[d_i], &molecule->atoms[k]);
									xd = cvalence_contribution_d(&molecule->atoms[d_i], &molecule->atoms[k]);
									for(c=0;c<3;c++) g[c] =(molecule->atoms[d_i].coordinates[c]-molecule->atoms[k].coordinates[c]) * -xd/x * slope;
									addVectorToGrad(molecule, d_i, g, -e_para * e_radial * e_angular * e_bond_switch * e_scale_cha * e_scale_w);
									addVectorToGrad(molecule, k, g, e_para * e_radial * e_angular * e_bond_switch * e_scale_cha * e_scale_w);
								}
							}
						}
						// scaled groups: COO-
						if (addGradient && f_O1 * f_O2 * f_cc != 0.0)
						{
							slope = parameters->multiplier_COO - 1.0;
							// Atoms around O1
							for (k = 0; k <  molecule->nAtoms; k++)
							{
								if (k != o1) 
								{
									xd = cvalence_contribution_d(&molecule->atoms[o1], &molecule->atoms[k]);
									if (xd != 0.0)
									{
										x = getDistance(&molecule->atoms[o1], &molecule->atoms[k]);
										if (cv_O1 > 1.0) xd *= -1.0; 
										xd *= f_O2 * f_cc;
										for(c=0;c<3;c++) g[c] =(molecule->atoms[o1].coordinates[c]-molecule->atoms[k].coordinates[c]) * -xd/x * slope;
										 addVectorToGrad(molecule, o1, g, -e_para * e_radial * e_angular * e_bond_switch * e_scale_chd * e_scale_w);
										 addVectorToGrad(molecule, k, g, e_para * e_radial * e_angular * e_bond_switch * e_scale_chd * e_scale_w);
									}
								}
							}
							slope = parameters->multiplier_COO - 1.0;
							// Atoms around O2
							for (k = 0; k <  molecule->nAtoms; k++)
							{ 
								if (k != o2) 
								{
									xd = cvalence_contribution_d(&molecule->atoms[o2], &molecule->atoms[k]);
									if (xd != 0.0) 
									{
										x =  getDistance(&molecule->atoms[o2], &molecule->atoms[k]);
										if (cv_O2 > 1.0) xd *= -1.0; 
										xd *= f_O1 * f_cc;
										for(c=0;c<3;c++) g[c] =(molecule->atoms[o2].coordinates[c]-molecule->atoms[k].coordinates[c]) * -xd/x * slope;
										addVectorToGrad(molecule, o2, g, -e_para * e_radial * e_angular * e_bond_switch * e_scale_chd * e_scale_w);
										addVectorToGrad(molecule, k, g, e_para * e_radial * e_angular * e_bond_switch * e_scale_chd * e_scale_w);
									}
								}
							}
							slope = parameters->multiplier_COO - 1.0;
							for (k = 0; k <  molecule->nAtoms; k++)
							{ 
								if (k != cc) 
								{
									xd = cvalence_contribution_d(&molecule->atoms[cc], &molecule->atoms[k]);
									if (xd != 0.0) 
									{
										x =  getDistance(&molecule->atoms[cc], &molecule->atoms[k]);
										if (cv_cc > 3.0) xd *= -1.0; 
										xd *= f_O1 * f_O2;
										for(c=0;c<3;c++) g[c] =(molecule->atoms[cc].coordinates[c]-molecule->atoms[k].coordinates[c]) * -xd/x * slope;
										addVectorToGrad(molecule, cc, g, -e_para * e_radial * e_angular * e_bond_switch * e_scale_chd * e_scale_w);
										addVectorToGrad(molecule, k, g, e_para * e_radial * e_angular * e_bond_switch * e_scale_chd * e_scale_w);
									}
								}
							}
						}
					}
				}
			}
		}
		
	}
	}
	}}

	return e_corr_sum;
}
/**********************************************************************/
static boolean getOneDouble(char* buffer, char* name, double* pval)
{
	char* st = strstr(buffer,name);
	if(st) 	
	{
		char* beg = strstr(buffer,"=");
		int k = 0;
		if(beg) k=sscanf(beg+1,"%lf",pval);
		else k=sscanf(st+strlen(st),"%lf",pval);
		if(k==1) return TRUE;
	}
	return FALSE;
}
/**********************************************************************/
static boolean getOneString(char* buffer, char* name, char*pval)
{
	char* st = strstr(buffer,name);
	if(st) 	
	{
		char* beg = strstr(buffer,"=");
		int k = 0;
		if(beg) k=sscanf(beg+1,"%s",pval);
		else k=sscanf(st+strlen(st),"%s",pval);
		if(k==1) return TRUE;
	}
	return FALSE;
}
/**********************************************************************/
static void printParameters(HyhrogenBondCorrectionParameters* parameters, FILE* file)
{
	fprintf(file,"---------------------------------------------------\n");
	fprintf(file,"Hyhrogen-Bond Correction Parameters:\n");
	fprintf(file,"Method=%s\n",parameters->method);
	fprintf(file,"OH_O=%f\n",parameters->para_OH_O);
	fprintf(file,"OH_N=%f\n",parameters->para_OH_N);
	fprintf(file,"NH_O=%f\n",parameters->para_NH_O);
	fprintf(file,"NH_N=%f\n",parameters->para_NH_N);
	fprintf(file,"WH_O=%f\n",parameters->multiplier_WH_O);
	fprintf(file,"COO=%f\n",parameters->multiplier_COO);
	fprintf(file,"NH4=%f\n",parameters->multiplier_COO);
	fprintf(file,"HB_R_CUTOFF=%f\n", parameters->HB_R_CUTOFF);
	fprintf(file,"HB_R_0=%f\n", parameters->HB_R_0);
	fprintf(file,"MAX_XH_BOND=%f\n", parameters->MAX_XH_BOND);
	fprintf(file,"HH_REPULSION_K=%f\n", parameters->HH_REPULSION_k);
	fprintf(file,"HH_REPULSION_E=%f\n", parameters->HH_REPULSION_e);
	fprintf(file,"HH_REPULSION_R0=%f\n", parameters->HH_REPULSION_r0);
	fprintf(file,"---------------------------------------------------\n");
}
/**********************************************************************/
int readHydrogenBondCorrectionParameters(HyhrogenBondCorrectionParameters* parameters, char* fileName)
{
	char buffer[BSIZE];
	FILE* file = fopen(fileName,"r");
	sprintf(parameters->method,"%s","Generic");
/* default cutoffs */
	parameters->HB_R_CUTOFF = 5.5;
	parameters->HB_R_0 = 1.5;
	parameters->MAX_XH_BOND=1.15;
/* default HH repulsion*/
	parameters->HH_REPULSION_k = 0.4;
	parameters->HH_REPULSION_e = 12.7;
	parameters->HH_REPULSION_r0 = 2.3;

/* init H4 repulsion tp -1, to check after read*/
	parameters->para_OH_O = -1;
	parameters->para_OH_N = -1;
	parameters->para_NH_O = -1;
	parameters->para_NH_N = -1;
	parameters->multiplier_WH_O = -1;
	parameters->multiplier_COO = -1;
	parameters->multiplier_NH4 = -1;
	while(file && !feof(file))
	{
		if(!fgets(buffer,BSIZE,file))break;
		uppercase(buffer);
		if(!getOneDouble(buffer, "OH_O", &parameters->para_OH_O))
		if(!getOneDouble(buffer, "OH_N", &parameters->para_OH_N))
		if(!getOneDouble(buffer, "NH_O", &parameters->para_NH_O))
		if(!getOneDouble(buffer, "NH_N", &parameters->para_NH_N))
		if(!getOneDouble(buffer, "WH_O", &parameters->multiplier_WH_O))
		if(!getOneDouble(buffer, "COO", &parameters->multiplier_COO))
		if(!getOneDouble(buffer, "NH4", &parameters->multiplier_NH4))
		if(!getOneDouble(buffer, "HB_R_CUTOFF", &parameters->HB_R_CUTOFF))
		if(!getOneDouble(buffer, "HB_R_0", &parameters->HB_R_0))
		if(!getOneDouble(buffer, "MAX_XH_BOND", &parameters->MAX_XH_BOND))
		if(!getOneDouble(buffer, "HH_REPULSION_K", &parameters->HH_REPULSION_k))
		if(!getOneDouble(buffer, "HH_REPULSION_E", &parameters->HH_REPULSION_e))
		if(!getOneDouble(buffer, "HH_REPULSION_R0", &parameters->HH_REPULSION_r0))
		getOneString(buffer, "METHOD", parameters->method);
	}
	if(!file)
	{
		fprintf(stderr,"Sorry I caanot opent %s file\n",fileName);
		exit(1);
	}
	if(
		parameters->para_OH_O<0 || 
		parameters->para_OH_N<0 || 
		parameters->para_NH_O<0 || 
		parameters->para_NH_N<0 || 
		parameters->multiplier_WH_O<0  ||
		parameters->multiplier_COO<0 ||
		parameters->multiplier_NH4<0
	)
	{
		fprintf(stderr,"Parameters =\n");
		printParameters(parameters, stderr);

		fprintf(stderr,"I cannot read all required parameters\n"
	 	"Required parameters : OH_O, OH_N, NH_O, NH_N, WH_O, COO, NH4\n"
		"Format of file \n"
		"OH_O= value1\n"
		"OH_N= value2\n"
		"NH_O= value3\n"
		"NH_N= value4\n"
		"WH_O= value5\n"
		"COO= value5\n"
		"NH4= value7\n"
		);
		fprintf(stderr,"Here are the default parameters for several method\n");
		printDefParameters("SCC-DFTB", stderr);
		printDefParameters("OM3", stderr);
		printDefParameters("PM6", stderr);
		printDefParameters("AM1", stderr);
		printDefParameters("RM1", stderr);
		printDefParameters("PM3", stderr);
		exit(1);
		return 1;
	}
	printParameters(parameters, stdout);
	return 0;
}
/**********************************************************************/
int setHydrogenBondCorrectionParameters(HyhrogenBondCorrectionParameters* parameters, char* fileName, char* method)
{
	if(fileName) return readHydrogenBondCorrectionParameters(parameters, fileName);
	return setDefParameters(parameters, method);
	return 1;
}
/****************************************************************************************************/
double getH4Correction(Molecule* molecule, HyhrogenBondCorrectionParameters* parameters, boolean addGradient)
{
	double e;
	if(!parameters) return 0; 
	e = getHHRep(parameters, molecule, addGradient);
	/* printf("HH=%f\n",e);*/
	e +=getH4(parameters, molecule, addGradient);
	/* printf("HH+H4=%f\n",e);*/
	return e;
}
File: ./cchemilib/src/EmpriricalCorrections/DispersionCorrection.c
/* DispersionCorrection.c */
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/


/* Grimme at al, JCP, 132, 154104(2010) */

#ifndef OS_WIN32
#include <unistd.h>
#endif

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#ifdef ENABLE_MPI
#include <mpi.h>
#endif

#include "DispersionCorrection.h"
#include "../Utils/Constants.h"
#include "D3Parameters.h"

static double** r0ab = NULL;
static double***** c6ab = NULL;
static double* maxCi = NULL;
/**********************************************************************/
static void setParameters(DispersionParameters* parameters, char* method)
{
/* only the zero version(3) of D3 is implemented. BJ version is not yet implemented */
/* from J. Rezac, P. Hobza J. Chem. Theory Comput. 8, 141-151 (2012)*/
	double s6  =  1.0;
	double s8 = 0.0;
	double rs6 = 1.0;
	double rs8 = 1.0;
	double alp =  14.0;
	sprintf(parameters->method,"%s",method);
	if(strstr(method,"PM6"))
	{
               rs6=1.18;
               alp = 22.0;
               s6=0.88;
               s8=0.0;
	}
	else if(strstr(method,"SCC-DFTB"))
	{
               rs6=1.215;
               alp = 30.0;
               s8=0.0;
	}
	else if(strstr(method,"PM3"))
	{
               rs6=0.90;
               alp = 22.0;
               s8=0.0;
	}
	else if(strstr(method,"AM1"))
	{
               rs6=0.90;
               alp = 15.0;
               s8=0.0;
	}
	else if(strstr(method,"RM1"))
	{
               rs6=1.0;
               alp = 16.0;
               s8=0.0;
	}
	else if(strstr(method,"OM3"))
	{
               rs6=1.14;
               alp = 23.0;
               s8=0.0;
	}
	parameters->s6 = s6;
	parameters->rs6 = rs6;
	parameters->alp6 = alp;
	parameters->s8 = s8;
	parameters->rs8 = rs8;
	parameters->alp8 = alp + 2.0;
	parameters->k1 = 16.0;
	parameters->k2 = 4.0/3.0;
	parameters->k3 = -4.0;
	parameters->rthr = 20000;
}
/****************************************************************************************************/
static void setr0ab()
{
	int i,j,k;
	static const int mm = sizeof(r0ab1D)/sizeof(r0ab1D[0]);
	if(r0ab) return;
	r0ab = malloc(maxElements*sizeof(double*));
	k = 0;
	for(i=0;i<maxElements;i++) r0ab[i] = malloc(maxElements*sizeof(double));

	for(i=0;i<maxElements;i++)
	for(j=0;j<=i;j++)
	{
		r0ab[i][j] = r0ab1D[k]*ANGTOBOHR;
		r0ab[j][i] = r0ab[i][j];
		k++;
		if(k>=mm) break;
	}
}
/****************************************************************************************************/
static void scaleRCovalent(DispersionParameters* parameters)
{
	static int first = 1;
	int i;
	if(!first) return;
	for(i=0;i<maxElements;i++) RCovalent[i] *=parameters->k2*ANGTOBOHR;
	first = 0;
}
/****************************************************************************************************/
static void scaler2r4(DispersionParameters* parameters)
{
	static int first = 1;
	int i;
	if(!first) return;
	for(i=0;i<maxElements;i++) r2r4[i]=sqrt( 0.5*r2r4[i]*sqrt((i+1)*1.0));
	first = 0;
}
/****************************************************************************************************/
static void setc6abtable()
{
	int i,j,ia,ib,k;
	if(c6ab) return;
	maxCi = malloc(maxElements*sizeof(double));
	for(i=0;i<maxElements;i++) maxCi[i] = -1;
	static const int mm = sizeof(c6)/sizeof(c6[0]);

	c6ab = malloc(maxElements*sizeof(double****));
	k = 0;
	for(i=0;i<maxElements;i++) 
	{
		c6ab[i] = malloc(maxElements*sizeof(double***));
		for(j=0;j<maxElements;j++) 
		{
			c6ab[i][j] = malloc(maxCN*sizeof(double**));
			for(ia=0;ia<maxCN;ia++) 
			{
				c6ab[i][j][ia] = malloc(maxCN*sizeof(double*));
				for(ib=0;ib<maxCN;ib++) 
				{
					c6ab[i][j][ia][ib] = malloc(3*sizeof(double));
					for(k=0;k<3;k++)  c6ab[i][j][ia][ib][k] = -1;
				}
			}
		}
	}
	for(i=0;i<mm;i++)
	{
		int iat = iza[i]-1;
		int jat = izb[i]-1;
      		int iadr = 0;
      		int jadr = 0;
		while(iat>=100) {
			iat -=100;
			iadr++;
		}
		while(jat>=100) {
			jat -=100;
			jadr++;
		}
		if(iadr>=maxCN) continue;
		if(jadr>=maxCN) continue;
		if(maxCi[iat]<iadr) maxCi[iat]=iadr;
		if(maxCi[jat]<jadr) maxCi[jat]=jadr;
		c6ab[iat][jat][iadr][jadr][0] = c6[i];
		c6ab[iat][jat][iadr][jadr][1] = cna[i];
		c6ab[iat][jat][iadr][jadr][2] = cnb[i];
		c6ab[jat][iat][jadr][iadr][0] = c6[i];
		c6ab[jat][iat][jadr][iadr][1] = cnb[i];
		c6ab[jat][iat][jadr][iadr][2] = cna[i];
	}
}
/* interpolation of C6 */
static double getC6(DispersionParameters* parameters, int iat, int jat, double cni, double cnj)
{
	double c6mem = -1.0e90;
	double rsum = 0.0;
	double csum = 0.0;
	double c6 = 0.0;
	double cn1,cn2;
	double d;
	double t;
	int i,j;
	for(i=0;i<=maxCi[iat];i++)
	for(j=0;j<=maxCi[jat];j++)
	{
         	c6=c6ab[iat][jat][i][j][0];
         	if(c6>0)
		{
            		c6mem=c6;
            		cn1=c6ab[iat][jat][i][j][1];
            		cn2=c6ab[iat][jat][i][j][2];
            		d=(cn1-cni)*(cn1-cni)+(cn2-cnj)*(cn2-cnj);
            		t=exp(parameters->k3*d);
            		rsum=rsum+t;
            		csum=csum+t*c6;
		}
	}
      if(rsum>0) c6=csum/rsum;
      else { c6=c6mem;}
	return c6;
}
/*  compute coordination numbers by adding an inverse damping function*/
/* store values in cn table */
static void computeCN(Molecule* mol, DispersionParameters* parameters,double* cn)
{
	int iat;
	double d[3],r,damp,xn,rr;
	int i,iz,jz,k;
	double k1 = parameters->k1;
	for(i=0;i<mol->nAtoms;i++)
	{
		xn = 0;
		for(iat=0;iat<mol->nAtoms;iat++)
		{
			if(iat==i) continue;
			for(k=0;k<3;k++) d[k] = mol->atoms[iat].coordinates[k]-mol->atoms[i].coordinates[k];
			r = 0;
			for(k=0;k<3;k++) r+=d[k]*d[k];
			r = sqrt(r);
			r *= ANGTOBOHR;
			iz =  mol->atoms[i].prop.atomicNumber-1;
			jz =  mol->atoms[iat].prop.atomicNumber-1;
			rr = (RCovalent[iz]+RCovalent[jz])/r;
			damp  = 1./(1.+exp(-k1*(rr-1.0)));
            		xn=xn+damp;
		}
      		cn[i] = xn;
	}
}
/*  compute energy */
static double getEnergy(Molecule* mol, DispersionParameters* parameters)
{
	int iat,jat;
	int k;
	int iz,jz;
	double r,r2,r6,r8,tmp,c6,c8;
	double damp6,damp8,rr;
	double* cn = NULL;
	double d[3];
	double e6,e8;
	double rthr;
	double rs6, alp6, rs8, alp8, s6,s8;

	e6 =0;
	e8 =0;
	if(!mol) return 0;
	if(!parameters) return 0;
	if(mol->nAtoms<1) return 0;
	rthr = parameters->rthr;

	rs6 = parameters->rs6;
	rs8 = parameters->rs8;
	alp6 = parameters->alp6;
	alp8 = parameters->alp8;
	s6 = parameters->s6;
	s8 = parameters->s8;
	
/*
	printf("s6 = %f\n",s6);
	printf("rs6 = %f\n",rs6);
	printf("alpha6 = %f\n",alp6);
*/

	cn = malloc(mol->nAtoms*sizeof(double));
	computeCN(mol,parameters,cn);
	for(iat=0;iat<mol->nAtoms-1;iat++)
	for(jat=iat+1;jat<mol->nAtoms;jat++)
	{
		for(k=0;k<3;k++) 
			d[k] = mol->atoms[iat].coordinates[k]-mol->atoms[jat].coordinates[k];
		r2 = 0;
		for(k=0;k<3;k++) r2 +=d[k]*d[k];
		if(r2>rthr) continue;
		r = sqrt(r2);
		r *= ANGTOBOHR;
		r2 = r*r;
		iz =  mol->atoms[iat].prop.atomicNumber-1;
		jz =  mol->atoms[jat].prop.atomicNumber-1;
		rr = r0ab[iz][jz]/r;

		tmp=rs6*rr;
		damp6 =1./( 1.+6.*pow(tmp,alp6) );
		tmp=rs8*rr;
		damp8 =1./( 1.+6.*pow(tmp,alp8) );
		c6 = getC6(parameters, iz, jz, cn[iat], cn[jat]);
		r6=r2*r2*r2;
		r8=r6*r2;
		c8 =3.0*c6*r2r4[iz]*r2r4[jz];
		e6=e6+c6*damp6/r6;
		e8=e8+c8*damp8/r8;
	}
/*
	double x = 0;
	for(iat=0;iat<mol->nAtoms;iat++)
	for(jat=0;jat<mol->nAtoms;jat++)
	{
		iz =  mol->atoms[iat].prop.atomicNumber-1;
		jz =  mol->atoms[jat].prop.atomicNumber-1;
		x += getC6(parameters, iz, jz, cn[iat], cn[jat]);
	}
	printf("x = %f\n",x);
*/
	if(cn) free(cn);
	return -(s6*e6+s8*e8)*AUTOKCAL;
}
/*  compute energy and gradient */
static double computeEnergyAddGradient(Molecule* mol, DispersionParameters* parameters)
{
	double energy = getEnergy(mol,parameters);
	double step=2.e-5*BOHRTOANG;
	int i,j;
	double eplus,emoins;
	double f = 0.5/step;
	if(!mol) return 0;
      	for(i=0;i<mol->nAtoms;i++)
	{
      		for(j=0;j<3;j++) 
		{
			mol->atoms[i].coordinates[j] += step;
			eplus = getEnergy(mol,parameters);
			mol->atoms[i].coordinates[j] -= 2*step;
			emoins = getEnergy(mol,parameters);
      			mol->atoms[i].gradient[j]  += f*(eplus-emoins);
			mol->atoms[i].coordinates[j] += step;
		}
	}
	return energy;
}
/****************************************************************************************************/
double getD3Correction(Molecule* mol, char* method, boolean addGradient)
{
	double e = 0;
	DispersionParameters parameters;
	setr0ab();
	setc6abtable();
	setParameters(&parameters, method);
	scaleRCovalent(&parameters);
	scaler2r4(&parameters);
	if(addGradient) e = computeEnergyAddGradient(mol,&parameters);
	else e = getEnergy(mol,&parameters);
	return e;
}
File: ./cchemilib/src/EmpriricalCorrections/ShortRangeBasisSetCorrection.c
/* ShortRangeBasisSetCorrection.c */
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* Reference: J. Rezac, P. Hobza J. Chem. Theory Comput. 8, 141-151 (2012)*/

#ifndef OS_WIN32
#include <unistd.h>
#endif

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <ctype.h>
#ifdef ENABLE_MPI
#include <mpi.h>
#endif

#include "ShortRangeBasisSetCorrection.h"
#include "../Utils/Constants.h"
#include "../Utils/Utils.h"

static int setDefParameters(ShortRangeBasisSetCorrectionParameters* parameters, char* method);
static void printParameters(ShortRangeBasisSetCorrectionParameters* parameters, FILE* file);
/**********************************************************************/
static void printDefParameters(char* method, FILE* file)
{
	ShortRangeBasisSetCorrectionParameters pars;
	setDefParameters(&pars, method);
	printParameters(&pars, file);
}
/**********************************************************************/
static int setDefParameters(ShortRangeBasisSetCorrectionParameters* parameters, char* method)
{
	sprintf(parameters->method,"%s",method);
	if(strstr(method,"SCC-DFTB"))
	{
		parameters->nBonds=1;
        	parameters->sRBBonds = malloc(parameters->nBonds*sizeof(SRBBond));

		sprintf(parameters->sRBBonds[0].symbol1,"O");
		sprintf(parameters->sRBBonds[0].symbol2,"H");
		parameters->sRBBonds[0].A = -0.232106;
		parameters->sRBBonds[0].beta = 0.747067;
		parameters->sRBBonds[0].C = 0.0788854;
		parameters->sRBBonds[0].gamma = 0.0792195;
		parameters->sRBBonds[0].omega = 0.25;  // 1/rcut, rcut = 4 Bohr
	}
	else if(strstr(method,"BLYP"))
	{
		parameters->nBonds=1;
        	parameters->sRBBonds = malloc(parameters->nBonds*sizeof(SRBBond));

		sprintf(parameters->sRBBonds[0].symbol1,"O");
		sprintf(parameters->sRBBonds[0].symbol2,"H");
		parameters->sRBBonds[0].A = -0.232106;
		parameters->sRBBonds[0].beta = 0.747067;
		parameters->sRBBonds[0].C = 0.0788854;
		parameters->sRBBonds[0].gamma = 0.0792195;
		parameters->sRBBonds[0].omega = 0.25;  // 1/rcut, rcut = 4 Bohr
	}
	else
	{
		fprintf(stderr,"I cannot set SRB parameters, method %s is unknown\n"
	 	"The known methods are : SCC-DFTB, BLYP\n"
		,method
		);
		fprintf(stderr,"You can also give your parameters using an input file (value in atomic unit)\n"
		"Format of file \n"
		"Symbol1 Symbol2 AValue betaValue\n"
		"Symbol1 Symbol2 AValue betaValue\n"
		"Symbol1 Symbol2 AValue betaValue\n"
		);
		fprintf(stderr,"Here are the default parameters for several method\n");
		printDefParameters("SCC-DFTB", stderr);
		printDefParameters("BLYP", stderr);
		exit(1);
		return 1;
	}
	printParameters(parameters, stdout);
	return 0;
}
/**********************************************************************************************************/
/* SRB correction calculation*/
static double getSRB(ShortRangeBasisSetCorrectionParameters* parameters, Molecule* molecule, boolean addGradient)
{
	double e_corr_sum = 0;
	double rijxyz[3];
	int i,j,k,c;
	static double convg = AUTOKCAL*ANGTOBOHR;
	static double conve = AUTOKCAL;
	static double twoOverPI05 = 2.0/sqrt(M_PI);

	for(i=0;i<molecule->nAtoms-1;i++)
	{
		for (j = i+1; j < molecule->nAtoms; j++)
		{ 
			double rij = getDistance(&molecule->atoms[i],&molecule->atoms[j]);
			rij = rij*ANGTOBOHR;
			//fprintf(stdout,"DEBUG ij = %d, %d rij=%lf\n", i,j,rij);
			for(k=0;k<parameters->nBonds;k++)
			if(
				( !strcmp(molecule->atoms[i].prop.symbol,parameters->sRBBonds[k].symbol1) && !strcmp(molecule->atoms[j].prop.symbol,parameters->sRBBonds[k].symbol2)) ||
				( !strcmp(molecule->atoms[j].prop.symbol,parameters->sRBBonds[k].symbol1) && !strcmp(molecule->atoms[i].prop.symbol,parameters->sRBBonds[k].symbol2)) 
			)
			{
			// V= A*exp(beta*rij)*erfc(w rij)+C*exp(gamma*rij)*erf(w rij)
			// erfc(x) = 1 - erf(x)
			// derive de erf(x)= 2/sqrt(M_PI)*exp(-x*x)
			// deriv xi [A*exp(beta*rij)*erfc(w rij)] = A*exp(beta*rij) [ beta erfc(w rij)-2 w/sqrt(M_PI)*exp(-(w*rij)^2) ] (xi-xj)/rij
			// deriv xi [C*exp(gamma*rij)*erf(w rij)] = C*exp(gamma*rij) [ gamma erf(w rij)+2 w/sqrt(M_PI)*exp(-(w*rij)^2) ] (xi-xj)/rij

				double A=parameters->sRBBonds[k].A;
				double beta=parameters->sRBBonds[k].beta;
				double gamma=parameters->sRBBonds[k].gamma;
				double C=parameters->sRBBonds[k].C;
				double w=parameters->sRBBonds[k].omega;
				//fprintf(stdout,"DEBUG ij = %d, %d A=%lf beta=%lf, C=%lf gamma=%lf omega=%lf\n", i,j,A,beta,C,gamma,omega);
                                //w = 0;
				//C = 0;
				double wr = rij*w;
				double erfwr = erf(wr);
				double erfcwr = 1-erfwr;
				double Abeta= A*exp(beta*rij);
				double Cgamma= C*exp(gamma*rij);
				e_corr_sum += Abeta*erfcwr+Cgamma*erfwr;
				if (addGradient) 
				{
					double derfwr = twoOverPI05*w*exp(-wr*wr);
					double term1 = Abeta*(beta*erfcwr-derfwr);
					double term2 = Cgamma*(gamma*erfwr+derfwr);
					double term = (term1+term2)/rij;
					term *= convg;
					for(c=0;c<3;c++) rijxyz[c] =  term*(molecule->atoms[i].coordinates[c] - molecule->atoms[j].coordinates[c])*ANGTOBOHR;
					for(c=0;c<3;c++) molecule->atoms[i].gradient[c] += rijxyz[c];
					for(c=0;c<3;c++) molecule->atoms[j].gradient[c] -= rijxyz[c];
                		}
			}
		}
	}
	e_corr_sum *= conve;
	return e_corr_sum;
}
/**********************************************************************/
static int readOneLine(char* buffer, char* symbol1, char* symbol2, double* pA, double* pBeta, double* pOmega, double* pC, double* pGamma)
{
	int k=sscanf(buffer,"%s %s %le %le %le %le %le", symbol1, symbol2, pA, pBeta, pOmega, pC, pGamma);
	//fprintf(stdout,"DEBUG k=%d\n",k);
	if(k>=4)
	{
		int i;
		for(i=1;i<strlen(symbol1);i++) symbol1[i]=tolower(symbol1[i]);
		for(i=1;i<strlen(symbol2);i++) symbol2[i]=tolower(symbol2[i]);
	}

	return k;
}
/**********************************************************************/
static boolean getOneString(char* buffer, char* name, char*pval)
{
        char* st = strstr(buffer,name);
        if(st)
        {
                char* beg = strstr(buffer,"=");
                int k = 0;
                if(beg) k=sscanf(beg+1,"%s",pval);
                else k=sscanf(st+strlen(st),"%s",pval);
                if(k==1) return TRUE;
        }
        return FALSE;
}
/**********************************************************************/
static void printParameters(ShortRangeBasisSetCorrectionParameters* parameters, FILE* file)
{
	int i;
	fprintf(file,"---------------------------------------------------\n");
	fprintf(file,"SRB Correction Parameters:\n");
	fprintf(file,"Method=%s\n",parameters->method);
	for(i=0;i<parameters->nBonds;i++) 
		fprintf(file,"%s %s %le %le %le %le %le\n",
			parameters->sRBBonds[i].symbol1, parameters->sRBBonds[i].symbol2,
			parameters->sRBBonds[i].A,parameters->sRBBonds[i].beta,
			parameters->sRBBonds[i].omega,
			parameters->sRBBonds[i].C,parameters->sRBBonds[i].gamma
			);
	fprintf(file,"End\n");
}
/**********************************************************************/
int readShortRangeBasisSetCorrectionParameters(ShortRangeBasisSetCorrectionParameters* parameters, char* fileName)
{
	char buffer[BSIZE];
	FILE* file = fopen(fileName,"r");
	int nBonds=0;
	char symbol1[10];
	char symbol2[10];
	double A;
	double beta;
	double C;
	double gamma;
	double omega;
	int k;

	sprintf(parameters->method,"%s","Generic");
	while(file && !feof(file))
	{
		if(!fgets(buffer,BSIZE,file))break;
		uppercase(buffer);
		if(strstr(buffer,"END")) break;
		if(!getOneString(buffer, "METHOD", parameters->method))
			if(readOneLine(buffer, symbol1, symbol2, &A, &beta, &omega, &C, &gamma)>=4) nBonds++;
	}
	if(!file)
	{
		fprintf(stderr,"Sorry I cannot opent %s file\n",fileName);
		exit(1);
	}
	if(nBonds<1)
	{
		fprintf(stderr,"Sorry I cannot read the SRB parameters from %s file\n",fileName);
		exit(1);
	}
	rewind(file);
	parameters->nBonds=nBonds;
        parameters->sRBBonds = malloc(parameters->nBonds*sizeof(SRBBond));
	int i=0;
	while(file && !feof(file))
	{
		if(!fgets(buffer,BSIZE,file))break;
		uppercase(buffer);
		if(strstr(buffer,"END")) break;
		if(strstr(buffer, "METHOD")) continue;
		k =readOneLine(buffer, symbol1, symbol2, &A, &beta, &omega, &C, &gamma);
		if(k>=4)
		{
			sprintf(parameters->sRBBonds[i].symbol1,"%s", symbol1);
			sprintf(parameters->sRBBonds[i].symbol2,"%s", symbol2);
			parameters->sRBBonds[i].A = A; 
			parameters->sRBBonds[i].beta = beta;
			parameters->sRBBonds[i].omega = 0;
			parameters->sRBBonds[i].C = 0; 
			parameters->sRBBonds[i].gamma = 0.0;
			if(k>=5) parameters->sRBBonds[i].omega = omega; 
			if(k>=6)
			{
				parameters->sRBBonds[i].C = C; 
				parameters->sRBBonds[i].gamma = gamma;
			}
			i++;
		}
	}

	printParameters(parameters, stdout);
	return 0;
}
/**********************************************************************/
int setShortRangeBasisSetCorrectionParameters(ShortRangeBasisSetCorrectionParameters* parameters, char* fileName, char* method)
{
	if(fileName) return readShortRangeBasisSetCorrectionParameters(parameters, fileName);
	return setDefParameters(parameters, method);
	return 1;
}
/****************************************************************************************************/
double getSRBCorrection(Molecule* molecule, ShortRangeBasisSetCorrectionParameters* parameters, boolean addGradient)
{
	double e;
	//fprintf(stdout," DEBUG je suis dans getSRBCorrection\n");
	//if(!parameters) { fprintf(stdout," DEBUG SRB parameters= NULL\n"); return 0; }
	if(!parameters) return 0;
	e = getSRB(parameters, molecule, addGradient);
	/* printf("SRB Energy=%f\n",e);*/
	return e;
}
File: ./cchemilib/src/EmpriricalCorrections/WallCorrection.c
/* WallCorrection.c */
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/


#ifndef OS_WIN32
#include <unistd.h>
#endif

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#ifdef ENABLE_MPI
#include <mpi.h>
#endif

#include "WallCorrection.h"
#include "../Utils/Constants.h"


/**********************************************************************/
/*
static boolean isConnected(Molecule* mol, int j)
{
	int nc = 0;
	int k;
	if(!mol->atoms[j].typeConnections) return FALSE;
        for(k=0;k<mol->nAtoms;k++) if(mol->atoms[j].typeConnections[k]>0) nc++;
	if(nc>0) return TRUE;
	return FALSE;
}
*/
/**********************************************************************/
/*  compute energy */
static double getEnergy(Molecule* mol)
{

	double C[3] = {0,0,0};
	int iat,c;
	int nc = 0;
	double E0 = mol->wall.E0;
	double srho2 =1/(mol->wall.rho*mol->wall.rho);
	int n = mol->wall.n;
	double E = 0;
	for(iat=0;iat<mol->nAtoms;iat++)
	{
		if(mol->atoms[iat].residueNumber==0)
		{
			nc++;
			for(c=0;c<3;c++) C[c]+= mol->atoms[iat].coordinates[c];
		}
	}
	if(nc>0) for(c=0;c<3;c++) C[c] /= nc;
	//printf("nc=%d\n",nc);
	for(iat=0;iat<mol->nAtoms;iat++)
	{
		if(mol->atoms[iat].residueNumber!=0)
		{
			double r2 = 0;
			for(c=0;c<3;c++) r2 +=  (mol->atoms[iat].coordinates[c]-C[c])*(mol->atoms[iat].coordinates[c]-C[c]);
			E += E0*pow(1-exp(-r2*srho2),n);
		}
	}
	//printf("EWall=%f\n",E);

	return E;
}
/*  compute energy and gradient */
/*
static double computeEnergyAddGradientNumeric(Molecule* mol)
{
	double energy = getEnergy(mol);
	double step=2.e-5*BOHRTOANG;
	int i,j;
	double eplus,emoins;
	double f = 0.5/step;
	if(!mol) return 0;
      	for(i=0;i<mol->nAtoms;i++)
	{
      		for(j=0;j<3;j++) 
		{
			mol->atoms[i].coordinates[j] += step;
			eplus = getEnergy(mol);
			mol->atoms[i].coordinates[j] -= 2*step;
			emoins = getEnergy(mol);
      			mol->atoms[i].gradient[j]  += f*(eplus-emoins);
			mol->atoms[i].coordinates[j] += step;
		}
	}
	return energy;
}
*/
/*  compute energy and gradient analytically */
static double computeEnergyAddGradientAnalytic(Molecule* mol)
{
	double C[3] = {0,0,0};
	int iat,c;
	int nc = 0;
	double E0 = mol->wall.E0;
	double srho2 =1/(mol->wall.rho*mol->wall.rho);
	int n = mol->wall.n;
	double energy = 0;
	for(iat=0;iat<mol->nAtoms;iat++)
	{
		if(mol->atoms[iat].residueNumber==0)
		{
			nc++;
			for(c=0;c<3;c++) C[c]+= mol->atoms[iat].coordinates[c];
		}
	}
	if(nc>0) for(c=0;c<3;c++) C[c] /= nc;
	for(iat=0;iat<mol->nAtoms;iat++)
	{
		if(mol->atoms[iat].residueNumber!=0)
		{
			double r2 = 0;
			double ex = 0;
			double exn = 0;
			for(c=0;c<3;c++) r2 +=  (mol->atoms[iat].coordinates[c]-C[c])*(mol->atoms[iat].coordinates[c]-C[c]);
			if( r2> mol->wall.rho*mol->wall.rho) printf("r=%f\n",sqrt(r2));
			ex = exp(-r2*srho2);
			exn = pow(1-ex,n-1);
			energy += E0*exn*(1-ex);
			exn  = 2*n*srho2*exn*ex*E0;
			for(c=0;c<3;c++) mol->atoms[iat].gradient[c] += (mol->atoms[iat].coordinates[c]-C[c])*exn;
		}
	}
	//printf("EWall=%f\n",energy);
	return energy;

}
/****************************************************************************************************/
double getWallCorrection(Molecule* mol, boolean addGradient)
{
	double e = 0;
	//printf("E0=%f\n",mol->wall.E0);
	//printf("rho=%f\n",mol->wall.rho);
	//printf("n=%d\n",mol->wall.n);
	if(mol->wall.E0<0 || fabs(mol->wall.E0)<1e-10) return 0;
	//if(addGradient) e = computeEnergyAddGradientNumeric(mol);
	if(addGradient) e = computeEnergyAddGradientAnalytic(mol);
	else e = getEnergy(mol);
	return e;
}
File: ./cchemilib/src/Molecule/Atom.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* Atom.c */
#include <stdlib.h>
#include <math.h>
#include <string.h>

#include "../Utils/Constants.h"
#include "../Utils/AtomsProp.h"
#include "Atom.h"

/*****************************************************************/
Atom getCopyAtom(Atom *atom)
{
	Atom a;
	a=*atom;
	a.prop = propAtomGet(atom->prop.symbol);
	a.mmType = strdup(atom->mmType);
	a.pdbType = strdup(atom->pdbType);
	a.residueName = strdup(atom->residueName);
	a.typeConnections = NULL;
	return a;
}
/*****************************************************************/
double getDistance(Atom *a1,Atom* a2)
{
	double* C1 = a1->coordinates;
	double* C2 = a2->coordinates;

	double x, y, z;
	
        x = C1[ 0 ] - C2[ 0 ];
       	y = C1[ 1 ] - C2[ 1 ];
       	z = C1[ 2 ] - C2[ 2 ];

	return sqrt( x * x + y * y + z * z );
}
/*****************************************************************/
double getAngle(Atom *a1,Atom* a2,Atom* a3)
{
	double* C1 = a1->coordinates;
	double* C2 = a2->coordinates;
	double* C3 = a3->coordinates;

	double x12, x32, y12, y32, z12, z32, l12, l32, dp;
	
        x12 = C1[ 0 ] - C2[ 0 ];
       	y12 = C1[ 1 ] - C2[ 1 ];
       	z12 = C1[ 2 ] - C2[ 2 ];
       	x32 = C3[ 0 ] - C2[ 0 ];
       	y32 = C3[ 1 ] - C2[ 1 ];
       	z32 = C3[ 2 ] - C2[ 2 ];

       	l12 = sqrt( x12 * x12 + y12 * y12 + z12 * z12 );
       	l32 = sqrt( x32 * x32 + y32 * y32 + z32 * z32 );
        if( l12 == 0.0 )
	{
               	return 0.0;
        }
        if( l32 == 0.0 )
	{
               	return 0.0;
       	}
        dp = ( x12 * x32 + y12 * y32 + z12 * z32 ) / (l12 * l32 );
	if ( dp < -1.0 )
		dp = -1.0;
	else if ( dp > 1.0 )
		dp = 1.0;
    return RADTODEG * acos(dp);
}
/*****************************************************************/
double getTorsion(Atom* a1,Atom* a2,Atom* a3,Atom* a4)
{
	double* C1 = a1->coordinates;
	double* C2 = a2->coordinates;
	double* C3 = a3->coordinates;
	double* C4 = a4->coordinates;

	double   xij, yij, zij;
       	double   xkj, ykj, zkj;
	double   xkl, ykl, zkl;
      	double   dx, dy, dz;
        double   gx, gy, gz;
        double   bi, bk;
        double   ct, d, ap, app, bibk;

        xij = C1[ 0 ] - C2[ 0 ];
        yij = C1[ 1 ] - C2[ 1 ];
        zij = C1[ 2 ] - C2[ 2 ];
        xkj = C3[ 0 ] - C2[ 0 ];
        ykj = C3[ 1 ] - C2[ 1 ];
        zkj = C3[ 2 ] - C2[ 2 ];
        xkl = C3[ 0 ] - C4[ 0 ];
        ykl = C3[ 1 ] - C4[ 1 ];
        zkl = C3[ 2 ] - C4[ 2 ];

        dx = yij * zkj - zij * ykj;
        dy = zij * xkj - xij * zkj;
        dz = xij * ykj - yij * xkj;
        gx = zkj * ykl - ykj * zkl;
        gy = xkj * zkl - zkj * xkl;
        gz = ykj * xkl - xkj * ykl;

        bi = dx * dx + dy * dy + dz * dz;
        bk = gx * gx + gy * gy + gz * gz;
        ct = dx * gx + dy * gy + dz * gz;
		bibk = bi * bk;
		
		if ( bibk < 1.0e-6 )	
			return 0;
        
		ct = ct / sqrt( bibk );
        
		if( ct < -1.0 )
                ct = -1.0;
        else if( ct > 1.0 )
                ct = 1.0;

        ap = acos( ct );
        
		d  = xkj*(dz*gy-dy*gz) + ykj*(dx*gz-dz*gx) + zkj*(dy*gx-dx*gy);
        
		if( d < 0.0 )
                ap = -ap;
        
		ap = PI - ap;
       	app = 180.0 * ap / PI;
       	if( app > 180.0 )
               	app = app - 360.0;
        return( app );
}
File: ./cchemilib/src/Molecule/TreeMolecule.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* TreeMolecule.c */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <ctype.h>

#include "../Utils/Utils.h"
#include "../Utils/AtomsProp.h"
#include "../Utils/Constants.h"
#include "../Utils/Types.h"
#include "../Utils/QL.h"
#include "../Molecule/Molecule.h"
#include "../Utils/CalculTypesAmber.h"
#include "../Utils/PDBTemplate.h"
#include "../Molecule/TreeMolecule.h"


/************************************************************************/
static void freeStack(TreeMolecule* treeMolecule)
{
	if(treeMolecule->inStack) free(treeMolecule->inStack);
	treeMolecule->inStack = NULL;
}
/************************************************************************/
static void initStack(TreeMolecule* treeMolecule)
{
	int i;
	/* if(treeMolecule->inStack) freeStack(treeMolecule);*/
	treeMolecule->inStack = malloc(treeMolecule->nAtoms*sizeof(boolean));
	for(i=0;i<treeMolecule->nAtoms;i++) treeMolecule->inStack[i] = FALSE;
}
/************************************************************************/
static void freeConnections(TreeMolecule* treeMolecule)
{
	int i;
	if(!treeMolecule->connected) return;
	for(i=0;i<treeMolecule->nAtoms;i++)
	{
		if(treeMolecule->connected[i]) free(treeMolecule->connected[i]);
	}
	free(treeMolecule->connected);
	treeMolecule->connected = NULL;
	treeMolecule->nAtoms = 0;
}
/************************************************************************/
static void disconnect(TreeMolecule* treeMolecule, int n1, int n2)
{
	int i;
	int k;
	if(treeMolecule->nAtoms<1) return;
	for(k=1;k<=treeMolecule->connected[n1][0];k++)
	{
		if(treeMolecule->connected[n1][k]==n2)
		{
			for(i=k;i<treeMolecule->connected[n1][0];i++)
				treeMolecule->connected[n1][i]=treeMolecule->connected[n1][i+1];
			treeMolecule->connected[n1][0]--;
			break;
		}
	}
	for(k=1;k<=treeMolecule->connected[n2][0];k++)
	{
		if(treeMolecule->connected[n2][k]==n1)
		{
			for(i=k;i<treeMolecule->connected[n2][0];i++)
				treeMolecule->connected[n2][i]=treeMolecule->connected[n2][i+1];
			treeMolecule->connected[n2][0]--;
			break;
		}
	}
}
/************************************************************************/
static void initConnections(TreeMolecule* treeMolecule, Molecule*  mol)
{
	int i;
	int j;
	int k;
	int nj;
	if(treeMolecule->nAtoms<1) return;
	treeMolecule->connected = malloc(treeMolecule->nAtoms*sizeof(int*));
	for(i=0;i<treeMolecule->nAtoms;i++)
	{
		treeMolecule->connected[i] = malloc((treeMolecule->nAtoms+1)*sizeof(int));
		treeMolecule->connected[i][0] = 0;
	}
	for(i=0;i<treeMolecule->nAtoms;i++)
	if(mol->atoms[i].typeConnections)
	for(j=0;j<treeMolecule->nAtoms;j++)
	{
		if(i==j) continue;
		nj = mol->atoms[j].N-1;
		if(mol->atoms[i].typeConnections[nj]>0)
		{
			treeMolecule->connected[i][0]++;
			k = treeMolecule->connected[i][0];
			treeMolecule->connected[i][k]=j;
		}
	}
}
/************************************************************************/
void initTreeMolecule(TreeMolecule* treeMolecule, Molecule*  mol, int ringSize)
{
	treeMolecule->done = FALSE;
	treeMolecule->bonds = 0;
	treeMolecule->ringSize = ringSize;
	treeMolecule->nAtoms = mol->nAtoms;
	if(mol->nAtoms<1) return;
	initStack(treeMolecule);
	initConnections(treeMolecule, mol);
}
/************************************************************************/
void freeTreeMolecule(TreeMolecule* treeMolecule)
{
	freeConnections(treeMolecule);
	freeStack(treeMolecule);
}
/************************************************************************/
boolean inRingTreeMolecule(TreeMolecule* treeMolecule,int currentAtom, int rootAtom)
{
	int i;
	treeMolecule->inStack[currentAtom] = TRUE;
	if (treeMolecule->done) return TRUE;
	else if ( ( currentAtom == rootAtom ) && ( treeMolecule->bonds == treeMolecule->ringSize ) ) return TRUE;
	else if ( ( currentAtom == rootAtom ) && ( treeMolecule->bonds > 2 ) && ( treeMolecule->ringSize < 3 ) ) return TRUE;
	if ( treeMolecule->bonds < treeMolecule->ringSize )
	{
		int numberOfConnections = treeMolecule->connected[ currentAtom ][ 0 ];
		for (i = 1; i <= numberOfConnections; i++ )
		{
			int newAtom = treeMolecule->connected[currentAtom][i];
			if ( ! ( treeMolecule->inStack[newAtom] ) )
			{
				treeMolecule->bonds++;
				treeMolecule->done = inRingTreeMolecule(treeMolecule, newAtom, rootAtom);
			}
			if (treeMolecule->done) return TRUE;
		}
	}
	treeMolecule->inStack[currentAtom] = FALSE;
	treeMolecule->bonds--;
	return FALSE;
}
/************************************************************************/
static boolean isConnected(TreeMolecule* treeMolecule, int i, int j)
{
	int k;
	for(k=0;k<treeMolecule->connected[i][0];k++)
		if(treeMolecule->connected[i][k+1]==j) return TRUE;
	return FALSE;
}
/************************************************************************/
int* getRingTreeMolecule(TreeMolecule* treeMolecule)
{
	int i;
	int n= 0;
 	int* ringAtoms = NULL;
	int k;
	int j;
	if(treeMolecule->inStack && treeMolecule->ringSize>1)
	{
 		ringAtoms = malloc(treeMolecule->ringSize*sizeof(int));
		for(i=0;i<treeMolecule->nAtoms;i++)
		{
			if(treeMolecule->inStack[i])
			{
				ringAtoms[n] = i;
				n++;
				if(n>=treeMolecule->ringSize) break;
			}
		}
	}
	if(ringAtoms)
	{
		for(i=1;i<n;i++)
			if(ringAtoms[i]<ringAtoms[0])
			{
				int t = ringAtoms[i];
				ringAtoms[i] = ringAtoms[0];
				ringAtoms[0] = t;
			}

		for(i=0;i<n-2;i++)
		{
			k = i+1;
			for(j=i+1;j<n;j++)
				if(isConnected(treeMolecule,ringAtoms[i],ringAtoms[j]))
				{
					k = j;
					break;
				}
			if(k!=(i+1))
			{
				int t = ringAtoms[i+1];
				ringAtoms[i+1] = ringAtoms[k];
				ringAtoms[k] = t;
			}
		}
	}
	return ringAtoms;
}
/********************************************************************************/
void getCentreRingTreeMolecule(TreeMolecule* treeMolecule, Molecule* mol,int i, int j, double C[])
{

	int k;
	int c;
	int* num  = NULL;
	int n;

	for(c=0;c<3;c++) C[c] = 0;
	if(mol->nAtoms != treeMolecule->nAtoms) return;
	n = 4;
	initTreeMolecule(treeMolecule, mol, n-1);
	if(inRingTreeMolecule(treeMolecule,j, i) ) num = getRingTreeMolecule(treeMolecule);
	if(!num)
	{
		n++;
		initTreeMolecule(treeMolecule, mol, n-1);
		if(inRingTreeMolecule(treeMolecule,j, i)) num = getRingTreeMolecule(treeMolecule);
	}
	if(!num)
	{
		n++;
		initTreeMolecule(treeMolecule, mol, n-1);
		if(inRingTreeMolecule(treeMolecule,j, i)) num = getRingTreeMolecule(treeMolecule);
	}
	if(num)
	{
		for(c=0;c<3;c++) C[c] += mol->atoms[j].coordinates[c];
		for(k=0;k<n-1;k++) 
		{
			for(c=0;c<3;c++) C[c] += mol->atoms[num[k]].coordinates[c];
		}
		for(c=0;c<3;c++) C[c] /= n;
		if(num)free(num);
	}
}
/********************************************************************************/
boolean inGroupTreeMolecule(TreeMolecule* treeMolecule,int currentAtom, int nEx1, int nEx2, int nEx3)
{
	int i;
	//int end = FALSE;
	treeMolecule->inStack[currentAtom] = TRUE;
	if ( currentAtom == nEx1  || currentAtom == nEx2  ||  currentAtom == nEx2 )
	{
		treeMolecule->done = TRUE;
		return TRUE;
	}
	{
		int numberOfConnections = treeMolecule->connected[ currentAtom ][ 0 ];
		for (i = 1; i <= numberOfConnections; i++ )
		{
			int newAtom = treeMolecule->connected[currentAtom][i];
			if ( ! ( treeMolecule->inStack[newAtom] ) )
			{
				treeMolecule->bonds++;
				//end = inGroupTreeMolecule(treeMolecule, newAtom, nEx1, nEx2, nEx3);
				inGroupTreeMolecule(treeMolecule, newAtom, nEx1, nEx2, nEx3);
			}
		}
	}
	return FALSE;
}
/************************************************************************/
int* getListGroupe(int* nGroupAtoms, Molecule*  mol, int i1, int i2, int i3, int i4)
{
	int i;
	int nG = 0;
	int nEx1 = 0;
	int nEx2 = 0;
	int nEx3 = 0;
	TreeMolecule treeMolecule;
	int* listGroupAtoms = NULL;
	int n = 0;

	*nGroupAtoms = 0;
	if(mol->nAtoms<2) return NULL;
	if(i1<0 || i2<0) return NULL;
	initTreeMolecule(&treeMolecule, mol, 6);
	if(i3>=0 && i4>=0) 
	{
		if(i4>=mol->nAtoms)
		{
			nG = i3;
			nEx1 = i2;
			nEx2 = i1;
			nEx3 = i4-mol->nAtoms;
		}
		else
		{
			nG = i4;
			nEx1 = i3;
			nEx2 = i2;
			nEx3 = i1;
		}
	}
	else if(i3>=0) 
	{
		nG = i3;
		nEx1 = i2;
		nEx2 = i1;
		nEx3 = i4;
	}
	else 
	{
		nG = i2;
		nEx1 = i1;
		nEx2 = i3;
		nEx3 = i4;
	}
	disconnect(&treeMolecule, nG, nEx1);
	inGroupTreeMolecule(&treeMolecule,nG, nEx1, nEx2, nEx3);
	if(treeMolecule.done) return NULL;
	
	/*
	printf("end = %d\n",treeMolecule.done);
	printf("nex = %d n = %d\n",mol->atoms[nEx1].N, mol->atoms[nG].N);
	for(i=0;i<treeMolecule.nAtoms;i++) printf("%d %d\n",mol->atoms[i].N,treeMolecule.inStack[i]);
	*/

	for(i=0;i<treeMolecule.nAtoms;i++) 
		if(treeMolecule.inStack[i] && i!=nG) n++;
	if(n==0) return NULL;
	listGroupAtoms = malloc(n*sizeof(int));
	for(i=0;i<n;i++) listGroupAtoms[i]=-1;
	n = 0;
	for(i=0;i<treeMolecule.nAtoms;i++) 
		if(treeMolecule.inStack[i] && i!=nG) listGroupAtoms[n++]=i;

	freeTreeMolecule(&treeMolecule);

	*nGroupAtoms = n;
	return listGroupAtoms;
}
File: ./cchemilib/src/Molecule/Molecule.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* Molecule.c */
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <ctype.h>

#include "../Utils/Utils.h"
#include "../Utils/AtomsProp.h"
#include "../Utils/Constants.h"
#include "../Utils/Types.h"
#include "../Utils/QL.h"
#include "../Molecule/Molecule.h"
#include "../Utils/CalculTypesAmber.h"
#include "../Utils/PDBTemplate.h"

static boolean** bondedMatrix = NULL;
static void removeTranslation(Molecule* molecule);
static void removeRotation(Molecule* molecule);
static void removeTranslationAndRotation(Molecule* molecule);
static void removeTranslationCluster(Molecule** molecule, int nMols);
static void removeRotationCluster(Molecule** molecules, int nMols);
static void removeTranslationAndRotationCluster(Molecule** molecules, int nMols);

static void removeTranslationForceCluster(Molecule** molecule, int nMols, double** vectors);
static void removeRotationForceCluster(Molecule** molecules, int nMols, double** vectors);
static void removeTranslationAndRotationForceCluster(Molecule** molecules, int nMols, double** vectors);

static void removeTranslationForce(Molecule* molecule, double* f);
static void removeRotationForce(Molecule* molecule, double* f);
static void removeTranslationAndRotationForce(Molecule* molecules, double* f);

static void removeTranslationMoments(Molecule** molecule, int nMols, double*** P);
static void removeRotationMoments(Molecule** molecules, int nMols, double*** P);
static void removeTranslationAndRotationMoments(Molecule** molecules, int nMols, double*** P);

static void removeTranslationAcceleration(Molecule* molecule, double* a);
static void removeRotationAcceleration(Molecule* molecule, double* a);
static void removeTranslationAndRotationAcceleration(Molecule* molecule, double* a);
static boolean printMolecule(Molecule* molecule, FILE* file);
static void scaleVelocities(Molecule* molecule, double temperature);
static double getKelvin(Molecule* molecule);
static void setMaxwellVelocities(Molecule* molecule, double temperature);
static boolean setMaxwellVelocitiesIfNull(Molecule* molecule, double temperature);
static boolean resetConstraints(Molecule* molecule, Constraints constraints);
static void setRattleConstraintsParameters(Molecule* m);
static boolean setRandomPositions(Molecule* molecule);
static boolean setRandomPositionsChain(Molecule* molecule);
static boolean addGeometry(Molecule* molecule,FILE* file);
static boolean addGeometryToGabedit(Molecule* molecule,FILE* file);
static boolean addMolecule(Molecule* molecule,FILE* file);
static boolean addVelocities(Molecule* molecule,FILE* file);
static Molecule* readGeom(char* namefile);
static boolean readGeometry(Molecule* molecule,char* namefile);
static void computeDipole(Molecule* mol);
static void copyChargeInCharge0(Molecule* molecule);
static void setBondHardness(Molecule* molecule, int nBonds, char** atomTypes1, char** atomTypes2, double* hardness);
static void setHardness(Molecule* molecule, int nTypes, char** atomTypes, double* hardness);
static void setElectronegativity(Molecule* molecule, int nTypes, char** atomTypes, double* electronegativity);
static void setWidth(Molecule* molecule, int nTypes, char** atomTypes, double* width);
static void setCharge0(Molecule* molecule, int nTypes, char** atomTypes, double* charge0);
static void setChargesEEM(Molecule* molecule);
static void setChargesACKS2(Molecule* molecule);
static double getEnergyEEM(Molecule* molecule);
static double getEnergyACKS2(Molecule* molecule);
static boolean saveGeometry(Molecule* molecule,char* fileName);
static boolean saveGeometryAndVelocities(Molecule* molecule,char* fileName);
static boolean isLinear(Molecule* molecule);
static boolean saveMolecule(Molecule* molecule,char* fileName);
static boolean saveMol2(Molecule* molecule,char* fileName);
static boolean saveHIN(Molecule* molecule,char* fileName);
static boolean saveFrequencies(Molecule* molecule, char* fileName, int nModes, double* frequencies, double** modes, double* reducedMasses, double* IRIntensities);
static int computeIR(Molecule* mol, double *F, double* dmuX[3]);
static boolean readGradientFromGabeditFile(Molecule* mol, char* namefile);
static int computeFrequenciesFromFiles(Molecule* mol, char* inputFileName, double dx);
static int computeFrequenciesOneStepFromFiles(Molecule* mol, char* inputFileName, double dx);
static int computeFrequenciesFromGradFiles(Molecule* mol, char* inputFileName, double dx);
static int computeFrequenciesOneStepFromGradFiles(Molecule* mol, char* inputFileName, double dx);
static int generateCChemIFilesForFrequencies(Molecule* mol, char* inputFileName, double dx);
static int generateCChemIFilesOneStepForFrequencies(Molecule* mol, char* inputFileName, double dx);
static int generateCChemIGradFilesForFrequencies(Molecule* mol, char* inputFileName, double dx);
static int generateCChemIGradFilesOneStepForFrequencies(Molecule* mol, char* inputFileName, double dx);
static void freeVibrations(Molecule* mol);

static void removeTransRotModes(Molecule* mol);
static void sortFrequencies(Molecule* mol);
static void removeFrequencies(Molecule* mol, double freqMin, double freqMax);
static void removeNotSelectedFrequencies(Molecule* mol, boolean* selected);
static void freeMolecule(Molecule* molecule);
static Molecule* copyMolecule(Molecule* m);
static void computeHarmonicVelocitiesCoordinates(Molecule* mol, double T, int numMode, boolean changeGeom);
static int generateQFFCChemIFiles(Molecule* mol, char* inputFileName, double delta, boolean reducedCoordinates, int ordre);
static double*** getGeomsQFF(Molecule* mol, char* inputFileName, double delta, boolean reducedCoordinates, int ordre, double** pDeltas, int* nGeoms);
static void readGeomFromMopacOutputFile(Molecule* mol, char *fileName, int numgeometry);
static void readGeomFromGamessOutputFile(Molecule* mol, char *fileName, int numgeometry);
static void readGeomFromOrcaOutputFile(Molecule* mol, char* fileName, int numgeometry);
static void readGeomFromOpenBabelOutputFile(Molecule* mol, char* fileName, int numgeometry);
static void readGeomFromGaussianOutputFile(Molecule* mol, char *fileName, int numgeometry);
static void readGeomFromMopacAuxFile(Molecule* mol, char *fileName,int numgeometry);
static void setConnections(Molecule* molecule);
static boolean resetMMTypes(Molecule* mol, char* type);
static boolean buildMMTypes(Molecule* mol, FILE* file);

static boolean addFirstDerivativeToFile(Molecule* molecule, FILE* file);
static Molecule* getMoleculeFromGaussianOutputFile(char *fileName, int numgeometry);
static boolean readVibrationFromGaussianOutputFile(Molecule* mol, char* fileName);
static boolean readDipolesDerivativesFromOrcaHessianFile(Molecule* mol, char* fileName);
static boolean readDipolesDerivativesFromGaussianOutputFile(Molecule* mol, char* fileName);
static boolean readDipolesDerivativesFromGabeditFile(Molecule* mol, char* fileName);
static boolean readDipolesDerivativesFromOrcaOutputFile(Molecule* mol, char* fileName);

static boolean readMolecule0(Molecule* molecule, char* fileName);

static boolean fit2Molecule(Molecule* molToFit, Molecule* molRef, double u[3][3]);
static boolean fitRMSD2Molecule(Molecule* molFit, Molecule* molRef, boolean center);
static void buildStandardOrientation(Molecule* mol,double* centerOfGravity, int* numberOfEquivalentAxes, double* inertialMoment, double axes[3][3]);
static void centerMolecule(Molecule* mol, double C[]);
static char* saveFirstDerivatives(char* inputFileName, Molecule* mol);
static double* getDeltaTable(Molecule* mol, double delta, boolean reducedCoordinates);
static int getQFFOneGeom(Molecule* mol, int mode1, int mode2, double delta1, double delta2, double akOverI1, double** geom);
static int getQFFOneGeom3(Molecule* mol, int mode1, int mode2, int mode3, double delta1, double delta2, double delta3, double** geom);
static int getQFFOneGeom4(Molecule* mol, int mode1, int mode2, int mode3, int mode4, double delta1, double delta2, double delta3, double delta4, double** geom);
static Molecule** readMoleculesFromXYZFile(char *fileName, boolean connections);
static Molecule** readMoleculesFromGabeditFile(char* namefile, boolean connections);
static Molecule** readMoleculesFromCChemIFile(char *fileName, boolean connections);
static void getFileNameToRead(char* fileName, char* fileNameToRead);
static void computePseudoInertia(Molecule* mol, double*pI, double* pI4);
static  boolean similarInertia(Molecule* mol1, Molecule* mol2, double precision);
static  boolean similarBonds(Molecule* mol1, Molecule* mol2, double sTol, double distMaxTol);
static boolean setGeometryToAxes(Molecule* molecule, double axis1[], double axis2[], double axis3[]);
static boolean setRandomOrientation(Molecule* molecule);
static boolean makeLocalSphericalMutation(Molecule* molecule, double rate);
static boolean makeCenterOfMassSphericalMutation(Molecule* molecule);
static  Molecule* makeSphereCutSpliceCrossover(Molecule* mol1, Molecule* mol2, int *err);
static  Molecule* makePlaneCutSpliceCrossover(Molecule* mol1, Molecule* mol2, int *err);
static  void freeTypesOfAtoms(char** types, int nTypes);
static  char** getTypesOfAtoms(Molecule* mol, int* pnTypes);
CCHEMIFileType getTypeFile(char* fileName);
static  boolean smallDistance(Molecule* mol);
static  boolean oneFragment(Molecule* mol);
static double* getDistancesBetweenAtoms(Molecule* mol);
static void swap2Double(double* a, double *b);
static void swap2Int(int* a, int *b);
static  double getSimilatityByBonds(Molecule* mol1, Molecule* mol2, double* pmaxDifference);
static boolean setRandomFragments(Molecule* molecule);
/****************************************************************************************************************************/
static void sortDoubles(double* tab, int n)
{
	int i;
        for (i=0;i<n-1;i++)
	{
		int k = i;
		int j;
		for(j=i+1;j<n;j++) if(tab[j]<tab[k]) k= j;
		if(k!=i) swap2Double(&tab[i],&tab[k]);
	}
}
/****************************************************************************************************************************/
static double sumDoubles(double* tab, int n)
{
	double sum=0;
	int i;
        for (i=0;i<n;i++) sum+= tab[i];
	return sum;
}
/*************************************************************************************************************************/
// sTol = 0.02 , distMaxTol = 0.7 Ang, recommanded in Jorgensen et al JCTC, 2017
static  boolean similarBonds(Molecule* mol1, Molecule* mol2, double sTol, double distMaxTol)
{
	double maxDifference =-1;
	double s =-1;
	s = getSimilatityByBonds(mol1,mol2, &maxDifference);
	fprintf(stderr,"s=%f maxDiffDist=%f\n",s,maxDifference);
	fflush(stderr);
	return (s>=0 && maxDifference>=0 && s<sTol && maxDifference<distMaxTol);
}
/*************************************************************************************************************************/
//Mathias S. Jrgensen , Michael N. Groves, and Bjrk Hammer
//J. Chem. Theory Comput., 2017, 13 (3), pp 14861493
//DOI: 10.1021/acs.jctc.6b01119
static  double getSimilatityByBonds(Molecule* mol1, Molecule* mol2, double* pmaxDifference)
{
	int nAtoms = mol1->nAtoms;
	double* distances1 = NULL;
	double* distances2 = NULL;
	double maxDifference = -1;
	double s = -1;
	int nTypes=0;
	int nTypes2=0;
	int nDists=mol2->nAtoms*(mol2->nAtoms-1)/2;

	*pmaxDifference = maxDifference;
	if(mol1->nAtoms<2 || mol2->nAtoms<2 || mol1->nAtoms != mol2->nAtoms) return s;

	char** types = getTypesOfAtoms(mol1, &nTypes);
	if(nTypes<1) return s;

	char** types2 = getTypesOfAtoms(mol2, &nTypes2);
	if(nTypes2 != nTypes)
	{
		freeTypesOfAtoms(types,nTypes);
		freeTypesOfAtoms(types2,nTypes2);
		return s;
	}

	freeTypesOfAtoms(types2,nTypes2);

	nDists=nAtoms*(nAtoms-1)/2;
	distances1 = getDistancesBetweenAtoms(mol1);
	distances2 = getDistancesBetweenAtoms(mol2);
	int* nAtomsByType = malloc(nTypes*sizeof(int));
	int k;
        for (k=0; k<nTypes; k++) nAtomsByType[k] = 0;

	int i;
        for (i=0;i<mol1->nAtoms;i++)
        	for (k=0; k<nTypes; k++) 
			if(!strcmp(mol1->atoms[i].prop.symbol,types[k])) 
				nAtomsByType[k]++;
		
	double* fab1 = malloc(nDists*sizeof(int));
	double* fab2 = malloc(nDists*sizeof(int));

	s=0;
	maxDifference=-1;
	int l;
        for (k=0; k<nTypes; k++) 
        for (l=k; l<nTypes; l++) 
	{
		int n1=0;
		int it1=0;
		int i,j;
        	for (i=0;i<mol1->nAtoms;i++)
        	for (j=i+1;j<mol1->nAtoms;j++)
		{
			if( (!strcmp(mol1->atoms[i].prop.symbol,types[k]) && !strcmp(mol1->atoms[j].prop.symbol,types[l]))
		     || (!strcmp(mol1->atoms[i].prop.symbol,types[l]) && !strcmp(mol1->atoms[j].prop.symbol,types[k]))
			) fab1[it1++] = distances1[n1];
			n1++;
		}
		int n2=0;
		int it2=0;
        	for (i=0;i<mol2->nAtoms;i++)
        	for (j=i+1;j<mol2->nAtoms;j++)
		{
			if( (!strcmp(mol2->atoms[i].prop.symbol,types[k]) && !strcmp(mol2->atoms[j].prop.symbol,types[l]))
		     || (!strcmp(mol2->atoms[i].prop.symbol,types[l]) && !strcmp(mol2->atoms[j].prop.symbol,types[k]))
			) fab2[it2++] = distances2[n2];
			n2++;
		}
		//fprintf(stderr,"n1=%d n2=%d it1=%d it2=%d\n",n1,n2,it1,it2); fflush(stderr);
		if(n1==n2 && it1==it2)
		{
			sortDoubles(fab1,it1);
			sortDoubles(fab2,it2);
			double sfab1=sumDoubles(fab1,it1);
			double sfab2=sumDoubles(fab2,it2);
			//fprintf(stderr,"sfab1=%f sfab2=%f\n",sfab1,sfab2); fflush(stderr);
			s+= fabs(sfab1-sfab2)/(sfab1+sfab2)*(nAtomsByType[k]+nAtomsByType[l])/(double)(nAtoms);
			int i;
        		for (i=0;i<it1;i++)
			{
				double diff=fabs(fab2[i]-fab1[i]);
				if(maxDifference<0 || maxDifference < diff) maxDifference = diff;
			}
		}
	}

	*pmaxDifference = maxDifference;

	free(nAtomsByType);
	free(fab1);
	free(fab2);
	free(distances1);
	free(distances2);
	freeTypesOfAtoms(types,nTypes);
	return s;
}
/****************************************************************************************************************************/
static double* getDistancesBetweenAtoms(Molecule* mol)
{
	double* distances = NULL;
	int n;
	if(mol->nAtoms<1) return distances;
	n = mol->nAtoms*(mol->nAtoms-1)/2;
	distances = malloc(n*sizeof(double));
	n = 0;
	int i,j;
	for (i = 0; i < mol->nAtoms-1; i++ )
	for (j = i+1; j < mol->nAtoms; j++ )
	{
		double d;
		distances[n] = 0;
		int k;
		for (k = 0; k < mol->nAtoms; k++ )
		{
			d = mol->atoms[i].coordinates[k]-mol->atoms[j].coordinates[k];
			distances[n] += d*d;
		}
		distances[n] = sqrt(distances[n]);
		n++;
	}
	return distances;
}
/****************************************************************************************************************************/
static  boolean oneFragment(Molecule* mol)
{
	// list of atoms connected to atom number 1, directly o indeirectly via a string
	int *list = malloc(mol->nAtoms*sizeof(int));
	int *inGroup = malloc(mol->nAtoms*sizeof(int));
	int nA1=1;
	int i;
	for (i = 0; i<mol->nAtoms; i++)  list[i]=-1;
	for (i = 0; i<mol->nAtoms; i++)  inGroup[i]=0;
	Atom* atoms = mol->atoms;
	int n=0;
	list[0]=0;
	inGroup[0]=1;
	int it=0;
	do{
		it++;
		n=0;
		for (i = 0; i<mol->nAtoms; i++) 
		{
			if(inGroup[i]==1) continue;
			int i1;
			for (i1 = 0; i1<nA1 && nA1<mol->nAtoms; i1++) 
			{
				int j = list[i1];
				double distance = 0;
				int k;
				for (k=0;k<3;k++) 
				{ 
					double dij = atoms[i].coordinates[k]-atoms[j].coordinates[k];
					distance +=dij*dij;
				}
				distance = sqrt(distance);
				double bd = atoms[i].prop.covalentRadii + atoms[j].prop.covalentRadii;
				bd *= BOHRTOANG;
				bd *= 1.2;
				if(distance < bd) { list[nA1+n]=i;n++;inGroup[i]=1;break;}
			}
		}
		nA1 += n;
	}while(n!=0 && it<mol->nAtoms);
	free(list);
	free(inGroup);
	return (mol->nAtoms == nA1);
}
/****************************************************************************************************************************/
static  boolean smallDistance(Molecule* mol)
{
	Atom* atoms = mol->atoms;
	boolean small = FALSE;
	int i,j;
	for (i = 0; i<mol->nAtoms-1 && !small; i++) 
	for (j = i+1; j<mol->nAtoms && !small; j++) 
	{
		double distance = 0;
		int k;
		for (k=0;k<3;k++) 
		{ 
			double dij = atoms[i].coordinates[k]-atoms[j].coordinates[k];
			distance +=dij*dij;
		}
		double bd = atoms[i].prop.covalentRadii + atoms[j].prop.covalentRadii;
		bd *= BOHRTOANG;
		bd *=0.6;
		distance = sqrt(distance);
		if(distance < bd) small=TRUE;
		//if(small) { fprintf(stderr,"d=%f bd =%f\n",distance, bd); fflush(stderr);}
	}
	return small;
}
/****************************************************************************************************************************/
static  boolean compare2Molecules(Molecule* mol1, Molecule* mol2, boolean warning)
{
	boolean ok = TRUE;
	int j;
	if(mol1->nAtoms != mol2->nAtoms)
	{
		ok = FALSE;
		fprintf(stderr,"???????????????  Error Error Error ???????????????????????????????????????????????\n");
		fprintf(stderr," The number of atoms is not the same for geometries in the 2 files\n");
		fprintf(stderr,"       Program QFFPot stopped\n");
		fprintf(stderr,"??????????????????????????????????????????????????????????????????????????????????\n");
		exit(1);
	}
	for(j=0;j<mol1->nAtoms;j++)
	{
		if(strcmp(mol1->atoms[j].prop.symbol,mol2->atoms[j].prop.symbol))
		{
			ok = FALSE;
			break;
		}
	}
	if(!ok) 
	{
		fprintf(stderr,"???????????????  Error Error Error ???????????????????????????????????????????????\n");
		fprintf(stderr," Error the order of atoms is not the same for geometries in the 2 files\n");
		fprintf(stderr,"       Program QFFPot stopped\n");
		fprintf(stderr,"??????????????????????????????????????????????????????????????????????????????????\n");
		for(j=0;j<mol1->nAtoms;j++)
		{
			if(strcmp(mol1->atoms[j].prop.symbol,mol2->atoms[j].prop.symbol))
				fprintf(stderr," %s != %s\n", mol1->atoms[j].prop.symbol,mol2->atoms[j].prop.symbol);
		}
		exit(1);
	}
	if(warning)
	{
		for(j=0;j<mol1->nAtoms;j++)
			if(warning && fabs(mol1->atoms[j].mass-mol2->atoms[j].mass)>1e-6)
				fprintf(stderr," %0.12lf != %0.12lf\n", mol1->atoms[j].mass,mol2->atoms[j].mass);
	}
	return ok;

}
/****************************************************************************************************************************/
static boolean readGeom0(Molecule* mol, char* namefile)
{
	Molecule* molNew = readGeom(namefile);
	*mol = *molNew;
	return TRUE;
}
/*******************************************************************************************************************/
static boolean readMolecule0(Molecule* molecule, char* fileName)
{
	return readGeom0(molecule, fileName);
}
/*******************************************************************************************************************/
/****************************************************************************************************************************/
// q2mat Generate a left rotation matrix from a normalized quaternion
static void q2mat (double q[], double u[][3])
{
        u[0][0] = q[0]*q[0] + q[1]*q[1] - q[2]*q[2] - q[3]*q[3];
        u[1][0] = 2.0 * (q[1] * q[2] - q[0] * q[3]);
        u[2][0] = 2.0 * (q[1] * q[3] + q[0] * q[2]);

        u[0][1] = 2.0 * (q[2] * q[1] + q[0] * q[3]);
        u[1][1] = q[0]*q[0] - q[1]*q[1] + q[2]*q[2] - q[3]*q[3];
        u[2][1] = 2.0 * (q[2] * q[3] - q[0] * q[1]);

        u[0][2] = 2.0 *(q[3] * q[1] - q[0] * q[2]);
        u[1][2] = 2.0 * (q[3] * q[2] + q[0] * q[1]);
        u[2][2] = q[0]*q[0] - q[1]*q[1] - q[2]*q[2] + q[3]*q[3];
}
/**********************************************************************/
static void rotMolecule (Molecule* mol, double u[3][3])
{
	double yx, yy, yz;
	int i;
	/*
	fprintf(stderr,"RotMatrix\n");
	for (i = 0; i < 3; i++)
	{
		int j;
		for (j = 0; j < 3; j++) fprintf(stderr,"%f ",u[i][j]);
		fprintf(stderr,"\n");
	}
	fprintf(stderr,"Mol before rot\n");  
	for(i=0;i<mol->nAtoms;i++)
	{
		fprintf(stderr,"%s ",mol->atoms[i].symbol);
		int j;
		for(j=0;j<3;j++) fprintf(stderr,"%f ",mol->atoms[i].coordinates[j]); 
		fprintf(stderr,"\n");
		
	}
	*/

	for (i = 0; i < mol->nAtoms; i++)
	{
   		yx = u[0][0] * mol->atoms[i].coordinates[0] + u[0][1] * mol->atoms[i].coordinates[1] + u[0][2] * mol->atoms[i].coordinates[2];
   		yy = u[1][0] * mol->atoms[i].coordinates[0] + u[1][1] * mol->atoms[i].coordinates[1] + u[1][2] * mol->atoms[i].coordinates[2];
   		yz = u[2][0] * mol->atoms[i].coordinates[0] + u[2][1] * mol->atoms[i].coordinates[1] + u[2][2] * mol->atoms[i].coordinates[2];

   		mol->atoms[i].coordinates[0] = yx;
   		mol->atoms[i].coordinates[1] = yy;
   		mol->atoms[i].coordinates[2] = yz;
	}
	/*
	fprintf(stderr,"Mol after rot\n");  
	for(i=0;i<mol->nAtoms;i++)
	{
		fprintf(stderr,"%s ",mol->atoms[i].symbol);
		int j;
		for(j=0;j<3;j++) fprintf(stderr,"%f ",mol->atoms[i].coordinates[j]); 
		fprintf(stderr,"\n");
		
	}
	*/
}

/**********************************************************************/
void qTransRotFit (Molecule* molFit, Molecule* molRef, double u[][3])
{
	double xxyx, xxyy, xxyz;
	double xyyx, xyyy, xyyz;
	double xzyx, xzyy, xzyz;
	double c[10];
	double d[4];
	double q[4];
	int i;
	int imax;
	double** v = malloc(4*sizeof(double*));
	for(i=0;i<4;i++) v[i] = malloc(4*sizeof(double));

/* generate the lower triangle of the quadratic form matrix */

	xxyx = 0.0;
	xxyy = 0.0;
	xxyz = 0.0;
	xyyx = 0.0;
	xyyy = 0.0;
	xyyz = 0.0;
	xzyx = 0.0;
	xzyy = 0.0;
	xzyz = 0.0;
 
	for (i = 0; i < molRef->nAtoms; i++)
	{
		//double w = molFit->atoms[i].mass*molFit->atoms[i].mass;
		//double w = molFit->atoms[i].mass;
		double w = 1.0;
		xxyx = xxyx + molFit->atoms[i].coordinates[0]*molRef->atoms[i].coordinates[0]*w;
		xxyy = xxyy + molFit->atoms[i].coordinates[0]*molRef->atoms[i].coordinates[1]*w;
		xxyz = xxyz + molFit->atoms[i].coordinates[0]*molRef->atoms[i].coordinates[2]*w;

		xyyx = xyyx + molFit->atoms[i].coordinates[1]*molRef->atoms[i].coordinates[0]*w;
		xyyy = xyyy + molFit->atoms[i].coordinates[1]*molRef->atoms[i].coordinates[1]*w;
		xyyz = xyyz + molFit->atoms[i].coordinates[1]*molRef->atoms[i].coordinates[2]*w;

		xzyx = xzyx + molFit->atoms[i].coordinates[2]*molRef->atoms[i].coordinates[0]*w;
		xzyy = xzyy + molFit->atoms[i].coordinates[2]*molRef->atoms[i].coordinates[1]*w;
		xzyz = xzyz + molFit->atoms[i].coordinates[2]*molRef->atoms[i].coordinates[2]*w;
	}
	for(i = 0; i <10; i++) c[i] = 0.0;

	c[0] = xxyx + xyyy + xzyz;

	c[1] = xzyy - xyyz;
	c[2] = xxyx - xyyy - xzyz;

	c[3] = xxyz - xzyx;
	c[4] = xxyy + xyyx;
	c[5] = xyyy - xzyz - xxyx;

	c[6] = xyyx - xxyy;
	c[7] = xzyx + xxyz;
	c[8] = xyyz + xzyy;
	c[9] = xzyz - xxyx - xyyy;

/* diagonalize c */
	eigenQL(4, c, d, v);
	imax = 0;
	for(i = 0; i <4; i++) if(d[i]>d[imax]) imax = i;

/* extract the desired quaternion */

	q[0] = v[0][imax];
	q[1] = v[1][imax];
	q[2] = v[2][imax];
	q[3] = v[3][imax];

	/*
	fprintf(stderr,"d=%f %f %f %f dimax = %f\n", d[0], d[1], d[2],d[3],d[imax]);
	fprintf(stderr,"Quat=%f %f %f %f norm=%f\n", q[0], q[1], q[2],q[3],sqrt(q[0]*q[0]+q[1]*q[1]+q[2]*q[2]+q[3]*q[3]));
	*/

/* generate the rotation matrix */
	q2mat (q, u);

	for(i=0;i<4;i++) if(v[i]) free(v[i]);
	if(v) free(v);
}

/**********************************************************************/
static void computeMCenterOfMolecule(Molecule* mol, double C[])
{
	int i;
	int j;
	double mt = 0;
	for(j=0;j<3;j++) C[j] = 0;
	for(i=0;i<mol->nAtoms;i++)
        {
	
                //mt += mol->atoms[i].mass;
                mt += 1.0;
		for(j=0;j<3;j++) C[j] += mol->atoms[i].mass*mol->atoms[i].coordinates[j];
		
                //mt += 1.0; for(j=0;j<3;j++) C[j] += mol->atoms[i].coordinates[j];
        }
	if(mt>0) for(j=0;j<3;j++) C[j] /= mt;
	/*
	fprintf(stderr,"Center = "); for(j=0;j<3;j++) fprintf(stderr,"%f ",C[j]); fprintf(stderr,"\n");
	*/
}
/**********************************************************************/
static void shiftMolecule(Molecule* mol, double C[], double scale)
{
	int i;
	int j;
	/*
	fprintf(stderr,"Before Center = "); for(j=0;j<3;j++) fprintf(stderr,"%f ",C[j]); fprintf(stderr,"\n");
	fprintf(stderr,"Mol\n");  
	for(i=0;i<mol->nAtoms;i++)
	{
		fprintf(stderr,"%s ",mol->atoms[i].symbol);
		for(j=0;j<3;j++) fprintf(stderr,"%f ",mol->atoms[i].coordinates[j]); 
		fprintf(stderr,"\n");
		
	}
	*/
	for(i=0;i<mol->nAtoms;i++)
		for(j=0;j<3;j++) mol->atoms[i].coordinates[j] += C[j]*scale;
	/*
	fprintf(stderr,"After Center = "); for(j=0;j<3;j++) fprintf(stderr,"%f ",C[j]); fprintf(stderr,"\n");
	fprintf(stderr,"Mol\n");  
	for(i=0;i<mol->nAtoms;i++)
	{
		fprintf(stderr,"%s ",mol->atoms[i].symbol);
		for(j=0;j<3;j++) fprintf(stderr,"%f ",mol->atoms[i].coordinates[j]); 
		fprintf(stderr,"\n");
		
	}
	*/
}
/**********************************************************************/
static void centerMolecule(Molecule* mol, double C[])
{
	computeMCenterOfMolecule(mol, C);
	shiftMolecule(mol, C, -1.0);
}
/**********************************************************************/
static boolean fit2Molecule(Molecule* molFit, Molecule* molRef, double u[3][3])
{
	double CFit[3];
	double CRef[3];
	centerMolecule(molFit,CFit);
	centerMolecule(molRef,CRef);

	qTransRotFit (molFit, molRef, u);
	rotMolecule (molFit, u);
	/*
	shiftMolecule(molFit,CRef,1.0);
	shiftMolecule(molRef,CRef,1.0);
	*/
	return TRUE;
}
/**********************************************************************/
static boolean fitRMSD2Molecule(Molecule* molFit, Molecule* molRef, boolean center)
{
	const int N = 8;
        double d[8];
        double w[8][3] = {
                {1,1,1},
                {-1,1,1},
                {1,-1,1},
                {1,1,-1},
                {-1,-1,1},
                {-1,1,-1},
                {1,-1,-1},
                {-1,-1,-1}
        };
        double x, y, z;
        double dmin;
	int jmin = 0;
	int i,j;
        double CFit[3];
        double CRef[3];
	int numberOfEquivalentAxes;
	double inertialMoment[3];
	double axes[3][3];
	double C[3];

	fprintf(stderr,"=======> Center molFit\n");
        centerMolecule(molFit,CFit);
	fprintf(stderr,"=======> Center molRef\n");
        centerMolecule(molRef,CRef);

	fprintf(stderr,"=======> std molFit\n");
	buildStandardOrientation(molFit, C, &numberOfEquivalentAxes, inertialMoment, axes);
	molFit->klass->print(molFit, stderr);
	fprintf(stderr,"=======> std molRef\n");
	buildStandardOrientation(molRef, C, &numberOfEquivalentAxes, inertialMoment, axes);
	molRef->klass->print(molRef, stderr);

	fprintf(stderr,"nAtomsRef=%d\n",molRef->nAtoms);
	fprintf(stderr,"nAtomsFit=%d\n",molFit->nAtoms);
	if(molFit->nAtoms != molRef->nAtoms) return FALSE;
        for (j=0;j<N;j++) d[j] = 0;
        for (i=0;i<molRef->nAtoms;i++)
        {
                for (j=0;j<N;j++)
                {
                	x = molRef->atoms[i].coordinates[0]- w[j][0]*molFit->atoms[i].coordinates[0];
                	y = molRef->atoms[i].coordinates[1]- w[j][1]*molFit->atoms[i].coordinates[1];
                	z = molRef->atoms[i].coordinates[2]- w[j][2]*molFit->atoms[i].coordinates[2];
                	d[j] += x*x + y*y + z*z;
                }
        }
        dmin = d[0];
        for (j=1;j<N;j++) if(dmin>d[j]) {dmin=d[j]; jmin = j;}
	fprintf(stderr,"jmin=%d\n",jmin);
        for (i=0;i<molFit->nAtoms;i++)
	{
                molFit->atoms[i].coordinates[0] *=  w[jmin][0];
                molFit->atoms[i].coordinates[1] *=  w[jmin][1];
                molFit->atoms[i].coordinates[2] *=  w[jmin][2];
	}
	if(!center) 
	{
		shiftMolecule(molFit,CFit,1.0);
		shiftMolecule(molRef,CRef,1.0);
	}
	fprintf(stderr,"=======> after minrms molFit\n");
	molFit->klass->print(molFit, stderr);
	fprintf(stderr,"=======> after minrms molRef\n");
	molRef->klass->print(molRef, stderr);
	return TRUE;
}
/********************************************************************************/
/*********************************************************************************/
static boolean buildMMTypes(Molecule* mol, FILE* file)
{
        char* buildMMTypes = NULL;
        if(readOneString(file,"buildMMTypes",&buildMMTypes) && buildMMTypes)
        {
                mol->klass->resetMMTypes(mol, buildMMTypes);
                free(buildMMTypes);
                return TRUE;
        }
        return FALSE;
}

/*********************************************************************************/
static boolean resetMMTypes(Molecule* mol, char* type)
{
	char* tmp = NULL;
	if(!type) return FALSE;
	tmp = strdup(type);
	uppercase(tmp);
	if(!strcmp(tmp,"AMBERFROMPDB")) 
	{
		buildMMTypesFromPDB(mol, FALSE);
		free(tmp);
		return TRUE;
	}
	if(!strcmp(tmp,"AMBERCHARGEFROMPDB")) 
	{
		buildMMTypesFromPDB(mol, TRUE);
		free(tmp);
		return TRUE;
	}
	if(!strcmp(tmp,"AMBER")) 
	{
		calculAmberTypes(mol);
		free(tmp);
		return TRUE;
	}
	fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
	fprintf(stderr," Error : sorry the %s is not yet implemented\n",type);
	fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
	free(tmp);
	return FALSE;
}
/*********************************************************************************/
static boolean isLinear(Molecule* molecule)
{
	double cm[3] = {0,0,0};
	int i;
	int j;
	int k;
	double mass = 1.0;
	double totMass = 0.0;
	double cdel[3];
	double tensor[3][3];
	double invTensor[3][3];
        double xx, xy,xz,yy,yz,zz;
	Atom* atoms = molecule->atoms;
	int nAtoms = molecule->nAtoms;
	double precision=1e6;
	if(nAtoms<3) return TRUE;

	for ( i = 0; i < nAtoms; i++)
	{
		mass = atoms[i].mass;
		totMass += mass;
		for ( j = 0; j < 3; j++)
			cm[j] += mass*atoms[i].coordinates[j];
	}


	for ( j = 0; j < 3; j++) cm[j] /= totMass;

	/* calculate and invert the inertia tensor */
	for ( k = 0; k < 3; k++)
	for ( j = 0; j < 3; j++)
		tensor[k][j] = 0;
	xx = 0;
	yy = 0;
	zz = 0;
	xy = 0;
	xz = 0;
	yz = 0;
	for ( i = 0; i < nAtoms; i++)
	{
		mass = atoms[i].mass;
		for ( j = 0; j < 3; j++) cdel[j] = atoms[i].coordinates[j]-cm[j];
		xx +=  cdel[0]*cdel[0]*mass;
		xy +=  cdel[0]*cdel[1]*mass;
		xz +=  cdel[0]*cdel[2]*mass;
		yy +=  cdel[1]*cdel[1]*mass;
		yz +=  cdel[1]*cdel[2]*mass;
		zz +=  cdel[2]*cdel[2]*mass;
	}
	tensor[0][0] = yy+zz;
	tensor[1][0] = -xy;
	tensor[2][0] = -xz;
	tensor[0][1] = -xy;
	tensor[1][1] = xx+zz;
	tensor[2][1] = -yz;
	tensor[0][2] = -xz;
	tensor[1][2] = -yz;
	tensor[2][2] = xx+yy;
	if(!InverseTensor(tensor,invTensor)) return TRUE;
	/*
	fprintf(stderr,"InvTensor : ");
	for ( j = 0; j < 3; j++) fprintf(stderr,"%lf ",invTensor[j][j]);
	fprintf(stderr,"\n");
	*/
	for ( j = 0; j < 3; j++) if(fabs(invTensor[j][j])>precision) return TRUE;
	return FALSE;
}
/*********************************************************************************/
static void initWallParameters(WallParameters* parameters, double E0, double rho, int n)
{
	parameters->E0 = E0;
	parameters->rho = fabs(rho);
	parameters->n = abs(n);
}
/*********************************************************************************/
static void initVibrations(Molecule* mol, int nModes, int nProps)
{
	int i;
	int j;
	int k;
	if(!mol) return;
	mol->vibration.nModes = 0;
	mol->vibration.nProperties = 0;
	mol->vibration.modes = NULL;
	if(nModes<1) return;
	mol->vibration.nModes = nModes;
	if(nProps<1) nProps = 1;
	mol->vibration.nProperties = nProps;
	mol->vibration.modes = malloc( mol->vibration.nModes*sizeof(VibMode));
	for(i=0;i< mol->vibration.nModes;i++)
	{
		mol->vibration.modes[i].frequency = 0;
		mol->vibration.modes[i].mass = 1;
		for(j=0;j<3;j++) mol->vibration.modes[i].vectors[j] = malloc(mol->nAtoms*sizeof(double));
		for(j=0;j<3;j++) 
			for(k=0;k<mol->nAtoms;k++)  mol->vibration.modes[i].vectors[j][k] = 0.0;

		mol->vibration.modes[i].properties = malloc(mol->vibration.nProperties*sizeof(double));
		for(k=0;k<mol->vibration.nProperties;k++)  mol->vibration.modes[i].properties[k] = 0.0;
	}
}
/*********************************************************************************/
static void freeVibrations(Molecule* mol)
{
	int i;
	int j;
	if(!mol) return;

	for(i=0;i< mol->vibration.nModes;i++)
	{
		mol->vibration.modes[i].frequency = 0;
		mol->vibration.modes[i].mass = 1;
		for(j=0;j<3;j++) if(mol->vibration.modes[i].vectors[j]) free(mol->vibration.modes[i].vectors[j]);
		if(mol->vibration.modes[i].properties) free(mol->vibration.modes[i].properties);
	}
	if(mol->vibration.modes)free(mol->vibration.modes);
	mol->vibration.nProperties = 0;
	mol->vibration.nModes = 0;
	mol->vibration.modes = NULL;
}
/*********************************************************************************/
static Vibration copyVibrations(Molecule* mol)
{
	int i;
	int j;
	int k;
	Vibration vib;
	vib.nModes = 0;
	vib.nProperties = 0;
	vib.modes = NULL;

	if(!mol) return vib;
	if(mol->vibration.nModes<1) return vib;
	vib.nModes = mol->vibration.nModes;
	vib.nProperties = mol->vibration.nProperties;
	vib.modes = malloc(vib.nModes*sizeof(VibMode));
	for(i=0;i<vib.nModes;i++)
	{
		vib.modes[i].frequency = mol->vibration.modes[i].frequency;
		vib.modes[i].mass = mol->vibration.modes[i].mass;
		for(j=0;j<3;j++) vib.modes[i].vectors[j] = malloc(mol->nAtoms*sizeof(double));
		for(j=0;j<3;j++) 
			for(k=0;k<mol->nAtoms;k++)  vib.modes[i].vectors[j][k] = mol->vibration.modes[i].vectors[j][k];

		vib.modes[i].properties = malloc(mol->vibration.nProperties*sizeof(double));
		for(k=0;k<vib.nProperties;k++)  vib.modes[i].properties[k] = mol->vibration.modes[i].properties[k];
	}
	return vib;
}
/*******************************************************************************************************************/
static void initBoxes(Boxes* boxes, double lx, double ly, double lz, double alpha, double beta, double gamma)
{
        double alphaCos = cos(alpha/RADTODEG);
        double betaSin = sin(beta/RADTODEG);
        double betaCos = cos(beta/RADTODEG);
        double gammaSin = sin(gamma/RADTODEG);
        double gammaCos = cos(gamma/RADTODEG);
        double betaTerm = (alphaCos - betaCos*gammaCos) / gammaSin;
        double gammaTerm = sqrt(betaSin*betaSin - betaTerm*betaTerm);
        double volbox = (gammaSin*gammaTerm) * lx * ly * lz;
	double ar1,ar2,ar3,br1,br2,br3,cr1,cr2,cr3;
	boxes->alpha = alpha;
	boxes->beta = beta;
	boxes->gamma = gamma;

//      real space lattice vectors as rows
	ar1 = lx;
      	ar2 = 0.0;
      	ar3 = 0.0;
      	br1 = ly * gammaCos;
      	br2 = ly * gammaSin;
      	br3 = 0.0;
      	cr1 = lz * betaCos;
      	cr2 = lz * betaTerm;
      	cr3 = lz * gammaTerm;
      	boxes->lVectors[0][0] = ar1;
      	boxes->lVectors[0][1] = ar2;
      	boxes->lVectors[0][2] = ar3;
      	boxes->lVectors[1][0] = br1;
      	boxes->lVectors[1][1] = br2;
      	boxes->lVectors[1][2] = br3;
      	boxes->lVectors[2][0] = cr1;
      	boxes->lVectors[2][1] = cr2;
      	boxes->lVectors[2][2] = cr3;

//     reciprocal lattice vectors as columns

	if (volbox >1e-10)
	{
		boxes->reciprocVectors[0][0] = (br2*cr3 - cr2*br3) / volbox;
         	boxes->reciprocVectors[1][0] = (br3*cr1 - cr3*br1) / volbox;
         	boxes->reciprocVectors[2][0] = (br1*cr2 - cr1*br2) / volbox;
         	boxes->reciprocVectors[0][1] = (cr2*ar3 - ar2*cr3) / volbox;
         	boxes->reciprocVectors[1][1] = (cr3*ar1 - ar3*cr1) / volbox;
         	boxes->reciprocVectors[2][1] = (cr1*ar2 - ar1*cr2) / volbox;
         	boxes->reciprocVectors[0][2] = (ar2*br3 - br2*ar3) / volbox;
         	boxes->reciprocVectors[1][2] = (ar3*br1 - br3*ar1) / volbox;
         	boxes->reciprocVectors[2][2] = (ar1*br2 - br1*ar2) / volbox;
	}
}
/**********************************************************************/
static double getGradientNorm(Molecule* molecule)
{
        double gradientNorm = 0;
	int i,j;
	for (i = 0; i < molecule->nAtoms; i++)
		for ( j = 0; j < 3; j++)
                        gradientNorm += 
				molecule->atoms[i].gradient[j] * 
				molecule->atoms[i].gradient[j]; 

        gradientNorm = sqrt( gradientNorm );
	return gradientNorm;
}
/**********************************************************************/
static double getKineticEnergyMass(Molecule* molecule, double* masses)
{
	double ekin = 0;
	int i;
	int j;
	for ( i = 0; i < molecule->nAtoms; i++)
		for ( j = 0; j < 3; j++)
			ekin += molecule->atoms[i].velocity[j]*
			        molecule->atoms[i].velocity[j]*
			        masses[i];
	ekin /=2;
	return ekin;
}
/**********************************************************************/
static double getKineticEnergy(Molecule* molecule)
{
	double ekin = 0;
	int i;
	int j;
	for ( i = 0; i < molecule->nAtoms; i++)
		for ( j = 0; j < 3; j++)
			ekin += molecule->atoms[i].velocity[j]*
			        molecule->atoms[i].velocity[j]*
			        molecule->atoms[i].mass;
	ekin /=2;
	return ekin;
}
/*****************************************************************************/
/* in Debye */
static void computeDipole(Molecule* mol)
{
	int i,k;
	for(k=0;k<3;k++) mol->dipole[k] = 0;
	for(i=0;i<mol->nAtoms;i++)
	for(k=0;k<3;k++)
		mol->dipole[k] += mol->atoms[i].charge*mol->atoms[i].coordinates[k];
	for(k=0;k<3;k++) mol->dipole[k] *= ANGTOBOHR*AUTODEB;
}
/**********************************************************************/
static void copyChargeInCharge0(Molecule* molecule)
{
	int i;
	for ( i = 0; i < molecule->nAtoms; i++) 
		molecule->atoms[i].charge0 = molecule->atoms[i].charge;
}
/**********************************************************************/
Molecule* newMolecule()
{
	int i;
	Molecule*  molecule = malloc(sizeof(Molecule));

	molecule->klass = malloc(sizeof(MoleculeClass));
	molecule->klass->print = printMolecule;
	molecule->klass->scaleVelocities = scaleVelocities;
	molecule->klass->setMaxwellVelocities = setMaxwellVelocities;
	molecule->klass->setMaxwellVelocitiesIfNull = setMaxwellVelocitiesIfNull;
	molecule->klass->getGradientNorm = getGradientNorm;
	molecule->klass->getKelvin = getKelvin;
	molecule->klass->getKineticEnergy = getKineticEnergy;
	molecule->klass->computeDipole = computeDipole;
	molecule->klass->getKineticEnergyMass = getKineticEnergyMass;
	molecule->klass->removeTranslation = removeTranslation ;
	molecule->klass->removeRotation = removeRotation ;
	molecule->klass->removeTranslationAndRotation = removeTranslationAndRotation ;

	molecule->klass->removeTranslationCluster = removeTranslationCluster ;
	molecule->klass->removeRotationCluster = removeRotationCluster ;
	molecule->klass->removeTranslationAndRotationCluster = removeTranslationAndRotationCluster ;

	molecule->klass->removeTranslationForceCluster = removeTranslationForceCluster ;
	molecule->klass->removeRotationForceCluster = removeRotationForceCluster ;
	molecule->klass->removeTranslationAndRotationForceCluster = removeTranslationAndRotationForceCluster ;

	molecule->klass->removeTranslationForce = removeTranslationForce ;
	molecule->klass->removeRotationForce = removeRotationForce ;
	molecule->klass->removeTranslationAndRotationForce = removeTranslationAndRotationForce ;

	molecule->klass->removeTranslationMoments = removeTranslationMoments ;
	molecule->klass->removeRotationMoments = removeRotationMoments ;
	molecule->klass->removeTranslationAndRotationMoments = removeTranslationAndRotationMoments ;

	molecule->klass->removeTranslationAcceleration = removeTranslationAcceleration ;
	molecule->klass->removeRotationAcceleration = removeRotationAcceleration ;
	molecule->klass->removeTranslationAndRotationAcceleration = removeTranslationAndRotationAcceleration ;
	molecule->klass->resetConstraints = resetConstraints;
	molecule->klass->setRattleConstraintsParameters = setRattleConstraintsParameters;
	molecule->klass->setRandomPositions = setRandomPositions;
	molecule->klass->setRandomPositionsChain = setRandomPositionsChain;
	molecule->klass->setRandomFragments = setRandomFragments;
	molecule->klass->addMolecule = addMolecule;
	molecule->klass->addGeometry = addGeometry;
	molecule->klass->addVelocities = addVelocities;
	molecule->klass->addFirstDerivativeToFile=addFirstDerivativeToFile;
	molecule->klass->readGeometry = readGeometry;
	molecule->klass->compare = compare2Molecules;
	molecule->klass->saveGeometry = saveGeometry;
	molecule->klass->save = saveMolecule;
	molecule->klass->saveMol2 = saveMol2;
	molecule->klass->saveHIN = saveHIN;
	molecule->klass->saveFrequencies = saveFrequencies;
	molecule->klass->computeIR = computeIR;
	molecule->klass->removeFrequencies = removeFrequencies;
	molecule->klass->removeNotSelectedFrequencies = removeNotSelectedFrequencies;
	molecule->klass->saveGeometryAndVelocities = saveGeometryAndVelocities;
	molecule->klass->isLinear = isLinear;
	molecule->klass->copyChargeInCharge0 = copyChargeInCharge0;
	molecule->klass->setBondHardness = setBondHardness;
	molecule->klass->setElectronegativity = setElectronegativity;
	molecule->klass->setWidth = setWidth;
	molecule->klass->setHardness = setHardness;
	molecule->klass->setCharge0 = setCharge0;
	molecule->klass->setChargesEEM = setChargesEEM;
	molecule->klass->setChargesACKS2 = setChargesACKS2;
	molecule->klass->getEnergyEEM = getEnergyEEM;
	molecule->klass->getEnergyACKS2 = getEnergyACKS2;
	molecule->klass->addGeometryToGabedit = addGeometryToGabedit;
	molecule->klass->readGradientFromGabeditFile = readGradientFromGabeditFile;
	molecule->klass->computeFrequenciesFromFiles = computeFrequenciesFromFiles;
	molecule->klass->computeFrequenciesOneStepFromFiles = computeFrequenciesOneStepFromFiles;
	molecule->klass->computeFrequenciesFromGradFiles = computeFrequenciesFromGradFiles;
	molecule->klass->computeFrequenciesOneStepFromGradFiles = computeFrequenciesOneStepFromGradFiles;
	molecule->klass->generateCChemIFilesForFrequencies = generateCChemIFilesForFrequencies;
	molecule->klass->generateCChemIFilesOneStepForFrequencies = generateCChemIFilesOneStepForFrequencies;
	molecule->klass->generateCChemIGradFilesForFrequencies = generateCChemIGradFilesForFrequencies;
	molecule->klass->generateCChemIGradFilesOneStepForFrequencies = generateCChemIGradFilesOneStepForFrequencies;


	molecule->klass->free = freeMolecule;
	molecule->klass->copy = copyMolecule;
	molecule->klass->computeHarmonicVelocitiesCoordinates = computeHarmonicVelocitiesCoordinates;
	molecule->klass->generateQFFCChemIFiles = generateQFFCChemIFiles;
	molecule->klass->getGeomsQFF = getGeomsQFF;

	molecule->klass->read = readMolecule0;
	molecule->klass->readGeomFromMopacOutputFile = readGeomFromMopacOutputFile;
	molecule->klass->readGeomFromGamessOutputFile = readGeomFromGamessOutputFile;
	molecule->klass->readGeomFromOrcaOutputFile = readGeomFromOrcaOutputFile;
	molecule->klass->readGeomFromOpenBabelOutputFile = readGeomFromOpenBabelOutputFile;
	molecule->klass->readGeomFromGaussianOutputFile = readGeomFromGaussianOutputFile;
	molecule->klass->readGeomFromMopacAuxFile = readGeomFromMopacAuxFile;
	molecule->klass->removeTransRotModes = removeTransRotModes;
	molecule->klass->setConnections = setConnections;
	molecule->klass->resetMMTypes = resetMMTypes;
	molecule->klass->buildMMTypes = buildMMTypes;
        molecule->klass->fit = fit2Molecule;
        molecule->klass->fitRMSD = fitRMSD2Molecule;
        molecule->klass->buildStandardOrientation = buildStandardOrientation;
        molecule->klass->center = centerMolecule;
        molecule->klass->saveFirstDerivatives = saveFirstDerivatives;
        molecule->klass->getDeltaTable = getDeltaTable;
        molecule->klass->getQFFOneGeom = getQFFOneGeom;
        molecule->klass->getQFFOneGeom3 = getQFFOneGeom3;
        molecule->klass->getQFFOneGeom4 = getQFFOneGeom4;

        molecule->klass-> computePseudoInertia = computePseudoInertia;
        molecule->klass-> similarInertia = similarInertia;
        molecule->klass-> similarBonds = similarBonds;
        molecule->klass-> makeSphereCutSpliceCrossover = makeSphereCutSpliceCrossover;
        molecule->klass-> makePlaneCutSpliceCrossover = makePlaneCutSpliceCrossover;
        molecule->klass-> makeLocalSphericalMutation = makeLocalSphericalMutation;
        molecule->klass-> makeCenterOfMassSphericalMutation = makeCenterOfMassSphericalMutation;
        molecule->klass-> setGeometryToAxes = setGeometryToAxes;
        molecule->klass-> setRandomOrientation = setRandomOrientation;
        molecule->klass-> smallDistance = smallDistance;
        molecule->klass-> oneFragment = oneFragment;
        molecule->klass-> getDistancesBetweenAtoms = getDistancesBetweenAtoms;
        molecule->klass-> getSimilatityByBonds = getSimilatityByBonds;

	molecule->nAtoms = 0;
	molecule->atoms = NULL;
	molecule->potentialEnergy = 0;
	for(i=0;i<3;i++) molecule->dipole[i] = 0;
	molecule->numberOf2Connections = 0;
	for(i=0;i<2;i++)
		molecule->connected2[i] = NULL;
	molecule->numberOf3Connections = 0;
	for(i=0;i<3;i++)
		molecule->connected3[i] = NULL;
	molecule->numberOf4Connections = 0;
	for(i=0;i<4;i++)
		molecule->connected4[i] = NULL;

	molecule->numberOfNonBonded = 0;
	for(i=0;i<2;i++)
		molecule->nonBonded[i] = NULL;

	molecule->bondHardness = NULL;

	molecule->spinMultiplicity = 1;
	molecule->totalCharge = 0;
	molecule->constraints = NOCONSTRAINTS;
	molecule->nFree = 3* molecule->nAtoms;
	molecule->numberOfRattleConstraintsTerms = 0;

	for(i=0;i<RATTLEDIM;i++)
		molecule->rattleConstraintsTerms[i] = NULL;

	initBoxes(&molecule->boxes, -1,-1,-1,0,0,0);
	initWallParameters(&molecule->wall, 0.0,1.0,2);
	initVibrations(molecule, 0, 0);

	return molecule;

}
/**********************************************************************/
static void freeMolecule(Molecule* molecule)
{

	int i;
        if(molecule->nAtoms<=0) return;
	freeVibrations(molecule);

	if(molecule->atoms != NULL)
	{
		for(i=0;i<molecule->nAtoms;i++)
		{
			if(molecule->atoms[i].prop.symbol != NULL)
				free(molecule->atoms[i].prop.symbol);
			if(molecule->atoms[i].mmType !=NULL )
				free(molecule->atoms[i].mmType);
			if(molecule->atoms[i].pdbType !=NULL )
				free(molecule->atoms[i].pdbType);
			if(molecule->atoms[i].typeConnections !=NULL )
				free(molecule->atoms[i].typeConnections);
		}

		free(molecule->atoms);
		molecule->atoms = NULL;
	}
	molecule->nAtoms = 0;
	molecule->potentialEnergy = 0;
	for(i=0;i<3;i++) molecule->dipole[i] = 0;
	molecule->numberOf2Connections = 0;
	for(i=0;i<2;i++)
	{
		if(molecule->connected2[i] != NULL)
			free(molecule->connected2[i]);
		molecule->connected2[i] = NULL;
	}
	molecule->numberOf3Connections = 0;
	for(i=0;i<3;i++)
	{
		if(molecule->connected3[i] != NULL)
			free(molecule->connected3[i]);
		molecule->connected3[i] = NULL;
	}
	molecule->numberOf4Connections = 0;
	for(i=0;i<4;i++)
	{
		if(molecule->connected4[i] != NULL)
			free(molecule->connected4[i]);
		molecule->connected4[i] = NULL;
	}
	if(molecule->klass) free(molecule->klass);
	for(i=0;i<RATTLEDIM;i++) if(molecule->rattleConstraintsTerms[i]) free(molecule->rattleConstraintsTerms[i]); 
}
/*****************************************************************************/
void createBondedMatrix(Molecule* molecule)
{
	int nAtoms = molecule->nAtoms;
	int i;
	int j;

	if(nAtoms<1)
		return;

	bondedMatrix = malloc(nAtoms*sizeof(boolean*));
	for(i=0;i<nAtoms;i++)
		bondedMatrix[i] = malloc(nAtoms*sizeof(boolean));

	for(i=0;i<nAtoms;i++)
	{
		for(j=0;j<nAtoms;j++)
			bondedMatrix[i][j] = FALSE;

		bondedMatrix[i][i] = TRUE;
	}

}
/*****************************************************************************/
void freeBondedMatrix(Molecule* molecule)
{
	int nAtoms = molecule->nAtoms;
	int i;

	if(bondedMatrix == NULL)
	       return;
	for(i=0;i<nAtoms;i++)
		if(bondedMatrix[i] != NULL)
		       	free(bondedMatrix[i]);

	free(bondedMatrix);
	bondedMatrix = NULL;

}
/*****************************************************************************/
void updatebondedMatrix(int a1, int a2)
{
	bondedMatrix[a1][a2] = TRUE;
	bondedMatrix[a2][a1] = TRUE;

}
/*****************************************************************************/
boolean isConnected2(Molecule* molecule,int i,int j)
{
	double distance;
	double dij;
	int k;
	Atom a1 = molecule->atoms[i];
	Atom a2 = molecule->atoms[j];

	if(molecule->atoms[i].typeConnections)
	{
		 	int nj = molecule->atoms[j].N-1;
			if(molecule->atoms[i].typeConnections[nj]>0) return TRUE;
			else return FALSE;
	}
	distance = 0;
	for (k=0;k<3;k++)
	{
		dij = a1.coordinates[k]-a2.coordinates[k];
		distance +=dij*dij;
	}
	distance = sqrt(distance)/BOHRTOANG;

	if(distance<(a1.prop.covalentRadii+a2.prop.covalentRadii)) return TRUE;
  	else return FALSE;
}
/*****************************************************************************/
void set2Connections(Molecule* molecule)
{
	int i;
	int j;
	int k=0;

	k = molecule->nAtoms;
	k = k*(k-1)/2;
	for(i=0;i<2;i++)
		molecule->connected2[i] = malloc(k*sizeof(int));

	k=0;
	for(i=0;i<molecule->nAtoms-1;i++)
		for(j=i+1;j<molecule->nAtoms;j++)
	{
		if(isConnected2(molecule,i,j))
		{
			molecule->connected2[0][k]= i;
			molecule->connected2[1][k]= j;

			updatebondedMatrix(i,j);

			k++;

		}
	}
	molecule->numberOf2Connections = k;
	if(k==0)
		for(i=0;i<2;i++)
		{
			free(molecule->connected2[i]);
			molecule->connected2[i] = NULL;
		}
	else
		for(i=0;i<2;i++)
			molecule->connected2[i] = realloc(molecule->connected2[i],k*sizeof(int));
	/* printing for test*/
	/*
	printf("%d 2 connections : \n",molecule->numberOf2Connections);
	for(k=0;k<molecule->numberOf2Connections;k++)
	{

		i =  molecule->connected2[0][k];
		j =  molecule->connected2[1][k];
		printf("%d-%d ",i,j);
	}
	printf("\n");
	*/


}
/*****************************************************************************/
static void permut(int* a,int *b)
{
	int c = *a;
	*a = *b;
	*b = c;
}
/*****************************************************************************/
boolean  isConnected3(Molecule* molecule,int n,int i,int j, int k)
{
	int c;
	int a1,a2,a3;
	for(c=0;c<n;c++)
	{
		a1 =  molecule->connected3[0][c];
		a2 =  molecule->connected3[1][c];
		a3 =  molecule->connected3[2][c];
		if(a1==i && a2 == j && a3 == k)
			return TRUE;
	}
	return FALSE;

}
/*****************************************************************************/
boolean  connect3(Molecule* molecule,int n,int i,int j, int k)
{
	if(i>k)permut(&i,&k);
	if(!isConnected3(molecule,n,i,j,k))
	{
		molecule->connected3[0][n]= i;
		molecule->connected3[1][n]= j;
		molecule->connected3[2][n]= k;

		updatebondedMatrix(i,j);
		updatebondedMatrix(i,k);
		updatebondedMatrix(j,k);

		return TRUE;
	}
	return FALSE;

}
/*****************************************************************************/
void set3Connections(Molecule* molecule)
{
	int i;
	int j;
	int k=0;
	int l=0;
	int n=0;

	k = molecule->numberOf2Connections*molecule->nAtoms;
	for(i=0;i<3;i++)
		molecule->connected3[i] = malloc(k*sizeof(int));

	n=0;
	for(k=0;k<molecule->numberOf2Connections;k++)
	{
		i = molecule->connected2[0][k];
		j = molecule->connected2[1][k];
		for(l=0;l<molecule->nAtoms;l++)
		{
			if(l!=i && l!=j)
			{
				if( isConnected2(molecule,i,l))
					if( connect3(molecule,n,l,i,j))
						n++;

				if( isConnected2(molecule,j,l))
					if( connect3(molecule,n,i,j,l))
						n++;
			}
		}

	}
	molecule->numberOf3Connections = n;
	if(n==0)
		for(i=0;i<3;i++)
		{
			free(molecule->connected3[i]);
			molecule->connected3[i] = NULL;
		}
	else
		for(i=0;i<3;i++)
			molecule->connected3[i] = realloc(molecule->connected3[i],n*sizeof(int));
	/* printing for test*/
	/*
	printf("%d 3 connections : \n",molecule->numberOf3Connections);
	for(k=0;k<molecule->numberOf3Connections;k++)
	{

		i =  molecule->connected3[0][k];
		j =  molecule->connected3[1][k];
		l =  molecule->connected3[2][k];
		printf("%d-%d-%d ",i,j,l);
	}
	printf("\n");
	*/


}
/*****************************************************************************/
boolean  isConnected4(Molecule* molecule,int n,int i,int j, int k,int l)
{
	int c;
	int a1,a2,a3,a4;
	for(c=0;c<n;c++)
	{
		a1 =  molecule->connected4[0][c];
		a2 =  molecule->connected4[1][c];
		a3 =  molecule->connected4[2][c];
		a4 =  molecule->connected4[3][c];

		if(a1==i && a2 == j && a3 == k && a4 == l)
			return TRUE;
	}
	return FALSE;

}
/*****************************************************************************/
boolean  connect4(Molecule* molecule,int n,int i,int j, int k,int l)
{
	if(i>l)
	{
		permut(&i,&l);
		permut(&j,&k);
	}
	if(!isConnected4(molecule,n,i,j,k,l))
	{
		molecule->connected4[0][n]= i;
		molecule->connected4[1][n]= j;
		molecule->connected4[2][n]= k;
		molecule->connected4[3][n]= l;

		updatebondedMatrix(i,j);
		updatebondedMatrix(i,k);
		updatebondedMatrix(i,l);
		updatebondedMatrix(j,k);
		updatebondedMatrix(j,l);
		updatebondedMatrix(k,l);

		return TRUE;
	}
	return FALSE;

}
/*****************************************************************************/
void set4Connections(Molecule* molecule)
{
	int i;
	int j;
	int k=0;
	int m=0;
	int l=0;
	int n=0;

	k = molecule->numberOf3Connections*molecule->nAtoms;
	for(i=0;i<4;i++)
		molecule->connected4[i] = malloc(k*sizeof(int));

	n=0;
	for(k=0;k<molecule->numberOf3Connections;k++)
	{
		i = molecule->connected3[0][k];
		j = molecule->connected3[1][k];
		m = molecule->connected3[2][k];
		for(l=0;l<molecule->nAtoms;l++)
		{
			/* a refaire voir Set3Co */
			if(l!=i && l!=j && l!= m)
			{
				if( isConnected2(molecule,i,l))
					if(connect4(molecule,n,l,i,j,m))
						n++;
				if( isConnected2(molecule,m,l))
					if(connect4(molecule,n,i,j,m,l))
						n++;
			}
		}

	}
	molecule->numberOf4Connections = n;
	if(n==0)
		for(i=0;i<4;i++)
		{
			free(molecule->connected4[i]);
			molecule->connected4[i] = NULL;
		}
	else
		for(i=0;i<4;i++)
			molecule->connected4[i] = realloc(molecule->connected4[i],n*sizeof(int));
	/* printing for test*/
	/*
	printf("%d 4 connections : \n",molecule->numberOf4Connections);
	for(k=0;k<molecule->numberOf4Connections;k++)
	{

		i =  molecule->connected4[0][k];
		j =  molecule->connected4[1][k];
		l =  molecule->connected4[2][k];
		m =  molecule->connected4[3][k];
		printf("%d-%d-%d-%d ",i,j,l,m);
	}
	printf("\n");
	*/


}
/*****************************************************************************/
void setNonBondedConnections(Molecule* molecule)
{
	int i;
	int j;
	int k;
	int numberOfNonBonded =0;
	int numberOfAtoms = molecule->nAtoms;
	int *nonBonded[2];

	k = numberOfAtoms;
	k = k*(k-1)/2;
	for(i=0;i<2;i++)
		nonBonded[i] = malloc(k*sizeof(int));

	/* list for all nonbonded connections */
	numberOfNonBonded = 0;
	for (  i = 0; i < numberOfAtoms; i++ )
		for (  j = i + 1; j < numberOfAtoms; j++ )
		{
			if ( !bondedMatrix[ i ][ j ] )
			{
				nonBonded[0][numberOfNonBonded] = i;
				nonBonded[1][numberOfNonBonded] = j;
				numberOfNonBonded++;
			}
		}
	if(numberOfNonBonded==0)
		for(i=0;i<2;i++)
		{
			free(nonBonded[i]);
			nonBonded[i] = NULL;
		}
	else
		for(i=0;i<2;i++)
		{
			nonBonded[i] = realloc(nonBonded[i],numberOfNonBonded*sizeof(int));
		}
	molecule->numberOfNonBonded = numberOfNonBonded;
	for(i=0;i<2;i++)
		molecule->nonBonded[i] = nonBonded[i];
	/* printing for test*/
	/*
	printf("%d nonBonded connections : \n",molecule->numberOfNonBonded);
	for(k=0;k<molecule->numberOfNonBonded;k++)
	{

		i =  molecule->nonBonded[0][k];
		j =  molecule->nonBonded[1][k];
		printf("%d-%d ",i,j);
	}
	printf("\n");
	*/
}
/************************************************************************/
static void setMultipleBonds(Molecule* mol)
{
	int* nBonds = NULL;
	int i;
	int j;
	int nAtoms = mol->nAtoms;
	Atom* atoms = NULL;
	if(nAtoms<1) return;
	nBonds = malloc(nAtoms*sizeof(int));
	atoms = mol->atoms;

	for(i=0;i<(int)nAtoms;i++) nBonds[i] = 0;
	for(i=0;i<(int)nAtoms;i++)
		for(j=i+1;j<(int)nAtoms;j++)
			 if(atoms[i].typeConnections && atoms[i].typeConnections[j]!=0) 
			 {
				 nBonds[i] += 1;
				 nBonds[j] += 1;
			 }
	for(i=0;i<nAtoms;i++)
	{
		SAtomsProp Prop_i = atoms[i].prop;
		if(!atoms[i].typeConnections) continue;
		for(j=i+1;j<nAtoms;j++)
		{
			SAtomsProp Prop_j;
			if(atoms[i].typeConnections[j]==0) continue;
			Prop_j = atoms[j].prop;
			if(
		 	nBonds[i] < Prop_i.maximumBondValence &&
		 	nBonds[j] < Prop_j.maximumBondValence 
			)
			{
				atoms[i].typeConnections[j] = 2;
				if(atoms[j].typeConnections) atoms[j].typeConnections[i] = 2;
				nBonds[i] += 1;
				nBonds[j] += 1;
			}
		}
	}
	for(i=0;i<nAtoms;i++)
	{
		SAtomsProp Prop_i = atoms[i].prop;
		if(!atoms[i].typeConnections) continue;
		for(j=i+1;j<nAtoms;j++)
		{
			SAtomsProp Prop_j;
			if(atoms[i].typeConnections[j]==0) continue;
			Prop_j = atoms[j].prop;
			if(
		 	nBonds[i] < Prop_i.maximumBondValence &&
		 	nBonds[j] < Prop_j.maximumBondValence 
			)
			{
				atoms[i].typeConnections[j] = 3;
				if(atoms[j].typeConnections) atoms[j].typeConnections[i] = 3;
				nBonds[i] += 1;
				nBonds[j] += 1;
			}
		}
	}
	free(nBonds);
}
/*****************************************************************************/
static boolean connected(Molecule* mol, int i,int j)
{
	double distance;
	double dif[3];
	int k;
	double d;

	for (k=0;k<3;k++) dif[k] = mol->atoms[i].coordinates[k] -  mol->atoms[j].coordinates[k];
	distance = 0;
	for (k=0;k<3;k++) distance += dif[k]*dif[k];
	distance = sqrt(distance);
  
	d  = mol->atoms[i].width;
	d += mol->atoms[j].width;
	d *= BOHRTOANG;

	//printf("%d %d dis=%f w=%f\n",i+1,j+1,distance,d);
	if(distance<d) return TRUE;
	else return FALSE;
}
/*****************************************************************************/
static void resetTypeConnections(Molecule* mol)
{
	int i,j;
	int nAtoms = mol->nAtoms;
	Atom* atoms = NULL;
	if(nAtoms<1) return;
	atoms = mol->atoms;
	for(i=0;i<nAtoms;i++)
	{
		if(atoms[i].typeConnections) free(atoms[i].typeConnections);
		atoms[i].typeConnections = malloc(nAtoms*sizeof(int));
		for(j=0;j<nAtoms;j++) atoms[i].typeConnections[j] = 0;
		for(j=0;j<nAtoms;j++) 
			if(i!=j && connected(mol,i,j)) atoms[i].typeConnections[j]=1;
	}
	setMultipleBonds(mol);
}
/*****************************************************************************/
static void setConnections(Molecule* molecule)
{
	createBondedMatrix(molecule);

	/* printf("Set Connection\n");*/
	printf(("Establishing connectivity : 2 connections...\n"));
	set2Connections(molecule);
	printf(("Establishing connectivity : 3 connections...\n"));
	set3Connections(molecule);
	printf(("Establishing connectivity : 4 connections...\n"));
	set4Connections(molecule);
	printf(("Establishing connectivity : non bonded ...\n"));
	setNonBondedConnections(molecule);

	freeBondedMatrix(molecule);
}
/*****************************************************************************/
static Molecule* copyMolecule(Molecule* m)
{

	int i;
	int j;
	int k;
	Molecule* molecule = newMolecule();

	molecule->constraints = m->constraints;
	molecule->nFree = m->nFree;
	molecule->klass = malloc(sizeof(MoleculeClass));
	*molecule->klass = *m->klass;
	molecule->potentialEnergy = m->potentialEnergy;
	for(i=0;i<3;i++) molecule->dipole[i] = m->dipole[i];
	molecule->nAtoms = m->nAtoms;
	molecule->spinMultiplicity =  m->spinMultiplicity;
	molecule->totalCharge =  m->totalCharge;
	if( molecule->nAtoms>0) molecule->atoms = malloc(molecule->nAtoms*sizeof(Atom));
	if(m && m->bondHardness)
	{
		if(molecule->nAtoms>0) molecule->bondHardness = malloc(molecule->nAtoms*(molecule->nAtoms+1)/2*sizeof(double));
		for(i=0;i<molecule->nAtoms*(molecule->nAtoms+1)/2;i++) molecule->bondHardness[i] = m->bondHardness[i];
	}
		

	for(i=0;i<molecule->nAtoms;i++)
	{
		molecule->atoms[i].prop = propAtomGet(m->atoms[i].prop.symbol);
		for(j=0;j<3;j++) molecule->atoms[i].coordinates[j] = m->atoms[i].coordinates[j];
		for(j=0;j<3;j++) molecule->atoms[i].gradient[j] = m->atoms[i].gradient[j];
		for(j=0;j<3;j++) molecule->atoms[i].velocity[j] = m->atoms[i].velocity[j];
		molecule->atoms[i].charge = m->atoms[i].charge;
		molecule->atoms[i].charge0 = m->atoms[i].charge0;
		molecule->atoms[i].electronegativity = m->atoms[i].electronegativity;
		molecule->atoms[i].hardness = m->atoms[i].hardness;
		molecule->atoms[i].width = m->atoms[i].width;
		molecule->atoms[i].mass = m->atoms[i].mass;
		molecule->atoms[i].mmType = strdup(m->atoms[i].mmType);
		molecule->atoms[i].pdbType = strdup(m->atoms[i].pdbType);
		molecule->atoms[i].residueName = strdup(m->atoms[i].residueName);
		molecule->atoms[i].residueNumber = m->atoms[i].residueNumber;
		molecule->atoms[i].layer = m->atoms[i].layer;
		molecule->atoms[i].show = m->atoms[i].show;
		molecule->atoms[i].variable = m->atoms[i].variable;
		molecule->atoms[i].N = m->atoms[i].N;
		molecule->atoms[i].rho = m->atoms[i].rho;
		molecule->atoms[i].U = m->atoms[i].U;

		molecule->atoms[i].typeConnections = NULL; 
		if(m->atoms[i].typeConnections)
		{
			int j;
			molecule->atoms[i].typeConnections = malloc(molecule->nAtoms*sizeof(int));
			for(j=0;j<molecule->nAtoms;j++)
				molecule->atoms[i].typeConnections[j] = m->atoms[i].typeConnections[j];
		}
	}
	/*
	printf("End copyCoordinate\n");
	fflush(stdout);
	*/

	molecule->numberOf2Connections = m->numberOf2Connections;
	k = molecule->numberOf2Connections;
	if(k>0)
	for(j=0;j<2;j++)
	{
		molecule->connected2[j] = malloc(k*sizeof(int));
		for(i=0;i<k;i++) molecule->connected2[j][i] = m->connected2[j][i];
	}
	/*
	printf("End copyConnections2\n");
	fflush(stdout);
	*/
	molecule->numberOf3Connections = m->numberOf3Connections;
	k = molecule->numberOf3Connections;
	if(k>0)
	for(j=0;j<3;j++)
	{
		molecule->connected3[j] = malloc(k*sizeof(int));
		for(i=0;i<k;i++) molecule->connected3[j][i] = m->connected3[j][i];
	}
	/*
	printf("End copyConnections3\n");
	fflush(stdout);
	*/
	molecule->numberOf4Connections = m->numberOf4Connections;
	k = molecule->numberOf4Connections;
	if(k>0)
	for(j=0;j<4;j++)
	{
		molecule->connected4[j] = malloc(k*sizeof(int));
		for(i=0;i<k;i++) molecule->connected4[j][i] = m->connected4[j][i];
	}
	/*
	printf("End copyConnections4\n");
	fflush(stdout);
	*/

	molecule->numberOfNonBonded = m->numberOfNonBonded;
	k = molecule->numberOfNonBonded;
	if(k>0)
	for(j=0;j<2;j++)
	{
		molecule->nonBonded[j] = malloc(k*sizeof(int));
		for(i=0;i<k;i++) molecule->nonBonded[j][i] = m->nonBonded[j][i];
	}
	/*
	printf("End copyNonBonded\n");
	fflush(stdout);
	*/

	/*
	printf("End copyGradient\n");
	fflush(stdout);
	*/
	molecule->numberOfRattleConstraintsTerms = m->numberOfRattleConstraintsTerms;
	k = molecule->numberOfRattleConstraintsTerms;
	if(k>0)
	for(i=0;i<RATTLEDIM;i++)
	{
		molecule->rattleConstraintsTerms[i] = malloc(k*sizeof(double));
		for(j=0;j<k;j++) molecule->rattleConstraintsTerms[i][j] = m->rattleConstraintsTerms[i][j];
	}
	/*
	printf("End copyMolecule\n");
	fflush(stdout);
	*/

	molecule->boxes = m->boxes;
	molecule->wall = m->wall;
	molecule->vibration = copyVibrations(m);

	return molecule;
}
/********************************************************************************/
/*
static void getChargesFromGaussianOutputFile(Molecule* mol, FILE* file)
{
  	char t[BSIZE];
  	char dump[BSIZE];
  	char d[BSIZE];
  	char* pdest;
	int i;
	int ngrad=0;


  	while(!feof(file) )
	{
    		pdest = NULL;
    		if(!fgets(t,BSIZE,file)) break;
    		pdest = strstr( t, "Total atomic charges");
		if(!pdest) // Gaussian 03 
    			pdest = strstr( t, "atomic charges");

		if(pdest)
		{
    			if(!fgets(t,BSIZE,file)) break;

			for(i=0;i<mol->nAtoms;i++)
			{
    				if(!fgets(t,BSIZE,file)) break;
				if(sscanf(t,"%s %s %s",dump,dump,d)==3)
				{
					mol->atoms[i].charge = atof(d);
				}
			}
			break;
		}
		else
		{
          		pdest = strstr( t, "GradGradGrad" );
			if(pdest)
			{
				ngrad++;
			}
			if(ngrad>2)
				break;
		}

	}
}
static void getNaturalChargesFromGaussianOutputFile(Molecule* mol, FILE* file)
{
  	char t[BSIZE];
  	char dump[BSIZE];
  	char d[BSIZE];
  	char* pdest;
	int i;
	int ngrad =0;



  	while(!feof(file) )
	{
    		pdest = NULL;
    		if(!fgets(t,BSIZE,file)) break;
    		pdest = strstr( t, "Summary of Natural Population Analysis:");
		if(!pdest) // Gaussian 03 
    			pdest = strstr( t, "Summary of Natural Population Analysis:");

		if(pdest)
		{
    			if(!fgets(t,BSIZE,file)) break;
    			if(!fgets(t,BSIZE,file)) break;


			if(!strstr(t,"Natural Population"))break;
    			if(!fgets(t,BSIZE,file)) break;
			if(!strstr(t,"Natural"))break;
    			if(!fgets(t,BSIZE,file)) break;
			if(!strstr(t,"Charge"))break;
    			if(!fgets(t,BSIZE,file)) break;
			if(!strstr(t,"-------------"))break;

			for(i=0;i<mol->nAtoms;i++)
			{
    				if(!fgets(t,BSIZE,file)) break;
				if(sscanf(t,"%s %s %s",dump,dump,d)==3)
				{
					mol->atoms[i].charge = atof(d);
				}
			}
			break;
		}
		else
		{
          		pdest = strstr( t, "GradGradGrad" );
			if(pdest)
			{
				ngrad++;
			}
			if(ngrad>2)
				break;
		}

	}
}
static void getEpsChargesFromGaussianOutputFile(Molecule* mol, FILE* file)
{
  	char t[BSIZE];
  	char dump[BSIZE];
  	char d[BSIZE];
  	char* pdest;
	int i;
	int ngrad=0;


  	while(!feof(file) )
	{
    		pdest = NULL;
    		if(!fgets(t,BSIZE,file)) break;
    		pdest = strstr( t, "Charges from ESP fit");
		if(!pdest) // Gaussian 03 
    			pdest = strstr( t, "harges from ESP");

		if(pdest)
		{
    			if(!fgets(t,BSIZE,file)) break;
    			if(!fgets(t,BSIZE,file)) break;

			for(i=0;i<mol->nAtoms;i++)
			{
    				if(!fgets(t,BSIZE,file)) break;
				if(sscanf(t,"%s %s %s",dump,dump,d)==3)
				{
					mol->atoms[i].charge = atof(d);

				}
			}
			break;
		}
		else
		{
          		pdest = strstr( t, "GradGradGrad" );
			if(pdest)
			{
				ngrad++;
			}
			if(ngrad>2)
				break;
		}

	}
}
*/
/********************************************************************************/
static void getChargesFromGamessOutputFile(Molecule* mol, FILE* file)
{
  	char t[BSIZE];
  	char dump[BSIZE];
  	char d[BSIZE];
  	char* pdest;
	int i;


  	while(!feof(file) )
	{
    		pdest = NULL;
    		if(!fgets(t,BSIZE,file)) break;
    		pdest = strstr( t, "TOTAL MULLIKEN AND LOWDIN ATOMIC POPULATIONS");

		if(pdest)
		{
    			if(!fgets(t,BSIZE,file)) break;
			for(i=0;i<mol->nAtoms;i++)
			{
    				if(!fgets(t,BSIZE,file)) break;
				if(sscanf(t,"%s %s %s %s %s %s",dump, dump ,dump, dump, dump, d)==6)
				{
					mol->atoms[i].charge = atof(d);
				}
				else break;
			}
			break;
		}
	}
}
/********************************************************************************/
void getChargesFromOrcaOutputFile(Molecule* mol, FILE* file)
{
  	char t[BSIZE];
  	char dump[BSIZE];
  	char d[BSIZE];
  	char* pdest;
	int i;


	for(i=0;i<mol->nAtoms;i++) mol->atoms[i].charge = 0.0;

  	while(!feof(file) )
	{
    		pdest = NULL;
		if(!fgets(t,BSIZE,file)) break;
		//if(strstr(t,"GEOMETRY OPTIMIZATION CYCLE")) break;
    		pdest = strstr( t, "MULLIKEN ATOMIC CHARGES");

		if(pdest)
		{
			boolean OK = FALSE;
  			while(!feof(file) )
			{
    				if(!fgets(t,BSIZE,file)) break;
				if(strstr(t,"----------------"))
				{
					OK = TRUE;
					break;
				}
			}
			if(!OK) break;

			for(i=0;i<mol->nAtoms;i++)
			{
				if(!fgets(t,BSIZE,file)) break;
				if(sscanf(t,"%s %s %s %s",dump,dump,dump,d)==4)
				{
					mol->atoms[i].charge = atof(d);
				}
			}
			break;
		}
	}
}
/********************************************************************************/
void readGeomFromMopacOutputFile(Molecule* mol, char *fileName, int numgeometry)
{
/*      Change only the coordinates of mol */
	char* t;
	boolean OK;
	char *AtomCoord[5];
	FILE *file;
	int idummy;
	int i;
	int j=0;
	int l;
	int numgeom;
	char *pdest;
	long int geomposok = 0;

	for(i=0;i<5;i++) AtomCoord[i]=malloc(BSIZE*sizeof(char));
	t=malloc(BSIZE*sizeof(char));
	 
	file = fopen(fileName, "r");
	if(file ==NULL)
	{
	 	free(t);
	 	printf(("Sorry\nI can not open %s  mopac output file\n"),fileName);
		exit(1);
	 	return;
	}
	numgeom =0;
	OK=FALSE;
	 while(!feof(file))
	 {
		if(!fgets(t,BSIZE,file))break;
		//pdest = strstr( t, "CARTESIAN COORDINATES");
		pdest = strstr( t, " ATOM   CHEMICAL          X               Y               Z");
		if(pdest) 
		{
			//printf(("%s\n"),pdest);
			if(!fgets(t,BSIZE,file)) {pdest=0;break;}
			//printf(("%s\n"),pdest);
			if(!fgets(t,BSIZE,file)) {pdest=0;break;}
			//printf(("%s\n"),pdest);
			//if(!fgets(t,BSIZE,file)) {pdest=0;break;}
			//printf(("%s\n"),pdest);
		}
		if ( pdest )
		{
			numgeom++;
			geomposok = ftell(file);
			if(numgeom == numgeometry )
			{
				OK = TRUE;
				break;
			}
			if(numgeometry<0)
			{
				OK = TRUE;
			}
		}
	 }
	 if(!OK || numgeom == 0)
	 {
		free(t);
	 	printf(("Sorry\nI can not open %s mopac output file\n"),fileName);
		exit(1);
	 	return;
	  }
	j=-1;
	fseek(file, geomposok, SEEK_SET);
	while(!feof(file) )
	{
		if(!fgets(t,BSIZE,file))break;
		if(isABackspace(t))
		{
			break;
		}
		int ii;
		if(sscanf(t,"%d",&ii)==0) {break;}
		j++;
		if(j> mol->nAtoms-1)
		{
	 		free(t);
	 		printf(("Sorry\nnumber of Atoms read > number of atoms in mol. Mopac output file =  %s\n"),fileName);
			exit(1);
	 		return;
		}
		
		for(ii=0;ii<strlen(t);ii++) if (t[ii]=='*') t[ii] = ' ';
		sscanf(t,"%d %s %s %s %s",&idummy,AtomCoord[0],AtomCoord[1],AtomCoord[2],AtomCoord[3]);
		AtomCoord[0][0]=toupper(AtomCoord[0][0]);
		l=strlen(AtomCoord[0]); 
		if(isdigit(AtomCoord[0][1]))l=1;
		if (l==2) AtomCoord[0][1]=tolower(AtomCoord[0][1]);
		if(l==1)sprintf(t,"%c",AtomCoord[0][0]);
		else sprintf(t,"%c%c",AtomCoord[0][0],AtomCoord[0][1]);
		/* test symbol to do */

		mol->atoms[j].coordinates[0]=atof(AtomCoord[1]);
		mol->atoms[j].coordinates[1]=atof(AtomCoord[2]);
		mol->atoms[j].coordinates[2]=atof(AtomCoord[3]);
	  }
	 fclose(file);
	 free(t);
	 for(i=0;i<5;i++) free(AtomCoord[i]);
}
/********************************************************************************/
void readGeomFromGamessOutputFile(Molecule* mol, char *fileName, int numgeometry)
{
	char *t;
	boolean OK;
	char *AtomCoord[5];
	FILE *file;
	int i;
	int j=0;
	int l;
	int numgeom;
	char dum[100];


	for(i=0;i<5;i++) AtomCoord[i]=malloc(BSIZE*sizeof(char));
  
	t=malloc(BSIZE*sizeof(char));
 	file = fopen(fileName, "rb");
	if(file ==NULL)
	{
		free(t);
		printf(("Sorry\nI can not open %s Firefly (gamess) output file\n"),fileName);
		exit(1);
		return;
	}
	numgeom = 0;
	do 
	{
		OK=FALSE;
		while(!feof(file)){
			fgets(t,BSIZE,file);
			if ( numgeometry==1 && strstr(t,"COORDINATES (BOHR)"))
			{
	  			fgets(t,BSIZE,file);
 				numgeom++;
				if((int)numgeom == numgeometry ) { OK = TRUE; break; }
	  		}
			if ( strstr(t,"COORDINATES OF ALL ATOMS ARE (ANGS)"))
			{
	  			fgets(t,BSIZE,file);
	  			fgets(t,BSIZE,file);
 				numgeom++;
				if((int)numgeom == numgeometry ) { OK = TRUE; break; }
				if(numgeometry<0 ) { OK = TRUE; break; }
	  		}
		}
		if(!OK && (numgeom == 0) ){
			free(t);
			printf(("Sorry\nI can not open read geometry from %s Firefly (gamess) output file\n"),fileName);
			exit(1);
			return;
		}
		if(!OK)break;

		j=-1;
		while(!feof(file) )
		{
			fgets(t,BSIZE,file);
			strDeleten(t);
			if (isABackspace(t)) break;
			if ( !strcmp(t,"\n")) break;
			if ( !strcmp(t,"\r\n")) break;
			j++;
			if(j> mol->nAtoms-1)
			{
	 			free(t);
	 			printf(("Sorry\nnumber of Atoms read > number of atoms in mol. Mopac output file =  %s\n"),fileName);
				exit(1);
	 			return;
			}

			sscanf(t,"%s %s %s %s %s",AtomCoord[0],dum, AtomCoord[1], AtomCoord[2],AtomCoord[3]);
			{
				int k;
				for(k=0;k<(int)strlen(AtomCoord[0]);k++) if(isdigit(AtomCoord[0][k])) AtomCoord[0][k] = ' ';
				deleteAllSpaces(AtomCoord[0]);
			}

			AtomCoord[0][0]=toupper(AtomCoord[0][0]);
			l=strlen(AtomCoord[0]);
			if (l==2) AtomCoord[0][1]=tolower(AtomCoord[0][1]);
			mol->atoms[j].coordinates[0]=atof(AtomCoord[1]);
			mol->atoms[j].coordinates[1]=atof(AtomCoord[2]);
			mol->atoms[j].coordinates[2]=atof(AtomCoord[3]);
			if(j==mol->nAtoms-1) break;
		}
		if(OK && numgeometry>=0) break;
	}while(!feof(file));
	fclose(file);
	free(t);
	for(i=0;i<5;i++) free(AtomCoord[i]);
}
/********************************************************************************/
void readGeomFromOrcaOutputFile(Molecule* mol, char* fileName, int numgeometry)
{
	char *t;
	char *AtomCoord[5];
	FILE *file;
	int i;
	int j=0;
	int l;
	int numgeom;
	char *pdest;
	long int geomposok = 0;

	for(i=0;i<5;i++) AtomCoord[i]=malloc(BSIZE*sizeof(char));
	 
	t=malloc(BSIZE*sizeof(char));
	file = fopen(fileName, "r");
	if(file ==NULL)
	{
	 	free(t);
	 	printf(("Sorry\nI can not open the %s  orca output file\n"),fileName);
	 	return;
	}
	numgeom =0;
	 while(!feof(file))
	 {
		if(!fgets(t,BSIZE,file))break;
		pdest = strstr( t, "CARTESIAN COORDINATES (ANGSTROEM)");
		if(pdest) 
		{
			if(!fgets(t,BSIZE,file))break;
			pdest = strstr( t, "---------------------------------");
		}
		if ( pdest )
		{
			numgeom++;
			geomposok = ftell(file);
			if(numgeom == numgeometry )
			{
				break;
			}
			if(numgeometry<0)
			{
			}
		}
	 }
	 if(numgeom == 0)
	 {
		free(t);
		t = strdup_printf(("Sorry\nI can not read geometry from %s  orca output file\n"),fileName);
		return;
	  }
	j=-1;
	fseek(file, geomposok, SEEK_SET);
	while(!feof(file) )
	{
		if(!fgets(t,BSIZE,file))break;
		pdest = strstr( t, "----------------------------------" );
		if (pdest || isABackspace(t))
		{
			break;
		}
		j++;
		if(j> mol->nAtoms-1)
		{
	 		free(t);
	 		printf(("Sorry\nnumber of Atoms read > number of atoms in mol. Mopac output file =  %s\n"),fileName);
			exit(1);
	 		return;
		}
		sscanf(t,"%s %s %s %s",AtomCoord[0],AtomCoord[1],AtomCoord[2],AtomCoord[3]);
		AtomCoord[0][0]=toupper(AtomCoord[0][0]);
		l=strlen(AtomCoord[0]); 
		if(isdigit(AtomCoord[0][1]))l=1;
		if (l==2) AtomCoord[0][1]=tolower(AtomCoord[0][1]);
		if(l==1)sprintf(t,"%c",AtomCoord[0][0]);
		else sprintf(t,"%c%c",AtomCoord[0][0],AtomCoord[0][1]);
		mol->atoms[j].coordinates[0]=atof(AtomCoord[1]);
		mol->atoms[j].coordinates[1]=atof(AtomCoord[2]);
		mol->atoms[j].coordinates[2]=atof(AtomCoord[3]);
	  }
	 fclose(file);
	 free(t);
	 for(i=0;i<5;i++) free(AtomCoord[i]);
}
/********************************************************************************/
void readGeomFromOpenBabelOutputFile(Molecule* mol, char* fileName, int numgeometry)
{
	FILE* file = NULL;
	char buffer[BSIZE];
	char* pdest = NULL;
	//char* energyTag = "TOTAL ENERGY =";
	char* energyTag = "FINAL ENERGY:";
	char* geomTag = "Geometry";
	char* gradTag = "Gradients:";
	double dum;

	printf("Read geom from %s\n",fileName);
 	file = fopen(fileName, "r");
	if(!file) return;
	 while(!feof(file))
	 {
		if(!fgets(buffer,BSIZE,file))break;
		pdest = strstr( buffer, energyTag);
		if(pdest &&sscanf(pdest+strlen(energyTag)+1,"%lf",&mol->potentialEnergy)==1)
		{
			if(strstr(pdest,"kJ")) mol->potentialEnergy /= KCALTOKJ;
			break;
		}
	 }
	 while(!feof(file))
	 {
		if(!fgets(buffer,BSIZE,file))break;
		if(strstr(buffer, geomTag))
		{
			int i;
			for(i=0;i<mol->nAtoms;i++)
			{
				if(!fgets(buffer,BSIZE,file))break;
				//printf("%s\n",buffer);
				if(sscanf(buffer,"%lf %lf %lf %lf",
					&dum,
					&mol->atoms[i].coordinates[0],
					&mol->atoms[i].coordinates[1],
					&mol->atoms[i].coordinates[2]
					)!=4) break;
			}
			break;
		}
	 }
	 while(!feof(file))
	 {
		if(!fgets(buffer,BSIZE,file))break;
		if(strstr(buffer, gradTag))
		{
			int i;
			for(i=0;i<mol->nAtoms;i++)
			{
				if(!fgets(buffer,BSIZE,file))break;
				//printf("%s\n",buffer);
				if(sscanf(buffer,"%lf %lf %lf",
					&mol->atoms[i].gradient[0],
					&mol->atoms[i].gradient[1],
					&mol->atoms[i].gradient[2]
					)!=3) break;
			}
			break;
		}
	 }
	fclose(file);
}
/***********************************************************************************************/
/*
static boolean readOrcaFile_SpinCharge(Molecule* mol, FILE*file)
{
 	char t[BSIZE];
 	char t1[20];
 	char t2[20];
 	char t3[20];
 	char t4[20];
	int dum;
	int n=0;
	mol->spinMultiplicity = 1;
	mol->totalCharge = 0;
 	while(!feof(file))
	{
		if(!fgets(t,BSIZE,file)) break;
 		if (strstr( t,"Total Charge") && strstr( t,"...") )
		{
			if(5==sscanf(t,"%s %s %s %s %d",t1,t2,t3,t4,&dum)) { mol->totalCharge = dum; n++;}
		}
 		if (strstr( t,"Multiplicity") && strstr( t,"...") )
		{
			if(4==sscanf(t,"%s %s %s %d",t1,t2,t3,&dum)) { mol->spinMultiplicity = dum; n++;}
		}
		if(n>=2) break;
	}
	return n>=2;
}
*/
/***********************************************************************************************/
static boolean readOrcaHessianFile_IR(Molecule* mol, FILE*file, char* tag)
{
	int nFreqs = 0;
 	char t[BSIZE];
	double frequency;
	double val[5] = {0,0,0,0,0};
	int nf;
	int i;
	int j;
	int itype = 0;
        double mu0 = 4*PI*1e-7;
        double eps0 = 1.0/(mu0*slight*slight);
        double   kmmolm1 = 4*PI*PI*PI*NAvogadro/3/hPlank/slight/4/PI/eps0*1e-3*100.0*8.47835267e-30*8.47835267e-30;/* 1e-3 m to km, 100 : cm-1 to m-1 */
	double f = 1.0/sqrt(kmmolm1);
 	while(!feof(file))
	{
		if(!fgets(t,BSIZE,file)) break;
 		if (strstr( t,tag) )
		{
			if(!fgets(t,BSIZE,file)) break;
			sscanf(t,"%d",&nFreqs);
			break;
		}
	}
	if(nFreqs<1) return FALSE;
	if(mol->nAtoms*3 != nFreqs)
	{
		fprintf(stderr,"Error : dimension of ir/raman vector is not equal to 3*number of Atoms\n");
		return FALSE;
	}
	
	if(strstr(tag,"raman_")) { itype = 1; f = 1.0;}
	for(i = 0;i<nFreqs;i++)
	{
		if(!fgets(t,BSIZE,file)) break;
		nf = sscanf(t,"%lf %lf %lf %lf %lf", &frequency,&val[itype],&val[2],&val[3],&val[4]);
		if(nf<5) break;
		
		mol->vibration.modes[i].properties[itype] = val[itype];
		for(j=2;j<5;j++) mol->vibration.modes[i].properties[j] = val[j]*f;
		printf("Freq calc from Hessian = %0.5f Freq from orca = %0.5f\n", frequency, mol->vibration.modes[i].frequency);
	}
	return TRUE;
}
/********************************************************************************/
static boolean readOrcaHessianFile_Hessian(Molecule* mol, FILE*file)
{
	int nFreqs = 0;
 	char t[BSIZE];
	int nblock, iblock;
	double** hessian = NULL;
	double* frequencies = NULL;
	double* effectiveMasses = NULL;
	double** modes = NULL;
	double* F = NULL;
	int jh;
	int nf;
	int i,j,k;
	double v[6];
	int ih[6];
	int c;
	rewind(file);
 	while(!feof(file))
	{
    		if(!fgets(t,BSIZE,file)) break;
 		if (strstr( t,"$hessian") )
		{
    			fgets(t,BSIZE,file);
			/* printf("t=%s\n",t);*/
			sscanf(t,"%d",&nFreqs);
			break;
		}
	}
	//printf("nFreqs = %d\n",nFreqs);
	if(nFreqs<1) return FALSE;
	if(mol->nAtoms*3 != nFreqs)
	{
		fprintf(stderr,"Error : dimension of hessian matrix is not equal to 3*number of Atoms\n");
		return FALSE;
	}
	hessian = malloc(nFreqs*sizeof(double*));
	for(j=0;j<nFreqs;j++) hessian[j] = malloc(nFreqs*sizeof(double));
	for(j=0;j<nFreqs;j++) for(i=0;i<nFreqs;i++) hessian[i][j] = 0.0;

	nblock = nFreqs/6; 
	if(nFreqs%6!=0) nblock++;
	for(iblock = 0;iblock<nblock;iblock++)
	{
		if(!fgets(t,BSIZE,file)) break;
		/* printf("t=%s\n",t);*/
		nf = sscanf(t,"%d %d %d %d %d %d", &ih[0],&ih[1],&ih[2], &ih[3],&ih[4],&ih[5]);
		if(iblock==0 && nf>0)
		{
			nblock = nFreqs/nf; 
			if(nFreqs%nf!=0) nblock++;
		}
		for(j=0;j<nFreqs && !feof(file);j++)
		{
			if(!fgets(t,BSIZE,file)) break;
			/* printf("t=%s\n",t);*/
			nf = sscanf(t,"%d %lf %lf %lf %lf %lf %lf",
					&jh,
					&v[0],&v[1],&v[2],
					&v[3],&v[4],&v[5]
					);
			nf--;
			if(jh<nFreqs && jh>-1)
			for(k=0;k<nf;k++)
			{
		
				if(ih[k]<nFreqs && ih[k]>-1) hessian[jh][ih[k]]  = v[k]; 
			}
		}
	}
        for(i=0;i<mol->nAtoms;i++) for(c=0;c<3;c++) 
	for(j=0;j<mol->nAtoms;j++) for(k=0;k<3;k++) 
		hessian[3*i+c][3*j+k] /= sqrt(mol->atoms[i].mass*mol->atoms[j].mass)*AMUTOAU;

	/* symmetrize */
        for(i=0;i<nFreqs;i++)
        for(j=0;j<i;j++)
	{
		hessian[i][j] = (hessian[i][j]+hessian[j][i])/2;
		hessian[j][i] = hessian[i][j];
	}

	/* printf("Ok end div mass\n");*/
	modes = malloc(nFreqs*sizeof(double*));
	for(j=0;j<nFreqs;j++) modes[j] = malloc(nFreqs*sizeof(double));
	frequencies = malloc(nFreqs*sizeof(double));
	effectiveMasses = malloc(nFreqs*sizeof(double));
	/* printf("Ok end read hessian\n");*/
	F = malloc(nFreqs*(nFreqs+1)/2*sizeof(double));
        /* F is an inf symmetric matrix */
        k = -1;
        for(i=0;i<nFreqs;i++)
        for(j=0;j<=i;j++)
        {
                k++;
		F[k] = hessian[i][j];
        }

	eigenQL(nFreqs, F, frequencies, modes);
	free(F);
	/* printf("Ok end eigenQL hessian\n");*/
        /* convert frequencies in cm-1 */
        for(i=0;i<nFreqs;i++)
             if( (frequencies)[i]>0) frequencies[i] = sqrt(frequencies[i])*AUTOCM1;
             else frequencies[i] = -sqrt(-frequencies[i])*AUTOCM1;

        /* for(i=0;i<nFreqs;i++) printf("freq = %f\n",frequencies[i]);*/

        /* compute the effective masses */
        for(i=0;i<nFreqs;i++)
        {
                double m = 0;
                for(j=0;j<mol->nAtoms;j++)
                {
                        double r2 = 0;
                        for(c=0;c<3;c++) r2+= modes[3*j+c][i]*modes[3*j+c][i];
			/* printf("masse = %f\n", GeomOrb[j].Prop.masse);*/
                        m+= r2/(mol->atoms[j].mass);
                }
                if(m<=0) m = 1;
                m = 1.0/m;
                for(j=0;j<mol->nAtoms;j++)
                {
                        double r =sqrt(m)/sqrt(mol->atoms[j].mass);
                        for(c=0;c<3;c++) modes[3*j+c][i] *= r;
                }

                //printf("%f %f\n",(*frequencies)[i],m);
                effectiveMasses[i] = m;
        }
	for(i=0;i<nFreqs;i++)
	{
		mol->vibration.modes[i].frequency = frequencies[i];
		mol->vibration.modes[i].mass = effectiveMasses[i];
		for(c=0;c<3;c++)
		{
			for(j=0;j<mol->nAtoms;j++) mol->vibration.modes[i].vectors[c][j] = modes[3*j+c][i];
		}
	}
	mol->vibration.nModes = nFreqs;
	sortFrequencies(mol);
	/* free tables */
	if(hessian) for(j=0;j<nFreqs;j++) if(hessian[j]) free(hessian[j]);
	if(hessian) free(hessian);
	if(modes) for(j=0;j<nFreqs;j++) if(modes[j]) free(modes[j]);
	if(modes) free(modes);
	if(frequencies) free(frequencies);
	return TRUE;
}
/********************************************************************************/
static boolean readVibrationFromOrcaHessianFile(Molecule* mol, char *fileName)
{
 	FILE *file;


	initVibrations(mol, 3*mol->nAtoms,5);
 	file = fopen(fileName, "rb");
	if(!file) return FALSE;

	if(readOrcaHessianFile_Hessian(mol,file))
	{
		rewind(file);
		readOrcaHessianFile_IR(mol, file, "$ir_spectrum");
		readOrcaHessianFile_IR(mol, file, "$raman_spectrum");
	}
	if(mol->vibration.nModes<1) 
	{
 		char t[BSIZE];
		freeVibrations(mol);
		sprintf(t,"Sorry, I can not read frequencies from '%s' file\n",fileName);
  		fprintf(stderr,"%s\n",t);
		fclose(file);
		return FALSE;
	}
	sortFrequencies(mol);
	removeTransRotModes(mol);
	fclose(file);
	return TRUE;
}
/********************************************************************************/
static Molecule* getMoleculeFromOrcaHessianFile(char *fileName)
{
	Molecule* mol = NULL;
 	char *t;
 	char *AtomCoord[5];
 	FILE *file;
 	int i;
 	int j=0;
 	int l;
	double mass;
	int nAtoms = 0;
	int totalCharge = 0;
	int spinMultiplicity = 1;
 	char t1[20];
 	char t2[20];
 	char t3[20];
 	char t4[20];
	int dum;

 	for(i=0;i<5;i++) AtomCoord[i]=malloc(BSIZE*sizeof(char));
  
 	file = fopen(fileName, "rb");
	t = malloc(BSIZE*sizeof(char));

	while(!feof(file))
	{
		if(!fgets(t,BSIZE,file))break;
		if(strstr( t, "$atoms"))
		{
			if(!fgets(t,BSIZE,file))break;
			sscanf(t,"%d",&nAtoms);
			break;
		}
 		if (strstr( t,"Total Charge") && strstr( t,"...") ) if(5==sscanf(t,"%s %s %s %s %d",t1,t2,t3,t4,&dum)) { totalCharge = dum;}
 		if (strstr( t,"Multiplicity") && strstr( t,"...") ) if(4==sscanf(t,"%s %s %s %d",t1,t2,t3,&dum)) { spinMultiplicity = dum;}
	}
	if(nAtoms == 0)
	{
 		fclose(file);
 		free(t);
 		for(i=0;i<5;i++) free(AtomCoord[i]);
		return NULL;
	}
	mol = newMolecule();
	mol->nAtoms = nAtoms;
	mol->atoms = malloc(mol->nAtoms*sizeof(Atom));
 	for(j=0;j<nAtoms;j++)
  	{
		if(!fgets(t,BSIZE,file))break;
   		sscanf(t,"%s %lf %s %s %s",AtomCoord[0],&mass,AtomCoord[1],AtomCoord[2],AtomCoord[3]);
		/* printf("t=%s\n",t);*/
		AtomCoord[0][0]=toupper(AtomCoord[0][0]);
 		l=strlen(AtomCoord[0]);
       		if (l==2) 
		{
			AtomCoord[0][1]=tolower(AtomCoord[0][1]);
			if(isdigit(AtomCoord[0][1]))l=1;
		}
		if(l==1)sprintf(t,"%c",AtomCoord[0][0]);
	        else sprintf(t,"%c%c",AtomCoord[0][0],AtomCoord[0][1]);

		mol->atoms[j].prop = propAtomGet(t);
                mol->atoms[j].mmType=strdup(t);
                mol->atoms[j].pdbType=strdup(t);
                mol->atoms[j].residueName=strdup(t);
                mol->atoms[j].N=j+1;
                mol->atoms[j].layer=HIGH_LAYER;
                mol->atoms[j].variable=TRUE;
                mol->atoms[j].show=TRUE;
		mol->atoms[j].residueNumber=0;
                mol->atoms[j].charge=0.0;
                mol->atoms[j].charge0=0.0;
                mol->atoms[j].electronegativity=0.0;
                mol->atoms[j].hardness=0.0;
	   	mol->atoms[j].width=mol->atoms[j].prop.covalentRadii;
                mol->atoms[j].mass=mass;
                mol->atoms[j].rho=0.0;
                mol->atoms[j].U = 0.0;

                mol->atoms[j].coordinates[0]=atof(AtomCoord[1])*BOHRTOANG;
                mol->atoms[j].coordinates[1]=atof(AtomCoord[2])*BOHRTOANG;
                mol->atoms[j].coordinates[2]=atof(AtomCoord[3])*BOHRTOANG;

                mol->atoms[j].gradient[0]=0.0;
                mol->atoms[j].gradient[1]=0.0;
                mol->atoms[j].gradient[2]=0.0;

                mol->atoms[j].velocity[0]=0.0;
                mol->atoms[j].velocity[1]=0.0;
                mol->atoms[j].velocity[2]=0.0;
  	}
        mol->dipole[0]=0.0;
        mol->dipole[1]=0.0;
        mol->dipole[2]=0.0;
	rewind(file);
 	get_dipole_from_orca_output_file(file, mol->dipole);
	rewind(file);
	getChargesFromOrcaOutputFile(mol,file);
 	fclose(file);
 	free(t);
 	for(i=0;i<5;i++) free(AtomCoord[i]);
        for(i=0; i<mol->nAtoms; i++) mol->atoms[i].typeConnections = NULL;
	resetTypeConnections(mol);
        int connections = 1;
        if(connections) setConnections(mol);
        else
        {
                createBondedMatrix(mol);
                printf(("Establishing connectivity : non bonded ...\n"));
                setNonBondedConnections(mol);
                freeBondedMatrix(mol);
        }

        /* if all freezed, set all to variable */
        {
                int j = 0;
                for(i=0;i<mol->nAtoms;i++)
                        if(!mol->atoms[i].variable) j++;
                if(j==mol->nAtoms)
                for(i=0;i<mol->nAtoms;i++)
                        mol->atoms[i].variable = TRUE;
        }
	mol->totalCharge = totalCharge;
	mol->spinMultiplicity = spinMultiplicity;
	return mol;
}
/********************************************************************************/
Molecule* readMoleculeFromOrcaHessianFile(char *fileName)
{
	Molecule* mol = getMoleculeFromOrcaHessianFile(fileName);
	readVibrationFromOrcaHessianFile(mol, fileName);
	readDipolesDerivativesFromOrcaHessianFile(mol, fileName);
	return mol;
	
}
/********************************************************************************/
void readGeomFromGaussianOutputFile(Molecule* mol, char *fileName, int numgeometry)
{
	char *t;
	boolean	OK;
	char *AtomCoord[5];
	FILE *file;
	int taille=BSIZE;
	int idummy;
	int i;
	int j=0;
	/* int l;*/
	int numgeom;
	char *pdest;
	int result;
	int itype=0;
	char* strStandard = "Standard orientation:";
	char* strInput = "Input orientation:";
	char* strOther = "orientation:";
	char* strSearch = strOther;

	for(i=0;i<5;i++) AtomCoord[i]=malloc(taille*sizeof(char));
	 
	t=malloc(taille*sizeof(char));
	file = fopen(fileName, "r");
	if(file ==NULL)
	{
		free(t);
	 	t = strdup_printf(("Sorry\nI can not open %s  file "),fileName);
	 	printf("%s\n",t);
	 	free(t);
	 	exit(1);
	}
	while(!feof(file))
	{
		 if(!fgets(t,taille,file))break;
	         if(strstr( t, strStandard))
		 {
			 strSearch = strStandard;
			 break;
		 }
	         if(strstr( t, strInput)) strSearch = strInput;
	}
	fseek(file, 0L, SEEK_SET);
	numgeom =0;
	do 
	{
		OK=FALSE;
		while(!feof(file))
		{
		 	fgets(t,taille,file);
			/*
		 	if(strstr(t,"Charge =") && strstr(t,"Multiplicity ="))
		 	{
				 char* p = strstr(t,"Charge =")+8;
			 	TotalCharges[0] = atoi(p);
			 	p = strstr(t,"Multiplicity =")+14;
			 	SpinMultiplicities[0] = atoi(p);
		 	}
			*/
	         	pdest = strstr( t, strSearch);
	         	result = pdest - t ;
			if ( result >0 )
		 	{
		 		fgets(t,taille,file);
		 		fgets(t,taille,file);
		 		fgets(t,taille,file);
	               		pdest = strstr( t, "Type" );
	               		result = pdest - t ;
	               		if(result>0) itype=1;
	               		else itype=0;
		 		fgets(t,taille,file);
	               		numgeom++;
	               		if(numgeom == numgeometry )
				{
					OK = TRUE;
		 			break;
				}
				OK = TRUE;
				break;
			}
		}
		if(!OK && (numgeom == 0) )
		{
	 		free(t);
	 		t = strdup_printf(("Sorry\nI can not read geometry in  %s  file "),fileName);
	 		printf("%s\n",t);
	 		free(t);
	 		return;
	   	}
	 	if(!OK)break;

	 	j=-1;
	 	while(!feof(file) )
	 	{
	   		fgets(t,taille,file);
	   		pdest = strstr( t, "----------------------------------" );
	   		result = pdest - t ;
	   		if ( result >0 )
	   		{
				/*
				long geomposok = ftell(file);
	     			get_dipole_from_gaussian_output_file(file);
				fseek(file, geomposok, SEEK_SET);
				get_charges_from_gaussian_output_file(file,j+1);
				get_natural_charges_from_gaussian_output_file(file,j+1);
				fseek(file, geomposok, SEEK_SET);
				get_esp_charges_from_gaussian_output_file(file,j+1);
				*/
	     			break;
	   		}
	   		j++;

	   		if(itype==0) sscanf(t,"%d %s %s %s %s",&idummy,AtomCoord[0],AtomCoord[1],AtomCoord[2],AtomCoord[3]);
	   		else sscanf(t,"%d %s %d %s %s %s",&idummy,AtomCoord[0],&idummy,AtomCoord[1],AtomCoord[2],AtomCoord[3]);
			/* to do : test symbol */
			/*
			AtomCoord[0][0]=toupper(AtomCoord[0][0]);
			l=strlen(AtomCoord[0]);
	         	if (l==2) AtomCoord[0][1]=tolower(AtomCoord[0][1]);
			*/


			mol->atoms[j].coordinates[0]=atof(AtomCoord[1]);
			mol->atoms[j].coordinates[1]=atof(AtomCoord[2]);
			mol->atoms[j].coordinates[2]=atof(AtomCoord[3]);

	   		mol->atoms[j].charge=0.0;
	   		mol->atoms[j].charge0=0.0;
	   		mol->atoms[j].electronegativity=0.0;
	   		mol->atoms[j].hardness=0.0;
	   		mol->atoms[j].width=mol->atoms[j].prop.covalentRadii;
	   		mol->atoms[j].rho=0.0;
	   		mol->atoms[j].U = 0.0;
		}
		if(OK && numgeometry>-1) break;
	}while(!feof(file));

	fclose(file);
	free(t);
	for(i=0;i<5;i++) free(AtomCoord[i]);
}
/********************************************************************************/
static boolean readVibrationFromMopacAuxFile(Molecule* mol, char* fileName)
{
	char** freqs = NULL;
	int nFreqs = 0;
	int numberOfFrequencies = 0;
	char** symmetries = NULL;
	int nSymmetries = 0;
	char** modes = NULL;
	int nModes = 0;
	char** intensities = NULL;
	char** effectiveMass = NULL;
	int nIntensities = 0;
	int nEffectiveMass = 0;
	int i,j, c, im;
	FILE* file;
	int nProps = 0;

	if(!mol) return FALSE;
	if(mol->nAtoms<1) return FALSE;
	if(!fileName) return FALSE; 
	file = fopen(fileName,"rb");
	if(!file) { return FALSE; }
	nModes = 0;

	rewind(file);
	freqs = get_one_block_from_aux_mopac_file(file, "VIB._FREQ:CM(-1)[",  &nFreqs);
	/* numberOfFrequencies = nFreqs-6;*/
	numberOfFrequencies = nFreqs;
	if(!freqs || numberOfFrequencies <mol->nAtoms*3)
	{
		char buffer[BSIZE];
		free_one_string_table(freqs, nFreqs);
		sprintf(buffer,"Sorry, I can not read the frequencies from '%s' file\n",fileName);
  		fprintf(stderr,"%s\n",buffer);
		fclose(file);
		return FALSE;
	}
	rewind(file);
	symmetries = get_one_block_from_aux_mopac_file(file, "NORMAL_MODE_SYMMETRY_LABELS[",  &nSymmetries);
	if(!symmetries || nSymmetries<mol->nAtoms*3)
	{
		nSymmetries = nFreqs;
		symmetries = malloc(nSymmetries*sizeof(char*));
		for(i=0;i<nSymmetries;i++)
		{
			symmetries[i] = strdup("UNK");
		}
	}
	rewind(file);
	intensities = get_one_block_from_aux_mopac_file(file, "VIB._T_DIP:ELECTRONS[",  &nIntensities);
	if(!intensities || nIntensities<mol->nAtoms*3)
	{
		nIntensities = nFreqs;
		intensities = malloc(nIntensities*sizeof(char*));
		for(i=0;i<nIntensities;i++)
		{
			intensities[i] = strdup("0.0");
		}
	}
	rewind(file);
	effectiveMass = get_one_block_from_aux_mopac_file(file, "VIB._EFF_MASS:AMU[",  &nEffectiveMass);
	if(!effectiveMass || nEffectiveMass<mol->nAtoms*3)
	{
		nEffectiveMass = nFreqs;
		effectiveMass = malloc(nEffectiveMass*sizeof(char*));
		for(i=0;i<nEffectiveMass;i++)
		{
			effectiveMass[i] = strdup("1.0");
		}
	}

	rewind(file);
	modes = get_one_block_from_aux_mopac_file(file, "NORMAL_MODES[",  &nModes);
	if(!modes || nModes<mol->nAtoms*3*numberOfFrequencies)
	{
		char buffer[BSIZE];
		free_one_string_table(freqs, nFreqs);
		free_one_string_table(symmetries, nSymmetries);
		free_one_string_table(intensities, nIntensities);
		free_one_string_table(effectiveMass, nEffectiveMass);
		free_one_string_table(modes, nModes);
		sprintf(buffer,"Sorry, I can not read the modes of frequencies from '%s' file\n",fileName);
  		fprintf(stderr,"%s\n",buffer);
		fclose(file);
		exit(1);
		return FALSE;
	}
	nModes = numberOfFrequencies;
	nProps = 1;

	initVibrations(mol, nModes, nProps);
	for(i=0;i<mol->vibration.nModes;i++) 
	for(j=0;j<mol->nAtoms;j++) 
	for(c=0;c<3;c++) mol->vibration.modes[i].vectors[c][j] = 0.0; 

	im = 0;
	for(i=0;i<mol->vibration.nModes;i++)
	{
		mol->vibration.modes[i].frequency = atof(freqs[i]);
		mol->vibration.modes[i].properties[0] = atof(intensities[i]);
		mol->vibration.modes[i].mass = atof(effectiveMass[i]);
		for(j=0;j<mol->nAtoms;j++) 
		{
			for(c=0;c<3;c++)
			{
				mol->vibration.modes[i].vectors[c][j] = atof(modes[im]);
				im++;
			}
		}
	}
	sortFrequencies(mol);
	removeTransRotModes(mol);
	free_one_string_table(freqs, nFreqs);
	free_one_string_table(symmetries, nSymmetries);
	free_one_string_table(intensities, nIntensities);
	free_one_string_table(effectiveMass, nEffectiveMass);
	free_one_string_table(modes, nModes);
	return TRUE;
}
/********************************************************************************/
static void readGeomFromMopacAuxFile(Molecule* mol, char *fileName,int numgeometry)
{
	char *t;
	boolean ok;
	char *AtomCoord[5];
	FILE *file;
	int i;
	int j=0;
	int l;
	int numgeom;
	char *pdest;
	long int geomposok = 0;
	char** elements = NULL;
	int nElements = 0;
	char** nuclearCharges = NULL;
	int nNuclearCharges = 0;
	char** partialCharges = NULL;
	int nPartialCharges = 0;

	if(!mol) {exit(1); return;}
	for(i=0;i<5;i++) AtomCoord[i] = malloc(BSIZE*sizeof(char));
	 
	t=malloc(BSIZE*sizeof(char));
	file = fopen(fileName, "rb");
	if(file ==NULL)
	{
	 	free(t);
	 	t = strdup_printf("Sorry\nI can not open %s file ",fileName);
		fprintf(stderr,"Error : %s\n",t);
	 	free(t);
		exit(1);
	 	return;
	}
	ok=FALSE;
	elements = get_one_block_from_aux_mopac_file(file, "ATOM_EL[",  &nElements);
	if(elements) ok = TRUE;
	if(!ok) 
	{
	 	free(t);
	 	t = strdup_printf("Sorry\nI can not read the atom symbols in %s file ",fileName);
		fprintf(stderr,"Error : %s\n",t);
	 	free(t);
		fclose(file);
		exit(1);
	 	return;
	 }
 	geomposok = ftell(file);
	nuclearCharges = get_one_block_from_aux_mopac_file(file, "ATOM_CORE[",  &nNuclearCharges);
	if(!nuclearCharges) fseek(file, geomposok, SEEK_SET);

	numgeom =0;
	 while(!feof(file))
	 {
		if(!fgets(t,BSIZE,file))break;
		if(numgeometry<0) pdest = strstr( t, "ATOM_X_OPT:ANGSTROMS");
		else pdest = strstr( t, "ATOM_X_UPDATED:ANGSTROMS");
		if (pdest)
		{
			numgeom++;
			geomposok = ftell(file);
			if(numgeom == numgeometry )
			{
				ok = TRUE;
				break;
			}
			if(numgeometry<0)
			{
				ok = TRUE;
			}
		}
	 }
	 if(numgeom == 0)
	 {
		free_one_string_table(elements, nElements);
		free(t);
		t = strdup_printf("Sorry\nI can not read geometry in %s file ",fileName);
		fprintf(stderr,"Error : %s\n",t);
		free(t);
		fclose(file);
		exit(1);
		return;
	  }

	mol->klass->free(mol);
	j=-1;
	fseek(file, geomposok, SEEK_SET);
	while(!feof(file) )
	{
		if(!fgets(t,BSIZE,file))break;
		if(strstr( t, "[")
		  || strstr(t,"HEAT_OF_FORM_UPDATED")
		  || strstr( t, "####################################")
		  || isABackspace(t) )
		{
			break;
		}
		if(j+1>nElements)break;
		j++;

		sscanf(t,"%s %s %s",AtomCoord[1],AtomCoord[2],AtomCoord[3]);
		if(j<nElements) sprintf(AtomCoord[0],"%s",elements[j]);
		else sprintf(AtomCoord[0],"X");
		AtomCoord[0][0]=toupper(AtomCoord[0][0]);
		l=strlen(AtomCoord[0]); 
		if (l==2) AtomCoord[0][1]=tolower(AtomCoord[0][1]);
		if(l==1)sprintf(t,"%c",AtomCoord[0][0]);
		else sprintf(t,"%c%c",AtomCoord[0][0],AtomCoord[0][1]);

	        mol->atoms = realloc(mol->atoms,(j+1)*sizeof(Atom));

                mol->atoms[j].prop = propAtomGet(t);
                mol->atoms[j].mmType=strdup(t);
                mol->atoms[j].pdbType=strdup(t);
                mol->atoms[j].residueName=strdup(t);
                mol->atoms[j].N=j+1;
                mol->atoms[j].layer=HIGH_LAYER;
                mol->atoms[j].variable=TRUE;
                mol->atoms[j].show=TRUE;
		mol->atoms[j].residueNumber=0;
                mol->atoms[j].charge=0.0;
                mol->atoms[j].charge0=0.0;
                mol->atoms[j].electronegativity=0.0;
                mol->atoms[j].hardness=0.0;
	   	mol->atoms[j].width=mol->atoms[j].prop.covalentRadii;
                mol->atoms[j].mass=mol->atoms[j].prop.mass;
                mol->atoms[j].rho=0.0;
                mol->atoms[j].U = 0.0;

                mol->atoms[j].coordinates[0]=atof(AtomCoord[1]);
                mol->atoms[j].coordinates[1]=atof(AtomCoord[2]);
                mol->atoms[j].coordinates[2]=atof(AtomCoord[3]);

                mol->atoms[j].gradient[0]=0.0;
                mol->atoms[j].gradient[1]=0.0;
                mol->atoms[j].gradient[2]=0.0;

                mol->atoms[j].velocity[0]=0.0;
                mol->atoms[j].velocity[1]=0.0;
                mol->atoms[j].velocity[2]=0.0;
		if(nuclearCharges && nNuclearCharges>j) mol->atoms[j].charge0 = atof(nuclearCharges[j]);
	}
        mol->nAtoms = j+1;

	if(numgeometry<0)
	{
		fseek(file, geomposok, SEEK_SET);
		partialCharges = get_one_block_from_aux_mopac_file(file, "ATOM_CHARGES[",  &nPartialCharges);
		if(partialCharges)
		{
    			for(j=0;j<mol->nAtoms;j++) 
				if(j<nPartialCharges) mol->atoms[j].charge = atof(partialCharges[j]);
			free_one_string_table(partialCharges, nPartialCharges);
		}
	}
	get_dipole_from_mopac_aux_file(file, mol->dipole);
	fclose(file);
	free(t);

	free_one_string_table(elements, nElements);
        free_one_string_table(nuclearCharges, nNuclearCharges);

	for(i=0;i<5;i++) free(AtomCoord[i]);
        for(i=0; i<mol->nAtoms; i++) mol->atoms[i].typeConnections = NULL;
	resetTypeConnections(mol);
        int connections = 1;
        if(connections) setConnections(mol);
        else
        {
                createBondedMatrix(mol);
                printf(("Establishing connectivity : non bonded ...\n"));
                setNonBondedConnections(mol);
                freeBondedMatrix(mol);
        }

        /* if all freezed, set all to variable */
        {
                int j = 0;
                for(i=0;i<mol->nAtoms;i++) if(!mol->atoms[i].variable) j++;
                if(j==mol->nAtoms) for(i=0;i<mol->nAtoms;i++) mol->atoms[i].variable = TRUE;
        }
}
/********************************************************************************/
int get_connections_one_atom(char* t, int nAtoms, int ibeg, int* connections)
{
	int k;
	int nc;
	int nj;
	char** ssplit = NULL;
	int nA = 0;
	/* int ibeg = 12;*/
	for(k=0;k<nAtoms;k++) connections[k] = 0;
	ssplit = split(t);
	nA = 0;
	while(ssplit && ssplit[nA]!=NULL) nA++;
	if(nA<ibeg)
	{
		strfreev(ssplit);
		return 0;
	}
	nc = atoi(ssplit[ibeg-1]);
	for(k=0;k<2*nc;k+=2) 
	{
		if(!ssplit[ibeg+k]) break;
		if(!ssplit[ibeg+k+1]) break;
		nj = atoi(ssplit[ibeg+k]);
		connections[nj-1] = atoi(ssplit[ibeg+k+1]);
	}

	strfreev(ssplit);

	return 1;
}
/********************************************************************************/
int get_gradients_one_atom(char* t, double G[])
{
	int k;
	for(k=0;k<3;k++) G[k] = 0;
	char tmp[BSIZE];
	char s[BSIZE];
	
	sprintf(tmp,"%s",t);
	uppercase(tmp);
	if(!strstr(tmp,"GRAD")) return 0;
	k = sscanf(strstr(tmp,"GRAD"),"%s %lf %lf %lf",s, &G[0], &G[1], &G[2]);

	if(k!=4) return 0;
	return 1;
}
/********************************************************************************/
int save_gradients_one_atom(FILE* file, double G[])
{
	if(!file) return 0;
	fprintf(file," GRADIENT %0.14f %0.14f %0.14f",G[0], G[1], G[2]);
	return 1;
}
/********************************************************************************/
Molecule* readMoleculeFromMopacAuxFile(char *fileName, int numgeometry)
{
	Molecule* mol = NULL;

	mol = newMolecule();
	readGeomFromMopacAuxFile(mol, fileName,numgeometry);
	readVibrationFromMopacAuxFile(mol, fileName);
	return mol;
}
/********************************************************************************/
Molecule* readMoleculeFromMopacOutputFile(char *fileName, int numgeometry)
{
/*      Change only the coordinates of mol */
	char* t;
	boolean OK;
	char *AtomCoord[5];
	FILE *file;
	int idummy;
	int i;
	int j=0;
	int l;
	int numgeom;
	char *pdest;
	long int geomposok = 0;
	Molecule* mol = NULL;

	for(i=0;i<5;i++) AtomCoord[i]=malloc(BSIZE*sizeof(char));
	t=malloc(BSIZE*sizeof(char));
	 
	file = fopen(fileName, "r");
	if(file ==NULL)
	{
	 	free(t);
	 	printf(("Sorry\nI can not open %s  mopac output file\n"),fileName);
		exit(1);
	 	return NULL;
	}
	numgeom =0;
	OK=FALSE;
	 while(!feof(file))
	 {
		if(!fgets(t,BSIZE,file))break;
		//pdest = strstr( t, "CARTESIAN COORDINATES");
		pdest = strstr( t, " ATOM   CHEMICAL          X               Y               Z");
		if(pdest) 
		{
			if(!fgets(t,BSIZE,file)) {pdest=0;break;}
			if(!fgets(t,BSIZE,file)) {pdest=0;break;}
		}
		if ( pdest )
		{
			numgeom++;
			geomposok = ftell(file);
			if(numgeom == numgeometry )
			{
				OK = TRUE;
				break;
			}
			if(numgeometry<0)
			{
				OK = TRUE;
			}
		}
	 }
	 if(!OK || numgeom == 0)
	 {
		free(t);
	 	printf(("Sorry\nI can not open %s mopac output file\n"),fileName);
		exit(1);
	 	return NULL;
	  }
	j=-1;
	fseek(file, geomposok, SEEK_SET);
	mol = newMolecule();
	while(!feof(file) )
	{
		if(!fgets(t,BSIZE,file))break;
		if(isABackspace(t))
		{
			break;
		}
		j++;
		for(i=0;i<strlen(t);i++) if (t[i]=='*') t[i] = ' ';
		sscanf(t,"%d %s %s %s %s",&idummy,AtomCoord[0],AtomCoord[1],AtomCoord[2],AtomCoord[3]);
		AtomCoord[0][0]=toupper(AtomCoord[0][0]);
		l=strlen(AtomCoord[0]); 
		if(isdigit(AtomCoord[0][1]))l=1;
		if (l==2) AtomCoord[0][1]=tolower(AtomCoord[0][1]);
		if(l==1)sprintf(t,"%c",AtomCoord[0][0]);
		else sprintf(t,"%c%c",AtomCoord[0][0],AtomCoord[0][1]);
		/* test symbol to do */

		mol->atoms = realloc(mol->atoms,(j+1)*sizeof(Atom));

		mol->atoms[j].prop = propAtomGet(t);
		mol->atoms[j].mmType=strdup(t);
		mol->atoms[j].pdbType=strdup(t);
		mol->atoms[j].residueName=strdup(t);
		mol->atoms[j].N=j+1;
		mol->atoms[j].layer=HIGH_LAYER;
		mol->atoms[j].variable=TRUE;
		mol->atoms[j].show=TRUE;
		mol->atoms[j].residueNumber=0;
	   	mol->atoms[j].charge=0.0;
	   	mol->atoms[j].charge0=0.0;
	   	mol->atoms[j].electronegativity=0.0;
	   	mol->atoms[j].hardness=0.0;
	   	mol->atoms[j].width=mol->atoms[j].prop.covalentRadii;
	   	mol->atoms[j].mass=mol->atoms[j].prop.mass;
	   	mol->atoms[j].rho=0.0;
	   	mol->atoms[j].U = 0.0;

		mol->atoms[j].coordinates[0]=atof(AtomCoord[1]);
		mol->atoms[j].coordinates[1]=atof(AtomCoord[2]);
		mol->atoms[j].coordinates[2]=atof(AtomCoord[3]);

		mol->atoms[j].gradient[0]=0.0;
		mol->atoms[j].gradient[1]=0.0;
		mol->atoms[j].gradient[2]=0.0;

		mol->atoms[j].velocity[0]=0.0;
		mol->atoms[j].velocity[1]=0.0;
		mol->atoms[j].velocity[2]=0.0;
	  }
	  mol->nAtoms = j+1;

	 fclose(file);
	 free(t);
	 for(i=0;i<5;i++) free(AtomCoord[i]);
        for(i=0; i<mol->nAtoms; i++) mol->atoms[i].typeConnections = NULL;
	resetTypeConnections(mol);
	int connections = 1;
	if(connections) setConnections(mol);
	else
	{
		createBondedMatrix(mol);
		printf(("Establishing connectivity : non bonded ...\n"));
		setNonBondedConnections(mol);
		freeBondedMatrix(mol);
	}

	/* if all freezed, set all to variable */
	{
		int j = 0;
		for(i=0;i<mol->nAtoms;i++)
			if(!mol->atoms[i].variable) j++;
		if(j==mol->nAtoms)
		for(i=0;i<mol->nAtoms;i++)
			mol->atoms[i].variable = TRUE;
	}
	return mol;
}
/********************************************************************************/
static boolean readVibrationFromGamessOutputFile(Molecule* mol, char* fileName)
{
 	char t[BSIZE];
 	boolean ok;
	int i;
	int j;
	int c;
	int ne;
	int nf;
	int nir;
	int nmass = 0;
	int nfMax = 5;
	double freq[5];
	double ir[5];
	double raman[5];
	double mass[5];
 	char* sdum[5*2];
 	char* tmp;
	int k;
	int nProps;
	FILE* file;

	if(!mol) return FALSE;
        if(mol->nAtoms<1) return FALSE;
        if(!fileName) return FALSE;
        file = fopen(fileName,"rb");
        if(!file) { return FALSE; }

	nProps = 2;

 	ok=FALSE;
 	while(!feof(file))
	{
		if(!fgets(t,BSIZE,file))break;
	 	if ( strstr( t,"FREQUENCY:") )
	  	{
			ok = TRUE;
			break;
	  	}
	}

	if(!ok) return 1;

	initVibrations(mol, 3*mol->nAtoms, nProps);

	for(i=0;i<nfMax*2;i++) sdum[i] = malloc(BSIZE*sizeof(char));

	j = 0;
  	while(!feof(file))
  	{
		int nfi=0;
		if(!strstr( t,"FREQUENCY:")) break;

		tmp = strstr(t,":")+1;
		for(i=0;i<nfMax*2;i++) sprintf(sdum[i]," ");
		nfi = sscanf(tmp,"%s %s %s %s %s %s %s %s %s %s", sdum[0],sdum[1],sdum[2],sdum[3],sdum[4],
				sdum[5],sdum[6],sdum[7],sdum[8],sdum[9]
				);
		if(nfi<1)
		{
			mol->vibration.nModes = j;
                	mol->vibration.modes = realloc(mol->vibration.modes, mol->vibration.nModes*sizeof(VibMode));
			for(i=0;i<nfMax*2;i++) free(sdum[i]);
			return 2;
		}
		nf = 0;
		for(i=0;i<nfi;)
		{
			if(strstr(sdum[i+1],"I"))
			{
				freq[nf] = -atof(sdum[i]);
				i+=2;
			}
			else
			{
				freq[nf] = atof(sdum[i]);
				i+=1;
			}
			nf++;
		}
		nir=-1;
		for(i=0;i<nfMax;i++) ir[i] = 0;
		for(i=0;i<nfMax;i++) raman[i] = 0;
		while(fgets(t,BSIZE,file) && strstr(t,":")) /* REDUCED MASS: IR INTENSITY: RAMAN ACTIVITY: Depol,... backspace */
		{
			if(strstr(t,"MASS:"))
			{
				tmp =  strstr(t,":")+1;
				nmass = sscanf(tmp,"%s %s %s %s %s", sdum[0],sdum[1],sdum[2],sdum[3],sdum[4]);
				if(nf!=nmass)
				{
					mol->vibration.nModes = j;
                			mol->vibration.modes = realloc(mol->vibration.modes, mol->vibration.nModes*sizeof(VibMode));
					for(i=0;i<nfMax*2;i++) free(sdum[i]);
					return 2;
				}
				for(i=0;i<nf;i++) mass[i] = atof(sdum[i]);
			}
			if(strstr(t,"IR"))
			{
				tmp =  strstr(t,":")+1;
				nir = sscanf(tmp,"%s %s %s %s %s", sdum[0],sdum[1],sdum[2],sdum[3],sdum[4]);
				if(nf!=nir)
				{
					mol->vibration.nModes = j;
                			mol->vibration.modes = realloc(mol->vibration.modes, mol->vibration.nModes*sizeof(VibMode));
					for(i=0;i<nfMax*2;i++) free(sdum[i]);
					return 2;
				}
				for(i=0;i<nf;i++) ir[i] = atof(sdum[i]);
			}
			if(strstr(t,"RAMAN"))
			{
				tmp =  strstr(t,":")+1;
				nir = sscanf(tmp,"%s %s %s %s %s", sdum[0],sdum[1],sdum[2],sdum[3],sdum[4]);
				if(nf!=nir)
				{
					mol->vibration.nModes = j;
                			mol->vibration.modes = realloc(mol->vibration.modes, mol->vibration.nModes*sizeof(VibMode));
					for(i=0;i<nfMax*2;i++) free(sdum[i]);
					return 2;
				}
				for(i=0;i<nf;i++) raman[i] = atof(sdum[i]);
			}
		}
		for(i=0;i<nf;i++)
		{
			mol->vibration.modes[j].frequency = freq[i];
			mol->vibration.modes[j].properties[0] = ir[i];
			mol->vibration.modes[j].mass = mass[i];
			mol->vibration.modes[j].properties[1] = raman[i];
			j++;
		}
		for(i=0;i<mol->nAtoms;i++)
		{
			k = j-nf;
    			if(!fgets(t,BSIZE,file)) break;
			c = 0;
			ne = sscanf(t,"%s %s %s %lf %lf %lf %lf %lf %lf", sdum[0],sdum[1],sdum[2],
				&mol->vibration.modes[k  ].vectors[c][i],
				&mol->vibration.modes[k+1].vectors[c][i],
				&mol->vibration.modes[k+2].vectors[c][i],
				&mol->vibration.modes[k+3].vectors[c][i],
				&mol->vibration.modes[k+4].vectors[c][i],
				&mol->vibration.modes[k+5].vectors[c][i]);
			if(ne!=nf+3)return 2;
    			if(!fgets(t,BSIZE,file)) break;
			c = 1;
			ne = sscanf(t," %s %lf %lf %lf %lf %lf %lf",sdum[0],
				&mol->vibration.modes[k  ].vectors[c][i],
				&mol->vibration.modes[k+1].vectors[c][i],
				&mol->vibration.modes[k+2].vectors[c][i],
				&mol->vibration.modes[k+3].vectors[c][i],
				&mol->vibration.modes[k+4].vectors[c][i],
				&mol->vibration.modes[k+5].vectors[c][i]);
			if(ne!=nf+1)return 2;
    			if(!fgets(t,BSIZE,file)) break;
			c = 2;
			ne = sscanf(t," %s %lf %lf %lf %lf %lf %lf",sdum[0],
				&mol->vibration.modes[k  ].vectors[c][i],
				&mol->vibration.modes[k+1].vectors[c][i],
				&mol->vibration.modes[k+2].vectors[c][i],
				&mol->vibration.modes[k+3].vectors[c][i],
				&mol->vibration.modes[k+4].vectors[c][i],
				&mol->vibration.modes[k+5].vectors[c][i]);
			if(ne!=nf+1)return 2;
		}
		for(i=0;i<5*2+2;i++)
		{
			if(!fgets(t,BSIZE,file))break;
		}
		if(i!=5*2+2 || !fgets(t,BSIZE,file))
		{
			mol->vibration.nModes = j;
                	mol->vibration.modes = realloc(mol->vibration.modes, mol->vibration.nModes*sizeof(VibMode));
			for(i=0;i<nfMax*2;i++) free(sdum[i]);
			return 2;
		}
	}
	mol->vibration.nModes = j;
        mol->vibration.modes = realloc(mol->vibration.modes, mol->vibration.nModes*sizeof(VibMode));
	for(j=0;j< mol->vibration.nModes;j++)
	{
			for(i=0;i< mol->nAtoms;i++)
			for(c=0;c<3;c++)
			mol->vibration.modes[j].vectors[c][i] *= sqrt(mol->vibration.modes[j].mass);
	}
	for(i=0;i<nfMax*2;i++) free(sdum[i]);
	sortFrequencies(mol);
	removeTransRotModes(mol);
	return 0;
}
/********************************************************************************/
Molecule* getMoleculeFromGamessOutputFile(char *fileName, int numgeometry)
{
	char *t;
	boolean OK;
	char *AtomCoord[5];
	FILE *file;
	int i;
	int j=0;
	int l;
	int numgeom;
	char dum[100];
	Molecule* mol = NULL;


	for(i=0;i<5;i++) AtomCoord[i]=malloc(BSIZE*sizeof(char));
  
	t=malloc(BSIZE*sizeof(char));
 	file = fopen(fileName, "rb");
	if(file ==NULL)
	{
		free(t);
		printf(("Sorry\nI can not open %s Firefly (gamess) output file\n"),fileName);
		exit(1);
		return NULL;
	}
	numgeom = 0;
	do 
	{
		OK=FALSE;
		while(!feof(file)){
			fgets(t,BSIZE,file);
			if ( numgeometry==1 && strstr(t,"COORDINATES (BOHR)"))
			{
	  			fgets(t,BSIZE,file);
 				numgeom++;
				if((int)numgeom == numgeometry ) { OK = TRUE; break; }
	  		}
			if ( strstr(t,"COORDINATES OF ALL ATOMS ARE (ANGS)"))
			{
	  			fgets(t,BSIZE,file);
	  			fgets(t,BSIZE,file);
 				numgeom++;
				if((int)numgeom == numgeometry ) { OK = TRUE; break; }
				if(numgeometry<0 ) { OK = TRUE; break; }
	  		}
		}
		if(!OK && (numgeom == 0) ){
			free(t);
			printf(("Sorry\nI can not open read geometry from %s Firefly (gamess) output file\n"),fileName);
			exit(1);
			return NULL;
		}
		if(!OK)break;

		//printf("Begin freMole\n");
		if(mol) freeMolecule(mol);
		mol = newMolecule();
		mol->atoms = NULL;
		mol->nAtoms = 0;
		//printf("numgeom=%d numgeometry=%d\n",numgeom,numgeometry);

		j=-1;
		while(!feof(file) )
		{
			fgets(t,BSIZE,file);
			strDeleten(t);
			if (isABackspace(t)) break;
			if ( !strcmp(t,"\n")) break;
			if ( !strcmp(t,"\r\n")) break;
			j++;
			//printf("j=%d t = %s\n",j,t);
			sscanf(t,"%s %s %s %s %s",AtomCoord[0],dum, AtomCoord[1], AtomCoord[2],AtomCoord[3]);
			{
				int k;
				for(k=0;k<(int)strlen(AtomCoord[0]);k++) if(isdigit(AtomCoord[0][k])) AtomCoord[0][k] = ' ';
				deleteAllSpaces(AtomCoord[0]);
			}

			AtomCoord[0][0]=toupper(AtomCoord[0][0]);
			l=strlen(AtomCoord[0]);
			if (l==2) AtomCoord[0][1]=tolower(AtomCoord[0][1]);
			mol->atoms = realloc(mol->atoms,(j+1)*sizeof(Atom));

			mol->atoms[j].prop = propAtomGet(AtomCoord[0]);
			mol->atoms[j].mmType=strdup(AtomCoord[0]);
			mol->atoms[j].pdbType=strdup(AtomCoord[0]);
			mol->atoms[j].residueName=strdup(AtomCoord[0]);
			mol->atoms[j].N=j+1;
			mol->atoms[j].layer=HIGH_LAYER;
			mol->atoms[j].variable=TRUE;
			mol->atoms[j].show=TRUE;
			mol->atoms[j].residueNumber=0;
	   		mol->atoms[j].charge=0.0;
	   		mol->atoms[j].charge0=0.0;
	   		mol->atoms[j].electronegativity=0.0;
	   		mol->atoms[j].hardness=0.0;
	   		mol->atoms[j].width=mol->atoms[j].prop.covalentRadii;
	   		mol->atoms[j].mass= mol->atoms[j].prop.mass;
	   		mol->atoms[j].rho=0.0;
	   		mol->atoms[j].U = 0.0;

			mol->atoms[j].coordinates[0]=atof(AtomCoord[1]);
			mol->atoms[j].coordinates[1]=atof(AtomCoord[2]);
			mol->atoms[j].coordinates[2]=atof(AtomCoord[3]);

			mol->atoms[j].gradient[0]=0.0;
			mol->atoms[j].gradient[1]=0.0;
			mol->atoms[j].gradient[2]=0.0;

			mol->atoms[j].velocity[0]=0.0;
			mol->atoms[j].velocity[1]=0.0;
			mol->atoms[j].velocity[2]=0.0;
        		mol->atoms[j].typeConnections = NULL;
			if(j==mol->nAtoms-1) break;
		}
		if(OK && numgeometry>=0) break;
		mol->nAtoms = j+1;
	}while(!feof(file));
	//printf("end read molecule\n");

	rewind(file);
	getChargesFromGamessOutputFile(mol, file);
	fclose(file);
	free(t);
	for(i=0;i<5;i++) free(AtomCoord[i]);
	//printf("begin resetTypeConnections\n");
        for(i=0; i<mol->nAtoms; i++) mol->atoms[i].typeConnections = NULL;
	resetTypeConnections(mol);
	//printf("end resetTypeConnections\n");
	int connections = 1;
	if(connections) setConnections(mol);
	else
	{
		createBondedMatrix(mol);
		printf(("Establishing connectivity : non bonded ...\n"));
		setNonBondedConnections(mol);
		freeBondedMatrix(mol);
	}

	/* if all freezed, set all to variable */
	{
		int j = 0;
		for(i=0;i<mol->nAtoms;i++)
			if(!mol->atoms[i].variable) j++;
		if(j==mol->nAtoms)
		for(i=0;i<mol->nAtoms;i++)
			mol->atoms[i].variable = TRUE;
	}
	return mol;
}
/********************************************************************************/
Molecule* readMoleculeFromGamessOutputFile(char *fileName, int numgeometry)
{
	//printf("Begin redMolecule from gamess output file\n");
	Molecule* mol = getMoleculeFromGamessOutputFile(fileName, numgeometry);
	//printf("End redMolecule from gamess output file\n");
	readVibrationFromGamessOutputFile(mol, fileName);
	return mol;
	
}
/********************************************************************************/
static boolean readVibrationFromOrcaOutputFile(Molecule* mol, char* fileName)
{
 	char t[BSIZE];
 	char sdum1[BSIZE];
 	boolean ok;
 	FILE *file;
	int nf;
	int n;
	double freq = 0;
	double v[6] ={0,0,0,0,0,0};
	int j;
	int k;
	int nfOld;
	boolean Begin = TRUE;
	int nblock, iblock;
	int ix;
	double dum;
	int numberOfFrequencies = 0;


	initVibrations(mol, 3*mol->nAtoms,2);
 	file = fopen(fileName, "rb");
	if(!file) return FALSE;
 	do 
 	{
 		ok=FALSE;
 		while(!feof(file))
		{
    			if(!fgets(t,BSIZE,file)) break;
	 		if (strstr( t,"VIBRATIONAL FREQUENCIES") ) ok = TRUE;
	 		if (strstr( t,":") && ok ){ ok = TRUE; break;}
		}
		if(!ok) break;
  		numberOfFrequencies = 0;
  		while(!feof(file) )
  		{
			if(!strstr(t,":")) break;
			nf = sscanf(t,"%s %lf",sdum1,&freq);
			if(nf!=2) { ok = FALSE; break;}
  			numberOfFrequencies++;
			if(numberOfFrequencies>mol->nAtoms*3) break;
			k = numberOfFrequencies-1;
			mol->vibration.modes[k].frequency = freq;
			mol->vibration.modes[k].mass = 1.0;
			mol->vibration.modes[k].properties[0] = 0;
			mol->vibration.modes[k].properties[1] = 0;
			if(!fgets(t,BSIZE,file)) break;
		}
		if(!ok) break;
 		ok=FALSE;
 		while(!feof(file))
		{
    			if(!fgets(t,BSIZE,file)) break;
	 		if (strstr( t,"NORMAL MODES") ) ok = TRUE;
	 		if (sscanf(t,"%d",&k)==1 && ok ){ ok = TRUE; break;}
		}
		if(!ok) break;
		nblock = numberOfFrequencies/6; 
		if(numberOfFrequencies%6!=0) nblock++;
		for(iblock = 0;iblock<nblock;iblock++)
		{
			nf = sscanf(t,"%s %lf %lf %lf %lf %lf %lf",
					sdum1,
					&v[0],&v[1],&v[2],
					&v[3],&v[4],&v[5]
					);
			ix = 0;
			for(j=0;j<mol->nAtoms*3 && !feof(file);j++)
			{
				if(!fgets(t,BSIZE,file)) break;
				nf = sscanf(t,"%s %lf %lf %lf %lf %lf %lf",
					sdum1,
					&v[0],&v[1],&v[2],
					&v[3],&v[4],&v[5]
					);
				nf--;
				nfOld = iblock*6;
				for(k=0;k<nf;k++)
				{
					mol->vibration.modes[k+nfOld].vectors[ix][j/3]= v[k]; 
				}
				ix++;
				if(ix>2) ix = 0;
			}
			if(!fgets(t,BSIZE,file)) {ok = FALSE;break;};/* new block */
		}
		if(!ok) break;
		Begin = FALSE;
 		ok=FALSE;
 		while(!feof(file))
		{
			if(!fgets(t,BSIZE,file)) break;
	 		if (strstr( t,"IR SPECTRUM") ) ok = TRUE;
	 		if (strstr( t,"TX")  && strstr( t,"TY") && strstr( t,"TZ") && ok ){ ok = TRUE; break;}
		}
		if(!ok) {continue;}
    		if(fgets(t,BSIZE,file))
  		while(!feof(file) )
  		{
			if(!fgets(t,BSIZE,file)) break;
			n = sscanf(t,"%s %lf %lf", sdum1, &freq,&dum);
			if(n!=3) { break; }
			k = atoi(t);
			mol->vibration.modes[k].properties[0] = dum;
		}
		if(!ok) break;
 		ok=FALSE;
 		while(!feof(file))
		{
			if(!fgets(t,BSIZE,file)) break;
	 		if (strstr( t,"RAMAN SPECTRUM") ) ok = TRUE;
	 		if (strstr( t,"Activity")  && strstr( t,"Depolarization") && ok ){ ok = TRUE; break;}
		}
		if(!ok) {continue;}
    		if(fgets(t,BSIZE,file))
  		while(!feof(file) )
  		{
			if(!fgets(t,BSIZE,file)) break;
			n = sscanf(t,"%s %lf %lf", sdum1, &freq,&dum);
			if(n!=3) { break; }
			k = atoi(t);
			mol->vibration.modes[k].properties[1] = dum;
		}
		if(!ok) break;
		break;
 	}while(!feof(file));
	if((Begin && !ok) || numberOfFrequencies<1) 
	{
		char buffer[BSIZE];
		freeVibrations(mol);
		sprintf(buffer,"Sorry, I can not read frequencies from '%s' file\n",fileName);
  		fprintf(stderr,"%s",buffer);
		return FALSE;
	}
	else
	{
		char buffer[BSIZE];
		sprintf(buffer,
				"\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"
				"Warning, the effective masses are not available in an orca ourput file\n"
				"It is if you want to generate a geometry along a vibrational mode.\n"
				"These masses are set here to 1.0\n"
				"RECOMMENDED : Use the *.hessian file given by orca\n"
				"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"
				);
  		fprintf(stdout,"%s\n",buffer);
		mol->vibration.nModes = numberOfFrequencies;
		mol->vibration.modes = realloc(mol->vibration.modes, mol->vibration.nModes*sizeof(VibMode));
		sortFrequencies(mol);
		removeTransRotModes(mol);
	}
	return TRUE;
}
/********************************************************************************/
Molecule* getMoleculeFromOrcaOutputFile(char* fileName, int numgeometry)
{
	char *t;
	char *AtomCoord[5];
	FILE *file;
	int taille=BSIZE;
	int i;
	int j=0;
	int l;
	int numgeom;
	char *pdest;
	long int geomposok = 0;
	Molecule* mol = NULL;
	int totalCharge = 0;
	int spinMultiplicity = 1;
 	char t1[20];
 	char t2[20];
 	char t3[20];
 	char t4[20];
	int dum;

	for(i=0;i<5;i++) AtomCoord[i]=malloc(taille*sizeof(char));
	 
	t=malloc(taille*sizeof(char));
	file = fopen(fileName, "r");
	if(file ==NULL)
	{
	 	free(t);
	 	printf(("Sorry\nI can not open the %s  orca output file\n"),fileName);
	 	return NULL;
	}
	numgeom =0;
	 while(!feof(file))
	 {
		if(!fgets(t,taille,file))break;
 		if (strstr( t,"Total Charge") && strstr( t,"...") ) if(5==sscanf(t,"%s %s %s %s %d",t1,t2,t3,t4,&dum)) { totalCharge = dum;}
 		if (strstr( t,"Multiplicity") && strstr( t,"...") ) if(4==sscanf(t,"%s %s %s %d",t1,t2,t3,&dum)) { spinMultiplicity = dum;}
		pdest = strstr( t, "CARTESIAN COORDINATES (ANGSTROEM)");
		if(pdest) 
		{
			if(!fgets(t,taille,file))break;
			pdest = strstr( t, "---------------------------------");
		}
		if ( pdest )
		{
			numgeom++;
			geomposok = ftell(file);
			if(numgeom == numgeometry )
			{
				break;
			}
			if(numgeometry<0)
			{
			}
		}
	 }
	 if(numgeom == 0)
	 {
		free(t);
		t = strdup_printf(("Sorry\nI can not read geometry from %s  orca output file\n"),fileName);
		return NULL;
	  }
	j=-1;
	fseek(file, geomposok, SEEK_SET);
	mol = newMolecule();
	mol->atoms = NULL;
	mol->nAtoms = 0;


	while(!feof(file) )
	{
		if(!fgets(t,taille,file))break;
		pdest = strstr( t, "----------------------------------" );
		if (pdest || isABackspace(t))
		{
			break;
		}
		j++;
		sscanf(t,"%s %s %s %s",AtomCoord[0],AtomCoord[1],AtomCoord[2],AtomCoord[3]);
		AtomCoord[0][0]=toupper(AtomCoord[0][0]);
		l=strlen(AtomCoord[0]); 
		if(isdigit(AtomCoord[0][1]))l=1;
		if (l==2) AtomCoord[0][1]=tolower(AtomCoord[0][1]);
		if(l==1)sprintf(t,"%c",AtomCoord[0][0]);
		else sprintf(t,"%c%c",AtomCoord[0][0],AtomCoord[0][1]);

		mol->atoms = realloc(mol->atoms,(j+1)*sizeof(Atom));

		mol->atoms[j].prop = propAtomGet(AtomCoord[0]);
		mol->atoms[j].mmType=strdup(AtomCoord[0]);
		mol->atoms[j].pdbType=strdup(AtomCoord[0]);
		mol->atoms[j].residueName=strdup(AtomCoord[0]);
		mol->atoms[j].N=j+1;
		mol->atoms[j].layer=HIGH_LAYER;
		mol->atoms[j].variable=TRUE;
		mol->atoms[j].show=TRUE;
		mol->atoms[j].residueNumber=0;
	   	mol->atoms[j].charge=0.0;
	   	mol->atoms[j].charge0=0.0;
	   	mol->atoms[j].electronegativity=0.0;
	   	mol->atoms[j].hardness=0.0;
	   	mol->atoms[j].width=mol->atoms[j].prop.covalentRadii;
	   	mol->atoms[j].mass= mol->atoms[j].prop.mass;
	   	mol->atoms[j].rho=0.0;
	   	mol->atoms[j].U = 0.0;

		mol->atoms[j].coordinates[0]=atof(AtomCoord[1]);
		mol->atoms[j].coordinates[1]=atof(AtomCoord[2]);
		mol->atoms[j].coordinates[2]=atof(AtomCoord[3]);

		mol->atoms[j].gradient[0]=0;
		mol->atoms[j].gradient[1]=0;
		mol->atoms[j].gradient[2]=0;

		mol->atoms[j].velocity[0]=0.0;
		mol->atoms[j].velocity[1]=0.0;
		mol->atoms[j].velocity[2]=0.0;
	  }
	 mol->nAtoms = j+1;
	 fclose(file);
	 free(t);
	 for(i=0;i<5;i++) free(AtomCoord[i]);
        for(i=0; i<mol->nAtoms; i++) mol->atoms[i].typeConnections = NULL;
	resetTypeConnections(mol);
	int connections = 1;
	if(connections) setConnections(mol);
	else
	{
		createBondedMatrix(mol);
		printf(("Establishing connectivity : non bonded ...\n"));
		setNonBondedConnections(mol);
		freeBondedMatrix(mol);
	}

	/* if all freezed, set all to variable */
	{
		int j = 0;
		for(i=0;i<mol->nAtoms;i++)
			if(!mol->atoms[i].variable) j++;
		if(j==mol->nAtoms)
		for(i=0;i<mol->nAtoms;i++)
			mol->atoms[i].variable = TRUE;
	}
	mol->totalCharge = totalCharge;
	mol->spinMultiplicity = spinMultiplicity;
	return mol;
}
/********************************************************************************/
static boolean readDipolesDerivativesFromOrcaHessianFile(Molecule* mol, char* fileName)
{
	// Here I read derivatives along atomic coordinates and then I compute the derivative along the normal modes
 	char t[BSIZE];
 	boolean ok;
 	FILE *file;
	int nf;
	int i,j,k;
	int xyz;
	double*** T = NULL;
	int nAll = 0;
	//printf("nModes =%d\n",mol->vibration.nModes);
	//printf("fileName =%s\n",fileName);
	if(mol->vibration.nModes<1) return FALSE;
	if(mol->nAtoms<1) return FALSE;
	//printf("fileName =%s\n",fileName);
	T = malloc(3*sizeof(double**));// Dx, Dy, Dz
	for(xyz=0;xyz<3;xyz++) 
	{
		T[xyz] = malloc(3*sizeof(double*)); // 3 coordiantes for each atom
		for(j=0;j<3;j++) T[xyz][j] = malloc(mol->nAtoms*sizeof(double)); 
	}

 	file = fopen(fileName, "rb");
	if(!file) return FALSE;
	//printf("fileName =%s\n",fileName);

/*$dipole_derivatives
9
    -0.786390     0.000000     0.000000
     0.000000    -0.287454     0.000000
     0.000000     0.000000    -0.263611
     0.393191    -0.000000     0.000000
    -0.000000     0.143737     0.147331
     0.000000     0.188756     0.131853
     0.393191    -0.000000    -0.000000
    -0.000000     0.143737    -0.147331
    -0.000000    -0.188756     0.131853
*/

 	ok=FALSE;
	while(!feof(file))
	{
    		if(!fgets(t,BSIZE,file)) break;
 		if (strstr( t,"$dipole_derivatives"))
		{ 
    			if(!fgets(t,BSIZE,file)) break;
			nf=sscanf(t,"%d",&nAll);
			if(nf!=1) break;
			if(nAll!=mol->nAtoms*3) break;
			ok = TRUE; 
			break;
		}
	}
	k = 0;
	if(ok)
	for(i=0;i<mol->nAtoms;i++)
	for(j=0;j<3;j++) 
  	{
    		if(!fgets(t,BSIZE,file)) { ok = FALSE;  break;}
		nf = sscanf(t,"%lf %lf %lf",&T[0][j][i], &T[1][j][i], &T[2][j][i]);
		if(nf!=3) { ok = FALSE; break;}
		k++;
	}
	//printf("k=%d nAll = %d\n",k,nAll);
	if(k!=nAll) ok = FALSE;
	if(ok)
	{
        	double mu0 = 4*PI*1e-7;
        	double eps0 = 1.0/(mu0*slight*slight);
        	double   kmmolm1 = 4*PI*PI*PI*NAvogadro/3/hPlank/slight/4/PI/eps0*1e-3*100.0*8.47835267e-30*8.47835267e-30;/* 1e-3 m to km, 100 : cm-1 to m-1 */
		double f = sqrt(AUTOCM1/AMUTOAU);
		int nPOld = 2;
		double IRI = 0.;
		// allocation already make for dipole derivatives in readOrca
		for(i=0;i<mol->vibration.nModes;i++)
		{
			for(xyz=0;xyz<3;xyz++)
			{
				int jxyz = nPOld+xyz;
				mol->vibration.modes[i].properties[jxyz] = 0;
				for(j=0;j<3;j++) 
				for(k=0;k<mol->nAtoms;k++)
					mol->vibration.modes[i].properties[jxyz] += mol->vibration.modes[i].vectors[j][k]*T[xyz][j][k]/sqrt(mol->vibration.modes[i].mass);
			}
			IRI = 0;
			for(xyz=0;xyz<3;xyz++)
			{
				int jxyz = nPOld+xyz;
				mol->vibration.modes[i].properties[jxyz] *= f;
				IRI += mol->vibration.modes[i].properties[jxyz]*mol->vibration.modes[i].properties[jxyz];
			}
			IRI *= kmmolm1;
			mol->vibration.modes[i].properties[0] = IRI;
			/*
			for(xyz=0;xyz<3;xyz++)
			{
				int jxyz = nPOld+xyz;
				printf("xyz = %d mode = %d mu = %f\n",xyz,i,mol->vibration.modes[i].properties[jxyz]);
			}
			printf("IR (km/mol) = %f\n",mol->vibration.modes[i].properties[0]);
			*/
		}
	}
	for(xyz=0;xyz<3;xyz++) 
	{
		for(j=0;j<3;j++) free(T[xyz][j]);
		free(T[xyz]);
	}
	free(T);
	fclose(file);
	return TRUE;
}
/********************************************************************************/
static boolean readDipolesDerivativesFromGaussianOutputFile(Molecule* mol, char* fileName)
{
 	char t[BSIZE];
 	boolean ok;
 	FILE *file;
	int nf;
	int numberOfFrequencies = 0;
	double* TX = NULL;
	double* TY = NULL;
	double* TZ = NULL;
	//printf("nModes =%d\n",mol->vibration.nModes);
	//printf("fileName =%s\n",fileName);
	if(mol->vibration.nModes<1) return FALSE;
	//printf("fileName =%s\n",fileName);
	TX = malloc(mol->vibration.nModes*sizeof(double));
	TY = malloc(mol->vibration.nModes*sizeof(double));
	TZ = malloc(mol->vibration.nModes*sizeof(double));


 	file = fopen(fileName, "rb");
	if(!file) return FALSE;
	//printf("fileName =%s\n",fileName);

 	ok=TRUE;
  	numberOfFrequencies = 0;
  	while(!feof(file) )
  	{
		int i;
		if(!fgets(t,BSIZE,file)) break;
		if(strstr(t,"Harmonic frequencies") && strstr(t,"IR intensities")) break;
		if(!strstr(t,"Dipole derivatives wrt mode"))  continue;
		if(!strstr(t,":"))  continue;
		for(i=0;i<strlen(t);i++) if(t[i]=='D') t[i]='E';
		nf = sscanf(strstr(t,":")+1,"%lf %lf %lf",&TX[numberOfFrequencies], &TY[numberOfFrequencies], &TZ[numberOfFrequencies]);
		if(nf!=3) { ok = FALSE; break;}
		numberOfFrequencies++;
		if(numberOfFrequencies>mol->vibration.nModes) { ok = FALSE; break;}
	}
	if(numberOfFrequencies!=mol->vibration.nModes) ok = FALSE;
	if(!ok)
	{
			fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
			fprintf(stderr," WARNING : I cannot read the dipole derivatives from %s \n",fileName);
			fprintf(stderr,"         : To print these values, add iop(7/33=1) Freq keywords to your  gaussian input file \n");
			fprintf(stderr,"         : For unknown reason iop(7/33=1) does not work with opt keyword! \n");
			fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
	}
	if(ok && numberOfFrequencies==mol->vibration.nModes)
	{
        	double mu0 = 4*PI*1e-7;
        	double eps0 = 1.0/(mu0*slight*slight);
        	double   kmmolm1 = 4*PI*PI*PI*NAvogadro/3/hPlank/slight/4/PI/eps0*1e-3*100.0*8.47835267e-30*8.47835267e-30;/* 1e-3 m to km, 100 : cm-1 to m-1 */
		double f = 1.0/sqrt(kmmolm1);
		int i;
		int nPOld = mol->vibration.nProperties;
		mol->vibration.nProperties += 3;
		for(i=0;i<mol->vibration.nModes;i++)
		{
			mol->vibration.modes[i].properties = realloc(mol->vibration.modes[i].properties, mol->vibration.nProperties*sizeof(double));
			mol->vibration.modes[i].properties[nPOld] = TX[i]*f;
			mol->vibration.modes[i].properties[nPOld+1] = TY[i]*f;
			mol->vibration.modes[i].properties[nPOld+2] = TZ[i]*f;
		}
	}
	free(TX);
	free(TY);
	free(TZ);
	fclose(file);
	return TRUE;
}
/********************************************************************************/
static boolean readDipolesDerivativesFromGabeditFile(Molecule* mol, char* fileName)
{
 	FILE *file;
	double** first = NULL;

	if(!mol) return FALSE;
	if(mol->vibration.nModes<1) return FALSE;
	//printf("nModes =%d\n",mol->vibration.nModes);
	//printf("fileName =%s\n",fileName);

 	file = fopen(fileName, "rb");
	if(!file) return FALSE;

	//printf("fileName =%s\n",fileName);
	first = newMatrixDouble(3,mol->vibration.nModes);
	if(!readMatrixReal(file,"First Derivatives",3, mol->vibration.nModes, first))
	{
		printf("I cannot read the dipole derivatives from the %s file\n",fileName);
		freeMatrixDouble(&first, 3);
		return FALSE;
	}
	else
	{
		int i;
		int j;
		int nPOld = mol->vibration.nProperties;
		mol->vibration.nProperties += 3;
		//printf("nprops = %d\n",mol->vibration.nProperties);
		for(i=0;i<mol->vibration.nModes;i++)
		{
			mol->vibration.modes[i].properties = realloc(mol->vibration.modes[i].properties, mol->vibration.nProperties*sizeof(double));
			for(j=0;j<3;j++) mol->vibration.modes[i].properties[nPOld+j] = first[j][i];
			for(j=0;j<3;j++) printf("%f ",mol->vibration.modes[i].properties[nPOld+j]);
			printf("\n");
		}
	}
	freeMatrixDouble(&first, 3);
	fclose(file);
	return TRUE;
}
/********************************************************************************/
static boolean readDipolesDerivativesFromOrcaOutputFile(Molecule* mol, char* fileName)
{
 	char t[BSIZE];
 	char sdum1[BSIZE];
 	char sdum2[BSIZE];
 	boolean ok;
	double freq;
 	FILE *file;
	int nf;
	int numberOfFrequencies = 0;
	double* TX = NULL;
	double* TY = NULL;
	double* TZ = NULL;
	//printf("nModes =%d\n",mol->vibration.nModes);
	//printf("fileName =%s\n",fileName);
	if(mol->vibration.nModes<1) return FALSE;
	//printf("fileName =%s\n",fileName);
	TX = malloc(mol->vibration.nModes*sizeof(double));
	TY = malloc(mol->vibration.nModes*sizeof(double));
	TZ = malloc(mol->vibration.nModes*sizeof(double));

 	file = fopen(fileName, "rb");
	if(!file) return FALSE;
	//printf("fileName =%s\n",fileName);

 	ok=FALSE;
	while(!feof(file))
	{
    		if(!fgets(t,BSIZE,file)) break;
 		if (strstr( t,"TX") && strstr( t,"TY") && strstr( t,"TZ") ) ok = TRUE;
 		if (strstr( t,":") && ok ){ ok = TRUE; break;}
	}
  	numberOfFrequencies = 0;
	if(ok)
  	while(!feof(file) )
  	{
		int i;
		if(!strstr(t,":")) break;
		for(i=0;i<strlen(t);i++) if(t[i]=='(' || t[i]==')') t[i]=' ';
		nf = sscanf(t,"%s %lf %s %lf %lf %lf",sdum1,&freq, sdum2, &TX[numberOfFrequencies], &TY[numberOfFrequencies], &TZ[numberOfFrequencies]);
		if(nf!=6) { ok = FALSE; break;}
		if(fabs(mol->vibration.modes[numberOfFrequencies].frequency-freq)>2.0)
		{
			fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
			fprintf(stderr," WARNING : %f # %f \n", mol->vibration.modes[numberOfFrequencies].frequency,freq);
			fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		}
		numberOfFrequencies++;
		if(numberOfFrequencies>mol->vibration.nModes) { ok = FALSE; break;}
		if(!fgets(t,BSIZE,file)) break;
	}
	//printf("nModOld = %d nModnew = %d\n",mol->vibration.nModes,numberOfFrequencies);
	if(ok && numberOfFrequencies==mol->vibration.nModes)
	{
        	double mu0 = 4*PI*1e-7;
        	double eps0 = 1.0/(mu0*slight*slight);
        	double   kmmolm1 = 4*PI*PI*PI*NAvogadro/3/hPlank/slight/4/PI/eps0*1e-3*100.0*8.47835267e-30*8.47835267e-30;/* 1e-3 m to km, 100 : cm-1 to m-1 */
		double f = 1.0/sqrt(kmmolm1);
		int i;
		int nPOld = mol->vibration.nProperties;
		mol->vibration.nProperties += 3;
		for(i=0;i<mol->vibration.nModes;i++)
		{
			mol->vibration.modes[i].properties = realloc(mol->vibration.modes[i].properties, mol->vibration.nProperties*sizeof(double));
			mol->vibration.modes[i].properties[nPOld] = TX[i]*f;
			mol->vibration.modes[i].properties[nPOld+1] = TY[i]*f;
			mol->vibration.modes[i].properties[nPOld+2] = TZ[i]*f;
		}
	}
	free(TX);
	free(TY);
	free(TZ);
	fclose(file);
	return TRUE;
}
/********************************************************************************/
Molecule* readMoleculeFromOrcaOutputFile(char* fileName, int numgeometry)
{
	Molecule* mol = getMoleculeFromOrcaOutputFile(fileName, numgeometry);
	readVibrationFromOrcaOutputFile(mol,fileName);
	readDipolesDerivativesFromOrcaOutputFile(mol,fileName);
	return mol;
}
/********************************************************************************/
static boolean readVibrationFromGaussianOutputFile(Molecule* mol, char* fileName)
{
 	char t[BSIZE];
 	char sdum1[BSIZE];
 	char sdum2[BSIZE];
 	char sdum3[BSIZE];
 	boolean ok;
 	FILE *file;
	int idum,jdum,kdum;
	int nf;
	double freq[3] = {0,0,0};
	double IRIntensity[3] = {0,0,0};
	double mass[3] = {1,1,1};
	double RamanIntensity[3]={ 0,0,0};
	double v[3][3];
	char sym[3][BSIZE];
	int j;
	int k;
	int nProps;
	int nModes = 0;

	if(!mol) return FALSE;
        if(mol->nAtoms<1) return FALSE;
        if(!fileName) return FALSE;
        file = fopen(fileName,"rb");
        if(!file) { return FALSE; }

        nModes = 0;
	nProps = 2;
	initVibrations(mol, 3*mol->nAtoms, nProps);

	for(j=0;j<3;j++)
	{
		sprintf(sym[j]," ");
		for(k=0;k<3;k++) v[j][k] = 0;
	}

 	do 
 	{
 		ok=FALSE;
 		while(!feof(file))
		{
    			if(!fgets(t,BSIZE,file)) break;
	 		/* if ( strstr( t,"reduced masses") )*/
	 		if ( strstr( t,"and normal coordinates:") )
	  		{
				ok = TRUE;
				break;
	  		}
		}
  		while(!feof(file) )
  		{
    			if(!fgets(t,BSIZE,file)) break;
			if(isABackspace(t)) break;
			nf = sscanf(t,"%d %d %d",&idum,&jdum,&kdum);
			if(nf<=0 || nf>3)
			{
				break;
			}
			if(!fgets(t,BSIZE,file)) break;
			sscanf(t,"%s %s %s",sym[0],sym[1],sym[2]);

			if(!fgets(t,BSIZE,file)) break;
			changeDInE(t); 
			sscanf(t,"%s %s %lf %lf %lf", sdum1,sdum2, &freq[0],&freq[1],&freq[2]);
			while(!feof(file))
			{
				if(!fgets(t,BSIZE,file)) break;
				if(strstr(t,"Red."))
				{
					changeDInE(t); 
					sscanf(t,"%s %s %s %lf %lf %lf", sdum1,sdum2, sdum3, &mass[0],&mass[1],&mass[2]);
					break;
				}
			}
			while(!feof(file))
			{
				if(!fgets(t,BSIZE,file)) break;
				if(strstr(t,"IR Inten"))
				{
					changeDInE(t); 
					sscanf(t,"%s %s %s %lf %lf %lf", sdum1,sdum2, sdum3, &IRIntensity[0],&IRIntensity[1],&IRIntensity[2]);
					break;
				}
			}
			while(!feof(file))
			{
				if(!fgets(t,BSIZE,file)) break;
				if(strstr(t,"Raman"))
				{
					changeDInE(t); 
					sscanf(t,"%s %s %s %lf %lf %lf", sdum1,sdum2, sdum3, &RamanIntensity[0],&RamanIntensity[1],&RamanIntensity[2]);
					break;
				}
				if(strstr(t,"Atom ") && strstr(t," AN")) break;
			}

			if(!(strstr(t,"Atom ") && strstr(t," AN")))
			while(!feof(file))
			{
				if(!fgets(t,BSIZE,file)) break;
				if(strstr(t,"Atom ") && strstr(t," AN")) break;
			}
			for(k=0;k<nf;k++)
			{
				int n = nModes + k;
				if(n>3*mol->nAtoms) { ok = FALSE; break;}
				mol->vibration.modes[n].frequency = freq[k];
				mol->vibration.modes[n].properties[0] = IRIntensity[k];
				mol->vibration.modes[n].properties[1] = RamanIntensity[k];
				mol->vibration.modes[n].mass = mass[k];
			}

			for(j=0;j<mol->nAtoms && !feof(file);j++)
			{
				if(!fgets(t,BSIZE,file)) break;
				changeDInE(t); 
				sscanf(t,"%d %d %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&idum,&jdum,
					&v[0][0],&v[0][1],&v[0][2],
					&v[1][0],&v[1][1],&v[1][2],
					&v[2][0],&v[2][1],&v[2][2]
					);
				for(k=0;k<nf;k++)
				{
					int n = nModes + k;
					if(n>3*mol->nAtoms) { ok = FALSE; break;}
					mol->vibration.modes[n].vectors[0][j]= v[k][0]; 
					mol->vibration.modes[n].vectors[1][j]= v[k][1]; 
					mol->vibration.modes[n].vectors[2][j]= v[k][2]; 
				}
				if(!ok) break;
			}
			if(!ok || j!=mol->nAtoms) { ok = FALSE; freeVibrations(mol); break;}
			nModes += nf;
		}
 	}while(!feof(file));
	if(nModes<1)
	{
		char buffer[BSIZE];
		sprintf(buffer,"Sorry, I can not read frequencies from '%s' file\n",fileName);
  		fprintf(stderr,"%s\n",buffer);
	}
	else
	{
		mol->vibration.nModes = nModes;
		mol->vibration.modes = realloc(mol->vibration.modes, mol->vibration.nModes*sizeof(VibMode));
		sortFrequencies(mol);
		removeTransRotModes(mol);
	}
	return ok;
}
/********************************************************************************/
static Molecule* getMoleculeFromGaussianOutputFile(char *fileName, int numgeometry)
{
	char *t;
	boolean	OK;
	char *AtomCoord[5];
	FILE *file;
	int taille=BSIZE;
	int idummy;
	int i;
	int j=0;
	/* int l;*/
	int numgeom;
	char *pdest;
	int result;
	int itype=0;
	char* strStandard = "Standard orientation:";
	char* strInput = "Input orientation:";
	char* strOther = "orientation:";
	char* strSearch = strOther;
	Molecule* mol = newMolecule();
	char* symbol = NULL;

	for(i=0;i<5;i++) AtomCoord[i]=malloc(taille*sizeof(char));
	 
	t=malloc(taille*sizeof(char));
	file = fopen(fileName, "r");
	if(file ==NULL)
	{
		free(t);
	 	t = strdup_printf(("Sorry\nI can not open %s  file "),fileName);
	 	printf("%s\n",t);
	 	free(t);
	 	exit(1);
		return NULL;
	}
	while(!feof(file))
	{
		 if(!fgets(t,taille,file))break;
	         if(strstr( t, strStandard))
		 {
			 strSearch = strStandard;
			 break;
		 }
	         if(strstr( t, strInput)) strSearch = strInput;
	}
	fseek(file, 0L, SEEK_SET);
	numgeom =0;
	do 
	{
		OK=FALSE;
		while(!feof(file))
		{
		 	fgets(t,taille,file);
		 	if(strstr(t,"Charge =") && strstr(t,"Multiplicity ="))
		 	{
				 char* p = strstr(t,"Charge =")+8;
				mol->totalCharge = atoi(p);
			 	p = strstr(t,"Multiplicity =")+14;
				mol->spinMultiplicity = atoi(p);
		 	}
	         	pdest = strstr( t, strSearch);
	         	result = pdest - t ;
			if ( result >0 )
		 	{
		 		fgets(t,taille,file);
		 		fgets(t,taille,file);
		 		fgets(t,taille,file);
	               		pdest = strstr( t, "Type" );
	               		result = pdest - t ;
	               		if(result>0) itype=1;
	               		else itype=0;
		 		fgets(t,taille,file);
	               		numgeom++;
	               		if(numgeom == numgeometry )
				{
					OK = TRUE;
		 			break;
				}
				OK = TRUE;
				break;
			}
		}
		if(!OK && (numgeom == 0) )
		{
	 		free(t);
	 		t = strdup_printf(("Sorry\nI can not read geometry in  %s  file "),fileName);
	 		printf("%s\n",t);
	 		free(t);
	 		return NULL;
	   	}
	 	if(!OK)break;

	 	j=-1;
		if(mol->atoms) free(mol->atoms);
		mol->atoms = NULL;
		mol->nAtoms = 0;
	 	while(!feof(file) )
	 	{
	   		fgets(t,taille,file);
	   		pdest = strstr( t, "----------------------------------" );
	   		result = pdest - t ;
	   		if ( result >0 )
	   		{
				/*
				long geomposok = ftell(file);
	     			get_dipole_from_gaussian_output_file(file);
				fseek(file, geomposok, SEEK_SET);
				get_charges_from_gaussian_output_file(file,j+1);
				get_natural_charges_from_gaussian_output_file(file,j+1);
				fseek(file, geomposok, SEEK_SET);
				get_esp_charges_from_gaussian_output_file(file,j+1);
				*/
	     			break;
	   		}
	   		j++;

	   		if(itype==0) sscanf(t,"%d %s %s %s %s",&idummy,AtomCoord[0],AtomCoord[1],AtomCoord[2],AtomCoord[3]);
	   		else sscanf(t,"%d %s %d %s %s %s",&idummy,AtomCoord[0],&idummy,AtomCoord[1],AtomCoord[2],AtomCoord[3]);
			/* to do : test symbol */
			/*
			AtomCoord[0][0]=toupper(AtomCoord[0][0]);
			l=strlen(AtomCoord[0]);
	         	if (l==2) AtomCoord[0][1]=tolower(AtomCoord[0][1]);
			*/
			mol->atoms = realloc(mol->atoms,(j+1)*sizeof(Atom));

			symbol = getSymbolUsingZ(atoi(AtomCoord[0]));

			mol->atoms[j].prop = propAtomGet(symbol);
			mol->atoms[j].mmType=strdup(symbol);
			mol->atoms[j].pdbType=strdup(symbol);
			mol->atoms[j].residueName=strdup(symbol);
			mol->atoms[j].N=j+1;
			mol->atoms[j].layer=HIGH_LAYER;
			mol->atoms[j].variable=TRUE;
			mol->atoms[j].show=TRUE;
			mol->atoms[j].residueNumber=0;

			mol->atoms[j].coordinates[0]=atof(AtomCoord[1]);
			mol->atoms[j].coordinates[1]=atof(AtomCoord[2]);
			mol->atoms[j].coordinates[2]=atof(AtomCoord[3]);

			mol->atoms[j].gradient[0]=0;
			mol->atoms[j].gradient[1]=0;
			mol->atoms[j].gradient[2]=0;

			mol->atoms[j].velocity[0]=0.0;
			mol->atoms[j].velocity[1]=0.0;
			mol->atoms[j].velocity[2]=0.0;

	   		mol->atoms[j].charge=0.0;
	   		mol->atoms[j].charge0=0.0;
	   		mol->atoms[j].electronegativity=0.0;
	   		mol->atoms[j].hardness=0.0;
	   		mol->atoms[j].width= mol->atoms[j].prop.covalentRadii;
	   		mol->atoms[j].mass= mol->atoms[j].prop.mass;
	   		mol->atoms[j].rho=0.0;
	   		mol->atoms[j].U = 0.0;
		}
		mol->nAtoms = j+1;
		if(OK && numgeometry>-1) break;
	}while(!feof(file));

	fclose(file);
	free(t);
	for(i=0;i<5;i++) free(AtomCoord[i]);
        for(i=0; i<mol->nAtoms; i++) mol->atoms[i].typeConnections = NULL;
	resetTypeConnections(mol);
	int connections = 1;
	if(connections) setConnections(mol);
	else
	{
		createBondedMatrix(mol);
		printf(("Establishing connectivity : non bonded ...\n"));
		setNonBondedConnections(mol);
		freeBondedMatrix(mol);
	}

	/* if all freezed, set all to variable */
	{
		int j = 0;
		for(i=0;i<mol->nAtoms;i++)
			if(!mol->atoms[i].variable) j++;
		if(j==mol->nAtoms)
		for(i=0;i<mol->nAtoms;i++)
			mol->atoms[i].variable = TRUE;
	}
	printf("nAtoms = %d\n",mol->nAtoms);

	return mol;
}
/********************************************************************************/
Molecule* readMoleculeFromGaussianOutputFile(char *fileName, int numgeometry)
{
	Molecule* mol = getMoleculeFromGaussianOutputFile(fileName, numgeometry);
	readVibrationFromGaussianOutputFile(mol,fileName);
	readDipolesDerivativesFromGaussianOutputFile(mol, fileName);
	return mol;
}
/********************************************************************************/
static boolean readVibrationFromGaussianFChkFile(Molecule* mol, char* fileName)
{
 	FILE *file;
	int nf;
	double* vibE2 = NULL;
	double* vibNM = NULL;
	int idxFreq = 0;
	int idxMass = 0;
	int idxIR = 0;
	int idxRaman = 0;
	int i,j,k;
	int n;
	int nProps;
        int nModes = 0;

        if(!mol) return FALSE;
        if(mol->nAtoms<1) return FALSE;
        if(!fileName) return FALSE;
        file = fopen(fileName,"rb");
        if(!file) { return FALSE; }



	nf = get_one_int_from_fchk_gaussian_file(file,"Number of Normal Modes ");
	if(nf<1)
	{
		fprintf(stderr,"Sorry\nNo normal modes in this file : Use the Freq(SaveNM) option in your input file");
		fclose(file);
		return FALSE;
	}
	rewind(file);
	vibE2 = get_array_real_from_fchk_gaussian_file(file, "Vib-E2 ", &n);
	/* nf frequencies, nf Red. masses , nf Frc consts, nf IR Inten  , nf Raman Activ, nf Depolar (P), nf Depolar (U) */
	if(!vibE2 || n < 5*nf)
	{
		fprintf(stderr,"Sorry\nI can not the frequencies from this file");
		if(vibE2) free(vibE2);
		fclose(file);
		return FALSE;
	}
	rewind(file);
	vibNM = get_array_real_from_fchk_gaussian_file(file, "Vib-Modes ", &n);
	if(!vibNM || n != nf*mol->nAtoms*3)
	{
		fprintf(stderr,"Sorry\nI can not the normal modes from this file");
		printf("n = %d nf*nAtoms*3 = %d\n",n, nf*mol->nAtoms*3);
		if(vibE2) free(vibE2);
		if(vibNM) free(vibNM);
		fclose(file);
		return FALSE;
	}
	fclose(file);
	idxMass = nf;
	idxIR = 3*nf;
	idxRaman = 4*nf;

        nModes = nf;
        nProps = 2;
        initVibrations(mol, nModes, nProps);

	for(k=0;k<nf;k++)
	{
		mol->vibration.modes[k].frequency = vibE2[idxFreq+k];
		mol->vibration.modes[k].properties[0] = vibE2[idxIR+k];
		mol->vibration.modes[k].mass = vibE2[idxMass+k]; 
		mol->vibration.modes[k].properties[1] = vibE2[idxRaman+k];
		for(i=0;i<3;i++)
		{
			for(j=0;j<mol->nAtoms;j++)
			{
				mol->vibration.modes[k].vectors[i][j] = vibNM[k*mol->nAtoms*3+3*j+i];
			}
		}
	}
	if(vibE2) free(vibE2);
	if(vibNM) free(vibNM);
	sortFrequencies(mol);
	removeTransRotModes(mol);

	return TRUE;
}
/********************************************************************************/
static Molecule* getMoleculeFromGaussianFChkFile(char *fileName)
{
 	FILE *file;
	int i,j;
	int n;
	double* coords = NULL;
	double* charges = NULL;
	double* dipole = NULL;
	int* z = NULL;
	double* zn = NULL;
	Molecule* mol;

	file = fopen(fileName, "rb");
	if(file ==NULL)
	{
  		fprintf(stderr,"Sorry\nI can not open this file");
  		return FALSE;
	}

	j = get_one_int_from_fchk_gaussian_file(file,"Number of atoms ");
	if(j<1)
	{
  		fprintf(stderr,"Sorry\nI can not the number of atoms from this file");
  		return FALSE;
	}
	z = get_array_int_from_fchk_gaussian_file(file, "Atomic numbers ", &n);
	if(n!=j)
	{
  		fprintf(stderr,"Sorry\nI can not read the atomic numbers from this file");
  		return FALSE;
	}
	coords = get_array_real_from_fchk_gaussian_file(file, "Current cartesian coordinates  ", &n);
	if(n!=3*j)
	{
  		fprintf(stderr,"Sorry\nI can not read the current cartesian coordinates from this file");
  		return FALSE;
	}
	rewind(file);
	mol = newMolecule();
	mol->nAtoms = j;

    	mol->atoms = malloc(mol->nAtoms*sizeof(Atom));
	for(j=0;j<mol->nAtoms;j++)
	{
    		char* t = strdup(symbAtomGet(z[j]));
               	mol->atoms[j].prop = propAtomGet(t);
                mol->atoms[j].mmType=strdup(t);
                mol->atoms[j].pdbType=strdup(t);
                mol->atoms[j].residueName=strdup(t);
                mol->atoms[j].N=j+1;
                mol->atoms[j].layer=HIGH_LAYER;
                mol->atoms[j].variable=TRUE;
                mol->atoms[j].show=TRUE;
		mol->atoms[j].residueNumber=0;
                mol->atoms[j].charge=0.0;
                mol->atoms[j].charge0=0.0;
                mol->atoms[j].electronegativity=0.0;
                mol->atoms[j].hardness=0.0;
	   	mol->atoms[j].width=mol->atoms[j].prop.covalentRadii;
                mol->atoms[j].mass=mol->atoms[j].prop.mass;
                mol->atoms[j].rho=0.0;
                mol->atoms[j].U = 0.0;

		for(i=0;i<3;i++) mol->atoms[j].coordinates[i]= coords[j*3+i]; 
		for(i=0;i<3;i++) mol->atoms[j].gradient[i] = 0.0;
		for(i=0;i<3;i++) mol->atoms[j].velocity[j]=0.0;
		free(t);
	}

	int connections = 1;
        for(i=0; i<mol->nAtoms; i++) mol->atoms[i].typeConnections = NULL;
	resetTypeConnections(mol);
	if(connections) setConnections(mol);

	if(z) free(z);
	if(coords) free(coords);
	z = NULL;
	coords = NULL;
	rewind(file);
	charges = get_array_real_from_fchk_gaussian_file(file, "NPA Charges ", &n);
	if(n==mol->nAtoms && charges) { for(j=0;j<mol->nAtoms;j++) mol->atoms[j].charge =charges[j]; }
	else
	{
		rewind(file);
		charges = get_array_real_from_fchk_gaussian_file(file, "ESP Charges  ", &n);
		if(n==mol->nAtoms && charges) { for(j=0;j<mol->nAtoms;j++) mol->atoms[j].charge =charges[j]; }
		else
		{
			rewind(file);
			charges = get_array_real_from_fchk_gaussian_file(file, "Mulliken Charges  ", &n);
			if(n==mol->nAtoms && charges) { for(j=0;j<mol->nAtoms;j++) mol->atoms[j].charge =charges[j]; }
		}
	}
	if(charges) free(charges);
	rewind(file);
	zn = get_array_real_from_fchk_gaussian_file(file, "Nuclear charges ", &n);
	if(zn && n== j)
	{
		for(j=0;j<mol->nAtoms;j++) mol->atoms[j].charge0 =zn[j];
	}
	if(zn)free(zn);
	if(n!=j)
	{
  		fprintf(stderr,"Sorry\nI can not read the atomic numbers from this file");
  		return FALSE;
	}
	dipole = get_array_real_from_fchk_gaussian_file(file, "Dipole Moment  ", &n);
	for(i=0;i<3;i++) mol->dipole[i] = 0.0;
	if(n==3)
	{
		for(i=0;i<3;i++) mol->dipole[i] = dipole[i];
	}
	if(dipole) free(dipole);
 	fclose(file);
	return mol;
}
/********************************************************************************/
Molecule* readMoleculeFromGaussianFChkFile(char *fileName)
{
	Molecule* mol = getMoleculeFromGaussianFChkFile(fileName);
	readVibrationFromGaussianFChkFile(mol,fileName);
	return mol;
}
/********************************************************************************/
static boolean readVibrationFromGabeditFile(Molecule* mol, char* fileName)
{
	FILE* file = NULL;
	static char *t = NULL; 
	int i,j,k;
	int nModes = 0;
	int nProps = 0;

	if(!mol) return FALSE;
	if(!fileName) return FALSE; 
	if(t==NULL) t = malloc(BSIZE*sizeof(char));
	file = fopen(fileName,"rb");
	if(!file) { return FALSE; }
	/* compute number of modes */
	nModes = 0;
	if(goToStr(file, "[FREQ]"))
	{ 
		double d;
		while(!feof(file))
		{
    			if(!fgets(t,BSIZE, file)) break;
			deleteFirstSpaces(t);
			if(t[0]=='#') continue;
			if(sscanf(t,"%lf",&d)!=1) break;
			nModes++;
		}
	}
	if(nModes<1) { fclose(file); return FALSE;}
	/* compute number of props */
	nProps = 0;
	if(goToStr(file, "[INT]"))
	{ 
		double d1,d2,d3,d4;
		while(!feof(file))
		{
    			if(!fgets(t,BSIZE, file)) break;
			deleteFirstSpaces(t);
			if(t[0]=='#') continue;
			nProps = sscanf(t,"%lf %lf %lf %lf",&d1,&d2,&d3,&d4);
			break;
		}
	}
	initVibrations(mol, nModes, nProps);
	/* read harmonic frequencies */
	if(goToStr(file, "[FREQ]"))
	{ 
		double d;
		for(i=0;i<mol->vibration.nModes;i++)
		{
    			if(!fgets(t,BSIZE, file)) break;
			deleteFirstSpaces(t);
			if(t[0]=='#') { i--; continue;}
			if(sscanf(t,"%lf",&d)!=1) break;
			mol->vibration.modes[i].frequency = d;
		}
	}
	/* read masses */
	if(goToStr(file, "[MASS]"))
	{ 
		double d;
		for(i=0;i<mol->vibration.nModes;i++)
		{
    			if(!fgets(t,BSIZE, file)) break;
			deleteFirstSpaces(t);
			if(t[0]=='#') { i--; continue;}
			if(sscanf(t,"%lf",&d)!=1) break;
			mol->vibration.modes[i].mass = d;
		}
		if(i!=mol->vibration.nModes)
		{
			fprintf(stderr,"----------------- Error -------------------------------------------------\n");
			fprintf(stderr,"Error , I cannot read masses from %s file, check your file\n",fileName);
			fprintf(stderr,"-------------------------------------------------------------------------\n");
			exit(1);
		}
	}
	else
	{
		fprintf(stderr,"----------------- Warning -------------------------------------------------\n");
		fprintf(stderr,"Error , I cannot read masses from %s file, check your file\n",fileName);
		fprintf(stderr,"-------------------------------------------------------------------------\n");
	}
	/* read intensities */
	if(goToStr(file, "[INT]"))
	{ 
		double d[4];
		int n;
		for(i=0;i<mol->vibration.nModes;i++)
		{
    			if(!fgets(t,BSIZE, file)) break;
			deleteFirstSpaces(t);
			if(t[0]=='#') { i--; continue;}
			n = sscanf(t,"%lf %lf %lf %lf",&d[0],&d[1],&d[2],&d[3]);
			if(n<<mol->vibration.nProperties)
			for(j=0;j<n;j++) mol->vibration.modes[i].properties[j] = d[j];
		}
	}
	/* read vectors */
	if(goToStr(file, "[FR-NORM-COORD]"))
	{ 
		double d[3];
		for(i=0;i<mol->vibration.nModes;i++)
		{
    			if(!fgets(t,BSIZE, file)) break; /* vibration i title */
			deleteFirstSpaces(t);
			if(t[0]=='#') { i--; continue;}
			for(j=0;j<mol->nAtoms;j++) 
			{
    				if(!fgets(t,BSIZE, file)) break;
				deleteFirstSpaces(t);
				if(t[0]=='#') {j--; continue;}
				sscanf(t,"%lf %lf %lf",&d[0],&d[1],&d[2]);
				for(k=0;k<3;k++) mol->vibration.modes[i].vectors[k][j] = d[k];
			}
		}
	}
	fclose(file);
	sortFrequencies(mol);
	removeTransRotModes(mol);
	return TRUE;
}
/********************************************************************************/
static boolean readGradientFromGabeditFile(Molecule* mol, char* namefile)
{
	FILE* file = NULL;
	static char *t = NULL; 
	boolean Ok = FALSE;
	int n,ic,is;
#define SZ 50
	int i;
	char* pos;
	int nGeoms = 0;
	int nLabels = 0;

	if(!namefile) 
	{
		printf("Sorry I cannot read geometry namefile = NULL\n");
		exit(1);
	}
	if(t==NULL) t = malloc(BSIZE*sizeof(char));
	file = fopen(namefile,"rb");
	if(!file)
	{
		printf("Sorry I cannot open %s file\n",namefile);
		exit(1);
	}
	rewind(file);
	while(!feof(file))
  	{
    		if(!fgets(t,BSIZE, file)) break;
		deleteFirstSpaces(t);
		if(t[0]=='#') continue;
		uppercase(t);
		pos = strstr(t,"[GEOMS]");
		if(pos)
		{ 
			while(!feof(file))
			{
    				if(!fgets(t,BSIZE, file)) break;
				deleteFirstSpaces(t);
				if(t[0]=='#') continue;
				break;
			}
			if(2==sscanf(t,"%d%d",&nGeoms,&nLabels))
			{

				for(i=0; i<nLabels; i++)
    					if(!fgets(t,BSIZE, file)) break;
				if(i==nLabels) Ok = TRUE;
			}
			break;
		}
	}
	/* I read the gradient of the first geometry */
	for(i=0; i<nLabels; i++)
    		if(!fgets(t,BSIZE, file)) break;
	if(i!=nLabels) Ok = FALSE;
    	if(!fgets(t,BSIZE, file)) {Ok = FALSE; }
	if(Ok && 3==sscanf(t,"%d%d%d",&n,&ic,&is) && n>0 && is>0)
	{
		/*printf("Mult = %d\n",is);*/
		if(mol->nAtoms!= n || mol->spinMultiplicity != is || mol->totalCharge != ic)
		{
			printf("Sorry geometry in file %s and that in memory have not the same number of atoms or spin or charge\n",namefile);
			exit(1);
			Ok = FALSE;
		}
	}
	else Ok = FALSE;
	if(!Ok)
	{
		printf("Sorry I cannot read geometry from %s file\n",namefile);
		exit(1);
	}
	for(i=0; i<mol->nAtoms; i++)
	{
			if(!fgets(t,BSIZE,file))
			{
				printf("Sorry I cannot read geometry from %s file.\n",namefile);
				exit(1);
			}
			deleteFirstSpaces(t);
			if(t[0]=='#') { i--;continue;}
			get_gradients_one_atom(t, mol->atoms[i].gradient);
	}
	
	fclose(file);
	return Ok;
}
/********************************************************************************/
static Molecule** readMoleculesFromCChemIFile(char *fileName, boolean connections)
{
	char tmp[BSIZE];
	FILE *file;
	int nAtoms;
	Molecule** mols = NULL;
	int tcharge=0;
	int mult=1;
#define SZ 50
	char symbol[SZ];
	char mmType[SZ];
	char pdbType[SZ];
	char residueName[SZ];
	double X,Y,Z;
	double charge;
	int layer;
	double energy;

	file = fopen(fileName, "r");
	if(file ==NULL)
	{
	 	sprintf(tmp,"Sorry\nI can not open %s  file ",fileName);
	 	fprintf(stderr,"%s\n",tmp);
	 	exit(1);
		return NULL;
	}
	while(!feof(file))
  	{
    		if(!fgets(tmp,BSIZE, file)) break;
		deleteFirstSpaces(tmp);
		if(tmp[0]=='#') continue;
		uppercase(tmp);
		if(strstr(tmp,"GEOMETRY"))break;
	}
	if(!strstr(tmp,"GEOMETRY"))
	{
	 	sprintf(tmp,"Sorry\nI cannot read geometries from %s file ",fileName);
	 	fprintf(stderr,"%s\n",tmp);
	 	exit(1);
		return NULL;
	}
	int nGeoms = 0;
	while(!feof(file))
	{
		if(!fgets(tmp,BSIZE,file))break;
		energy=0;
		if(3>sscanf(tmp,"%d%d%d %lf",&nAtoms,&tcharge,&mult,&energy)) break;
		Molecule* mol = newMolecule();
		mol->totalCharge = tcharge;
		mol->spinMultiplicity = mult;
		mol->potentialEnergy = energy;
		mol->atoms = NULL;
		mol->nAtoms = nAtoms;
		mol->atoms = malloc(nAtoms*sizeof(Atom));
		int i;
		for(i=0; i<mol->nAtoms; i++) mol->atoms[i].typeConnections = malloc(mol->nAtoms*sizeof(int));
		int l;
		for(i=0; i<mol->nAtoms; i++)
		{
			int variable = 0;
			int ibeg = 12;
			if(!fgets(tmp,BSIZE,file))
			{
				fprintf(stderr,"Sorry I cannot read geometry from %s file.\n",fileName);
				exit(1);
			}
			deleteFirstSpaces(tmp);
			if(tmp[0]=='#') { i--;continue;}
    			sscanf(tmp,"%s %s %s %s %d %lf %d %d %lf %lf %lf",
					symbol,mmType,pdbType,residueName, 
					&mol->atoms[i].residueNumber,
					&charge,&layer,&variable,&X,&Y,&Z);
			symbol[0]=toupper(symbol[0]);
			l=strlen(symbol);
			if (l==2) symbol[1]=tolower(symbol[1]);

			mol->atoms[i].prop = propAtomGet(symbol);
			mol->atoms[i].mmType=strdup(mmType);
			mol->atoms[i].pdbType=strdup(pdbType);
			mol->atoms[i].residueName=strdup(residueName);
			mol->atoms[i].N=i+1;
			mol->atoms[i].layer=layer;
			mol->atoms[i].variable=variable;
			mol->atoms[i].show=TRUE;
			mol->atoms[i].coordinates[0] = X;
			mol->atoms[i].coordinates[1] = Y;
			mol->atoms[i].coordinates[2] = Z;
			mol->atoms[i].velocity[0] = 0;
			mol->atoms[i].velocity[1] = 0;
			mol->atoms[i].velocity[2] = 0;
			mol->atoms[i].gradient[0]=0;
			mol->atoms[i].gradient[1]=0;
			mol->atoms[i].gradient[2]=0;
			mol->atoms[i].charge = charge;
			mol->atoms[i].charge0 = charge;
			mol->atoms[i].electronegativity = 0;
			mol->atoms[i].hardness = 0;
			mol->atoms[i].width = mol->atoms[i].prop.covalentRadii;
			mol->atoms[i].mass = mol->atoms[i].prop.mass;
			mol->atoms[i].rho = 0.0;
	   		mol->atoms[i].U = 0.0;
			if(!get_connections_one_atom(tmp, mol->nAtoms, ibeg, mol->atoms[i].typeConnections))
			{
				/*
				fprintf(stderr,"Sorry I cannot read the connection for atom # %d from the %s file.\n",i+1,fileName);
				exit(1);
				*/
				fprintf(stderr,"Warning : I cannot read the connection for atom # %d from the %s file.\n",i+1,fileName);
			}
		}
		if(i==nAtoms) 
		{
			if(connections) setConnections(mol);
			else {
				createBondedMatrix(mol);
				fprintf(stderr,"Establishing connectivity : non bonded ...\n");
				setNonBondedConnections(mol);
				freeBondedMatrix(mol);
			}
			/* if all freezed, set all to variable */
			{
				int jv = 0;
				int i;
				for(i=0;i<mol->nAtoms;i++)
					if(!mol->atoms[i].variable) jv++;
				if(jv==mol->nAtoms) for(i=0;i<mol->nAtoms;i++) mol->atoms[i].variable = TRUE;
			}
			nGeoms++;
			mols = realloc(mols, nGeoms*sizeof(Molecule*));
			mols[nGeoms-1] = mol;
		}
	}
	if(nGeoms>0){
			mols = realloc(mols, (nGeoms+1)*sizeof(Molecule*));
			mols[nGeoms] = NULL;
		}
	fclose(file);
	return mols;
}
/********************************************************************************/
static Molecule** readMoleculesFromXYZFile(char *fileName, boolean connections)
{
	char tmp[BSIZE];
	FILE *file;
	char symbol[BSIZE];
	double x,y,z;
	int nAtoms;
	Molecule** mols = NULL;
	int charge=0;
	int mult=1;
	double energy;

	file = fopen(fileName, "r");
	if(file ==NULL)
	{
	 	sprintf(tmp,"Sorry\nI can not open %s  file ",fileName);
	 	printf("%s\n",tmp);
	 	exit(1);
		return NULL;
	}
	int nGeoms = 0;
	while(!feof(file))
	{
		if(!fgets(tmp,BSIZE,file))break;
		if(1!=sscanf(tmp,"%d",&nAtoms)) break;
		if(!fgets(tmp,BSIZE,file))break;
		int a,b;
		if(2>sscanf(tmp,"%d %d %lf",&a,&b,&energy)) { charge=a; mult=b;} 
		Molecule* mol = newMolecule();
		mol->totalCharge = charge;
		mol->spinMultiplicity = mult;
		mol->potentialEnergy = energy;
		mol->atoms = NULL;
		mol->nAtoms = nAtoms;
		mol->atoms = malloc(nAtoms*sizeof(Atom));
		int j;
		for(j=0;j<nAtoms;j++)
		{
			if(!fgets(tmp,BSIZE,file))break;
			if(4==sscanf(tmp,"%s %lf %lf %lf",symbol, &x, &y, &z)) { 
			mol->atoms[j].prop = propAtomGet(symbol);
			mol->atoms[j].mmType=strdup(symbol);
			mol->atoms[j].pdbType=strdup(symbol);
			mol->atoms[j].residueName=strdup(symbol);
			mol->atoms[j].N=j+1;
			mol->atoms[j].layer=HIGH_LAYER;
			mol->atoms[j].variable=TRUE;
			mol->atoms[j].show=TRUE;
			mol->atoms[j].residueNumber=0;

			mol->atoms[j].coordinates[0]=x;
			mol->atoms[j].coordinates[1]=y;
			mol->atoms[j].coordinates[2]=y;

			mol->atoms[j].gradient[0]=0;
			mol->atoms[j].gradient[1]=0;
			mol->atoms[j].gradient[2]=0;

			mol->atoms[j].velocity[0]=0.0;
			mol->atoms[j].velocity[1]=0.0;
			mol->atoms[j].velocity[2]=0.0;

	   		mol->atoms[j].charge=0.0;
	   		mol->atoms[j].charge0=0.0;
	   		mol->atoms[j].electronegativity=0.0;
	   		mol->atoms[j].hardness=0.0;
	   		mol->atoms[j].width= mol->atoms[j].prop.covalentRadii;
	   		mol->atoms[j].mass= mol->atoms[j].prop.mass;
	   		mol->atoms[j].rho=0.0;
	   		mol->atoms[j].U = 0.0;
			} 
		}
		if(j==nAtoms) 
		{
			int i;
        		for(i=0; i<mol->nAtoms; i++) mol->atoms[i].typeConnections = NULL;
			resetTypeConnections(mol);
			if(connections) setConnections(mol);
			else {
				createBondedMatrix(mol);
				printf(("Establishing connectivity : non bonded ...\n"));
				setNonBondedConnections(mol);
				freeBondedMatrix(mol);
			}
			/* if all freezed, set all to variable */
			{
				int jv = 0;
				int i;
				for(i=0;i<mol->nAtoms;i++)
					if(!mol->atoms[i].variable) jv++;
				if(jv==mol->nAtoms) for(i=0;i<mol->nAtoms;i++) mol->atoms[i].variable = TRUE;
			}
			nGeoms++;
			mols = realloc(mols, nGeoms*sizeof(Molecule*));
			mols[nGeoms-1] = mol;
		}
	}
	if(nGeoms>0) {
			mols = realloc(mols, (nGeoms+1)*sizeof(Molecule*));
			mols[nGeoms] = NULL;
		}
	fclose(file);
	return mols;
}
/********************************************************************************/
static Molecule** readMoleculesFromGabeditFile(char* namefile, boolean connections)
{
	FILE* file = NULL;
	static char *t = NULL; 
	boolean Ok = FALSE;
	int n,ic,is;
	Molecule** mols = NULL;
#define SZ 50
	char symbol[SZ];
	char mmType[SZ];
	char pdbType[SZ];
	char residueName[SZ];
	double X,Y,Z;
	double charge;
	int layer;
	char* pos;
	int nGeoms = 0;
	int nLabels = 0;
	int iEnergy;
	double convEnergy = 1.0;

	if(!namefile) 
	{
		fprintf(stderr,"Sorry I cannot read geometry namefile = NULL\n");
		exit(1);
	}
	if(t==NULL) t = malloc(BSIZE*sizeof(char));
	file = fopen(namefile,"rb");
	if(!file)
	{
		fprintf(stderr,"Sorry I cannot open %s file\n",namefile);
		exit(1);
	}
	rewind(file);
	iEnergy=-1;
	while(!feof(file))
  	{
    		if(!fgets(t,BSIZE, file)) break;
		deleteFirstSpaces(t);
		if(t[0]=='#') continue;
		uppercase(t);
		pos = strstr(t,"[GEOMS]");
		if(pos)
		{ 
			while(!feof(file))
			{
    				if(!fgets(t,BSIZE, file)) break;
				deleteFirstSpaces(t);
				if(t[0]=='#') continue;
				break;
			}
			if(2==sscanf(t,"%d%d",&nGeoms,&nLabels))
			{

				int i;
				for(i=0; i<nLabels; i++)
				{
    					if(!fgets(t,BSIZE, file)) break;
					if(strstr(t,"nergy")) 
					{
						iEnergy=i;
						if(strstr(t,"tree")) convEnergy = AUTOKCAL;
						if(strstr(t,"eV")) convEnergy = AUTOKCAL/(AUTOEV);
					}
				}
				if(i==nLabels) Ok = TRUE;
			}
			break;
		}
	}
	mols = (Molecule**) malloc((nGeoms+1)*sizeof(Molecule*));
	int ig;
	for(ig=0; ig<nGeoms; ig++) mols[ig] = newMolecule();
	mols[nGeoms] = NULL;

	for(ig=0; ig<nGeoms; ig++) {
		int ie = 0;
		double energy=0;
		double e;
		Molecule* mol = mols[ig];
		/* I read a geometry */
		int i;
		for(i=0; i<nLabels; i++) 
		{
			if(!fgets(t,BSIZE, file)) break;
			if(iEnergy == i) energy = atof(t)*convEnergy;
		}
		if(i!=nLabels) Ok = FALSE;
    		if(!fgets(t,BSIZE, file)) {Ok = FALSE; }
		if(Ok) ie = sscanf(t,"%d%d%d%lf",&n,&ic,&is,&e);
		if(Ok && 3<=ie && n>0 && is>0)
		{
			/*printf("Mult = %d\n",is);*/
			mol->nAtoms = n;
			mol->spinMultiplicity = is;
			mol->totalCharge = ic;

			if(ie==4) mol->potentialEnergy = e;
			else mol->potentialEnergy = energy;

			mol->atoms = malloc(mol->nAtoms*sizeof(Atom));
			for(i=0; i<mol->nAtoms; i++) mol->atoms[i].typeConnections = malloc(mol->nAtoms*sizeof(int));
		}
		else Ok = FALSE;
		if(!Ok)
		{
			fprintf(stderr,"Sorry I cannot read geometry from %s file\n",namefile);
			exit(1);
		}
		for(i=0; i<mol->nAtoms; i++)
		{
			int variable = 0;
			int ibeg = 12;
			int l;
			if(!fgets(t,BSIZE,file))
			{
				fprintf(stderr,"Sorry I cannot read geometry from %s file.\n",namefile);
				exit(1);
			}
			deleteFirstSpaces(t);
			if(t[0]=='#') { i--;continue;}
    			sscanf(t,"%s %s %s %s %d %lf %d %d %lf %lf %lf", symbol,mmType,pdbType,residueName, 
					&mol->atoms[i].residueNumber,
					&charge,&layer,&variable,&X,&Y,&Z);
			symbol[0]=toupper(symbol[0]);
			l=strlen(symbol);
			if (l==2) symbol[1]=tolower(symbol[1]);

			mol->atoms[i].prop = propAtomGet(symbol);
			mol->atoms[i].mmType=strdup(mmType);
			mol->atoms[i].pdbType=strdup(pdbType);
			mol->atoms[i].residueName=strdup(residueName);
			mol->atoms[i].N=i+1;
			mol->atoms[i].layer=layer;
			mol->atoms[i].variable=variable;
			mol->atoms[i].show=TRUE;
			mol->atoms[i].coordinates[0] = X;
			mol->atoms[i].coordinates[1] = Y;
			mol->atoms[i].coordinates[2] = Z;
			mol->atoms[i].gradient[0]=0;
			mol->atoms[i].gradient[1]=0;
			mol->atoms[i].gradient[2]=0;
			mol->atoms[i].velocity[0]=0.0;
			mol->atoms[i].velocity[1]=0.0;
			mol->atoms[i].velocity[2]=0.0;
			mol->atoms[i].charge = charge;
			mol->atoms[i].charge0 = charge;
			mol->atoms[i].electronegativity = 0;
			mol->atoms[i].hardness = 0;
			mol->atoms[i].width = mol->atoms[i].prop.covalentRadii;
			mol->atoms[i].mass = mol->atoms[i].prop.mass;
			mol->atoms[i].rho = 0.0;
	   		mol->atoms[i].U = 0.0;
			if(!get_connections_one_atom(t, mol->nAtoms, ibeg, mol->atoms[i].typeConnections))
			{
				/*
				printf("Sorry I cannot read the connection for atom # %d from the %s file.\n",i+1,namefile);
				exit(1);
				*/
				fprintf(stderr,"Warning : I cannot read the connection for atom # %d from the %s file.\n",i+1,namefile);
			}
			get_gradients_one_atom(t, mol->atoms[i].gradient);
		}
		if(connections) setConnections(mol);
		else {
			createBondedMatrix(mol);
			printf(("Establishing connectivity : non bonded ...\n"));
			setNonBondedConnections(mol);
			freeBondedMatrix(mol);
		}
		/* if all freezed, set all to variable */
		{
			int jv = 0;
			for(i=0;i<mol->nAtoms;i++) if(!mol->atoms[i].variable) jv++;
			if(jv==mol->nAtoms) for(i=0;i<mol->nAtoms;i++) mol->atoms[i].variable = TRUE;
		}
	}
	fclose(file);
	/* for(ig=0; ig<nGeoms; ig++) fprintf(stdout,"Mol %d Energy = %f\n",ig,mols[ig]->potentialEnergy);*/
	return mols;
}
/*************************************************************************************/
Molecule** readMolecules(char* fileName, boolean connections)
{
	char* fileNameToRead = malloc(BSIZE*sizeof(char));
	CCHEMIFileType type;
	Molecule** mols = NULL;

	if(!fileName) return mols;

	fileNameToRead = malloc(BSIZE*sizeof(char));
	getFileNameToRead(fileName, fileNameToRead);

	type = getTypeFile(fileNameToRead);

	//printf("type %d\n",type);

	if(type == FILETYPE_CCHEMI) mols = readMoleculesFromCChemIFile(fileNameToRead, connections);
	else if(type == FILETYPE_GABEDIT) mols = readMoleculesFromGabeditFile(fileNameToRead, connections);
	else if(type == FILETYPE_XYZ) mols = readMoleculesFromXYZFile(fileNameToRead, connections);
	else
	{
		fprintf(stderr,"Sorry, I cannot read severla geometries from the molecule from %s file\n",fileNameToRead);
		fprintf(stderr,"       Only Gabedit & XYZ are supported for reading severla geometries\n");
		exit(1);
	}

	free(fileNameToRead);
	return mols;
}
/********************************************************************************/
static Molecule* getMoleculeFromGabeditFile_GEOMS(char* namefile)
{
	FILE* file = NULL;
	static char *t = NULL; 
	boolean Ok = FALSE;
	int n,ic,is;
	Molecule* mol = newMolecule();
#define SZ 50
	char symbol[SZ];
	char mmType[SZ];
	char pdbType[SZ];
	char residueName[SZ];
	double X,Y,Z;
	double charge;
	int layer;
	int i,l;
	char* pos;
	int nGeoms = 0;
	int nLabels = 0;
	int iEnergy = -1;
	double convEnergy = 1.0;
	int iDipole = -1;
	double convDipole = 1.0;

	if(!namefile) 
	{
		printf("Sorry I cannot read geometry namefile = NULL\n");
		exit(1);
	}
	if(t==NULL) t = malloc(BSIZE*sizeof(char));
	file = fopen(namefile,"rb");
	if(!file)
	{
		printf("Sorry I cannot open %s file\n",namefile);
		exit(1);
	}
	rewind(file);
	while(!feof(file))
  	{
    		if(!fgets(t,BSIZE, file)) break;
		deleteFirstSpaces(t);
		if(t[0]=='#') continue;
		uppercase(t);
		pos = strstr(t,"[GEOMS]");
		if(pos)
		{ 
			while(!feof(file))
			{
    				if(!fgets(t,BSIZE, file)) break;
				deleteFirstSpaces(t);
				if(t[0]=='#') continue;
				break;
			}
			if(2==sscanf(t,"%d%d",&nGeoms,&nLabels))
			{

				for(i=0; i<nLabels; i++)
				{
    					if(!fgets(t,BSIZE, file)) break;
					if(strstr(t,"nergy")) 
					{
						iEnergy=i;
						if(strstr(t,"tree")) convEnergy = AUTOKCAL;
						if(strstr(t,"eV")) convEnergy = AUTOKCAL/(AUTOEV);
					}
					if(strstr(t,"pole")) 
					{
						iDipole=i;
						if(strstr(t,"au") || strstr(t,"atomi")) convDipole = AUTODEB;
					}
				}
				if(i==nLabels) Ok = TRUE;
			}
			break;
		}
	}
	/* I read the first geometry */
	for(i=0; i<nLabels; i++) 
	{
		if(!fgets(t,BSIZE, file)) break;
		if(iEnergy == i) mol->potentialEnergy = atof(t)*convEnergy;
		if(iDipole == i) 
		{
			int k;
			sscanf(t,"%lf %lf %lf",&mol->dipole[0], &mol->dipole[1], &mol->dipole[2]);
			for(k=0;k<3;k++) mol->dipole[k] *= convDipole;
		}
	}
	if(i!=nLabels) Ok = FALSE;
    	if(!fgets(t,BSIZE, file)) {Ok = FALSE; }
	if(Ok && 3==sscanf(t,"%d%d%d",&n,&ic,&is) && n>0 && is>0)
	{
		/*printf("Mult = %d\n",is);*/
		mol->nAtoms = n;
		mol->spinMultiplicity = is;
		mol->totalCharge = ic;
		mol->atoms = malloc(mol->nAtoms*sizeof(Atom));
		for(i=0; i<mol->nAtoms; i++) mol->atoms[i].typeConnections = malloc(mol->nAtoms*sizeof(int));
	}
	else Ok = FALSE;
	if(!Ok)
	{
		printf("Sorry I cannot read geometry from %s file\n",namefile);
		exit(1);
	}
	for(i=0; i<mol->nAtoms; i++)
	{
			int variable = 0;
			int ibeg = 12;
			if(!fgets(t,BSIZE,file))
			{
				printf("Sorry I cannot read geometry from %s file.\n",namefile);
				exit(1);
			}
			deleteFirstSpaces(t);
			if(t[0]=='#') { i--;continue;}
    			sscanf(t,"%s %s %s %s %d %lf %d %d %lf %lf %lf", symbol,mmType,pdbType,residueName, 
					&mol->atoms[i].residueNumber,
					&charge,&layer,&variable,&X,&Y,&Z);
			symbol[0]=toupper(symbol[0]);
			l=strlen(symbol);
			if (l==2) symbol[1]=tolower(symbol[1]);

			mol->atoms[i].prop = propAtomGet(symbol);
			mol->atoms[i].mmType=strdup(mmType);
			mol->atoms[i].pdbType=strdup(pdbType);
			mol->atoms[i].residueName=strdup(residueName);
			mol->atoms[i].N=i+1;
			mol->atoms[i].layer=layer;
			mol->atoms[i].variable=variable;
			mol->atoms[i].show=TRUE;
			mol->atoms[i].coordinates[0] = X;
			mol->atoms[i].coordinates[1] = Y;
			mol->atoms[i].coordinates[2] = Z;
			mol->atoms[i].gradient[0]=0;
			mol->atoms[i].gradient[1]=0;
			mol->atoms[i].gradient[2]=0;
			mol->atoms[i].velocity[0]=0.0;
			mol->atoms[i].velocity[1]=0.0;
			mol->atoms[i].velocity[2]=0.0;
			mol->atoms[i].charge = charge;
			mol->atoms[i].charge0 = charge;
			mol->atoms[i].electronegativity = 0;
			mol->atoms[i].hardness = 0;
			mol->atoms[i].width = mol->atoms[i].prop.covalentRadii;
			mol->atoms[i].mass = mol->atoms[i].prop.mass;
			mol->atoms[i].rho = 0.0;
	   		mol->atoms[i].U = 0.0;
			if(!get_connections_one_atom(t, mol->nAtoms, ibeg, mol->atoms[i].typeConnections))
			{
				/*
				printf("Sorry I cannot read the connection for atom # %d from the %s file.\n",i+1,namefile);
				exit(1);
				*/
				fprintf(stderr,"Warning : I cannot read the connection for atom # %d from the %s file.\n",i+1,namefile);
			}
			get_gradients_one_atom(t, mol->atoms[i].gradient);
	}
	
	fclose(file);
	/* if all freezed, set all to variable */
	{
		int j = 0;
		for(i=0;i<mol->nAtoms;i++)
			if(!mol->atoms[i].variable) j++;
		if(j==mol->nAtoms)
		for(i=0;i<mol->nAtoms;i++)
			mol->atoms[i].variable = TRUE;
	}
	return mol;
}
/********************************************************************************/
static Molecule* getMoleculeFromGabeditFile_FRCOORD(char* namefile)
{
	FILE* file = NULL;
	static char *t = NULL; 
	Molecule* mol = newMolecule();
#define SZ 50
	char symbol[SZ];
	double X,Y,Z;
	int i,l;

	if(!namefile) 
	{
		printf("Sorry I cannot read geometry namefile = NULL\n");
		exit(1);
	}
	if(t==NULL) t = malloc(BSIZE*sizeof(char));
	file = fopen(namefile,"rb");
	if(!file)
	{
		printf("Sorry I cannot open %s file\n",namefile);
		exit(1);
	}
	rewind(file);
	while(!feof(file))
  	{
    		if(!fgets(t,BSIZE, file)) break;
		deleteFirstSpaces(t);
		if(t[0]=='#') continue;
		uppercase(t);
		if(strstr(t,"[FR-COORD]")) break;
	}
	mol->nAtoms = 0;
	mol->spinMultiplicity = 1;
	mol->totalCharge = 0;
	i = -1;
	while(!feof(file))
  	{
    		if(!fgets(t,BSIZE, file)) break;
		deleteFirstSpaces(t);
		if(t[0]=='#') continue;
		uppercase(t);
		if(strstr(t,"[")) break;
    		if(4!=sscanf(t,"%s %lf %lf %lf", symbol, &X,&Y,&Z)) break;
		symbol[0]=toupper(symbol[0]);
		l=strlen(symbol);
		if (l>=2) symbol[1]=tolower(symbol[1]);
		if (l>=3) symbol[2]=tolower(symbol[2]);
		i++;
		mol->atoms = realloc(mol->atoms,(i+1)*sizeof(Atom));
		mol->atoms[i].prop = propAtomGet(symbol);
		mol->atoms[i].mmType=strdup(symbol);
		mol->atoms[i].pdbType=strdup(symbol);
		mol->atoms[i].residueName=strdup("UNK");
		mol->atoms[i].N=i+1;
		mol->atoms[i].layer=HIGH_LAYER;
		mol->atoms[i].variable=TRUE;
		mol->atoms[i].show=TRUE;
		mol->atoms[i].residueNumber=0;
		mol->atoms[i].coordinates[0] = X*BOHRTOANG;
		mol->atoms[i].coordinates[1] = Y*BOHRTOANG;
		mol->atoms[i].coordinates[2] = Z*BOHRTOANG;
		mol->atoms[i].gradient[0]=0.0;
		mol->atoms[i].gradient[1]=0.0;
		mol->atoms[i].gradient[2]=0.0;
		mol->atoms[i].velocity[0]=0.0;
		mol->atoms[i].velocity[1]=0.0;
		mol->atoms[i].velocity[2]=0.0;
		mol->atoms[i].charge = 0.0;
		mol->atoms[i].charge0 = 0.0;
		mol->atoms[i].electronegativity = 0;
		mol->atoms[i].hardness = 0;
		mol->atoms[i].width = mol->atoms[i].prop.covalentRadii;
		mol->atoms[i].mass = mol->atoms[i].prop.mass;
		mol->atoms[i].rho = 0.0;
	   	mol->atoms[i].U = 0.0;
	}
	mol->nAtoms = i+1;
	printf("nAtoms = %d\n",mol->nAtoms);
	fclose(file);
	/* if all freezed, set all to variable */
	{
		int j = 0;
		for(i=0;i<mol->nAtoms;i++) if(!mol->atoms[i].variable) j++;
		if(j==mol->nAtoms) for(i=0;i<mol->nAtoms;i++) mol->atoms[i].variable = TRUE;
	}
        for(i=0; i<mol->nAtoms; i++) mol->atoms[i].typeConnections = NULL;
	resetTypeConnections(mol);
	setConnections(mol);
	return mol;
}
/********************************************************************************/
static Molecule* getMoleculeFromGabeditFile(char* namefile)
{
	FILE* file = NULL;
	Molecule* mol = NULL;
	boolean geoms = FALSE;

	if(!namefile) 
	{
		printf("Sorry I cannot read geometry namefile = NULL\n");
		exit(1);
	}
	file = fopen(namefile,"rb");
	if(!file)
	{
		printf("Sorry I cannot open %s file\n",namefile);
		exit(1);
	}
        if(goToStr(file, "[GEOMS]")) geoms = TRUE;
	fclose(file);
	if(geoms) return getMoleculeFromGabeditFile_GEOMS(namefile);
	else return getMoleculeFromGabeditFile_FRCOORD(namefile);

	return mol;
}
/********************************************************************************/
Molecule* readMoleculeFromGabeditFile(char *fileName)
{
	Molecule* mol = getMoleculeFromGabeditFile(fileName);
	readVibrationFromGabeditFile(mol, fileName);
	readDipolesDerivativesFromGabeditFile(mol, fileName);
	return mol;
	
}
/********************************************************************************/
static void readBoxes(Molecule* mol, FILE* file, char* t)
{
	char* pos;
	rewind(file);
	mol->boxes.lengths[0] = mol->boxes.lengths[1] = mol->boxes.lengths[2]= 0.0;
	while(!feof(file))
  	{
    		if(!fgets(t,BSIZE, file)) break;
		deleteFirstSpaces(t);
		if(t[0]=='#') continue;
		uppercase(t);
		pos = strstr(t,"BOXES");
		if(pos && strstr(t,"="))
		{ 
			double x,y,z;
			double a,b,g;
			int n =0;
			pos = strstr(t,"=")+1;
			n =sscanf(pos,"%lf %lf %lf %lf %lf %lf",&x,&y,&z,&a,&b,&g);
			if(n==1) initBoxes(&mol->boxes, x,x,x,90.0,90.0,90.0); 
			if(n==2) initBoxes(&mol->boxes, x,y,y,90.0,90.0,90.0);
			if(n==3) initBoxes(&mol->boxes, x,y,z,90.0,90.0,90.0);
			if(n==6) initBoxes(&mol->boxes, x,y,z,a,b,g);
			break;
		}
	}
}
/********************************************************************************/
static void readWall(Molecule* mol, FILE* file, char* t)
{
	char* pos;
	rewind(file);
	initWallParameters(&mol->wall, 0, 1.0,2);
	while(!feof(file))
  	{
    		if(!fgets(t,BSIZE, file)) break;
		deleteFirstSpaces(t);
		if(t[0]=='#') continue;
		uppercase(t);
		pos = strstr(t,"WALL");
		if(pos && strstr(t,"="))
		{ 
			double E0;
			double rho;
			int nc;
			int n =0;
			pos = strstr(t,"=") + 1;
			n =sscanf(pos,"%lf %lf %d",&E0,&rho,&nc);
			//printf("t=%s\n",t);
			//printf("pos=%s\n",pos);
			if(n==3 && nc%2==0) initWallParameters(&mol->wall, E0, rho,nc);
			else  { 
				fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
				fprintf(stderr,"Error during the reading of Wall parameters\n");
				fprintf(stderr,"You must give E0(au), rho (cutoff radius in angstrom) and nc(even integer)\n");
				fprintf(stderr,"Example : Wall=1000.0 10.0 6\n");
				fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
				exit(1);
			}
			break;
		}
	}
}
/********************************************************************************/
static Molecule* readGeom(char* namefile)
{
	FILE* file = NULL;
	static char *t = NULL; 
	boolean Ok = FALSE;
	int n,ic,is;
	Molecule* mol = newMolecule();
#define SZ 50
	char symbol[SZ];
	char mmType[SZ];
	char pdbType[SZ];
	char residueName[SZ];
	double X,Y,Z;
	double charge;
	int layer;
	int i,l;
	char* pos;

	if(!namefile) 
	{
		printf("Sorry I cannot read geometry namefile = NULL\n");
		exit(1);
	}
	if(t==NULL) t = malloc(BSIZE*sizeof(char));
	file = fopen(namefile,"rb");
	if(!file)
	{
		printf("Sorry I cannot open %s file\n",namefile);
		exit(1);
	}
	rewind(file);
	while(!feof(file))
  	{
    		if(!fgets(t,BSIZE, file)) break;
		deleteFirstSpaces(t);
		if(t[0]=='#') continue;
		uppercase(t);
		pos = strstr(t,"GEOMETRY");
		if(pos)
		{ 
			while(!feof(file))
			{
    				if(!fgets(t,BSIZE, file)) break;
				deleteFirstSpaces(t);
				if(t[0]=='#') continue;
				break;
			}
			if(3==sscanf(t,"%d%d%d",&n,&ic,&is) && n>0 && is>0)
			{
				/*
				printf("Mult = %d\n",is);
				printf("nAtoms = %d\n",n);
				*/
				mol->nAtoms = n;
				mol->spinMultiplicity = is;
				mol->totalCharge = ic;
				mol->atoms = malloc(mol->nAtoms*sizeof(Atom));
				for(i=0; i<mol->nAtoms; i++) mol->atoms[i].typeConnections = malloc(mol->nAtoms*sizeof(int));
				Ok = TRUE;
			}
			break;
		}
	}
	if(!Ok)
	{
		printf("Sorry I cannot read geometry from %s file\n",namefile);
		exit(1);
	}
	for(i=0; i<mol->nAtoms; i++)
	{
			int variable = 0;
			int ibeg = 12;
			if(!fgets(t,BSIZE,file))
			{
				printf("Sorry I cannot read geometry from %s file.\n",namefile);
				exit(1);
			}
			deleteFirstSpaces(t);
			if(t[0]=='#') { i--;continue;}
    			sscanf(t,"%s %s %s %s %d %lf %d %d %lf %lf %lf",
					symbol,mmType,pdbType,residueName, 
					&mol->atoms[i].residueNumber,
					&charge,&layer,&variable,&X,&Y,&Z);
			symbol[0]=toupper(symbol[0]);
			l=strlen(symbol);
			if (l==2) symbol[1]=tolower(symbol[1]);

			mol->atoms[i].prop = propAtomGet(symbol);
			mol->atoms[i].mmType=strdup(mmType);
			mol->atoms[i].pdbType=strdup(pdbType);
			mol->atoms[i].residueName=strdup(residueName);
			mol->atoms[i].N=i+1;
			mol->atoms[i].layer=layer;
			mol->atoms[i].variable=variable;
			mol->atoms[i].show=TRUE;
			mol->atoms[i].coordinates[0] = X;
			mol->atoms[i].coordinates[1] = Y;
			mol->atoms[i].coordinates[2] = Z;
			mol->atoms[i].velocity[0] = 0;
			mol->atoms[i].velocity[1] = 0;
			mol->atoms[i].velocity[2] = 0;
			mol->atoms[i].charge = charge;
			mol->atoms[i].charge0 = charge;
			mol->atoms[i].electronegativity = 0;
			mol->atoms[i].hardness = 0;
			mol->atoms[i].width = mol->atoms[i].prop.covalentRadii;
			mol->atoms[i].mass = mol->atoms[i].prop.mass;
			mol->atoms[i].rho = 0.0;
	   		mol->atoms[i].U = 0.0;
			if(!get_connections_one_atom(t, mol->nAtoms, ibeg, mol->atoms[i].typeConnections))
			{
				/*
				printf("Sorry I cannot read the connection for atom # %d from the %s file.\n",i+1,namefile);
				exit(1);
				*/
				fprintf(stderr,"Warning : I cannot read the connection for atom # %d from the %s file.\n",i+1,namefile);
			}
	}
	readBoxes(mol, file, t);
	readWall(mol, file, t);
	
	fclose(file);
	return mol;
}
/********************************************************************************/
boolean readVelocities(Molecule* mol, char* namefile)
{
	FILE* file = NULL;
	static char *t = NULL; 
	boolean Ok = FALSE;
	char* pos = NULL;

	if(!namefile) 
	{
		printf("Sorry I cannot read velocities namefile = NULL !\n");
		exit(1);
	}
	if(!mol)
	{
		printf("Sorry I cannot read velocities from the %s file !\n",namefile);
		exit(1);
	}
	if(mol->nAtoms<1)
	{
		printf("Sorry I cannot read velocities, number of atoms = %d !\n",mol->nAtoms);
		exit(1);
	}
	if(t==NULL) t = malloc(BSIZE*sizeof(char));
	file = fopen(namefile,"rb");
	if(!file)
	{
		printf("Sorry I cannot open %s file\n",namefile);
		exit(1);
	}
	rewind(file);
	while(!feof(file) && !pos)
  	{
    		if(!fgets(t,BSIZE, file)) break;
		deleteFirstSpaces(t);
		if(t[0]=='#') continue;
		uppercase(t);
		pos = strstr(t,"VELOCITIES");
	}
	if(pos)
	{ 
		int ia = 0;
		double v[3] = {0};
		int ic = 0;
		Ok = TRUE;
		while(!feof(file))
		{
			while(!feof(file))
			{
    				if(!fgets(t,BSIZE, file)) { Ok = FALSE; break;}
				deleteFirstSpaces(t);
				if(t[0]=='#') continue;
				break;
			}
			if(3==sscanf(t,"%lf %lf %lf",&v[0], &v[1],&v[2]))
			{
				for(ic=0;ic<3;ic++) mol->atoms[ia].velocity[ic] = v[ic];
				ia++;
				if(ia==mol->nAtoms) break;
			}
			else {Ok = FALSE; break;}
		}
	}
	if(!Ok && pos)
	{
		printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		printf("Sorry I cannot read velocities !\n");
		printf("Check your data in %s file\n",namefile);
		printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		exit(1);
	}
	fclose(file);
	return Ok;
}
/********************************************************************************/
boolean readMasses(Molecule* mol, char* namefile)
{
	FILE* file = NULL;
	static char *t = NULL; 
	boolean Ok = FALSE;
	char* pos = NULL;

	if(!namefile) 
	{
		printf("Sorry I cannot read masses, namefile = NULL\n");
		exit(1);
	}
	if(!mol)
	{
		printf("Sorry I cannot read masses from the %s file\n",namefile);
		exit(1);
	}
	if(mol->nAtoms<1)
	{
		printf("Sorry I cannot read masses, number of atoms = %d !\n",mol->nAtoms);
		exit(1);
	}
	if(t==NULL) t = malloc(BSIZE*sizeof(char));
	file = fopen(namefile,"rb");
	if(!file)
	{
		printf("Sorry I cannot open %s file\n",namefile);
		exit(1);
	}
	rewind(file);
	while(!feof(file) && !pos)
  	{
    		if(!fgets(t,BSIZE, file)) break;
		deleteFirstSpaces(t);
		if(t[0]=='#') continue;
		uppercase(t);
		pos = strstr(t,"MASSES");
	}
	if(pos)
	{ 
		int ia = 0;
		double m = 0;
		Ok = TRUE;
		while(!feof(file))
		{
			while(!feof(file))
			{
    				if(!fgets(t,BSIZE, file)) { Ok = FALSE; break;}
				deleteFirstSpaces(t);
				if(t[0]=='#') continue;
				break;
			}
			if(1==sscanf(t,"%lf",&m))
			{
				if(m==0) mol->atoms[ia].mass = mol->atoms[ia].prop.mass;
				else if(m>0) mol->atoms[ia].mass = m;
				else
				{
					int im = (int)(-m);
					int j;
					for(j=0;j<mol->atoms[ia].prop.nIsotopes;j++)
					{
						if(im==mol->atoms[ia].prop.iMass[j]) {mol->atoms[ia].mass = mol->atoms[ia].prop.rMass[j]; break;}
					}
					if(j>=mol->atoms[ia].prop.nIsotopes) { 
					printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
					printf("I cannot find the mass of the isotope %d for atom %d(%s)\n",im,ia,mol->atoms[ia].prop.symbol);
						Ok = FALSE; break;
					}
				}
				ia++;
				if(ia==mol->nAtoms) break;
			}
			else {Ok = FALSE; break;}
		}
	}
	if(!Ok && pos)
	{
		printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		printf("Sorry I cannot read masses !\n");
		printf("Check your data in %s file\n",namefile);
		printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		exit(1);
	}
	fclose(file);
	return Ok;
}
/*************************************************************************************/
Molecule* getMolecule(char* fileName, boolean connections)
{
	int i;
	Molecule* molecule = readGeom(fileName);
	readVelocities(molecule,fileName);
	readMasses(molecule,fileName);

	/* if all freezed, set all to variable */
	{
		int j = 0;
		for(i=0;i<molecule->nAtoms;i++)
			if(!molecule->atoms[i].variable) j++;
		if(j==molecule->nAtoms)
		for(i=0;i<molecule->nAtoms;i++)
			molecule->atoms[i].variable = TRUE;
	}
	return molecule;
}
/*************************************************************************************/
CCHEMIFileType getTypeFile(char* fileName)
{
	char* t = NULL;
	CCHEMIFileType type = FILETYPE_UNKNOWN;
	FILE* file = fopen(fileName, "rb");

	t = malloc(BSIZE*sizeof(char));
	rewind(file);
    	fgets(t,BSIZE,file);
	uppercase(t);
        if(strstr(t, "ENTERING" )) type = FILETYPE_GAUSSIANOUT;
	else if(strstr( t, "[MOLDEN FORMAT]" )) type = FILETYPE_MOLDEN;
	else if(strstr( t, "[GABEDIT FORMAT]" )) type = FILETYPE_GABEDIT;
	else if(strstr( t, "GAMESS" )) type = FILETYPE_GAMESSOUT;
	else if(atoi(t)>0 && !strstr(t,"**********")) type = FILETYPE_XYZ;
	rewind(file);
	if(goToStr(file, "GEOMETRY"))
	{
		int n, ic, is;
		if(3==fscanf(file,"%d%d%d",&n,&ic,&is) && n>0 && is>0) type = FILETYPE_CCHEMI;
	}
	rewind(file);
	if(type == FILETYPE_UNKNOWN)
	{
		while(!feof(file))
		{
    			if(!fgets(t,BSIZE,file)) break;
			uppercase(t);
			if(strstr(t,"PROGRAM SYSTEM MOLPRO")) { type = FILETYPE_MOLPROOUT; break; }
			if(strstr(t,"GAMESS VERSION") || strstr(t,"PC GAMESS")) { type = FILETYPE_GAMESSOUT; break; }//FireFLy7.1
			if(strstr(t,"FIREFLY VERSION")) { type = FILETYPE_GAMESSOUT; break; } // FireFly8.1
			if(strstr(t,"Welcome to Q-Chem")) { type = FILETYPE_QCHEMOUT; break; }
			if(strstr(t,"Northwest Computational Chemistry Package")) { type = FILETYPE_NWCHEMOUT; break; }
			if(strstr(t,"TURBOMOLE GmbH")) { type = FILETYPE_TURBOMOLEOUT; break; }
        		if(strstr(t, "ENTERING GAUSSIAN" )) { type = FILETYPE_GAUSSIANOUT; break; }
		}
	}
	rewind(file);
	if(type == FILETYPE_UNKNOWN)
	{
		while(!feof(file))
		{
    			if(!fgets(t,BSIZE,file)) break;
			if(strstr(t,"$orca_hessian_file")) { type = FILETYPE_ORCAHESSIAN; break; }
		}
	}
	rewind(file);
	if(type == FILETYPE_UNKNOWN)
	{
		while(!feof(file))
		{
    			if(!fgets(t,BSIZE,file)) break;
			if(strstr(t,"* O   R   C   A *")) { type = FILETYPE_ORCAOUT; break; }
		}
	}
	rewind(file);
	if(type == FILETYPE_UNKNOWN)
	{
		while(!feof(file))
		{
    			if(!fgets(t,BSIZE,file)) break;
			if(strstr(t,"IOpCl")) { type = FILETYPE_GAUSSIANFCHK; break; }
		}
	}
	rewind(file);
	if(type == FILETYPE_UNKNOWN)
	{
		while(!feof(file))
		{
    			if(!fgets(t,BSIZE,file)) break;
			if(strstr(t,"VASP")) { type = FILETYPE_VASPOUT; break; }
		}
	}
	rewind(file);
	if(type == FILETYPE_UNKNOWN)
	{
		while(!feof(file))
		{
    			if(!fgets(t,BSIZE,file)) break;
			if(strstr(t,"GAMESS"))
			{
    				if(!fgets(t,BSIZE,file)) break;
				if(strstr(t,"FROM IOWA STATE UNIVERSITY"))
				type = FILETYPE_GAMESSOUT;
				break;
			}
		}
	}
	rewind(file);
	if(type == FILETYPE_UNKNOWN)
	{
    		if(fgets(t,BSIZE,file) && strstr(t,"START OF MOPAC FILE")) { type = FILETYPE_MOPACAUX;}
	}
	rewind(file);
	if(type == FILETYPE_UNKNOWN)
	{
  		while(!feof(file) )
  		{
 			if(!fgets(t, BSIZE, file))break;
			if( strstr(t,"MOPAC DONE")) { type = FILETYPE_MOPACOUT; break; }
			if( strstr(t,"MOPAC2012")) { type = FILETYPE_MOPACOUT; break; }
		}
	}
	rewind(file);
	if(type == FILETYPE_UNKNOWN)
	{
  		while(!feof(file) )
  		{
 			if(!fgets(t, BSIZE, file))break;
			if( strstr(t,"VARIABLE") && strstr(t,"FUNCTION")) { type = FILETYPE_MOPACSCAN; break; }
		}
	}
	rewind(file);
	if(type == FILETYPE_UNKNOWN)
	{
  		while(!feof(file) )    
  		{
 			if(!fgets(t, BSIZE, file))break;
                 	if(strstr(t,"INTRINSIC REACTION COORDINATE") ) { type = FILETYPE_MOPACIRC; break; }
		}
	}
 	free(t);
	fclose(file);
	return type;

	
}
/*************************************************************************************/
static void getFileNameToRead(char* fileName, char* fileNameToRead)
{
	char* t = malloc(BSIZE*sizeof(char));
	FILE* file = fopen(fileName, "rb");
	sprintf(fileNameToRead,"%s",fileName);
	if(goToStr(file, "GEOMETRY"))
	{
		int n, ic, is;
    		if(fgets(t,BSIZE,file) && 3!=sscanf(t,"%d%d%d",&n,&ic,&is)) sscanf(t,"%s",fileNameToRead);
	}
	free(t);
}
/*************************************************************************************/
Molecule* readMoleculeFromCChemIFile(char* fileName, boolean connections)
{
	Molecule* mol = getMolecule(fileName, connections);
	readVibrationFromGabeditFile(mol, fileName);
	return mol;
}
/*************************************************************************************/
static void getFreqMinFreqMax(char* fileName, double* freqMin, double* freqMax)
{
	FILE* file = fopen(fileName,"rb");
	*freqMin = -1.0;
	*freqMax = -1.0;
        readOneReal(file,"freqMin",freqMin);
        readOneReal(file,"freqMax",freqMax);
	fclose(file);
}
/********************************************************************************/
static void getChargesFromMolproOutputFile(Molecule* mol, FILE* file)
{
  	char t[BSIZE];
  	char dump[100];
  	char d[100];
  	char sign[10];
	int i;

/*
 Population analysis by basis function type

 Unique atom        s        p        d        f        g    Total    Charge
   1  O       3.64454  4.63505  0.01261  0.00000  0.00000  8.29219  - 0.29219
   2  H       0.76538  0.08852  0.00000  0.00000  0.00000  0.85390  + 0.14610
   3  H       0.76538  0.08852  0.00000  0.00000  0.00000  0.85390  + 0.14610
*/
  	while(!feof(file) )
	{
    		if(!fgets(t,BSIZE,file)) break;
		if(strstr(t,"Population analysis by basis function type"))
		{
    			if(!fgets(t,BSIZE,file)) break;
    			if(!fgets(t,BSIZE,file)) break;
    			if(!fgets(t,BSIZE,file)) break;
			for(i=0;i<mol->nAtoms;i++)
			{
    				if(!fgets(t,BSIZE,file)) break;
				if(sscanf(t,"%s %s %s %s %s %s %s %s %s %s",dump, dump ,dump, dump, dump, dump, dump, dump, sign, d)==6)
				{
					mol->atoms[i].charge = atof(d);
					if(strstr(sign,"-")) mol->atoms[i].charge = -mol->atoms[i].charge;
				}
				else break;
			}
			//break; // To read last charges
		}
	}
}

/********************************************************************************/
static int compute_molpro_modes_masses(Molecule* mol, FILE* file)
{
	int i,j,c;
	rewind(file);
 	char t[BSIZE];
 	char sdum1[100];
 	char sdum2[100];
 	char sdum3[100];
	double mass;

 	while(!feof(file))
	{
    		fgets(t,BSIZE,file);
 		// Atom  1: H         Mass   1.00794
	 	if (strstr(t,"Atom") && strstr( t,"Mass") )
		{
			for(i=0;i<strlen(t);i++) if(t[i]==':') t[i]=' ';
			int nf = sscanf(t,"%s %d %s %s %lf", sdum1,&j, sdum2,sdum3,&mass);
			if(nf==5 && j>=1 && j<=mol->nAtoms) mol->atoms[j-1].mass = mass;
		}
	}
        /* compute the effective masses */
        /* modes already mass-weighted in Molpro output file*/
        for(i=0;i<mol->vibration.nModes;i++)
        {
                double m = 0;
                for(j=0;j<mol->nAtoms;j++)
                {
                        double r2 = 0;
                        for(c=0;c<3;c++) r2 += mol->vibration.modes[i].vectors[c][j]*mol->vibration.modes[i].vectors[c][j];
                        //m += r2/(mol->atoms[j].mass);// don't divide by mass[j]
                        m += r2;
                }
                if(m<=0) m = 1;
                m = 1.0/m;
                for(j=0;j<mol->nAtoms;j++)
                {
                        //double r =sqrt(m)/sqrt(mol->atoms[j].mass); // don't divide by mass[j]
                        double r =sqrt(m);
                        for(c=0;c<3;c++) mol->vibration.modes[i].vectors[c][j] *= r;
                }
		mol->vibration.modes[i].mass = m;
        }
	return 0;
}
/********************************************************************************/
static int read_molpro_modes_str(Molecule* mol, FILE* file, char* str, int jmin)
{
 	char t[BSIZE];
 	char sdum1[BSIZE];
 	char sdum2[BSIZE];
 	boolean OK;
 	int taille=BSIZE;
	int i;
	int j;
	int k;
	int c;
	int ne;
	int nf;
	double freq[5];
	double IRIntensity[5];

	if(mol->nAtoms<1) return 2;

 	OK=FALSE;
 	while(!feof(file))
	{
    		fgets(t,taille,file);
	 	if ( strstr( t,str) )
	  	{
			OK = TRUE;
			break;
	  	}
	}

	if(!OK) return 1;

	j = jmin;
  	while(!feof(file))
  	{
		if(!fgets(t,taille,file)) { return 2; }
		if(atof(t)==0) if(!fgets(t,taille,file)) break;
    		if(!fgets(t,taille,file)) break;
		if(!strstr(t,"Wavenumbers")) break;
		nf = sscanf(t,"%s %s %lf %lf %lf %lf %lf", sdum1,sdum2, &freq[0],&freq[1],&freq[2],&freq[3],&freq[4]);
		nf -= 2;
		if(strstr(str,"imaginary")) for(k=0;k<nf;k++) freq[k] = -freq[k];
    		if(!fgets(t,taille,file)) break;
		sscanf(t,"%s %s %lf %lf %lf %lf %lf",
				sdum1,sdum2,
				&IRIntensity[0],&IRIntensity[1],&IRIntensity[2],&IRIntensity[3],&IRIntensity[4]);

    		if(!fgets(t,taille,file)) break;

		for(k=0;k<nf;k++)
		{
			mol->vibration.modes[j+k].frequency = freq[k];
			mol->vibration.modes[j+k].properties[0] = IRIntensity[k];
			mol->vibration.modes[j+k].mass = 1.0;
		}

		for(i=0;i<mol->nAtoms;i++)
		{
			for(c=0;c<3;c++)
			{
    				if(!fgets(t,taille,file)) break;
				ne = sscanf(t,"%s %lf %lf %lf %lf %lf",sdum1,
					&mol->vibration.modes[j  ].vectors[c][i],
					&mol->vibration.modes[j+1].vectors[c][i],
					&mol->vibration.modes[j+2].vectors[c][i],
					&mol->vibration.modes[j+3].vectors[c][i],
					&mol->vibration.modes[j+4].vectors[c][i]);
				if(ne <2) { return 2; }
			}

		}
		j+=nf;

	}
	mol->vibration.nModes = j;
	return 0;
}
/********************************************************************************/
static boolean readVibrationFromMolproOutputFile(Molecule* mol, char* fileName)
{
	int normalModes = 0;
	int normalModesImag = 0;
 	FILE* file = fopen(fileName, "rb");
	int nProps = 1;
	if(file ==NULL)
	{
		fprintf(stderr,"Sorry\nI can not open %s Molpro output file\n",fileName);
		return FALSE;
	}
	if(mol->nAtoms<1) 
	{
		if(file) fclose(file);
		return FALSE;
	}

	initVibrations(mol, 3*mol->nAtoms, nProps);
	normalModes = read_molpro_modes_str(mol, file, "Normal Modes",0);
	if(normalModes<=1) normalModesImag = read_molpro_modes_str(mol, file, "Normal Modes of imaginary frequencies",mol->vibration.nModes);
	if(normalModes>1 || normalModesImag>1)
	{
			char buffer[BSIZE];
			freeVibrations(mol);
  			fprintf(stderr,"%s",buffer);
			if(file) fclose(file);
			return FALSE;
	}
/*
	mol->vibration.nModes = j;
        mol->vibration.modes = realloc(mol->vibration.modes, mol->vibration.nModes*sizeof(VibMode));
	for(j=0;j< mol->vibration.nModes;j++)
	{
			for(i=0;i< mol->nAtoms;i++)
			for(c=0;c<3;c++)
			mol->vibration.modes[j].vectors[c][i] *= sqrt(mol->vibration.modes[j].mass);
	}
*/
	compute_molpro_modes_masses(mol, file);
	sortFrequencies(mol);
	removeTransRotModes(mol);
	if(file) fclose(file);
	return 1;
}
/********************************************************************************/
Molecule* getMoleculeFromMolproOutputFile(char *fileName, int numgeometry)
{
	char *t;
	boolean OK;
	char *AtomCoord[5];
	FILE *file;
	int i;
	int j=0;
	int l;
	int numgeom;
	char dum[100];
	Molecule* mol = NULL;
	int kk;
	char AtomCharge[100];
	int idummy;



	for(i=0;i<5;i++) AtomCoord[i]=malloc(BSIZE*sizeof(char));
  
	t=malloc(BSIZE*sizeof(char));
 	file = fopen(fileName, "rb");
	if(file ==NULL)
	{
		free(t);
		printf(("Sorry\nI can not open %s Molpro output file\n"),fileName);
		exit(1);
		return NULL;
	}
	numgeom = 0;
	do 
	{
		OK=FALSE;
		while(!feof(file)){
			fgets(t,BSIZE,file);
			uppercase(t);
			if ( strstr(t," ATOMIC COORDINATE"))
			{
	  			fgets(t,BSIZE,file);
	  			fgets(t,BSIZE,file);
	  			fgets(t,BSIZE,file);
 				numgeom++;
				if((int)numgeom == numgeometry ) { OK = TRUE; break; }
				if(numgeometry<0 ) { OK = TRUE; break; }
	  		}
		}
		if(!OK && (numgeom == 0) ){
			free(t);
			printf(("Sorry\nI can not open read geometry from %s Molpro output file\n"),fileName);
			exit(1);
			return NULL;
		}
		if(!OK)break;

		//printf("Begin freMole\n");
		if(mol) freeMolecule(mol);
		mol = newMolecule();
		mol->atoms = NULL;
		mol->nAtoms = 0;
		//printf("numgeom=%d numgeometry=%d\n",numgeom,numgeometry);

		j=-1;
		while(!feof(file) )
		{
			fgets(t,BSIZE,file);
			strDeleten(t);
			if (isABackspace(t)) break;
			if ( !strcmp(t,"\n")) break;
			if ( !strcmp(t,"\r\n")) break;
			j++;
			//printf("j=%d t = %s\n",j,t);
			//sscanf(t,"%s %s %s %s %s",AtomCoord[0],dum, AtomCoord[1], AtomCoord[2],AtomCoord[3]);
			kk = sscanf(t,"%d %s %s %s %s %s %s",&idummy, AtomCoord[0],AtomCharge,AtomCoord[1], AtomCoord[2],AtomCoord[3], dum);
                        if(kk==7) sscanf(t,"%d %s %s %s %s %s %s",&idummy, AtomCoord[0],AtomCharge,dum, AtomCoord[1], AtomCoord[2],AtomCoord[3]);
			{
				int k;
				for(k=0;k<(int)strlen(AtomCoord[0]);k++) if(isdigit(AtomCoord[0][k])) AtomCoord[0][k] = ' ';
				deleteAllSpaces(AtomCoord[0]);
			}

			AtomCoord[0][0]=toupper(AtomCoord[0][0]);
			l=strlen(AtomCoord[0]);
			if (l==2) AtomCoord[0][1]=tolower(AtomCoord[0][1]);
			if (atoi(AtomCharge) == 0) sprintf(AtomCoord[0],"X");
			mol->atoms = realloc(mol->atoms,(j+1)*sizeof(Atom));

			mol->atoms[j].prop = propAtomGet(AtomCoord[0]);
			mol->atoms[j].mmType=strdup(AtomCoord[0]);
			mol->atoms[j].pdbType=strdup(AtomCoord[0]);
			mol->atoms[j].residueName=strdup(AtomCoord[0]);
			mol->atoms[j].N=j+1;
			mol->atoms[j].layer=HIGH_LAYER;
			mol->atoms[j].variable=TRUE;
			mol->atoms[j].show=TRUE;
			mol->atoms[j].residueNumber=0;
	   		mol->atoms[j].charge=0.0;
	   		mol->atoms[j].charge0=0.0;
	   		mol->atoms[j].electronegativity=0.0;
	   		mol->atoms[j].hardness=0.0;
	   		mol->atoms[j].width=mol->atoms[j].prop.covalentRadii;
	   		mol->atoms[j].mass= mol->atoms[j].prop.mass;
	   		mol->atoms[j].rho=0.0;
	   		mol->atoms[j].U = 0.0;

			mol->atoms[j].coordinates[0]=atof(AtomCoord[1])*BOHRTOANG;
			mol->atoms[j].coordinates[1]=atof(AtomCoord[2])*BOHRTOANG;
			mol->atoms[j].coordinates[2]=atof(AtomCoord[3])*BOHRTOANG;

			mol->atoms[j].gradient[0]=0.0;
			mol->atoms[j].gradient[1]=0.0;
			mol->atoms[j].gradient[2]=0.0;

			mol->atoms[j].velocity[0]=0.0;
			mol->atoms[j].velocity[1]=0.0;
			mol->atoms[j].velocity[2]=0.0;
        		mol->atoms[j].typeConnections = NULL;
			if(j==mol->nAtoms-1) break;
		}
		if(OK && numgeometry>=0) break;
		mol->nAtoms = j+1;
	}while(!feof(file));
	//printf("end read molecule\n");

	rewind(file);
	getChargesFromMolproOutputFile(mol, file);
	fclose(file);
	free(t);
	for(i=0;i<5;i++) free(AtomCoord[i]);
	//printf("begin resetTypeConnections\n");
        for(i=0; i<mol->nAtoms; i++) mol->atoms[i].typeConnections = NULL;
	resetTypeConnections(mol);
	//printf("end resetTypeConnections\n");
	int connections = 1;
	if(connections) setConnections(mol);
	else {
		createBondedMatrix(mol);
		printf(("Establishing connectivity : non bonded ...\n"));
		setNonBondedConnections(mol);
		freeBondedMatrix(mol);
	}

	/* if all freezed, set all to variable */
	{
		int j = 0;
		for(i=0;i<mol->nAtoms;i++)
			if(!mol->atoms[i].variable) j++;
		if(j==mol->nAtoms)
		for(i=0;i<mol->nAtoms;i++)
			mol->atoms[i].variable = TRUE;
	}
	return mol;
}
/********************************************************************************/
Molecule* readMoleculeFromMolproOutputFile(char *fileName, int numgeometry)
{
	//printf("Begin redMolecule from Molpro output file\n");
	Molecule* mol = getMoleculeFromMolproOutputFile(fileName, numgeometry);
	//printf("End redMolecule from Molpro output file\n");
	readVibrationFromMolproOutputFile(mol, fileName);
	return mol;
	
}
/*************************************************************************************/
Molecule* readMolecule(char* fileName, boolean connections)
{
	char* fileNameToRead = malloc(BSIZE*sizeof(char));
	CCHEMIFileType type;
	Molecule* mol = NULL;
	double freqMin;
	double freqMax;

	if(!fileName) return mol;

	fileNameToRead = malloc(BSIZE*sizeof(char));
	getFileNameToRead(fileName, fileNameToRead);

	type = getTypeFile(fileNameToRead);

	//printf("type %d\n",type);

	if(type == FILETYPE_CCHEMI) mol = readMoleculeFromCChemIFile(fileNameToRead, connections);
	else if(type == FILETYPE_GABEDIT) mol = readMoleculeFromGabeditFile(fileNameToRead);
	else if(type == FILETYPE_GAUSSIANOUT) mol = readMoleculeFromGaussianOutputFile(fileNameToRead,-1);
	else if(type == FILETYPE_GAUSSIANFCHK) mol = readMoleculeFromGaussianFChkFile(fileNameToRead);
	else if(type == FILETYPE_GAMESSOUT) mol = readMoleculeFromGamessOutputFile(fileNameToRead,-1);
	else if(type == FILETYPE_MOPACOUT) mol = readMoleculeFromMopacOutputFile(fileNameToRead,-1);
	else if(type == FILETYPE_MOPACAUX) mol = readMoleculeFromMopacAuxFile(fileNameToRead,-1);
	else if(type == FILETYPE_ORCAOUT) mol = readMoleculeFromOrcaOutputFile(fileNameToRead,-1);
	else if(type == FILETYPE_ORCAHESSIAN) mol = readMoleculeFromOrcaHessianFile(fileNameToRead);
	else if(type == FILETYPE_MOLPROOUT) mol = readMoleculeFromMolproOutputFile(fileNameToRead,-1);
	else
	{
		fprintf(stderr,"Sorry, I cannot read the molecule from %s file\n",fileNameToRead);
		exit(1);
	}

	if(connections) setConnections(mol);
	else {
		createBondedMatrix(mol);
		printf(("Establishing connectivity : non bonded ...\n"));
		setNonBondedConnections(mol);
		freeBondedMatrix(mol);
	}
	getFreqMinFreqMax(fileName, &freqMin, &freqMax);
	if(freqMin>-1 || freqMax>-1) mol->klass->removeFrequencies(mol, freqMin,freqMax);
	//if(type == FILETYPE_GAUSSIANOUT ) already read with ir intenisties
	//if(type == FILETYPE_ORCAOUT ) .... 
	//if(type == FILETYPE_ORCAHESSIAN )  already read with ir intenisties
	//if(type == FILETYPE_GABEDIT) already read with ir intenisties

	free(fileNameToRead);
	return mol;
}
/********************************************************************************/
void exchangeGeometries(Molecule* mol1, Molecule* mol2)
{
	int i,j;
	if(mol1->nAtoms!=mol2->nAtoms)
	{
		printf("Sorry I cannot exahnge the geometries... not same number of atoms\n");
		exit(1);
	}
	for(i=0;i<mol1->nAtoms;i++)
	for(j=0;j<3;j++)
	{
		double t = mol1->atoms[i].coordinates[j];
		mol1->atoms[i].coordinates[j]= mol2->atoms[i].coordinates[j];
		mol2->atoms[i].coordinates[j]= t;
	}
}
/*****************************************************************************/
static boolean addGeometryToGabedit(Molecule* molecule,FILE* file)
{
	int j,k;
	int nc;

	if(!molecule) return FALSE;
	fprintf(file,"%d %d %d %lf\n",molecule->nAtoms, molecule->totalCharge, molecule->spinMultiplicity,molecule->potentialEnergy);
	for(j=0;j<molecule->nAtoms;j++)
	{
		nc = 0;
		for(k=0;k<molecule->nAtoms;k++) if(molecule->atoms[j].typeConnections[k]>0) nc++;
		fprintf(file," %s %s %s %s %d %0.12lf %d %d %0.12lf %0.12lf %0.12lf %d ", 
				molecule->atoms[j].prop.symbol,
				molecule->atoms[j].mmType,
				molecule->atoms[j].pdbType,
				molecule->atoms[j].residueName,
				molecule->atoms[j].residueNumber,
				molecule->atoms[j].charge,
				molecule->atoms[j].layer,
				molecule->atoms[j].variable,
				molecule->atoms[j].coordinates[0],
				molecule->atoms[j].coordinates[1],
				molecule->atoms[j].coordinates[2],
				nc
				);
		for(k=0;k<molecule->nAtoms;k++) 
		{
	 		int nk = molecule->atoms[k].N-1;
			if(molecule->atoms[j].typeConnections[nk]>0) 
			fprintf(file," %d %d", nk+1,molecule->atoms[j].typeConnections[nk]);
		}
		save_gradients_one_atom(file, molecule->atoms[j].gradient);
		fprintf(file,"\n");
	}
	return TRUE;

}
/*****************************************************************************/
static boolean addFirstDerivativeToFile(Molecule* molecule, FILE* file)
{
	if(molecule->vibration.nModes>0 && molecule->vibration.nProperties>=5)
	{
		int i,j;
		int nOld = molecule->vibration.nProperties-3;
		fprintf(file,"\n#xyz    i       Values[au cm^1/2]\n");
		fprintf(file,"First derivatives\n");
		
		for(i=0;i<molecule->vibration.nModes;i++) 
		{
			char axes[] = {'X','Y','Z'};
			for(j=0;j<3;j++)
			if(fabs(molecule->vibration.modes[i].properties[j+nOld])>1e-10)
				fprintf(file,"%c\t%d\t%0.10lf\n", axes[j], i+1, molecule->vibration.modes[i].properties[j+nOld]);
		}
		fprintf(file,"END\n");
		return TRUE;
	}

	return FALSE;
}
/*****************************************************************************/
static boolean addVibrationToFile(Molecule* molecule, FILE* file)
{
	int i,j,k;

	if(!molecule) return FALSE;
	if(molecule->vibration.nModes<1) return FALSE;

	fprintf(file,"[FREQ]\n");
	for(i=0;i<molecule->vibration.nModes;i++) 
		fprintf(file,"%f\n", molecule->vibration.modes[i].frequency);

	if(molecule->vibration.nProperties>0)
	{
		fprintf(file,"[INT]\n");
		for(i=0;i<molecule->vibration.nModes;i++) 
		{
			for(j=0;j<molecule->vibration.nProperties;j++) 
				fprintf(file,"%0.14f ", molecule->vibration.modes[i].properties[j]);
			fprintf(file,"\n");
		}
	}

	fprintf(file,"[MASS]\n");
	for(i=0;i<molecule->vibration.nModes;i++) 
		fprintf(file,"%0.14f\n", molecule->vibration.modes[i].mass);

	fprintf(file,"[FR-COORD]\n");
	for(j=0;j<molecule->nAtoms;j++)
	{
		fprintf(file," %s %0.14f %0.14f %0.14f\n", 
			molecule->atoms[j].prop.symbol,
			molecule->atoms[j].coordinates[0]*ANGTOBOHR,
			molecule->atoms[j].coordinates[1]*ANGTOBOHR,
			molecule->atoms[j].coordinates[2]*ANGTOBOHR
			);
	}
	fprintf(file,"[FR-NORM-COORD]\n");
	for(i=0;i<molecule->vibration.nModes;i++) 
	{
		fprintf(file,"vibration %d\n",i+1);
		for(j=0;j<molecule->nAtoms;j++)
		{
			for(k=0;k<3;k++) fprintf(file,"%0.14f ",  molecule->vibration.modes[i].vectors[k][j]);
			fprintf(file,"\n");
		}
		
	}
	molecule->klass->addFirstDerivativeToFile(molecule, file);
	return TRUE;

}
/*****************************************************************************/
static boolean saveMoleculeTypeSave(char* fileName, char* typeSave, Molecule* molecule)
{
	FILE* file = NULL;
	int j;
	int form = 1;

	printf("Save molecule in %s\n",fileName);
	if(!molecule) return FALSE;

 	file = fopen(fileName, typeSave);

	if(!file) return FALSE;

	fprintf(file,"[Gabedit Format]\n");
	fprintf(file,"[GEOCONV]\n");
	fprintf(file,"energy\n");
	fprintf(file,"%f\n",molecule->potentialEnergy);
	fprintf(file,"max-force\n");
	fprintf(file,"%f\n",0.0);
	fprintf(file,"rms-force\n");
	fprintf(file,"%f\n",0.0);

	fprintf(file,"\n");
	fprintf(file,"[GEOMETRIES]\n");
	{
		fprintf(file,"%d\n",molecule->nAtoms);
		fprintf(file,"\n");
		for(j=0;j<molecule->nAtoms;j++)
		fprintf(file," %s %0.14f %0.14f %0.14f\n", 
				molecule->atoms[j].prop.symbol,
				molecule->atoms[j].coordinates[0],
				molecule->atoms[j].coordinates[1],
				molecule->atoms[j].coordinates[2]
				);
	}
	fprintf(file,"\n");
	fprintf(file,"[GEOMS] %d\n",form);
	fprintf(file,"%d 3\n",1);
	fprintf(file,"energy kcal/mol 1\n");
	fprintf(file,"deltaE K 1\n");
	fprintf(file,"Dipole Debye 3\n");
	//molecule->klass->computeDipole(molecule);
	{
		fprintf(file,"%0.14f\n",molecule->potentialEnergy);
		fprintf(file,"0\n");
		fprintf(file,"%0.14f %0.14f %0.14f\n",molecule->dipole[0],molecule->dipole[1],molecule->dipole[2]);
		molecule->klass->addGeometryToGabedit(molecule,file);
	}
	addVibrationToFile(molecule, file);
	fclose(file);
	return TRUE;

}
/*****************************************************************************/
static boolean saveMolecule(Molecule* molecule, char* fileName)
{
	return saveMoleculeTypeSave(fileName, "w", molecule);
}
/******************************************************************************/
static void save_atom_hin_file(FILE* file, char* name, int atomNumber, char* atomPDBType, char* atomMMType,
		double x, double y, double z, char* symbol, double charge,
		int N, int* connection, int* connectionType)
{
	int i;
        fprintf(file,"%s %d ",name,atomNumber);
        fprintf(file,"%s ",atomPDBType);
        fprintf(file,"%s ",symbol); 
        fprintf(file,"%s - ",atomMMType); 
        fprintf(file,"%0.14f ",charge); 
        fprintf(file,"%0.14f ",x); 
        fprintf(file,"%0.14f ",y); 
        fprintf(file,"%0.14f ",z); 
	if(N>0)
	{
        	fprintf(file,"%d ",N); 
		for(i=0;i<N;i++)
		{
			if(connectionType[i]==3) fprintf(file,"%d t ",connection[i]); 
			else if(connectionType[i]==2) fprintf(file,"%d d ",connection[i]); 
			else fprintf(file,"%d s ",connection[i]); 
		}
	}
        fprintf(file,"\n"); 
}
/******************************************************************************/
static boolean saveHIN(Molecule* mol, char* fileName)
{
	int i,n,k;
 	FILE* file = fopen(fileName, "w");
	int nAtoms;
	Atom* atoms;
	int* connection;
	int* connectionType;
	if(!file) return FALSE;
	nAtoms = mol->nAtoms;
	atoms = mol->atoms;

	fprintf(file,"forcefield Amber99\n");
	fprintf(file,"sys 0 0 1\n");
	fprintf(file,"view 40 0.1272 55 15 0.247224 0.3713666 0.8949677 -0.8641704 0.5022867 0.0302929 -0.4382806 -0.7808937 0.4451014 6.191 0.64575 -54.754\n");
	fprintf(file,"seed -1108\n");
	fprintf(file,"mol 1\n");

	connection = malloc(nAtoms*sizeof(int));
	connectionType = malloc(nAtoms*sizeof(int));

	for(i=0;i<nAtoms;i++)
	{
		n = 0;
		if(atoms[i].typeConnections)
		for(k=0;k<nAtoms;k++)
		{
			if(i==k) continue;
			if(atoms[i].typeConnections[k]>0)
			{
				connection[n] = k+1;
				connectionType[n] = atoms[i].typeConnections[k];
				n++;
			}
		}
		save_atom_hin_file(file,"ATOM",i+1,atoms[i].pdbType, atoms[i].mmType,
		atoms[i].coordinates[0], atoms[i].coordinates[1], atoms[i].coordinates[2],
		atoms[i].prop.symbol, atoms[i].charge,n,connection, connectionType);
	}
	fprintf(file,"endmol 1\n");
	fclose(file);
	free(connection);
	free(connectionType);
	return TRUE;
}

/*****************************************************************************/
static boolean saveMol2(Molecule* mol, char* fileName)
{
	int i,n,j;
 	FILE* file = fopen(fileName, "w");
	if(!file) return FALSE;
	n = 0;
	for(i=0;i<mol->nAtoms;i++)
        if(mol->atoms[i].typeConnections)
        for(j=i+1;j<mol->nAtoms;j++)
                if(mol->atoms[i].typeConnections[j]) n++;

	fprintf(file,"@<TRIPOS>MOLECULE\n");
	fprintf(file,"MOL2  : Made in CChemI. mol2 file\n");
	fprintf(file," %10d %10d %10d\n",mol->nAtoms,n,1);
	fprintf(file,"SMALL\n");
	fprintf(file,"GASTEIGER\n");
	fprintf(file,"\n");
	fprintf(file,"@<TRIPOS>ATOM\n");
      	for (i=0;i<mol->nAtoms;i++)
	{
       		fprintf(file,"%7d%1s%-6s%12.4f%10.4f%10.4f%1s%-5s%4d%1s%-8s%10.4f\n",
               		i+1,"",mol->atoms[i].prop.symbol,
				mol->atoms[i].coordinates[0],
				mol->atoms[i].coordinates[1],
				mol->atoms[i].coordinates[2],
				"",mol->atoms[i].prop.symbol,1," ","LIG111",mol->atoms[i].charge);
	}
	fprintf(file,"@<TRIPOS>BOND\n");
	n = 0;
	for(i=0;i<mol->nAtoms;i++)
        if(mol->atoms[i].typeConnections)
        for(j=i+1;j<mol->nAtoms;j++)
                if(mol->atoms[i].typeConnections[j]) 
		{
			n++;
			fprintf(file,"%6d%6d%6d%3s%2d\n",n+1, i+1, j+1, "",mol->atoms[i].typeConnections[j]);
		}


	fclose(file);
	return TRUE;
}
/*****************************************************************************/
static boolean addGeometry(Molecule* molecule,FILE* file)
{
	int j,k;
	int nc;

	if(!molecule) return FALSE;

	fprintf(file,"# Geometry, nAtoms, charge, spin multiplicity.\n");
	fprintf(file,"# symbol, MMType, pdbType, residueName, numResidue, charge, layer, variable, x(Ang),y,z, nconn, num1, typ1, num2, typ2,...\n");
	fprintf(file,"Geometry\n");
	fprintf(file,"%d %d %d\n",molecule->nAtoms, molecule->totalCharge, molecule->spinMultiplicity);
	for(j=0;j<molecule->nAtoms;j++)
	{
		nc = 0;
		for(k=0;k<molecule->nAtoms;k++) if(molecule->atoms[j].typeConnections[k]>0) nc++;
		fprintf(file," %s %s %s %s %d %0.12lf %d %d %0.12lf %0.12lf %0.12lf %d ", 
				molecule->atoms[j].prop.symbol,
				molecule->atoms[j].mmType,
				molecule->atoms[j].pdbType,
				molecule->atoms[j].residueName,
				molecule->atoms[j].residueNumber,
				molecule->atoms[j].charge,
				molecule->atoms[j].layer,
				molecule->atoms[j].variable,
				molecule->atoms[j].coordinates[0],
				molecule->atoms[j].coordinates[1],
				molecule->atoms[j].coordinates[2],
				nc
				);
		for(k=0;k<molecule->nAtoms;k++) 
		{
	 		int nk = molecule->atoms[k].N-1;
			if(molecule->atoms[j].typeConnections[nk]>0) 
			fprintf(file," %d %d", nk+1,molecule->atoms[j].typeConnections[nk]);
		}
		fprintf(file,"\n");
	}
	return TRUE;

}
/*****************************************************************************/
static boolean addMolecule(Molecule* molecule,FILE* file)
{
	int j,k;
	int nc;

	if(!molecule) return FALSE;

	fprintf(file,"Geometry\n");
	fprintf(file,"%d %d %d\n",molecule->nAtoms, molecule->totalCharge, molecule->spinMultiplicity);
	for(j=0;j<molecule->nAtoms;j++)
	{
		nc = 0;
		for(k=0;k<molecule->nAtoms;k++) if(molecule->atoms[j].typeConnections[k]>0) nc++;
		fprintf(file," %s %s %s %s %d %0.12lf %d %d %0.12lf %0.12lf %0.12lf %d ", 
				molecule->atoms[j].prop.symbol,
				molecule->atoms[j].mmType,
				molecule->atoms[j].pdbType,
				molecule->atoms[j].residueName,
				molecule->atoms[j].residueNumber,
				molecule->atoms[j].charge,
				molecule->atoms[j].layer,
				molecule->atoms[j].variable,
				molecule->atoms[j].coordinates[0],
				molecule->atoms[j].coordinates[1],
				molecule->atoms[j].coordinates[2],
				nc
				);
		for(k=0;k<molecule->nAtoms;k++) 
		{
	 		int nk = molecule->atoms[k].N-1;
			if(molecule->atoms[j].typeConnections[nk]>0) 
			fprintf(file," %d %d", nk+1,molecule->atoms[j].typeConnections[nk]);
		}
		fprintf(file,"\n");
	}
	return TRUE;

}
/*****************************************************************************/
static boolean addVelocities(Molecule* molecule,FILE* file)
{
	int j;

	if(!molecule) return FALSE;
	fprintf(file,"# Velocities, vx(Ang/AKMA-time) vy(Ang/AKMA-time) vz(Ang/AKMA-time): 1fs = %f AKMA\n",fsInAKMA);
	fprintf(file,"Velocities\n");
	for(j=0;j<molecule->nAtoms;j++)
	{
		fprintf(file,"%0.12le %0.12le %0.12le\n", 
				molecule->atoms[j].velocity[0],
				molecule->atoms[j].velocity[1],
				molecule->atoms[j].velocity[2]
				);
	}
	return TRUE;
}
/*****************************************************************************/
static boolean saveFrequencies(Molecule* molecule, char* fileName, int nModes, double* frequencies, double** modes, double* reducedMasses, double* IRIntensities)
{
	FILE* file = NULL;
	int i,j;

	printf("Save molecule in %s\n",fileName);
	if(!molecule) return FALSE;

 	file = fopen(fileName, "w");

	if(!file) return FALSE;

	fprintf(file,"[Gabedit Format]\n");
	fprintf(file,"[Atoms] Angs\n");
	for(j=0;j<molecule->nAtoms;j++)
	{
		fprintf(file," %s %d %d %0.8f %0.8f %0.8f\n", 
			molecule->atoms[j].prop.symbol,
			j+1,
			molecule->atoms[j].prop.atomicNumber,
			molecule->atoms[j].coordinates[0],
			molecule->atoms[j].coordinates[1],
			molecule->atoms[j].coordinates[2]
			);
	}
	fprintf(file,"[FREQ]\n");
	for(i=0;i<nModes;i++) fprintf(file,"%f\n", frequencies[i]);
	fprintf(file,"[INT]\n");
	for(i=0;i<nModes;i++) fprintf(file,"%f\n", IRIntensities[i]);
	fprintf(file,"[MASS]\n");
	for(i=0;i<nModes;i++) fprintf(file,"%f\n", reducedMasses[i]);
	fprintf(file,"[FR-COORD]\n");
	for(j=0;j<molecule->nAtoms;j++)
	{
		fprintf(file," %s %f %f %f\n", 
			molecule->atoms[j].prop.symbol,
			molecule->atoms[j].coordinates[0]*ANGTOBOHR,
			molecule->atoms[j].coordinates[1]*ANGTOBOHR,
			molecule->atoms[j].coordinates[2]*ANGTOBOHR
			);
	}
	fprintf(file,"[FR-NORM-COORD]\n");
	for(i=0;i<nModes;i++)
	{
		fprintf(file,"vibration %d\n",i+1);
		for(j=0;j<molecule->nAtoms;j++)
			fprintf(file,"%f %f %f\n", modes[3*j+0][i], modes[3*j+1][i], modes[3*j+2][i]);
		
	}
	fclose(file);
	saveMoleculeTypeSave(fileName, "a", molecule);
	return TRUE;

}
/****************************************************************************************************************************************************/
static void removeTranslation(Molecule* molecule)
{
	double vtot[3] = {0,0,0};
	int i;
	int j;
	double mass = 1.0;
	double totMass = 0.0;
	Atom* atoms = molecule->atoms;
	int nAtoms = molecule->nAtoms;
	for ( i = 0; i < nAtoms; i++)
	{
		mass = atoms[i].mass;
		totMass += mass;
		for ( j = 0; j < 3; j++)
		{
			vtot[j] += mass*atoms[i].velocity[j];
		}
	}

	for ( j = 0; j < 3; j++)
		vtot[j] /= totMass;

	for ( i = 0; i < nAtoms; i++)
		for ( j = 0; j < 3; j++)
			atoms[i].velocity[j] -= vtot[j];
	/* check */
	/*
	for ( j = 0; j < 3; j++)
		vtot[j] = 0;
	for ( i = 0; i < nAtoms; i++)
	{
		mass = molecule.atoms[i].mass;
		for ( j = 0; j < 3; j++)
		{
			vtot[j] += mass*molecule.atoms[i].velocity[j];
		}
	}
	printf("Trans velocity = %f %f %f\n",vtot[0], vtot[1], vtot[2]);
	*/
}
/*********************************************************************************/
static void removeRotation(Molecule* molecule)
{
	double vtot[3] = {0,0,0};
	double cm[3] = {0,0,0};
	double L[3] = {0,0,0};
	int i;
	int j;
	int k;
	double mass = 1.0;
	double totMass = 0.0;
	double cdel[3];
	double vAng[3]={0,0,0};
	double tensor[3][3];
	double invTensor[3][3];
        double xx, xy,xz,yy,yz,zz;
	/* find the center of mass coordinates  and total velocity*/
	Atom* atoms = molecule->atoms;
	int nAtoms = molecule->nAtoms;


	for ( i = 0; i < nAtoms; i++)
	{
		mass = atoms[i].mass;
		totMass += mass;
		for ( j = 0; j < 3; j++)
			cm[j] += mass*atoms[i].coordinates[j];
		for ( j = 0; j < 3; j++)
			vtot[j] += mass*atoms[i].velocity[j];
	}


	for ( j = 0; j < 3; j++)
		cm[j] /= totMass;
	for ( j = 0; j < 3; j++)
		vtot[j] /= totMass;

	/*   compute the angular momentum  */
	for ( i = 0; i < nAtoms; i++)
	{
		mass = atoms[i].mass;
		for ( j = 0; j < 3; j++)
			L[j] += (
				atoms[i].coordinates[(j+1)%3]*atoms[i].velocity[(j+2)%3]
			      - atoms[i].coordinates[(j+2)%3]*atoms[i].velocity[(j+1)%3]
			      )*mass;
	}
	for ( j = 0; j < 3; j++)
		L[j] -= (
			cm[(j+1)%3]*vtot[(j+2)%3]
		      - cm[(j+2)%3]*vtot[(j+1)%3]
			      )*totMass;

	/* calculate and invert the inertia tensor */
	for ( k = 0; k < 3; k++)
	for ( j = 0; j < 3; j++)
		tensor[k][j] = 0;
	xx = 0;
	yy = 0;
	zz = 0;
	xy = 0;
	xz = 0;
	yz = 0;
	for ( i = 0; i < nAtoms; i++)
	{
		mass = atoms[i].mass;
		for ( j = 0; j < 3; j++)
			cdel[j] = atoms[i].coordinates[j]-cm[j];
		xx +=  cdel[0]*cdel[0]*mass;
		xy +=  cdel[0]*cdel[1]*mass;
		xz +=  cdel[0]*cdel[2]*mass;
		yy +=  cdel[1]*cdel[1]*mass;
		yz +=  cdel[1]*cdel[2]*mass;
		zz +=  cdel[2]*cdel[2]*mass;
	}
	tensor[0][0] = yy+zz;
	tensor[1][0] = -xy;
	tensor[2][0] = -xz;
	tensor[0][1] = -xy;
	tensor[1][1] = xx+zz;
	tensor[2][1] = -yz;
	tensor[0][2] = -xz;
	tensor[1][2] = -yz;
	tensor[2][2] = xx+yy;
	if(InverseTensor(tensor,invTensor))
	{
		for ( j = 0; j < 3; j++)
		{
			vAng[j] = 0;
			for ( k = 0; k < 3; k++)
				vAng[j] += invTensor[j][k]*L[k];
		}
	}
	else
	if(nAtoms>1)
	{
		double U0[3];
		double U1[3];
		for ( j = 0; j < 3; j++)U0[j] = atoms[0].coordinates[j];
		for ( j = 0; j < 3; j++)U1[j] = atoms[1].coordinates[j];
		//printf("!!!!!!!!!!!I cannot invert the rotational Tensor : linear molecule!\n");
		computeAngularVelocitiesForALinearMolecule(U0, U1, tensor, L, vAng);
		//printf("Angular velocityi before rotation = %f %f %f\n",vAng[0], vAng[1], vAng[2]);
	}
	/*  eliminate any rotation about the system center of mass */
	for ( i = 0; i < nAtoms; i++)
	{
		for ( j = 0; j < 3; j++)
			cdel[j] = atoms[i].coordinates[j]-cm[j];
		for ( j = 0; j < 3; j++)
			atoms[i].velocity[j] += 
				cdel[(j+1)%3]*vAng[(j+2)%3]-
				cdel[(j+2)%3]*vAng[(j+1)%3];
	}

/* Check */
/*
	for ( j = 0; j < 3; j++) L[j] = 0;
	for ( i = 0; i < nAtoms; i++)
	{
		mass = atoms[i].mass;
		for ( j = 0; j < 3; j++)
			L[j] += (
				atoms[i].coordinates[(j+1)%3]*atoms[i].velocity[(j+2)%3]
			      - atoms[i].coordinates[(j+2)%3]*atoms[i].velocity[(j+1)%3]
			      )*mass;
	}
	for ( j = 0; j < 3; j++)
		L[j] -= (
			cm[(j+1)%3]*vtot[(j+2)%3]
		      - cm[(j+2)%3]*vtot[(j+1)%3]
			      )*totMass;

	if(linear) computeAngularVelocitiesForALinearMolecule(molecule, tensor, L, vAng);
	else
	{
		for ( j = 0; j < 3; j++)
		{
			vAng[j] = 0;
			for ( k = 0; k < 3; k++)
				vAng[j] += invTensor[j][k]*L[k];
		}
	}

	printf("Angular velocity = %f %f %f\n",vAng[0], vAng[1], vAng[2]);
*/

}
/*********************************************************************************/
static void removeTranslationAndRotation(Molecule* molecule)
{
	molecule->klass->removeTranslation(molecule);
	molecule->klass->removeRotation(molecule);
}
/*********************************************************************************/
static void removeTranslationCluster(Molecule** molecules, int nMols)
{
	double vtot[3] = {0,0,0};
	int im;
	int i;
	int j;
	double mass = 1.0;
	double totMass = 0.0;

	for ( im = 0; im < nMols; im++)
	{
		Atom* atoms = molecules[im]->atoms;
		int nAtoms = molecules[im]->nAtoms;
		for ( i = 0; i < nAtoms; i++)
		{
			mass = atoms[i].mass;
			totMass += mass;
			for ( j = 0; j < 3; j++)
			{
				vtot[j] += mass*atoms[i].velocity[j];
			}
		}
	}

	for ( j = 0; j < 3; j++)
		vtot[j] /= totMass;

	for ( im = 0; im < nMols; im++)
	{
		Atom* atoms = molecules[im]->atoms;
		int nAtoms = molecules[im]->nAtoms;
		for ( i = 0; i < nAtoms; i++)
			for ( j = 0; j < 3; j++)
				atoms[i].velocity[j] -= vtot[j];
	}
}
/*********************************************************************************/
static void removeRotationCluster(Molecule** molecules, int nMols)
{
	double vtot[3] = {0,0,0};
	double cm[3] = {0,0,0};
	double L[3] = {0,0,0};
	int im;
	int i;
	int j;
	int k;
	double mass = 1.0;
	double totMass = 0.0;
	double cdel[3];
	double vAng[3]={0,0,0};
	double tensor[3][3];
	double invTensor[3][3];
        double xx, xy,xz,yy,yz,zz;
	/* find the center of mass coordinates  and total velocity*/

	for ( im = 0; im < nMols; im++)
	{
		Atom* atoms = molecules[im]->atoms;
		int nAtoms = molecules[im]->nAtoms;
		for ( i = 0; i < nAtoms; i++)
		{
			mass = atoms[i].mass;
			totMass += mass;
			for ( j = 0; j < 3; j++)
				cm[j] += mass*atoms[i].coordinates[j];
			for ( j = 0; j < 3; j++)
				vtot[j] += mass*atoms[i].velocity[j];
		}
	}


	for ( j = 0; j < 3; j++) cm[j] /= totMass;
	for ( j = 0; j < 3; j++) vtot[j] /= totMass;

	/*   compute the angular momentum  */
	for ( im = 0; im < nMols; im++)
	{
		Atom* atoms = molecules[im]->atoms;
		int nAtoms = molecules[im]->nAtoms;
		for ( i = 0; i < nAtoms; i++)
		{
			mass = atoms[i].mass;
			for ( j = 0; j < 3; j++)
			L[j] += (
				atoms[i].coordinates[(j+1)%3]*atoms[i].velocity[(j+2)%3]
			      - atoms[i].coordinates[(j+2)%3]*atoms[i].velocity[(j+1)%3]
			      )*mass;
		}
	}
	for ( j = 0; j < 3; j++)
		L[j] -= (
			cm[(j+1)%3]*vtot[(j+2)%3]
		      - cm[(j+2)%3]*vtot[(j+1)%3]
			      )*totMass;

	/* calculate and invert the inertia tensor */
	for ( k = 0; k < 3; k++)
	for ( j = 0; j < 3; j++)
		tensor[k][j] = 0;
	xx = 0;
	yy = 0;
	zz = 0;
	xy = 0;
	xz = 0;
	yz = 0;
	for ( im = 0; im < nMols; im++)
	{
		Atom* atoms = molecules[im]->atoms;
		int nAtoms = molecules[im]->nAtoms;
		for ( i = 0; i < nAtoms; i++)
		{
			mass = atoms[i].mass;
			for ( j = 0; j < 3; j++)
				cdel[j] = atoms[i].coordinates[j]-cm[j];
			xx +=  cdel[0]*cdel[0]*mass;
			xy +=  cdel[0]*cdel[1]*mass;
			xz +=  cdel[0]*cdel[2]*mass;
			yy +=  cdel[1]*cdel[1]*mass;
			yz +=  cdel[1]*cdel[2]*mass;
			zz +=  cdel[2]*cdel[2]*mass;
		}
	}
	tensor[0][0] = yy+zz;
	tensor[1][0] = -xy;
	tensor[2][0] = -xz;
	tensor[0][1] = -xy;
	tensor[1][1] = xx+zz;
	tensor[2][1] = -yz;
	tensor[0][2] = -xz;
	tensor[1][2] = -yz;
	tensor[2][2] = xx+yy;
	if(InverseTensor(tensor,invTensor))
	{
		for ( j = 0; j < 3; j++)
		{
			vAng[j] = 0;
			for ( k = 0; k < 3; k++)
				vAng[j] += invTensor[j][k]*L[k];
		}
	}
	else
	if(molecules[0]->nAtoms>1)
	{
		double U0[3];
		double U1[3];
		Atom* atoms = molecules[0]->atoms;
		for ( j = 0; j < 3; j++)U0[j] = atoms[0].coordinates[j];
		for ( j = 0; j < 3; j++)U1[j] = atoms[1].coordinates[j];
		//printf("!!!!!!!!!!!I cannot invert the rotational Tensor : linear molecule!\n");
		computeAngularVelocitiesForALinearMolecule(U0, U1, tensor, L, vAng);
		//printf("Angular velocityi before rotation = %f %f %f\n",vAng[0], vAng[1], vAng[2]);
	}
	/*  eliminate any rotation about the system center of mass */
	for ( im = 0; im < nMols; im++)
	{
		Atom* atoms = molecules[im]->atoms;
		int nAtoms = molecules[im]->nAtoms;
		for ( i = 0; i < nAtoms; i++)
		{
			for ( j = 0; j < 3; j++)
				cdel[j] = atoms[i].coordinates[j]-cm[j];
			for ( j = 0; j < 3; j++)
				atoms[i].velocity[j] += 
				cdel[(j+1)%3]*vAng[(j+2)%3]-
				cdel[(j+2)%3]*vAng[(j+1)%3];
		}
	}
}
/*********************************************************************************/
static void removeTranslationAndRotationCluster(Molecule** molecules, int nMols)
{
	if(nMols<1) return;
	molecules[0]->klass->removeTranslationCluster(molecules,nMols);
	molecules[0]->klass->removeRotationCluster(molecules,nMols);
}
/*********************************************************************************/
static void removeTranslationForceCluster(Molecule** molecules, int nMols, double** vectors)
{
	// Vectors = FORCE or Moment
	// atot = acc. or veloc. 
	double atot[3] = {0,0,0};
	int im;
	int i;
	int j;
	double tot = 0.0;

	for ( im = 0; im < nMols; im++)
	{
		Atom* atoms = molecules[im]->atoms;
		int nAtoms = molecules[im]->nAtoms;
		for ( i = 0; i < nAtoms; i++)
		{
			tot += atoms[i].mass;
			for ( j = 0; j < 3; j++)
			{
				atot[j] += vectors[im][3*i+j];
			}
		}
	}

	for ( j = 0; j < 3; j++)
		atot[j] /= tot;

	for ( im = 0; im < nMols; im++)
	{
		int nAtoms = molecules[im]->nAtoms;
		for ( i = 0; i < nAtoms; i++)
			for ( j = 0; j < 3; j++)
				vectors[im][3*i+j] -=   molecules[im]->atoms[i].mass*atot[j];
	}
}
/*********************************************************************************/
static void removeRotationForceCluster(Molecule** molecules, int nMols, double** vectors)
{
	double atot[3] = {0,0,0};
	double cm[3] = {0,0,0};
	double L[3] = {0,0,0};
	int im;
	int i;
	int j;
	int k;
	double mass = 1.0;
	double totMass = 0.0;
	double tot = 0.0;
	double cdel[3];
	double vAng[3]={0,0,0};
	double tensor[3][3];
	double invTensor[3][3];
        double xx, xy,xz,yy,yz,zz;
	/* find the center of mass coordinates  and total vectors*/

	for ( im = 0; im < nMols; im++)
	{
		Atom* atoms = molecules[im]->atoms;
		int nAtoms = molecules[im]->nAtoms;
		for ( i = 0; i < nAtoms; i++)
		{
			mass = atoms[i].mass;
			totMass += mass;
			tot += 1;
			for ( j = 0; j < 3; j++)
				cm[j] += mass*atoms[i].coordinates[j];
			for ( j = 0; j < 3; j++)
				atot[j] += vectors[im][3*i+j];
		}
	}


	for ( j = 0; j < 3; j++) cm[j] /= totMass;
	//for ( j = 0; j < 3; j++) atot[j] /= totMass;

	/*   compute the angular momentum  */
	for ( im = 0; im < nMols; im++)
	{
		Atom* atoms = molecules[im]->atoms;
		int nAtoms = molecules[im]->nAtoms;
		for ( i = 0; i < nAtoms; i++)
		{
			mass = atoms[i].mass;
			for ( j = 0; j < 3; j++)
			L[j] += (
				atoms[i].coordinates[(j+1)%3]*vectors[im][3*i+(j+2)%3]
			      - atoms[i].coordinates[(j+2)%3]*vectors[im][3*i+(j+1)%3]
			      );
		}
	}
	for ( j = 0; j < 3; j++)
		L[j] -= (
			cm[(j+1)%3]*atot[(j+2)%3]
		      - cm[(j+2)%3]*atot[(j+1)%3]
			      );
			      //)*totMass;

	/* calculate and invert the inertia tensor */
	for ( k = 0; k < 3; k++)
	for ( j = 0; j < 3; j++)
		tensor[k][j] = 0;
	xx = 0;
	yy = 0;
	zz = 0;
	xy = 0;
	xz = 0;
	yz = 0;
	for ( im = 0; im < nMols; im++)
	{
		Atom* atoms = molecules[im]->atoms;
		int nAtoms = molecules[im]->nAtoms;
		for ( i = 0; i < nAtoms; i++)
		{
			mass = atoms[i].mass;
			for ( j = 0; j < 3; j++)
				cdel[j] = atoms[i].coordinates[j]-cm[j];
			xx +=  cdel[0]*cdel[0]*mass;
			xy +=  cdel[0]*cdel[1]*mass;
			xz +=  cdel[0]*cdel[2]*mass;
			yy +=  cdel[1]*cdel[1]*mass;
			yz +=  cdel[1]*cdel[2]*mass;
			zz +=  cdel[2]*cdel[2]*mass;
		}
	}
	tensor[0][0] = yy+zz;
	tensor[1][0] = -xy;
	tensor[2][0] = -xz;
	tensor[0][1] = -xy;
	tensor[1][1] = xx+zz;
	tensor[2][1] = -yz;
	tensor[0][2] = -xz;
	tensor[1][2] = -yz;
	tensor[2][2] = xx+yy;
	if(InverseTensor(tensor,invTensor))
	{
		for ( j = 0; j < 3; j++)
		{
			vAng[j] = 0;
			for ( k = 0; k < 3; k++)
				vAng[j] += invTensor[j][k]*L[k];
		}
	}
	else
	if(molecules[0]->nAtoms>1)
	{
		double U0[3];
		double U1[3];
		Atom* atoms = molecules[0]->atoms;
		for ( j = 0; j < 3; j++)U0[j] = atoms[0].coordinates[j];
		for ( j = 0; j < 3; j++)U1[j] = atoms[1].coordinates[j];
		//printf("!!!!!!!!!!!I cannot invert the rotational Tensor : linear molecule!\n");
		computeAngularVelocitiesForALinearMolecule(U0,U1, tensor, L, vAng);
		//printf("Angular vectors before rotation = %f %f %f\n",vAng[0], vAng[1], vAng[2]);
	}
	/*  eliminate any rotation about the system center of mass */
	for ( im = 0; im < nMols; im++)
	{
		Atom* atoms = molecules[im]->atoms;
		int nAtoms = molecules[im]->nAtoms;
		for ( i = 0; i < nAtoms; i++)
		{
			for ( j = 0; j < 3; j++)
				cdel[j] = atoms[i].coordinates[j]-cm[j];
			for ( j = 0; j < 3; j++)
				vectors[im][3*i+j] += 
				(cdel[(j+1)%3]*vAng[(j+2)%3]-
				cdel[(j+2)%3]*vAng[(j+1)%3])
				*atoms[i].mass
				;
		}
	}
}
/*********************************************************************************/
static void removeTranslationAndRotationForceCluster(Molecule** molecules, int nMols, double** vectors)
{
	if(nMols<1) return;
	molecules[0]->klass->removeTranslationForceCluster(molecules, nMols, vectors);
	molecules[0]->klass->removeRotationForceCluster(molecules, nMols, vectors);
}
/*********************************************************************************/
static void removeTranslationForce(Molecule* molecule, double* f)
{
	// Vectors = FORCE or Moment
	// atot = acc. or veloc. 
	double atot[3] = {0,0,0};
	int i;
	int j;
	double tot = 0.0;

	{
		Atom* atoms = molecule->atoms;
		int nAtoms = molecule->nAtoms;
		for ( i = 0; i < nAtoms; i++)
		{
			tot += atoms[i].mass;
			for ( j = 0; j < 3; j++)
			{
				atot[j] += f[3*i+j];
			}
		}
	}

	for ( j = 0; j < 3; j++)
		atot[j] /= tot;

	{
		int nAtoms = molecule->nAtoms;
		for ( i = 0; i < nAtoms; i++)
			for ( j = 0; j < 3; j++)
				f[3*i+j] -=   molecule->atoms[i].mass*atot[j];
	}
}
/*********************************************************************************/
static void removeRotationForce(Molecule* molecule, double* f)
{
	double atot[3] = {0,0,0};
	double cm[3] = {0,0,0};
	double L[3] = {0,0,0};
	int i;
	int j;
	int k;
	double mass = 1.0;
	double totMass = 0.0;
	double tot = 0.0;
	double cdel[3];
	double vAng[3]={0,0,0};
	double tensor[3][3];
	double invTensor[3][3];
        double xx, xy,xz,yy,yz,zz;
	/* find the center of mass coordinates  and total f*/

	{
		Atom* atoms = molecule->atoms;
		int nAtoms = molecule->nAtoms;
		for ( i = 0; i < nAtoms; i++)
		{
			mass = atoms[i].mass;
			totMass += mass;
			tot += 1;
			for ( j = 0; j < 3; j++)
				cm[j] += mass*atoms[i].coordinates[j];
			for ( j = 0; j < 3; j++)
				atot[j] += f[3*i+j];
		}
	}


	for ( j = 0; j < 3; j++) cm[j] /= totMass;

	/*   compute the angular momentum  */
	{
		Atom* atoms = molecule->atoms;
		int nAtoms = molecule->nAtoms;
		for ( i = 0; i < nAtoms; i++)
		{
			mass = atoms[i].mass;
			for ( j = 0; j < 3; j++)
			L[j] += (
				atoms[i].coordinates[(j+1)%3]*f[3*i+(j+2)%3]
			      - atoms[i].coordinates[(j+2)%3]*f[3*i+(j+1)%3]
			      );
		}
	}
	for ( j = 0; j < 3; j++)
		L[j] -= (
			cm[(j+1)%3]*atot[(j+2)%3]
		      - cm[(j+2)%3]*atot[(j+1)%3]
			      );

	/* calculate and invert the inertia tensor */
	for ( k = 0; k < 3; k++)
	for ( j = 0; j < 3; j++)
		tensor[k][j] = 0;
	xx = 0;
	yy = 0;
	zz = 0;
	xy = 0;
	xz = 0;
	yz = 0;
	{
		Atom* atoms = molecule->atoms;
		int nAtoms = molecule->nAtoms;
		for ( i = 0; i < nAtoms; i++)
		{
			mass = atoms[i].mass;
			for ( j = 0; j < 3; j++)
				cdel[j] = atoms[i].coordinates[j]-cm[j];
			xx +=  cdel[0]*cdel[0]*mass;
			xy +=  cdel[0]*cdel[1]*mass;
			xz +=  cdel[0]*cdel[2]*mass;
			yy +=  cdel[1]*cdel[1]*mass;
			yz +=  cdel[1]*cdel[2]*mass;
			zz +=  cdel[2]*cdel[2]*mass;
		}
	}
	tensor[0][0] = yy+zz;
	tensor[1][0] = -xy;
	tensor[2][0] = -xz;
	tensor[0][1] = -xy;
	tensor[1][1] = xx+zz;
	tensor[2][1] = -yz;
	tensor[0][2] = -xz;
	tensor[1][2] = -yz;
	tensor[2][2] = xx+yy;
	if(InverseTensor(tensor,invTensor))
	{
		for ( j = 0; j < 3; j++)
		{
			vAng[j] = 0;
			for ( k = 0; k < 3; k++)
				vAng[j] += invTensor[j][k]*L[k];
		}
	}
	else
	if(molecule->nAtoms>1)
	{
		double U0[3];
		double U1[3];
		Atom* atoms = molecule->atoms;
		for ( j = 0; j < 3; j++)U0[j] = atoms[0].coordinates[j];
		for ( j = 0; j < 3; j++)U1[j] = atoms[1].coordinates[j];
		//printf("!!!!!!!!!!!I cannot invert the rotational Tensor : linear molecule!\n");
		computeAngularVelocitiesForALinearMolecule(U0,U1, tensor, L, vAng);
		//printf("Angular f before rotation = %f %f %f\n",vAng[0], vAng[1], vAng[2]);
	}
	/*  eliminate any rotation about the system center of mass */
	{
		Atom* atoms = molecule->atoms;
		int nAtoms = molecule->nAtoms;
		for ( i = 0; i < nAtoms; i++)
		{
			for ( j = 0; j < 3; j++)
				cdel[j] = atoms[i].coordinates[j]-cm[j];
			for ( j = 0; j < 3; j++)
				f[3*i+j] += 
				(cdel[(j+1)%3]*vAng[(j+2)%3]-
				cdel[(j+2)%3]*vAng[(j+1)%3])
				*atoms[i].mass
				;
		}
	}
}
/*********************************************************************************/
static void removeTranslationAndRotationForce(Molecule* molecule, double*f)
{
	molecule->klass->removeTranslationForce(molecule, f);
	molecule->klass->removeRotationForce(molecule, f);
}
/*********************************************************************************/
static void removeTranslationMoments(Molecule** molecules, int nMols, double*** P)
{
	double vtot[3] = {0,0,0};
	int im;
	int i;
	int j;
	double totMass = 0.0;

	for ( im = 0; im < nMols; im++)
	{
		int nAtoms = molecules[im]->nAtoms;
		for ( i = 0; i < nAtoms; i++)
		{
			totMass += molecules[im]->atoms[i].mass;
			for ( j = 0; j < 3; j++)
			{
				vtot[j] += P[j][im][i];
			}
		}
	}
	for ( j = 0; j < 3; j++) vtot[j] /= totMass;


	for ( im = 0; im < nMols; im++)
	{
		int nAtoms = molecules[im]->nAtoms;
		for ( i = 0; i < nAtoms; i++)
			for ( j = 0; j < 3; j++)
				P[j][im][i] -= molecules[im]->atoms[i].mass*vtot[j];
	}
}
/*********************************************************************************/
static void removeRotationMoments(Molecule** molecules, int nMols, double*** P)
{
	double ptot[3] = {0,0,0};
	double cm[3] = {0,0,0};
	double L[3] = {0,0,0};
	int im;
	int i;
	int j;
	int k;
	double mass = 1.0;
	double totMass = 0.0;
	double cdel[3];
	double pAng[3]={0,0,0};
	double tensor[3][3];
	double invTensor[3][3];
        double xx, xy,xz,yy,yz,zz;
	boolean linear = FALSE;
	double n = 0;
	/* find the center of mass coordinates  and total vectors*/

	for ( im = 0; im < nMols; im++)
	{
		Atom* atoms = molecules[im]->atoms;
		int nAtoms = molecules[im]->nAtoms;
		for ( i = 0; i < nAtoms; i++)
		{
			mass = atoms[i].mass;
			totMass += mass;
			n++;
			for ( j = 0; j < 3; j++)
				cm[j] += mass*atoms[i].coordinates[j];
			for ( j = 0; j < 3; j++)
				ptot[j] += P[j][im][i];
		}
	}


	for ( j = 0; j < 3; j++) cm[j] /= totMass;
	//for ( j = 0; j < 3; j++) ptot[j] /= n;

	/*   compute the angular momentum  */
	for ( im = 0; im < nMols; im++)
	{
		Atom* atoms = molecules[im]->atoms;
		int nAtoms = molecules[im]->nAtoms;
		for ( i = 0; i < nAtoms; i++)
		{
			//mass = atoms[i].mass;
			for ( j = 0; j < 3; j++)
			L[j] += (
				atoms[i].coordinates[(j+1)%3]*P[(j+2)%3][im][i]
			      - atoms[i].coordinates[(j+2)%3]*P[(j+1)%3][im][i]
			      //)*mass;
			      );
		}
	}
	for ( j = 0; j < 3; j++)
		L[j] -= (
			cm[(j+1)%3]*ptot[(j+2)%3]
		      - cm[(j+2)%3]*ptot[(j+1)%3]
			      );
			      //)*totMass;

	/* calculate and invert the inertia tensor */
	for ( k = 0; k < 3; k++)
	for ( j = 0; j < 3; j++)
		tensor[k][j] = 0;
	xx = 0;
	yy = 0;
	zz = 0;
	xy = 0;
	xz = 0;
	yz = 0;
	for ( im = 0; im < nMols; im++)
	{
		Atom* atoms = molecules[im]->atoms;
		int nAtoms = molecules[im]->nAtoms;
		for ( i = 0; i < nAtoms; i++)
		{
			mass = atoms[i].mass;
			for ( j = 0; j < 3; j++)
				cdel[j] = atoms[i].coordinates[j]-cm[j];

			xx +=  cdel[0]*cdel[0]*mass;
			xy +=  cdel[0]*cdel[1]*mass;
			xz +=  cdel[0]*cdel[2]*mass;
			yy +=  cdel[1]*cdel[1]*mass;
			yz +=  cdel[1]*cdel[2]*mass;
			zz +=  cdel[2]*cdel[2]*mass;
		}
	}
	tensor[0][0] = yy+zz;
	tensor[1][0] = -xy;
	tensor[2][0] = -xz;
	tensor[0][1] = -xy;
	tensor[1][1] = xx+zz;
	tensor[2][1] = -yz;
	tensor[0][2] = -xz;
	tensor[1][2] = -yz;
	tensor[2][2] = xx+yy;
	if(InverseTensor(tensor,invTensor))
	{
		for ( j = 0; j < 3; j++)
		{
			pAng[j] = 0;
			for ( k = 0; k < 3; k++)
				pAng[j] += invTensor[j][k]*L[k];
		}
		printf("Angular vectors before rotation = %f %f %f\n",pAng[0], pAng[1], pAng[2]);
	}
	else
	if(molecules[0]->nAtoms>1)
	{
		double U0[3];
		double U1[3];
		Atom* atoms = molecules[0]->atoms;
		for ( j = 0; j < 3; j++)U0[j] = atoms[0].coordinates[j];
		for ( j = 0; j < 3; j++)U1[j] = atoms[1].coordinates[j];
		//printf("!!!!!!!!!!!I cannot invert the rotational Tensor : linear molecule!\n");
		computeAngularVelocitiesForALinearMolecule(U0, U1, tensor, L, pAng);
		printf("Angular vectors before rotation = %f %f %f\n",pAng[0], pAng[1], pAng[2]);
		linear = TRUE;
	}
	/*  eliminate any rotation about the system center of mass */
	for ( im = 0; im < nMols; im++)
	{
		Atom* atoms = molecules[im]->atoms;
		int nAtoms = molecules[im]->nAtoms;
		for ( i = 0; i < nAtoms; i++)
		{
			for ( j = 0; j < 3; j++)
				cdel[j] = atoms[i].coordinates[j]-cm[j];
			for ( j = 0; j < 3; j++)
				P[j][im][i] += 
				(cdel[(j+1)%3]*pAng[(j+2)%3]-
				cdel[(j+2)%3]*pAng[(j+1)%3])*atoms[i].mass;
		}
	}
/* Check */
	for ( j = 0; j < 3; j++) L[j] = 0;
	for ( im = 0; im < nMols; im++)
	{
		Atom* atoms = molecules[im]->atoms;
		int nAtoms = molecules[im]->nAtoms;
		for ( i = 0; i < nAtoms; i++)
		{
			//mass = atoms[i].mass;
			for ( j = 0; j < 3; j++)
			L[j] += (
				atoms[i].coordinates[(j+1)%3]*P[(j+2)%3][im][i]
			      - atoms[i].coordinates[(j+2)%3]*P[(j+1)%3][im][i]
			      //)*mass;
			      );
		}
	}
	for ( j = 0; j < 3; j++)
		L[j] -= (
			cm[(j+1)%3]*ptot[(j+2)%3]
		      - cm[(j+2)%3]*ptot[(j+1)%3]
			      );
			      //)*totMass;

	if(linear) 
	{
		double U0[3];
		double U1[3];
		Atom* atoms = molecules[0]->atoms;
		for ( j = 0; j < 3; j++) U0[j] = atoms[0].coordinates[j];
		for ( j = 0; j < 3; j++) U1[j] = atoms[1].coordinates[j];
		computeAngularVelocitiesForALinearMolecule(U0, U1, tensor, L, pAng);
		printf("Linear molecule Angular velocity = %f %f %f\n",pAng[0], pAng[1], pAng[2]);
	}
	else
	{
		for ( j = 0; j < 3; j++)
		{
			pAng[j] = 0;
			for ( k = 0; k < 3; k++)
				pAng[j] += invTensor[j][k]*L[k];
		}
		printf("Angular velocity = %f %f %f\n",pAng[0], pAng[1], pAng[2]);
	}

}
/*********************************************************************************/
static void removeTranslationAndRotationMoments(Molecule** molecules, int nMols, double*** P)
{
	if(nMols<1) return;
	molecules[0]->klass->removeTranslationMoments(molecules, nMols, P);
	molecules[0]->klass->removeRotationMoments(molecules, nMols, P);
}
/*********************************************************************************/
/* vectors = one vectors of 3*nAtoms elements */
static void removeRotationAcceleration(Molecule* molecule, double* a)
{
	int nAtoms = molecule->nAtoms;
	Atom* atoms = molecule->atoms;
	double cm[3] = {0,0,0};
	double L[3] = {0,0,0};
	int i;
	int j;
	int k;
	double mass = 1.0;
	double totMass = 0.0;
	double cdel[3];
	double fAng[3]={0,0,0};
	double tensor[3][3];
	double invTensor[3][3];
        double xx, xy,xz,yy,yz,zz;
	boolean linear = FALSE;
	double vectot[3] = {0,0,0};

	for ( i = 0; i < nAtoms; i++)
	{
		mass = atoms[i].mass;
		totMass += mass;
		for ( j = 0; j < 3; j++) vectot[j] += mass*a[3*i+j];
		for ( j = 0; j < 3; j++) cm[j] += mass*atoms[i].coordinates[j];
	}

	for ( j = 0; j < 3; j++) cm[j] /= totMass;
	for ( j = 0; j < 3; j++) vectot[j] /= totMass;

	/*   compute the angular momentum  */
	for ( i = 0; i < nAtoms; i++)
	{
		mass = atoms[i].mass;
		for ( j = 0; j < 3; j++)
			L[j] += (
				atoms[i].coordinates[(j+1)%3]*a[3*i+(j+2)%3]
			      - atoms[i].coordinates[(j+2)%3]*a[3*i+(j+1)%3]
			      )*mass;
	}
	for ( j = 0; j < 3; j++)
		L[j] -= (
			cm[(j+1)%3]*vectot[(j+2)%3]
		      - cm[(j+2)%3]*vectot[(j+1)%3]
			      )*totMass;

	/* calculate and invert the inertia tensor */
	for ( k = 0; k < 3; k++)
	for ( j = 0; j < 3; j++)
		tensor[k][j] = 0;
	xx = 0;
	yy = 0;
	zz = 0;
	xy = 0;
	xz = 0;
	yz = 0;
	for ( i = 0; i < nAtoms; i++)
	{
		mass = atoms[i].mass;
		for ( j = 0; j < 3; j++) cdel[j] = atoms[i].coordinates[j]-cm[j];
		xx +=  cdel[0]*cdel[0]*mass;
		xy +=  cdel[0]*cdel[1]*mass;
		xz +=  cdel[0]*cdel[2]*mass;
		yy +=  cdel[1]*cdel[1]*mass;
		yz +=  cdel[1]*cdel[2]*mass;
		zz +=  cdel[2]*cdel[2]*mass;
	}
	tensor[0][0] = yy+zz;
	tensor[1][0] = -xy;
	tensor[2][0] = -xz;
	tensor[0][1] = -xy;
	tensor[1][1] = xx+zz;
	tensor[2][1] = -yz;
	tensor[0][2] = -xz;
	tensor[1][2] = -yz;
	tensor[2][2] = xx+yy;
	if(InverseTensor(tensor,invTensor))
	{
		for ( j = 0; j < 3; j++)
		{
			fAng[j] = 0;
			for ( k = 0; k < 3; k++)
				fAng[j] += invTensor[j][k]*L[k];
		}
	}
	else
	if(molecule->nAtoms>1)
	{
		double U0[3];
		double U1[3];
		Atom* atoms = molecule->atoms;
		for ( j = 0; j < 3; j++)U0[j] = atoms[0].coordinates[j];
		for ( j = 0; j < 3; j++)U1[j] = atoms[1].coordinates[j];
		//printf("!!!!!!!!!!!I cannot invert the rotational Tensor : linear molecule!\n");
		computeAngularVelocitiesForALinearMolecule(U0, U1, tensor, L, fAng);
		//printf("Angular forces before rotation = %f %f %f\n",fAng[0], fAng[1], fAng[2]);
		linear = TRUE;
	}
	/*  eliminate any rotation about the system center of mass */
	for ( i = 0; i < nAtoms; i++)
	{
		for ( j = 0; j < 3; j++) cdel[j] = atoms[i].coordinates[j]-cm[j];
		for ( j = 0; j < 3; j++)
			a[3*i+j] += 
				(cdel[(j+1)%3]*fAng[(j+2)%3]-
				cdel[(j+2)%3]*fAng[(j+1)%3])
				;
	}

/* Check */
	for ( j = 0; j < 3; j++) L[j] = 0;
	for ( i = 0; i < nAtoms; i++)
	{
		mass = atoms[i].mass;
		for ( j = 0; j < 3; j++)
			L[j] += (
				atoms[i].coordinates[(j+1)%3]*a[3*i+(j+2)%3]
			      - atoms[i].coordinates[(j+2)%3]*a[3*i+(j+1)%3]
			      )*mass;
	}
	for ( j = 0; j < 3; j++)
		L[j] -= (
			cm[(j+1)%3]*vectot[(j+2)%3]
		      - cm[(j+2)%3]*vectot[(j+1)%3]
			      )*totMass;
	if(linear)
	{
		double U0[3];
		double U1[3];
		Atom* atoms = molecule->atoms;
		for ( j = 0; j < 3; j++)U0[j] = atoms[0].coordinates[j];
		for ( j = 0; j < 3; j++)U1[j] = atoms[1].coordinates[j];
		computeAngularVelocitiesForALinearMolecule(U0,U1, tensor, L, fAng);
	}
	else
	{
		for ( j = 0; j < 3; j++)
		{
			fAng[j] = 0;
			for ( k = 0; k < 3; k++)
				fAng[j] += invTensor[j][k]*L[k];
		}
	}

	printf("Angular forces = %f %f %f\n",fAng[0], fAng[1], fAng[2]);
}
/*********************************************************************************/
/* a = one vectors of 3*nAtoms elements */
static void removeTranslationAcceleration(Molecule* molecule, double* a)
{
	int nAtoms = molecule->nAtoms;
	double vectot[3] = {0,0,0};
	int i,j;
	Atom* atoms = molecule->atoms;
	double totMass = 0;
	for ( i = 0; i < nAtoms; i++)
	{
		for ( j = 0; j < 3; j++) vectot[j] += atoms[i].mass*a[3*i+j];
		totMass += atoms[i].mass;
	}

	for ( j = 0; j < 3; j++) vectot[j] /= totMass;
	for ( i = 0; i < nAtoms; i++)
		for ( j = 0; j < 3; j++) a[3*i+j] -= vectot[j];
}
/*********************************************************************************/
/* vectors = one vectors of 3*nAtoms elements */
static void removeTranslationAndRotationAcceleration(Molecule* molecule, double* a)
{
	molecule->klass->removeTranslationAcceleration(molecule,a);
	molecule->klass->removeRotationAcceleration(molecule,a);
}
/*****************************************************************************/
static boolean printMolecule(Molecule* molecule, FILE* file)
{
	int j;
	if(!molecule) return FALSE;
	if(!file) return FALSE;

	{
		int k,nc;
		fprintf(file,"%f\n",molecule->potentialEnergy);
		fprintf(file,"0\n");
		fprintf(file,"%d %d %d\n",molecule->nAtoms, molecule->totalCharge, molecule->spinMultiplicity);
		for(j=0;j<molecule->nAtoms;j++)
		{
			nc = 0;
			for(k=0;k<molecule->nAtoms;k++) if(molecule->atoms[j].typeConnections[k]>0) nc++;
			fprintf(file," %s %s %s %s %d %f %d %d %f %f %f %d ", 
				molecule->atoms[j].prop.symbol,
				molecule->atoms[j].mmType,
				molecule->atoms[j].pdbType,
				molecule->atoms[j].residueName,
				molecule->atoms[j].residueNumber,
				molecule->atoms[j].charge,
				molecule->atoms[j].layer,
				molecule->atoms[j].variable,
				molecule->atoms[j].coordinates[0],
				molecule->atoms[j].coordinates[1],
				molecule->atoms[j].coordinates[2],
				nc
				);
			for(k=0;k<molecule->nAtoms;k++) 
			{
		 		int nk = molecule->atoms[k].N-1;
				if(molecule->atoms[j].typeConnections[nk]>0) 
				fprintf(file," %d %d", nk+1,molecule->atoms[j].typeConnections[nk]);
			}
			fprintf(file,"\n");
		}
	}
	return TRUE;

}
/********************************************************************************/
static double getKelvin(Molecule* molecule)
{
	int nFree = molecule->nFree;
	if(nFree<1) return 0;
	double kin = molecule->klass->getKineticEnergy(molecule);
	return 2*kin / ( nFree * Kb);
}
/*****************************************************************************/
static void scaleVelocities(Molecule* molecule, double temperature)
{
	double kelvin = molecule->klass->getKelvin(molecule);
	double scale = 1.0;
	int i,j;
	if(temperature<=0) return;
	if(kelvin<=0) return;

	scale = sqrt(temperature/kelvin);
#ifdef DEBUG
	printf("temp = %f kelvin = %f scale = %f\n",temperature, kelvin, scale);
#endif
	for(i = 0;i<molecule->nAtoms; i++) 
		if(molecule->atoms[i].variable)
		for ( j = 0; j < 3; j++)
			molecule->atoms[i].velocity[j] *= scale;
}
/*****************************************************************************/
static void setMaxwellVelocities(Molecule* molecule, double temperature)
{
	int i,j;
	for ( i = 0; i < molecule->nAtoms; i++)
	{
        	if(!molecule->atoms[i].variable) 
		for ( j = 0; j < 3; j++) molecule->atoms[i].velocity[j] = 0.0;
		else
		{
			double speed = maxwel(molecule->atoms[i].mass,temperature);
			getRandVect(speed, molecule->atoms[i].velocity);
		}
	}
	molecule->klass->scaleVelocities(molecule, temperature);
}
/*****************************************************************************/
static boolean setMaxwellVelocitiesIfNull(Molecule* molecule, double temperature)
{
	
	double ekin = molecule->klass->getKineticEnergy(molecule);
	if(fabs(ekin)>1e-14) return FALSE;
	setMaxwellVelocities(molecule, temperature);
	return TRUE;
}
/*****************************************************************************/
static boolean resetConstraints(Molecule* molecule, Constraints constraints)
{
	int i;
	int nvariables = 0;
        int nAtoms = molecule->nAtoms;

        molecule->constraints = constraints;
	setRattleConstraintsParameters(molecule);

        for ( i = 0; i < nAtoms; i++)
                	if(molecule->atoms[i].variable) nvariables +=1;
        if(nvariables==0) 
	{
		nvariables = nAtoms;
        	for ( i = 0; i < nAtoms; i++)
                	molecule->atoms[i].variable = TRUE;
	}
        molecule->nFree = 3* nvariables;
        molecule->nFree -= molecule->numberOfRattleConstraintsTerms;

        if(nvariables==nAtoms) molecule->nFree -=6;
        if(nvariables==2 && 2==nAtoms) molecule->nFree +=1;
        if(nvariables==nAtoms-1) molecule->nFree -=3;
        if(nvariables==nAtoms-2) molecule->nFree -=1;
	if( molecule->nFree<1)  {
		printf("nFree =%d < 1\n",molecule->nFree);
		exit(1);
	}
	printf("#Number of free coordinates =%d \n",molecule->nFree);
	return TRUE;
}
/**********************************************************************/
static void setRattleConstraintsParameters(Molecule* m)
{
	int i;
	int j;
	int k;
	int a1,a2,a3;
	double r2;
	double d;
	int numberOfRattleConstraintsTerms = 0;
	double* rattleConstraintsTerms[RATTLEDIM];

	m->numberOfRattleConstraintsTerms = 0;
	for( i=0; i<RATTLEDIM;i++) m->rattleConstraintsTerms[i] = NULL;

	if(m->nAtoms<1) return;

	if(m->constraints==NOCONSTRAINTS) return;
	numberOfRattleConstraintsTerms = m->numberOf2Connections;
	if(m->constraints==BONDSANGLESCONSTRAINTS) 
		numberOfRattleConstraintsTerms += m->numberOf3Connections;

	if(numberOfRattleConstraintsTerms<1) return;
	for( i=0; i<RATTLEDIM;i++)
       		rattleConstraintsTerms[i] = malloc(numberOfRattleConstraintsTerms*sizeof(double));


	/* 1=a1, 2=a2, 3=r2a1a2 */
	/* RATTLEDIM 	3 */
	j = 0;
	for ( i = 0; i < m->numberOf2Connections; i++)
	{
		a1 = m->connected2[0][i];
		a2 = m->connected2[1][i];
		if(!m->atoms[a1].variable &&!m->atoms[a2].variable) continue;
		r2 = 0;
		for (k=0;k<3;k++)
		{
			d = m->atoms[a1].coordinates[k]-m->atoms[a2].coordinates[k];
			r2 +=d*d;
		}
		rattleConstraintsTerms[0][j] = a1;
		rattleConstraintsTerms[1][j] = a2;
		rattleConstraintsTerms[2][j] = r2;
		j++;
	}
	if(m->constraints==BONDSANGLESCONSTRAINTS)
	{
		int a1p, a2p;
		int* nConnections = NULL;
		int* nAngles = NULL;
       		nConnections = malloc(m->nAtoms*sizeof(int));
       		nAngles = malloc(m->nAtoms*sizeof(int));
		for ( i = 0; i < m->nAtoms; i++)
		{
			nConnections[i] = 0;
			nAngles[i] = 0;
		}
		for ( i = 0; i < m->nAtoms; i++)
		if(m->atoms[i].typeConnections)
		{
			for ( k = 0; k < m->nAtoms; k++)
				if(i!=k && m->atoms[i].typeConnections[m->atoms[k].N-1]>0) nConnections[i]++;
			/* printf("%d %s nCon=%d\n",i,m->atoms[i].mmType,nConnections[i]);*/
		}
		for ( i = 0; i < m->numberOf3Connections; i++)
		{
			a1 = m->connected3[0][i];
			a2 = m->connected3[1][i];
			a3 = m->connected3[2][i];
			if(!m->atoms[a1].variable &&!m->atoms[a3].variable) continue;
			if(nAngles[a2]>=2*nConnections[a2]-3) continue;
			for (k=0;k<j;k++)
			{
				a1p = (int)rattleConstraintsTerms[0][k];
				a2p = (int)rattleConstraintsTerms[1][k];
				if(a1p==a1 && a2p==a3) break;
				if(a1p==a3 && a2p==a1) break;
			}
			if(k!=j) continue;

			nAngles[a2]++;
			r2 = 0;
			for (k=0;k<3;k++)
			{
				d = m->atoms[a1].coordinates[k]-m->atoms[a3].coordinates[k];
				r2 +=d*d;
			}
			rattleConstraintsTerms[0][j] = a1;
			rattleConstraintsTerms[1][j] = a3;
			rattleConstraintsTerms[2][j] = r2;
			j++;
		}
		/*
		for ( i = 0; i < m->nAtoms; i++)
		{
			printf("%d %s nAngle = %d 2*nCon-3=%d\n",i,m->atoms[i].mmType,nAngles[i],2*nConnections[i]-3);
		}
		*/
       		if(nConnections) free(nConnections);
       		if(nAngles) free(nAngles);
	}

	if(j<1)
	{
		numberOfRattleConstraintsTerms=0;
		for( i=0; i<RATTLEDIM;i++)
		{
       			free(rattleConstraintsTerms[i]);
       			rattleConstraintsTerms[i] = NULL;
		}
	}
	else if(numberOfRattleConstraintsTerms!=j)
	{
		numberOfRattleConstraintsTerms=j;
		for( i=0; i<RATTLEDIM;i++)
		{
       			rattleConstraintsTerms[i] = 
				realloc(rattleConstraintsTerms[i],numberOfRattleConstraintsTerms*sizeof(double));
		}
	}
	m->numberOfRattleConstraintsTerms = numberOfRattleConstraintsTerms;
	for( i=0; i<RATTLEDIM;i++)
       		m->rattleConstraintsTerms[i] = rattleConstraintsTerms[i]; 

/*
	for ( i = 0; i < m->numberOfRattleConstraintsTerms; i++)
	{
			a1 = (int)rattleConstraintsTerms[0][i];
			a2 = (int)rattleConstraintsTerms[1][i];
			r2 = rattleConstraintsTerms[2][i];
			printf("%d  %d %s %s r2= %f\n",
				a1,a2,
				m->atoms[a1].mmType,
				m->atoms[a2].mmType,
				r2);
	}
*/
}
/*****************************************************************************/
static int getRanInt(int* index, int n, int M)
{
	boolean accepted=TRUE;
	int ir = 0;
	int itmax = 1000; 
	int it = 0;
	do
	{
		int i;
		it++;
		ir = rand()%M;
		accepted = TRUE;
		for(i=0;i<n;i++) if(ir==index[i]) {accepted = FALSE; break;}
	}while (!accepted && it<itmax);
	if(it>=itmax)
	{
		fprintf(stderr,"Error : number of call for rand() > %d\n",itmax);
		fprintf(stderr,"Program stopped in getRanInt of Molecule file\n");
		exit(1);
	}
	return ir;
}
/*****************************************************************************/
static boolean setRandomFragments(Molecule* molecule)
{
	int n = 0;
	double bd = 0;
	int itmax = 1000; 
	int nRes=0;
	int** listByResidue = NULL;
	int* nByResidue = NULL;
	int nAtoms = molecule->nAtoms;
	Molecule* mol0 = NULL;
	int i;

	if(nAtoms<=1) return FALSE;

	nRes=0;
	for (i = 0; i<nAtoms;i++) if(molecule->atoms[i].residueNumber>nRes) nRes++;
	nRes++;
	if(nRes<2) return FALSE;

	mol0 = molecule->klass->copy(molecule);

	nByResidue = malloc(nRes*sizeof(int));
	listByResidue = malloc(nRes*sizeof(int*));
	for (n = 0; n<nRes;n++) listByResidue[n] = malloc(nAtoms*sizeof(int));

	for (n = 0; n<nRes;n++) nByResidue[n]=0;

	for (n = 0; n<nRes;n++) 
	for (i = 0; i<nAtoms;i++) 
	{
		if(molecule->atoms[i].residueNumber==n) 
		{
			int k = nByResidue[n];
			listByResidue[n][k] =  i;
			nByResidue[n]++;
		}
	}
	// don't change n=0
	for (n = 1; n<nRes;n++)
	{
		boolean accepted;
		int it=0;
		do{
			double direction[3];
			double v[3];
			double O[3];
			double a1a2[3];
			double distance = 0;
			double MRot[3][3];
			int i,j,k;
			Atom* a1 = NULL;
			Atom* a2 = NULL;
			int k1=rand()%nByResidue[0];
			int i1=listByResidue[0][k1];
			int k2=rand()%nByResidue[n];
			int i2=listByResidue[n][k2];
			a1 = &mol0->atoms[i1];
			a2 = &mol0->atoms[i2];
			distance = 0;
			for (k=0;k<3;k++) { double dij = a1->coordinates[k]-a2->coordinates[k]; distance +=dij*dij;}
			for (k=0;k<3;k++) a1a2[k] = a2->coordinates[k]-a1->coordinates[k]; 
			distance = sqrt(distance);
			getRandDirection(direction);
			//printf("distance=%f\n",distance);
			for (k=0;k<3;k++) direction[k]*= distance;

			//double mod=0; for (k=0;k<3;k++) mod+= direction[k]*direction[k]; mod=sqrt(mod); printf("mod=%f\n",mod);

			for (k=0;k<3;k++) v[k] = direction[k]-a1a2[k];

			for(j=0;j<nByResidue[n];j++)
			{
				int jj=listByResidue[n][j];
				for (k=0;k<3;k++) molecule->atoms[jj].coordinates[k] = mol0->atoms[jj].coordinates[k] + v[k];
			}
			get3DRandMatrix(MRot);
			
			for (k=0;k<3;k++) O[k] = molecule->atoms[i2].coordinates[k];
			for(j=0;j<nByResidue[n];j++)
			{
				int l;
				int jj=listByResidue[n][j];
				for (k=0;k<3;k++) v[k] = molecule->atoms[jj].coordinates[k]-O[k];
				for (l=0;l<3;l++) 
				{
					molecule->atoms[jj].coordinates[l] = O[l];
					for (k=0;k<3;k++) molecule->atoms[jj].coordinates[l] += v[k]*MRot[l][k];
				}
			}

			accepted = TRUE;
			for(j=0;j<nByResidue[n] && accepted;j++)
			for(i=0;i<nAtoms && accepted;i++)
			{
				if(molecule->atoms[i].residueNumber>=n) continue;
				int ii=i;
				int jj=listByResidue[n][j];
				a1 = &molecule->atoms[ii];
				a2 = &molecule->atoms[jj];

				double distance = 0;
				for (k=0;k<3;k++) { double dij = a1->coordinates[k]-a2->coordinates[k]; distance +=dij*dij;}
				distance = sqrt(distance)/BOHRTOANG;
				bd = a1->prop.covalentRadii + a2->prop.covalentRadii;
				if(distance<0.6*bd)
				{
					accepted = FALSE;
					break;
				}
			}
			it++;
		}while(!accepted && it<itmax);
	}
	if(nByResidue) free(nByResidue);
	for (n = 0; n<nRes;n++) if(listByResidue[n]) free(listByResidue[n]);
	if(listByResidue) free(listByResidue);

	mol0->klass->free(mol0);
	//setConnections(molecule);
	return TRUE;
}
/*****************************************************************************/
static boolean setRandomPositions(Molecule* molecule)
{
	int* index = NULL;
	int n = 0;
	int ir;
	double bd = 0;
	int ic = 0;
	int it = 0;
	int itmax = 1000; 
	int i;
	int j;

	if(molecule->nAtoms<=1) return FALSE;
	index = malloc(molecule->nAtoms*sizeof(int));
	for(i=0;i<molecule->nAtoms;i++) index[i] = -1;

	ir = rand()%molecule->nAtoms;
	index[n] = ir;
	for(j = 0;j<3;j++) molecule->atoms[index[n]].coordinates[j] = 0;
	for (n = 1; n<molecule->nAtoms;n++)
	{
		boolean accepted;
		Atom* a1 = NULL;
		Atom* a2 = NULL;
		it = 0;
		ir = getRanInt(index, n, molecule->nAtoms);
		index[n] = ir;
		do{
			int j;
			int i;
			double phi;
			double theta;
			ic = rand()%n;
			a2 = &molecule->atoms[index[ic]];
			a1 = &molecule->atoms[index[n]];
			bd = a1->prop.covalentRadii + a2->prop.covalentRadii;
			bd *= BOHRTOANG;
			bd *=0.9;
			//for(j = 0;j<3;j++) a1->coordinates[j] =  a2->coordinates[j]+bd*(0.5+rand()/(double)(RAND_MAX))*(rand()%2==0?1:-1);
			phi = rand()/(double)RAND_MAX*2*M_PI;
			theta = rand()/(double)RAND_MAX*M_PI;
			j = 0;
			a1->coordinates[j] =  a2->coordinates[j]+bd*sin(theta)*cos(phi);
			j = 1;
			a1->coordinates[j] =  a2->coordinates[j]+bd*sin(theta)*sin(phi);
			j = 2;
			a1->coordinates[j] =  a2->coordinates[j]+bd*cos(theta);
			accepted = TRUE;
			for(i=0;i<n;i++)
			{
				int k;
				a2 = &molecule->atoms[index[i]];
				double distance = 0;
				for (k=0;k<3;k++) { double dij = a1->coordinates[k]-a2->coordinates[k]; distance +=dij*dij;}
				distance = sqrt(distance)/BOHRTOANG;
				bd = a1->prop.covalentRadii + a2->prop.covalentRadii;
				//if(distance<0.6*bd)
				if(distance<0.9*bd)
				{
					accepted = FALSE;
					break;
				}
			}
			it++;
		}while(!accepted && it<itmax);
		if(it>=itmax)
		{
			fprintf(stderr,"Error : number of call for rand() > %d\n",itmax);
			fprintf(stderr,"Program stopped in setRandomMolecule of Molecule file\n");
			exit(1);
		}
	}
	//setConnections(molecule);
	return TRUE;

}
/*****************************************************************************/
static boolean setRandomPositionsChain(Molecule* molecule)
{
	int n = 0;
	int ir;
	double bd = 0;
	int ic = 0;
	int it = 0;
	int itmax = 1000*molecule->nAtoms; 
	int j;

	if(molecule->nAtoms<=1) return FALSE;

	for(j = 0;j<3;j++) molecule->atoms[0].coordinates[j] = 0;
	for (n = 1; n<molecule->nAtoms;n++)
	{
		boolean accepted;
		Atom* a1 = NULL;
		Atom* a2 = NULL;
		it = 0;
		ir = n;
		do{
			int j;
			int i;
			double phi;
			double theta;
			ic = n-1;
			a2 = &molecule->atoms[ic];
			a1 = &molecule->atoms[ir];
			bd = a1->prop.covalentRadii + a2->prop.covalentRadii;
			bd *= BOHRTOANG;
			//bd *=0.75;
			bd *=0.9;
			phi = rand()/(double)RAND_MAX*2*M_PI;
			theta = rand()/(double)RAND_MAX*M_PI;
			j = 0;
			a1->coordinates[j] =  a2->coordinates[j]+bd*sin(theta)*cos(phi);
			j = 1;
			a1->coordinates[j] =  a2->coordinates[j]+bd*sin(theta)*sin(phi);
			j = 2;
			a1->coordinates[j] =  a2->coordinates[j]+bd*cos(theta);
			accepted = TRUE;
			for(i=0;i<n;i++)
			{
				int k;
				a2 = &molecule->atoms[i];
				double distance = 0;
				for (k=0;k<3;k++) { double dij = a1->coordinates[k]-a2->coordinates[k]; distance +=dij*dij;}
				distance = sqrt(distance)/BOHRTOANG;
				bd = a1->prop.covalentRadii + a2->prop.covalentRadii;
				//if(distance<0.65*bd)
				if(distance<0.9*bd)
				{
					accepted = FALSE;
					break;
				}
			}
			it++;
		}while(!accepted && it<itmax);
		if(it>=itmax)
		{
			fprintf(stderr,"Error : number of call for rand() > %d\n",itmax);
			fprintf(stderr,"Program stopped in setRandomMolecule of Molecule file\n");
			exit(1);
		}
	}
	return TRUE;

}
/****************************************************************************************************************************/
static void swap2Double(double* a, double *b)
{
	double c = *a;
	*a = *b;
	*b = c;
}
/****************************************************************************************************************************/
static void swap2Int(int* a, int *b)
{
	int c = *a;
	*a = *b;
	*b = c;
}
/****************************************************************************************************************************/
static  int getDistancesFromCM(Molecule* mol, double** pdists, int** pindex, double Cm[], char* symbol)
{
	double* dists = NULL;
	int* index = NULL;
	double mt =0;
	int nAtoms = mol->nAtoms;
	Atom* atoms = mol->atoms;
	*pdists = dists;
	*pindex = index;
	if(mol->nAtoms<1) return 0;
	dists  = malloc(nAtoms*sizeof(double));
	index  = malloc(nAtoms*sizeof(int));
	int k=0;
	int i;
	for(i=0;i<nAtoms;i++) if(!strcmp(symbol,atoms[i].prop.symbol)) { dists[k] = 0;k++;}
	k=0;
	for(i=0;i<nAtoms;i++) if(!strcmp(symbol,atoms[i].prop.symbol)) { index[k] = i;k++;}
	int nA=k;

	for(k=0;k<3;k++) Cm[k]=0;
	for(i=0;i<nAtoms;i++) for(k=0;k<3;k++) Cm[k] += atoms[i].mass*atoms[i].coordinates[k];
	for(i=0;i<nAtoms;i++) mt += atoms[i].mass;
	if(mt>0) for(k=0;k<3;k++) Cm[k] /= mt;

	k=0;
	for(i=0;i<nAtoms;i++) 
	{
		if(strcmp(symbol,atoms[i].prop.symbol)) continue;
		dists[k] = 0;
		int c;
		for(c=0;c<3;c++) dists[k] += (atoms[i].coordinates[c]-Cm[c])*(atoms[i].coordinates[c]-Cm[c]);
		k++;
	}

	for(i=0;i<nA-1;i++) 
	{
		int k=i;
		int j;
		for(j=i+1;j<nA;j++) 
			if(dists[j]<dists[k]) k =j;
		if(k!=i) swap2Double(&dists[i],&dists[k]);
		if(k!=i) swap2Int(&index[i],&index[k]);
	}
	*pdists = dists;
	*pindex = index;
	return nA;
}
/****************************************************************************************************************************/
/*
 * Citation: The Journal of Chemical Physics 138, 214303 (2013);
 * https://doi.org/10.1063/1.4807091
 */
static  Molecule* makeSphereCutSpliceCrossover(Molecule* mol1, Molecule* mol2, int *err)
{
	double* dists1;
	double* dists2;
	int* index1;
	int* index2;
	double Cm1[3];
	double Cm2[3];
	int nTypes=0;

	if(mol1->nAtoms != mol2->nAtoms) return NULL;

	char** types = getTypesOfAtoms(mol1, &nTypes);
	int nTypes2=0;
	char** types2 = getTypesOfAtoms(mol2, &nTypes2);
	if(nTypes2 != nTypes)
	{
		freeTypesOfAtoms(types,nTypes);
		freeTypesOfAtoms(types2,nTypes2);
		return NULL;
	}
	freeTypesOfAtoms(types2,nTypes2);

	*err = -1;
	Molecule* child = mol1->klass->copy(mol1);
	child->potentialEnergy =1e14;
	int it;
	for(it=0;it<nTypes;it++)
	{
		int n1 = getDistancesFromCM(mol1, &dists1, &index1,Cm1,types[it]);
		if(!dists1) {child->klass->free(child); return NULL; }
		int n2 = getDistancesFromCM(mol2, &dists2, &index2,Cm2,types[it]);
		if(!dists2) {child->klass->free(child); return NULL;}
		if(n1!=n2) { child->klass->free(child); return NULL; }
		*err = 1;
		int i;
		for(i=0;i<n1-1;i++)
		{
			int k1=index1[i];
			int k2=index2[i];
			fprintf(stderr,"check %d  %d \n",k1,k2);
			fprintf(stderr,"symbol %s\n",mol1->atoms[k1].prop.symbol);
			fprintf(stderr,"dis1 %f %f dist2 %f %f\n", dists1[i],dists1[i+1],dists2[i],dists2[i+1]);
			if(dists1[i]<dists2[i+1] && dists2[i]<dists1[i+1])
			{
				//if(rand()/(double)(RAND_MAX)>0.5)
				{
					child->atoms[k1] = mol2->atoms[k2];
					int c;
					for(c=0;c<3;c++) child->atoms[k1].coordinates[c] += -Cm2[c]+Cm1[c];
					fprintf(stderr,"take atom %d from second parent place in %d \n",k2,k1);
					*err = 0;
				}
			}
		}
		if(dists1) free(dists1); dists1=NULL;
		if(dists2) free(dists2); dists2=NULL;
		if(index1) free(index1); index1=NULL;
		if(index2) free(index2); index2=NULL;
	}
	freeTypesOfAtoms(types,nTypes);

	/*
	fprintf(stderr,"-----------------------------------------------------------\n");
	fprintf(stderr,"Parent 1\n"); printMolecule(mol1, stderr);
	fprintf(stderr,"Parent 2\n"); printMolecule(mol2, stderr);
	fprintf(stderr,"Molecule after crossing\n"); printMolecule(child, stderr);
	fprintf(stderr,"-----------------------------------------------------------\n");
	fflush(stderr);
	*/
	return child;
}
/****************************************************************************************************************************/
static  void freeTypesOfAtoms(char** types, int nTypes)
{

	int i;
        for (i=0;i<nTypes;i++) if(types[i]) free(types[i]);
        if(types) free(types);
}
/****************************************************************************************************************************/
static  char** getTypesOfAtoms(Molecule* mol, int* pnTypes)
{
	char** types = malloc(mol->nAtoms*sizeof(char*));
	int i;
        for (i=0;i<mol->nAtoms;i++) types[i]=NULL;

	int nTypes = 1;
	types[0]=strdup(mol->atoms[0].prop.symbol);
        for (i=1;i<mol->nAtoms;i++)
	{
		boolean newType=TRUE; 
		int it;
        	for (it=0;it<nTypes;it++)
		if(!strcmp(mol->atoms[i].prop.symbol,types[it]))
		{
			newType=FALSE; 
			break;
		}
		if(newType)
		{
			types[nTypes]=strdup(mol->atoms[i].prop.symbol);
			nTypes++;
		}
	}
	types = realloc(types,nTypes*sizeof(char*));
	*pnTypes = nTypes;
	return types;
}
/****************************************************************************************************************************/
static  void getListProjection(Molecule* mol, double axis[], double** pprojections, int** pindex, double Cm[])
{
	double* projections = NULL;
	int* index = NULL;
	double mt =0;
	int nAtoms = mol->nAtoms;
	Atom* atoms = mol->atoms;
	*pprojections = projections;
	*pindex = index;
	if(mol->nAtoms<1) return;
	projections  = malloc(nAtoms*sizeof(double));
	index  = malloc(nAtoms*sizeof(int));
	int i,k;
	for(i=0;i<nAtoms;i++) projections[i] = 0;
	for(i=0;i<nAtoms;i++) index[i] = i;
	for(k=0;k<3;k++) Cm[k]=0;
	for(i=0;i<nAtoms;i++) for(k=0;k<3;k++) Cm[k] += atoms[i].coordinates[k];
	for(i=0;i<nAtoms;i++) mt += atoms[i].mass;
	if(mt>0) for(k=0;k<3;k++) Cm[k] /= mt;

	for(i=0;i<nAtoms;i++) 
		for(k=0;k<3;k++) 
			projections[i] += (atoms[i].coordinates[k]-Cm[k])*axis[k];

	for(i=0;i<nAtoms;i++) 
	{
		int k=i;
		int j;
		for(j=i+1;j<nAtoms;j++) 
			if(projections[j]>projections[k]) k =j;
		if(k!=i) swap2Double(&projections[i],&projections[k]);
		if(k!=i) swap2Int(&index[i],&index[k]);
	}
	*pprojections = projections;
	*pindex = index;
}
/****************************************************************************************************************************/
/*
 * Citation: The Journal of Chemical Physics 138, 214303 (2013);
 * https://doi.org/10.1063/1.4807091
 */
static  Molecule* makePlaneCutSpliceCrossoverWithoutTestBonds(Molecule* mol1, Molecule* mol2, int *err)
{
	double* projections1;
	double* projections2;
	int* index1;
	int* index2;
	double Cm1[3];
	double Cm2[3];
	int nAtoms = mol1->nAtoms;
	double axis[3];
	double rho = 1.0;
	double theta = rand()/(double)(RAND_MAX)*M_PI;
	double phi = 2.0*rand()/(double)(RAND_MAX)*M_PI;

	axis[0]=rho*cos(theta)*cos(phi);
	axis[1]=rho*cos(theta)*sin(phi);
	axis[2]=rho*sin(theta);

	//fprintf(stderr,"axis= %f %f %f\n",axis[0],axis[1],axis[2]); fflush(stderr);

	*err = -1;
	if(mol1->nAtoms != mol2->nAtoms) return NULL;
	getListProjection(mol1, axis, &projections1, &index1,  Cm1);
	if(!projections1) return NULL;
	getListProjection(mol2, axis, &projections2, &index2,  Cm2);
	if(!projections2) return NULL;

	int nTypes=0;
	char** types = getTypesOfAtoms(mol1, &nTypes);
	int nTypes2=0;
	char** types2 = getTypesOfAtoms(mol2, &nTypes2);
	if(nTypes2 != nTypes)
	{
		freeTypesOfAtoms(types,nTypes);
		freeTypesOfAtoms(types2,nTypes2);
		if(projections1) free(projections1);
		if(projections2) free(projections2);
		if(index1) free(index1);
		if(index2) free(index2);
		return NULL;
	}
	freeTypesOfAtoms(types2,nTypes2);

	Molecule* child = mol1->klass->copy(mol1);
	child->potentialEnergy =1e14;
	// TO REMOVE return child;


	int it;
	for(it=0;it<nTypes;it++)
	{
		int na1 = 0; 
		int i;
		for(i=0;i<nAtoms;i++) if(!strcmp(mol1->atoms[i].prop.symbol,types[it])) na1++;
		int na2 = 0; 
		for(i=0;i<nAtoms;i++) if(!strcmp(mol1->atoms[i].prop.symbol,types[it])) na2++;
		int n1 = na1/2+na1%2;
		int n2 = na2-n1;
		if(n2<0) n2=0;
		int it2=0;
		for(i=nAtoms-1;i>=0;i--) 
		{
			int k2=index2[i];
			if(!strcmp(mol2->atoms[k2].prop.symbol,types[it])) 
			{
				int it1=0;
				it2++;
				int j;
				for(j=nAtoms-1;j>=0;j--) 
				{
					int k1=index1[j];
					if(!strcmp(mol1->atoms[k1].prop.symbol,types[it])) 
					{
						it1++;
						if(it1==it2)
						{
							int *con = child->atoms[k1].typeConnections;
							child->atoms[k1]=getCopyAtom(&mol2->atoms[k2]);
							child->atoms[k1].typeConnections=con;
							int c;
							for(c=0;c<3;c++) child->atoms[k1].coordinates[c] += Cm1[c]-Cm2[c];
							break;
						}
					}
				}
				if(it2==n2) break;
			}
		}
	}
	freeTypesOfAtoms(types,nTypes);
	if(projections1) free(projections1);
	if(projections2) free(projections2);
	if(index1) free(index1);
	if(index2) free(index2);

	/*
	fprintf(stderr,"-----------------------------------------------------------\n");
	fprintf(stderr,"Parent 1\n"); printMolecule(mol1, stderr);
	fprintf(stderr,"Parent 2\n"); printMolecule(mol2, stderr);
	fprintf(stderr,"Molecule after crossing\n"); printMolecule(child, stderr);
	fprintf(stderr,"-----------------------------------------------------------\n");
	fflush(stderr);
	*/
	return child;
}
static  Molecule* makePlaneCutSpliceCrossover(Molecule* mol1, Molecule* mol2, int *err)
{
	int itmax = 1000; 
	Molecule* child = NULL;
	boolean accepted=FALSE;
	int it;
	for(it=0;it<itmax && !accepted ;it++)
	{
		//fprintf(stderr,"it=%d\n",it); fflush(stderr);
		if(child) child->klass->free(child);
		child = makePlaneCutSpliceCrossoverWithoutTestBonds(mol1,mol2, err);
		if(!child) continue;
		if(!child->klass->smallDistance(child)) { accepted = TRUE; break;}
	}
	return child;
}
/********************************************************************************/
static boolean makeCenterOfMassSphericalMutation(Molecule* molecule)
{
	int itmax = 1000; 
	int it = 0;
	Atom* atoms = molecule->atoms;
	double C[3];
	double Cm[3];
	int k;

	if(molecule->nAtoms<=1) return FALSE;
	for (k=0;k<3;k++) Cm[k] = 0;
	double mt = 0;
	int i;
	for (i = 0; i<molecule->nAtoms;i++) 
	{
		int k;
		for (k=0;k<3;k++) 
			Cm[k] += atoms[i].mass*atoms[i].coordinates[k];
		mt += atoms[i].mass; 
	}
	if(mt>0) for (k=0;k<3;k++) Cm[k] /= mt;

	boolean accepted=FALSE;
	do{
		int ir = rand()%molecule->nAtoms;
		double rho = 0;
		int k;
		for (k=0;k<3;k++) 
		{ 
			double dij = atoms[ir].coordinates[k]-Cm[k];
			rho +=dij*dij;
		}
		rho = sqrt(rho);
		double theta = rand()/(double)(RAND_MAX)*M_PI;
		double phi = rand()/(double)(RAND_MAX)*2.0*M_PI;
		C[0] = rho*cos(phi)*cos(theta);
		C[1] = rho*sin(phi)*cos(theta);
		C[2] = rho*sin(theta);

		int imin=-1;
		double dmin=-1;
		int i;
		for (i = 0; i<molecule->nAtoms;i++)
		{
			if(i==ir) continue;
			double distance = 0;
			int k;
			for (k=0;k<3;k++) 
			{ 
				double dij = atoms[i].coordinates[k]-C[k]; 
				distance +=dij*dij;
			}
			if(dmin<0) { dmin = distance; imin=i;}
			if(distance<dmin) { dmin = distance; imin=i;}
		}
		if(imin>-1) 
		{
			double bd = atoms[ir].prop.covalentRadii + atoms[imin].prop.covalentRadii;
			bd *= BOHRTOANG;
			bd *=0.6;
			if(sqrt(dmin)>bd) accepted=TRUE;
		}
		if(accepted) for (k=0;k<3;k++) atoms[ir].coordinates[k] = C[k];
		it++;
	}while(!accepted && it<itmax);
	//fprintf(stderr,"accepte = %d, it/itmax =%d/%d\n",accepted,it,itmax); fflush(stderr);
	//setConnections(molecule);
	return accepted;

}
/********************************************************************************/
static boolean setRandomOrientation(Molecule* molecule)
{
	double axis1[3];
	double axis2[3]; 
	double axis3[3];

	if(molecule->nAtoms<1) return FALSE;

	double rho = 1.0;
	double theta = rand()/(double)(RAND_MAX)*M_PI;
	double phi = 2.0*rand()/(double)(RAND_MAX)*M_PI;

	axis1[0]=rho*cos(theta)*cos(phi);
	axis1[1]=rho*cos(theta)*sin(phi);
	axis1[2]=rho*sin(theta);

	theta = rand()/(double)(RAND_MAX)*M_PI;
	phi = 2.0*rand()/(double)(RAND_MAX)*M_PI;

	axis2[0]=rho*cos(theta)*cos(phi);
	axis2[1]=rho*cos(theta)*sin(phi);
	axis2[2]=rho*sin(theta);

	int is=0;
	int k;
	for(k=0;k<3;k++) if(axis1[k]!=0) is=k;

	double ps=0;
	for(k=0;k<3;k++) if(k!=is) ps += axis1[k]*axis2[k];
	axis2[is]=-ps/axis1[is];

	for(k=0;k<3;k++) axis3[k] = axis1[(k+1)%3]*axis2[(k+2)%3]-axis1[(k+2)%3]*axis2[(k+1)%3];
	return setGeometryToAxes(molecule,axis1, axis2, axis3);
}
/********************************************************************************/
static boolean setGeometryToAxes(Molecule* molecule, double axis1[], double axis2[], double axis3[])
{
	Atom* atoms = molecule->atoms;
	int nAtoms = molecule->nAtoms;
	double tensor[3][3];
	double invTensor[3][3];
	double** C;
	int i,j,k;
	boolean ok = FALSE;

	if(nAtoms<1) return ok;

	C = malloc(nAtoms*sizeof(double*));
	for(i=0;i<nAtoms;i++) C[i] = malloc(3*sizeof(double));

	tensor[0][0] = axis1[0];
	tensor[0][1] = axis1[1];
	tensor[0][2] = axis1[2];

	tensor[1][0] = axis2[0];
	tensor[1][1] = axis2[1];
	tensor[1][2] = axis2[2];

	tensor[2][0] = axis3[0];
	tensor[2][1] = axis3[1];
	tensor[2][2] = axis3[2];

	if(InverseTensor(tensor,invTensor))
	{
		double Cm[3];
		double mt = 0;
		for(k=0;k<3;k++) Cm[k]=0;
		for(i = 0;i<nAtoms;i++) for(k=0;k<3;k++) Cm[k] += atoms[i].mass*atoms[i].coordinates[k];
		for(i = 0;i<nAtoms;i++) mt += atoms[i].mass;
		if(mt>0) for(k=0;k<3;k++) Cm[k] /= mt;

		for(i = 0;i<nAtoms;i++)
		{
			for(j=0;j<3;j++)
			{
				C[i][j] = 0.0;
				for(k=0;k<3;k++) C[i][j] += invTensor[k][j]*(atoms[i].coordinates[k]-Cm[k]);
			}
		}
		for(i = 0;i<nAtoms;i++) for(k=0;k<3;k++) atoms[i].coordinates[k]=C[i][k]+Cm[k];
		ok = TRUE;
	}
	for(i=0;i<nAtoms;i++) if(C[i]) free(C[i]);
	if(C) free(C);
	return ok;
}
/********************************************************************************/
static boolean makeLocalSphericalMutation(Molecule* molecule, double rate)
{
	int itmax = 1000; 
	int it = 0;
	Atom* atoms = molecule->atoms;
	double C[3];

	if(molecule->nAtoms<=1) return FALSE;
	boolean accepted=FALSE;
	do{
		int ir = rand()%molecule->nAtoms;
		double dmin=-1;
		int i;
		for (i = 0; i<molecule->nAtoms;i++)
		{
			if(i==ir) continue;
			double distance = 0;
			int k;
			for (k=0;k<3;k++) 
			{ 
				double dij = atoms[i].coordinates[k]-atoms[ir].coordinates[k]; 
				distance +=dij*dij;
			}
			if(dmin<0) dmin = distance;
			if(distance<dmin) dmin = distance;
		}
		double rho = (-1+2*rand()/(double)(RAND_MAX))*rate*sqrt(dmin);
		double theta = rand()/(double)(RAND_MAX)*M_PI;
		double phi = rand()/(double)(RAND_MAX)*2.0*M_PI;
		C[0] = rho*cos(phi)*cos(theta);
		C[1] = rho*sin(phi)*cos(theta);
		C[2] = rho*sin(theta);

		int imin=-1;
		dmin=-1;
		for (i = 0; i<molecule->nAtoms;i++)
		{
			if(i==ir) continue;
			double distance = 0;
			int k;
			for (k=0;k<3;k++) 
			{ 
				double dij = atoms[i].coordinates[k]-C[k]; 
				distance +=dij*dij;
			}
			if(dmin<0) { dmin = distance; imin=i;}
			if(distance<dmin) { dmin = distance; imin=i;}
		}
		if(imin>-1) 
		{
			double bd = atoms[ir].prop.covalentRadii + atoms[imin].prop.covalentRadii;
			bd *= BOHRTOANG;
			bd *=0.6;
			if(sqrt(dmin)>bd) accepted=TRUE;
		}
		int k;
		if(accepted) for (k=0;k<3;k++) atoms[ir].coordinates[k] = C[k];
		it++;
	}while(!accepted && it<itmax);
	//setConnections(molecule);
	return accepted;

}
/********************************************************************************/
static boolean readGeometry(Molecule* molecule, char* namefile)
{
	FILE* file = NULL;
	static char *t = NULL; 
	boolean Ok = FALSE;
	int n,ic,is;
	Molecule* mol = newMolecule();
#define SZ 50
	char symbol[SZ];
	char mmType[SZ];
	char pdbType[SZ];
	char residueName[SZ];
	double X,Y,Z;
	double charge;
	int layer;
	int i,l;
	char* pos;

	if(!namefile) 
	{
		printf("Sorry I cannot read geometry namefile = NULL\n");
		exit(1);
	}
	if(t==NULL) t = malloc(BSIZE*sizeof(char));
	file = fopen(namefile,"rb");
	if(!file)
	{
		printf("Sorry I cannot open %s file\n",namefile);
		exit(1);
	}
	rewind(file);
	while(!feof(file))
  	{
    		if(!fgets(t,BSIZE, file)) break;
		deleteFirstSpaces(t);
		if(t[0]=='#') continue;
		uppercase(t);
		pos = strstr(t,"GEOMETRY");
		if(pos)
		{ 
			while(!feof(file))
			{
    				if(!fgets(t,BSIZE, file)) break;
				deleteFirstSpaces(t);
				if(t[0]=='#') continue;
				break;
			}
			if(3==sscanf(t,"%d%d%d",&n,&ic,&is) && n>0 && is>0)
			{
				/*
				printf("Mult = %d\n",is);
				printf("nAtoms = %d\n",n);
				*/
				mol->nAtoms = n;
				mol->spinMultiplicity = is;
				mol->totalCharge = ic;
				mol->atoms = malloc(mol->nAtoms*sizeof(Atom));
				for(i=0; i<mol->nAtoms; i++) mol->atoms[i].typeConnections = malloc(mol->nAtoms*sizeof(int));
				Ok = TRUE;
			}
			break;
		}
	}
	if(!Ok)
	{
		printf("Sorry I cannot read geometry from %s file\n",namefile);
	 	return FALSE;
	//	exit(1);
	}
	for(i=0; i<mol->nAtoms; i++)
	{
			int variable = 0;
			int ibeg = 12;
			if(!fgets(t,BSIZE,file))
			{
				printf("Sorry I cannot read geometry from %s file.\n",namefile);
				return FALSE;
				//exit(1);
			}
			deleteFirstSpaces(t);
			if(t[0]=='#') { i--;continue;}
    			sscanf(t,"%s %s %s %s %d %lf %d %d %lf %lf %lf",
					symbol,mmType,pdbType,residueName, 
					&mol->atoms[i].residueNumber,
					&charge,&layer,&variable,&X,&Y,&Z);
			symbol[0]=toupper(symbol[0]);
			l=strlen(symbol);
			if (l==2) symbol[1]=tolower(symbol[1]);

			mol->atoms[i].prop = propAtomGet(symbol);
			mol->atoms[i].mmType=strdup(mmType);
			mol->atoms[i].pdbType=strdup(pdbType);
			mol->atoms[i].residueName=strdup(residueName);
			mol->atoms[i].N=i+1;
			mol->atoms[i].layer=layer;
			mol->atoms[i].variable=variable;
			mol->atoms[i].show=TRUE;
			mol->atoms[i].coordinates[0] = X;
			mol->atoms[i].coordinates[1] = Y;
			mol->atoms[i].coordinates[2] = Z;
			mol->atoms[i].velocity[0] = 0;
			mol->atoms[i].velocity[1] = 0;
			mol->atoms[i].velocity[2] = 0;
			mol->atoms[i].charge = charge;
			mol->atoms[i].charge0 = charge;
			mol->atoms[i].electronegativity = 0;
			mol->atoms[i].hardness = 0;
			mol->atoms[i].width = mol->atoms[i].prop.covalentRadii;
			mol->atoms[i].mass = mol->atoms[i].prop.mass;
			mol->atoms[i].rho = 0.0;
	   		mol->atoms[i].U = 0.0;
			if(!get_connections_one_atom(t, mol->nAtoms, ibeg, mol->atoms[i].typeConnections))
			{
				/*
				printf("Sorry I cannot read the connection for atom # %d from the %s file.\n",i+1,namefile);
				exit(1);
				*/
				fprintf(stderr,"Warning : I cannot read the connection for atom # %d from the %s file.\n",i+1,namefile);
			}
	}
	readBoxes(mol, file, t);
	readWall(mol, file, t);
	
	fclose(file);
	mol->potentialEnergy = molecule->potentialEnergy;
	*molecule = *mol;
	return TRUE;
}
/*******************************************************************************************************************/
static void setBondHardness(Molecule* molecule, int nBonds, char** atomTypes1, char** atomTypes2, double* hardness)
{
	int i;
	int j;
	int k;
	int n;
	double* bondHardness = NULL;
	int numberOfAtoms = molecule->nAtoms;
	Atom* atoms = molecule->atoms;
	
	if(molecule->bondHardness) free(molecule->bondHardness);

	if(numberOfAtoms<2) return;
	bondHardness = malloc(numberOfAtoms*(numberOfAtoms+1)/2*sizeof(double));

	k=0;
	//printf("begin setBondHardness\n");
	for (  i = 0; i < numberOfAtoms; i++ )
		for (  j = i + 1; j < numberOfAtoms; j++ )
		{
			bondHardness[k] = 0;
			for(n=0;n<nBonds;n++)
			{
				if(
				(!strcmp(atomTypes1[n],atoms[i].mmType) && !strcmp(atomTypes2[n],atoms[j].mmType))
				||
				(!strcmp(atomTypes1[n],atoms[j].mmType) && !strcmp(atomTypes2[n],atoms[i].mmType))
				)
				{
					bondHardness[k] = hardness[n]/AUTOEV;
				}
			}
			k++;
		}
	molecule->bondHardness = bondHardness;
	//printf("end setBondHardness\n");
	/* printing for test*/
}
/*******************************************************************************************************************/
static void setHardness(Molecule* molecule, int nTypes, char** atomTypes, double* hardness)
{
	int i;
	int n;
	int numberOfAtoms = molecule->nAtoms;
	Atom* atoms = molecule->atoms;
	
	for (  i = 0; i < numberOfAtoms; i++ )
	{
		atoms[i].hardness = 0;
		for(n=0;n<nTypes;n++)
		{
			if(!strcmp(atomTypes[n],atoms[i].mmType)) atoms[i].hardness = hardness[n]/AUTOEV;//convert in Hartree
			//printf("atomTypes = %s mmType = %s\n",atomTypes[n],atoms[i].mmType);
		}
	}
	/* printing for test*/
}
/*******************************************************************************************************************/
static void setElectronegativity(Molecule* molecule, int nTypes, char** atomTypes, double* electronegativity)
{
	int i;
	int n;
	int numberOfAtoms = molecule->nAtoms;
	Atom* atoms = molecule->atoms;
	
	for(i = 0; i < numberOfAtoms; i++)
	{
		atoms[i].electronegativity = 0;
		for(n=0;n<nTypes;n++)
			if(!strcmp(atomTypes[n],atoms[i].mmType))
				atoms[i].electronegativity = electronegativity[n]/AUTOEV; // convert in Hartree
	}
	/* printing for test*/

}
/*******************************************************************************************************************/
static void setWidth(Molecule* molecule, int nTypes, char** atomTypes, double* width)
{
	int i;
	int n;
	int numberOfAtoms = molecule->nAtoms;
	Atom* atoms = molecule->atoms;
	
	for(i = 0; i < numberOfAtoms; i++)
	{
		atoms[i].width = 0;
		for(n=0;n<nTypes;n++)
			if(!strcmp(atomTypes[n],atoms[i].mmType))
				atoms[i].width = width[n];
	}
	/* printing for test*/
}
/*******************************************************************************************************************/
static void setCharge0(Molecule* molecule, int nTypes, char** atomTypes, double* charge0)
{
	int i;
	int n;
	int numberOfAtoms = molecule->nAtoms;
	Atom* atoms = molecule->atoms;
	
	for (  i = 0; i < numberOfAtoms; i++ )
	{
		atoms[i].charge0 = 0;
		for(n=0;n<nTypes;n++)
		{
			if(!strcmp(atomTypes[n],atoms[i].mmType)) atoms[i].charge0 = charge0[n];
			//printf("atomTypes = %s mmType = %s\n",atomTypes[n],atoms[i].mmType);
		}
	}
	/* printing for test*/
}
/*******************************************************************************************************************/
static void setup_EEM(Molecule* molecule, double** A, double* B)
{
	int i;
	int j;
	int numberOfAtoms = molecule->nAtoms;
	double rijx, rijy, rijz;
	double rij;
	double r0;
	
	for (  i = 0; i < numberOfAtoms; i++ )
	{
		A[i][i] = molecule->atoms[i].hardness;
		B[i] =-molecule->atoms[i].electronegativity;
		for (  j = i + 1; j < numberOfAtoms; j++ )
		{
			rijx = molecule->atoms[i].coordinates[0] - molecule->atoms[j].coordinates[0];
			rijy = molecule->atoms[i].coordinates[1] - molecule->atoms[j].coordinates[1];
			rijz = molecule->atoms[i].coordinates[2] - molecule->atoms[j].coordinates[2];
			rij = sqrt( rijx * rijx + rijy * rijy + rijz * rijz );
		
			A[i][j] = A[j][i] = 0;
			r0 = sqrt(
				 2*molecule->atoms[i].width*molecule->atoms[i].width
				+2*molecule->atoms[j].width*molecule->atoms[j].width
				);
			//printf("r0=%f\n",r0);
			if(fabs(rij)>1e-10 && r0>1e-10) A[i][j] = A[j][i] = erf(rij/r0)/(rij*ANGTOBOHR);// in Hartree
			else if(fabs(rij)>1e-10) A[i][j] = A[j][i] = 1/(rij*ANGTOBOHR);// in Hartree
		}
	}
	//  Fill in the constraints
	for (  i = 0; i < numberOfAtoms; i++ )
	{
		j = numberOfAtoms;
		A[i][j] = A[j][i] = 1;
	}
	i = j = numberOfAtoms;
	A[i][j] = 0;

	for (  i = 0; i < numberOfAtoms; i++ )
		B[i] += molecule->atoms[i].hardness*molecule->atoms[i].charge0;
	i = numberOfAtoms;
	B[i] = molecule->totalCharge;
}
/***********************************************************************************************/
static double getEnergyEEM(Molecule* molecule)
{
	int ia,ja;
	int numberOfAtoms = molecule->nAtoms;
	double energy = 0;

	for (  ia = 0; ia < numberOfAtoms; ia++ )
	{
		double Delta = molecule->atoms[ia].charge0 - molecule->atoms[ia].charge;
		double mu    = -molecule->atoms[ia].electronegativity;
		energy += mu*Delta;
	}
	for (  ia = 0; ia < numberOfAtoms; ia++ )
	{
		double Deltai =  molecule->atoms[ia].charge0 - molecule->atoms[ia].charge;
		double eta   = molecule->atoms[ia].hardness;
		energy += 0.5*Deltai*Deltai*eta;
		for (  ja = ia + 1; ja < numberOfAtoms; ja++ ) // ja>ia, for 0.5
		{
			double rijx, rijy, rijz, rij;
			double r0;
			double etaij;
			double Deltaj =  molecule->atoms[ja].charge0 - molecule->atoms[ja].charge;
			
			rijx = molecule->atoms[ia].coordinates[0] - molecule->atoms[ja].coordinates[0];
			rijy = molecule->atoms[ia].coordinates[1] - molecule->atoms[ja].coordinates[1];
			rijz = molecule->atoms[ia].coordinates[2] - molecule->atoms[ja].coordinates[2];
			rij = sqrt( rijx * rijx + rijy * rijy + rijz * rijz );
		
			r0 = sqrt(2*molecule->atoms[ia].width*molecule->atoms[ia].width+2*molecule->atoms[ja].width*molecule->atoms[ja].width);

			//printf("r0=%f\n",r0);
			etaij = 0;
			if(fabs(rij)>1e-10 && r0>1e-10) etaij = erf(rij/r0)/(rij*ANGTOBOHR);// in Hartree
			else if(fabs(rij)>1e-10) etaij = 1/(rij*ANGTOBOHR);// in Hartree

			etaij *=  Deltai*Deltaj;
			energy += etaij;
		}
	}
	return energy*AUTOKCAL;
}
/***********************************************************************************************/
static double getEnergyACKS2(Molecule* molecule)
{
	int ia,ja;
	int numberOfAtoms = molecule->nAtoms;
	double energy = 0;

	energy = getEnergyEEM(molecule)/AUTOKCAL;

	for (  ia = 0; ia < numberOfAtoms; ia++ ) 
	{
		double Delta = molecule->atoms[ia].charge0 - molecule->atoms[ia].charge;
		double U = molecule->atoms[ia].U;
		energy += -U*Delta;
	}
	if(molecule->bondHardness)
	{
		int k =0;
		double** A = malloc(numberOfAtoms*sizeof(double*));
		for(ia=0;ia<numberOfAtoms;ia++) A[ia] = malloc(numberOfAtoms*sizeof(double));
		for(ia=0;ia<numberOfAtoms;ia++) for(ja=0;ja<numberOfAtoms;ja++)  A[ia][ja] = 0; 

		k = 0;
		for(ia=0;ia<numberOfAtoms;ia++) 
		for(ja=ia+1;ja<numberOfAtoms;ja++) 
		{
			//printf("ia = %d ja = %d k = %d kappa = %f\n",ia, ja, k, molecule->bondHardness[k]);
			if(fabs(molecule->bondHardness[k]) >1e-10)
			{
				double bsoft = 1/molecule->bondHardness[k];
				A[ia][ja] += bsoft;
				A[ja][ia] += bsoft;
				A[ia][ia] -= bsoft;
				A[ja][ja] -= bsoft;
			}
			k++;
		}
		for (  ia = 0; ia < numberOfAtoms; ia++ )
		{
			double Ui =  molecule->atoms[ia].U;
			for (  ja = 0; ja < numberOfAtoms; ja++ ) // ja>ia, for 0.5
			{
				double Xij = A[ia][ja];
				double Uj =  molecule->atoms[ja].U;
				energy += 0.5*Ui*Uj*Xij;
			}
		}
		for(ia=0;ia<numberOfAtoms;ia++) free(A[ia]);
		free(A);
	}
	return energy*AUTOKCAL;
}
/***********************************************************************************************/
static void setChargesEEM(Molecule* molecule)
{
	double* B;
	double** A;
	double* values;
	int ia;
	int i,j;
	int numberOfAtoms = molecule->nAtoms;
	int n = molecule->nAtoms+1;
	B = malloc(n*sizeof(double));
	A = malloc(n*sizeof(double*));
	for(i=0;i<n;i++) A[i] = malloc(n*sizeof(double));

	for(i=0;i<n;i++) for(j=0;j<n;j++)  A[i][j] = 0; 
	for(i=0;i<n;i++) B[i] = 0;
	setup_EEM(molecule, A, B);

	/* test solveSymEqQL */
	/*
	for(i=0;i<n;i++) B[i] = 1;
	for(i=0;i<n;i++) for(j=0;j<n;j++) A[i][j] = 1.0;
	A[1][1] = -1.0;
	B[1] = 2;
	*/
	
	// to check
	/*
	printf("EEM Matrix = \n");
	printMatrixDouble(A, n, n);
	*/

	values =  malloc(n*sizeof(double));

	// TO CHANGE
	// test solveSymEqQL n = 2;
        solveSymEqQL(n, A, B, values);
	//for(i=0;i<n;i++) printf("Val %d = %f\n",i,values[i]);
	//double S = 0; for(i=0;i<n-1;i++) S+= values[i]; printf("Sum charges=%f\n",S);

	for (  ia = 0; ia < numberOfAtoms; ia++ ) molecule->atoms[ia].charge = values[ia];
	for (  ia = 0; ia < numberOfAtoms; ia++ ) molecule->atoms[ia].U = 0.0;
	free(values);
	free(B);
	for(i=0;i<n;i++) free(A[i]);
	free(A);
}
/***********************************************************************************************/
static void setChargesACKS2(Molecule* molecule)
{
	double* B;
	double** A;
	double* values;
	int i,j,k;
	int ia,ja;
	int numberOfAtoms = molecule->nAtoms;
	int n = 2*(molecule->nAtoms+1);
	B = malloc(n*sizeof(double));
	A = malloc(n*sizeof(double*));
	for(i=0;i<n;i++) A[i] = malloc(n*sizeof(double));
	for(i=0;i<n;i++) B[i] = 0;
	for(i=0;i<n;i++) for(j=0;j<n;j++)  A[i][j] = 0; 

	setup_EEM(molecule, A, B);
	//  Fill in the constraints
	for(ia=0;ia<numberOfAtoms;ia++) B[ia+numberOfAtoms+1] = molecule->atoms[ia].charge0; 
	for(ia=0;ia<numberOfAtoms;ia++) A[2*numberOfAtoms+1][ia+numberOfAtoms+1] = 1;
	for(ia=0;ia<numberOfAtoms;ia++) A[ia+numberOfAtoms+1][2*numberOfAtoms+1] = 1;

	// Fill in off diagonal identity matrix bloks
	for(ia=0;ia<numberOfAtoms;ia++) A[ia][ia+numberOfAtoms+1] = 1; 
	for(ia=0;ia<numberOfAtoms;ia++) A[ia+numberOfAtoms+1][ia] = 1; 
	// Add the bond hardness terms as off-diagonal bond-softness parameters
	//printf("Begin bond hardness\n");
	k = 0;
	if(molecule->bondHardness)
	for(ia=0;ia<numberOfAtoms;ia++) 
	for(ja=ia+1;ja<numberOfAtoms;ja++) 
	{
		//printf("ia = %d ja = %d k = %d kappa = %f\n",ia, ja, k, molecule->bondHardness[k]);
		if(fabs(molecule->bondHardness[k]) >1e-10)
		{
			i = numberOfAtoms+1+ia;
			j = numberOfAtoms+1+ja;
			double bsoft = 1/molecule->bondHardness[k];
			A[i][j] += bsoft;
			A[j][i] += bsoft;
			A[i][i] -= bsoft;
			A[j][j] -= bsoft;
		}
		k++;
	}
	// to check
	/*
	printf("ACKS2 = \n");
	printMatrixDouble(A, n, n);
	*/

	values =  malloc(n*sizeof(double));
        solveSymEqQL(n, A, B, values);
	for (  ia = 0; ia < numberOfAtoms; ia++ ) molecule->atoms[ia].charge = values[ia];
	for (  ia = 0; ia < numberOfAtoms; ia++ ) molecule->atoms[ia].U = values[numberOfAtoms+1+ia];
	free(values);
	free(B);
	for(i=0;i<n;i++) free(A[i]);
	free(A);
}
/********************************************************************************/
static boolean saveGeometry(Molecule* molecule, char* fileName)
{
 	FILE* file = fopen(fileName, "w");
	boolean ok=TRUE;
	if(!file) return FALSE;
	ok = addGeometry(molecule,file);
	fclose(file);
	return ok;
}
/********************************************************************************/
static boolean saveGeometryAndVelocities(Molecule* molecule, char* fileName)
{
 	FILE* file = fopen(fileName, "w");
	boolean ok=TRUE;
	if(!file) return FALSE;
	ok = addGeometry(molecule,file);
	if(ok)
	{
		ok = addVelocities(molecule,file);
	}
	fclose(file);
	return ok;
}
/*****************************************************************************/
static void copyGradients(Molecule* mol, double* g[])
{
        int i,k;
        if(!mol) return;
        for(i=0;i<mol->nAtoms;i++)
                for(k=0;k<3;k++)
                        g[k][i] = mol->atoms[i].gradient[k];
}
/*****************************************************************************/
static void removeTransRotModes(Molecule* mol)
{
	int i;
	int k;
	int nToRemove;
	if(!mol ||  mol->vibration.nModes<1) return;
	nToRemove = 6;
	if(isLinear(mol)) nToRemove = 5;
	if(mol->vibration.nModes != 3*mol->nAtoms) return;

	sortFrequencies(mol);
	for(i=0;i< mol->vibration.nModes-nToRemove;i++)
	{
		k = i+nToRemove;
		mol->vibration.modes[i] =  mol->vibration.modes[k];
	}
	mol->vibration.nModes -= nToRemove;
	mol->vibration.modes =  realloc(mol->vibration.modes,mol->vibration.nModes*sizeof(VibMode));
}
/*****************************************************************************/
static void sortFrequencies(Molecule* mol)
{
	int i;
	int j;
	int k;
	VibMode dum;
	if(!mol ||  mol->vibration.nModes<1) return;
	for(i=0;i< mol->vibration.nModes;i++)
	{
		k = i;
		for(j=i+1;j< mol->vibration.nModes;j++)
			if( mol->vibration.modes[j].frequency< mol->vibration.modes[k].frequency) k = j;
		if(k==i) continue;
		/* swap i and k modes */
		dum =  mol->vibration.modes[i];
		mol->vibration.modes[i] =  mol->vibration.modes[k];
		mol->vibration.modes[k] =  dum;
	}
}
/*****************************************************************************/
static void removeFrequencies(Molecule* mol, double freqMin, double freqMax)
{
	int i;
	int j;
	int k;
	int iMin = 0;
	int iMax= 0;
	int nM = 0;
	if(!mol ||  mol->vibration.nModes<1) return;
	if(freqMin<0 && freqMax<0) return;
	if(freqMin>0 && freqMax>0 && freqMin>freqMax) 
	{
		double f = freqMin;
		freqMin = freqMax;
		freqMax = f;
	}
	sortFrequencies(mol);
	iMin = 0;
	if(freqMin>0)
	for(i=0;i< mol->vibration.nModes;i++)
		if( mol->vibration.modes[i].frequency < freqMin) iMin = i+1;
	iMax = mol->vibration.nModes-1;
	if(freqMax>0)
	for(i=mol->vibration.nModes-1;i>0;i--) 
		if( mol->vibration.modes[i].frequency > freqMax) iMax = i-1;

	//fprintf(stderr,"iMin = %d\n",iMin);
	//fprintf(stderr,"iMax = %d\n",iMax);
	for(i=0;i< iMin;i++)
        {
                mol->vibration.modes[i].frequency = 0;
                mol->vibration.modes[i].mass = 1;
                for(j=0;j<3;j++) if(mol->vibration.modes[i].vectors[j]) free(mol->vibration.modes[i].vectors[j]);
                if(mol->vibration.modes[i].properties) free(mol->vibration.modes[i].properties);
        }
	for(i=iMax+1;i<mol->vibration.nModes;i++)
        {
                mol->vibration.modes[i].frequency = 0;
                mol->vibration.modes[i].mass = 1;
                for(j=0;j<3;j++) if(mol->vibration.modes[i].vectors[j]) free(mol->vibration.modes[i].vectors[j]);
                if(mol->vibration.modes[i].properties) free(mol->vibration.modes[i].properties);
        }
	nM = iMax-iMin+1;
	k = 0;
	for(i=iMin;i<=iMax;i++)
	{
		mol->vibration.modes[k] =  mol->vibration.modes[i];
		k++;
	}

	mol->vibration.nModes = nM;
	if(nM>0) mol->vibration.modes = realloc(mol->vibration.modes, mol->vibration.nModes*sizeof(VibMode));
	else if(mol->vibration.modes) free(mol->vibration.modes);
}
/*****************************************************************************/
static void removeNotSelectedFrequencies(Molecule* mol, boolean* selected)
{
	int i;
	int j;
	int n = 0;
	if(!mol ||  mol->vibration.nModes<1) return;
	for(i=0;i< mol->vibration.nModes;i++) if(selected[i]) n++;

	if(n==0 || n == mol->vibration.nModes) return;
	for(i=0;i<mol->vibration.nModes;i++)
        {
		if(selected[i]) continue;

                for(j=0;j<3;j++) if(mol->vibration.modes[i].vectors[j]) free(mol->vibration.modes[i].vectors[j]);
                if(mol->vibration.modes[i].properties) free(mol->vibration.modes[i].properties);

		for(j=i+1;j<mol->vibration.nModes;j++)
			if(selected[j]){ 
				int k;
				selected[j] = FALSE;
				selected[i] = TRUE;
				mol->vibration.modes[i] =  mol->vibration.modes[j];
                		for(k=0;k<3;k++) mol->vibration.modes[j].vectors[k] = NULL;
				mol->vibration.modes[j].properties = NULL;
				break;
			}
        }
	mol->vibration.nModes = n;
	if(n>0) mol->vibration.modes = realloc(mol->vibration.modes, mol->vibration.nModes*sizeof(VibMode));
	else if(mol->vibration.modes) free(mol->vibration.modes);
}
/****************************************************************************************************************************************************/
static int computeIR(Molecule* mol, double *F, double* dmuX[3])
{
	int nAtoms = mol->nAtoms;
	int i;
	int j;
	int k;
	int c;
	double* frequencies = NULL;
	double** modes = NULL;


	freeVibrations(mol);
	initVibrations(mol, 3*nAtoms, 1);
	frequencies = malloc(3*nAtoms*sizeof(double));
	modes = malloc(3*nAtoms*sizeof(double*));
	for(i=0;i<3*nAtoms;i++) modes[i] = malloc(3*nAtoms*sizeof(double));

	//printf("begin diag\n");
	eigenQL(3*nAtoms, F, frequencies, modes);

	//printf("end eigneQL\n");
	for(i=0;i<mol->vibration.nModes;i++) mol->vibration.modes[i].properties[0] = 0.0;
	
	/* convert in atomic unit  from kcal/Ang^2/amu */
	for(i=0;i<3*nAtoms;i++) frequencies[i] *= 1.59360150e-03*0.529177*0.529177*5.48579911e-04; 
	/* convert frequencies in cm-1 */
	for(i=0;i<3*nAtoms;i++) 
		if(frequencies[i]>0) frequencies[i] = sqrt(frequencies[i])*219474.63633664;
		else frequencies[i] = -sqrt(-frequencies[i])*219474.63633664;

	/* compute the IR intensities */
	for(i=0;i<nAtoms;i++)
	for(k=0;k<3;k++)
	{
		int id=3*i+k;
		double IRI = 0;
		double D[3] = {0,0,0};
		int kp;
		for(c = 0;c<3;c++)
		for(j=0;j<nAtoms;j++)
		for(kp = 0;kp<3;kp++) 
		{
			int jd = 3*j+kp;
			double Lji = modes[jd][id];
			double a=dmuX[c][jd]*Lji/sqrt(mol->atoms[j].mass);
			D[c]+=a;
		}
		IRI = 0;
		for(c = 0;c<3;c++)  IRI+= D[c]*D[c];
		mol->vibration.modes[id].properties[0] = IRI;
	}
	/* Intensities in 1 (D/Ang)^2 amu^-1 = 42.255 km/mol=171.65 cm^-2 atm^-1 at 0 C and 1 atm */
	/* Refs : D. Porezag and M. R. Pederson, Phys. Rev. B 54, 7830 (1996). and Y. Yamaguchi el al., J. Chem. Phys. 84,2262(1986)*/
	/* conversion in km/mol*/
	for(i=0;i<mol->vibration.nModes;i++) mol->vibration.modes[i].properties[0] *= 42.255;

	/* compute the reduced mass */
	for(i=0;i<3*nAtoms;i++) 
	{
		double m = 0;
		for(j=0;j<mol->nAtoms;j++)
		{
			double r2 = 0;
			for(c=0;c<3;c++) r2+= modes[3*j+c][i]*modes[3*j+c][i];
			m+= r2/(mol->atoms[j].mass); 
		}
		if(m<=0) m = 1;
		m = 1/m;
		for(j=0;j<mol->nAtoms;j++)
		{
			double r =sqrt(m)/sqrt(mol->atoms[j].mass);
			for(c=0;c<3;c++) modes[3*j+c][i]*=r;
		}

		//printf("%f %f\n",(*frequencies)[i],m);
		mol->vibration.modes[i].mass = m;
	}
	for(i=0;i<mol->vibration.nModes;i++) 
	{
		for(c=0;c<3;c++) mol->vibration.modes[i].frequency = frequencies[i];
		for(j=0;j<mol->nAtoms;j++)
			for(c=0;c<3;c++) mol->vibration.modes[i].vectors[c][j] = modes[3*j+c][i];
	}
	if(frequencies) free(frequencies);
	if(modes) for(i=0;i<3*nAtoms;i++) if(modes[i]) free(modes[i]);
	if(modes) free(modes);
	sortFrequencies(mol);
	removeTransRotModes(mol);
	return 3*nAtoms;
}
/*****************************************************************************************************/
static int readEnergyDipoleGradFromGabeditFile(Molecule* mol, char* inputFileName, int index, boolean readGrad)
{
	char* fileName = NULL;
	char* prefixName = NULL;
	int i;

	if(!mol) return 1;
	if(mol->nAtoms<1) return 1;
	if(!inputFileName) return 1;

	prefixName = strdup_printf("%sFreq",getSuffixNameFile(inputFileName));

	fileName = strdup_printf("%s_%d.gab",prefixName,index);
	i = readEnergyAndDipoleFromGabeditFile(fileName, &mol->potentialEnergy, mol->dipole);
	printf("FileName = %s E = %f D = %f %f %f\n", fileName, mol->potentialEnergy, mol->dipole[0],  mol->dipole[1],  mol->dipole[2]);
	if(readGrad) mol->klass->readGradientFromGabeditFile(mol, fileName);

	if(fileName) free(fileName);
	return i;
}
/*****************************************************************************/
static int computeGradientsFromFiles(Molecule* mol, char* inputFileName, int indexBegin, double dx)
{
        int i;
        int k;
        int nAtoms;
	int index = indexBegin;
	double Ep, Em;

	if(!inputFileName) return indexBegin;
	nAtoms = mol->nAtoms;

        for(i=0;i<nAtoms;i++)
        for(k=0;k<3;k++)
        {
                mol->atoms[i].coordinates[k] += dx;
		readEnergyDipoleGradFromGabeditFile(mol, inputFileName, index, FALSE);
		Ep = mol->potentialEnergy;
		index++;

                mol->atoms[i].coordinates[k] -= 2*dx;
		readEnergyDipoleGradFromGabeditFile(mol, inputFileName, index, FALSE);
		Em = mol->potentialEnergy;
		index++;
		mol->atoms[i].gradient[k] = (Ep-Em)/dx/2;

                mol->atoms[i].coordinates[k] += dx;
        }
	return index;
}
/*****************************************************************************/
static int computeFrequenciesFromFiles(Molecule* mol, char* inputFileName, double dx)
{
	int i;
	int j;
	int k;
	int c;
	int id,jd,index,idx;
	double* F;
	double* gp[3];
	double* gm[3];
	double* dmuX[3];
	double Dp[3];
	double Dm[3];
	int nAtoms;
	int ret;

	if(!mol || mol->nAtoms<1) return 0;

	nAtoms = mol->nAtoms;
	for(k=0;k<3;k++) gp[k] = malloc(nAtoms*sizeof(double));
	for(k=0;k<3;k++) gm[k] = malloc(nAtoms*sizeof(double));
	for(k=0;k<3;k++) dmuX[k] = malloc(3*nAtoms*sizeof(double));

	F = malloc(3*nAtoms*(3*nAtoms+1)/2*sizeof(double));

	index = 0;
	for(i=0;i<nAtoms;i++)
	for(k=0;k<3;k++)
	{
		id=3*i+k;

		mol->atoms[i].coordinates[k] += dx;
		index = computeGradientsFromFiles(mol, inputFileName, index, dx);
		copyGradients(mol, gp);
		readEnergyDipoleGradFromGabeditFile(mol, inputFileName, index,FALSE);
		for(c = 0;c<3;c++)  Dp[c] = mol->dipole[c];
		index++;
		
		mol->atoms[i].coordinates[k] -= 2*dx;
		index = computeGradientsFromFiles(mol, inputFileName, index, dx);
		copyGradients(mol, gm);
		readEnergyDipoleGradFromGabeditFile(mol, inputFileName, index,FALSE);
		for(c = 0;c<3;c++)  Dm[c] = mol->dipole[c];
		index++;

		for(c = 0;c<3;c++) dmuX[c][id] = (Dp[c]-Dm[c])/dx/2;
		mol->atoms[i].coordinates[k] += dx;
		
		for(j=0;j<=i;j++)
		{
			double invm = 1.0/sqrt( mol->atoms[i].mass* mol->atoms[j].mass);
			for(c = 0;c<3;c++) 
			{
				jd = 3*j+c;
				//printf("id = %d jd = %d\n",id,jd);
				if(jd>id) continue;
				idx = jd + id*(id+1)/2;
				//printf("index = %d i = %d k = %d j = %d c = %d\n",index,i,k,j,c);
				F[idx] = (gp[c][j]-gm[c][j])/dx/2; 
				F[idx] *= invm;
			}
		}
	}
	//printf("F\n");
	/*
	for(id=0;id<3*nAtoms;id++)
	{
		for(jd=0;jd<=id;jd++) 
		{
			index = jd + id*(id+1)/2;
			printf("%14.8f",F[index]);
		}
		printf("\n");
	}
	*/

	for(k=0;k<3;k++) free(gp[k]);
	for(k=0;k<3;k++) free(gm[k]);
	ret = computeIR(mol, F, dmuX);
	free(F);
	for(k=0;k<3;k++) free(dmuX[k]);
	return ret;
}
/*******************************************************************************************************************/
static int computeGradientsOneStepFromFiles(Molecule* mol, char* inputFileName, int indexBegin, double D[], double dx)
{
        int i;
        int k;
        int nAtoms;
	int index = indexBegin;
	double Ep, E0;
	int c;

	if(!mol || mol->nAtoms<1) return indexBegin;
	if(!inputFileName) return indexBegin;

	nAtoms = mol->nAtoms;

	readEnergyDipoleGradFromGabeditFile(mol, inputFileName, index,FALSE);
	E0 = mol->potentialEnergy;
	for(c = 0;c<3;c++)  D[c] = mol->dipole[c];
	index++;
        for(i=0;i<nAtoms;i++)
        for(k=0;k<3;k++)
        {
                mol->atoms[i].coordinates[k] += dx;
		readEnergyDipoleGradFromGabeditFile(mol, inputFileName, index,FALSE);
		Ep = mol->potentialEnergy;
		index++;

		mol->atoms[i].gradient[k] = (Ep-E0)/dx;

                mol->atoms[i].coordinates[k] -= dx;
        }
	return index;
}
/*******************************************************************************************************************/
static int computeFrequenciesOneStepFromFiles(Molecule* mol, char* inputFileName, double dx)
{
	int i;
	int j;
	int k;
	int c;
	int id,jd,index,idx;
	double* F;
	double* gp[3];
	double* g0[3];
	double* dmuX[3];
	double Dp[3];
	double D0[3];
	int nAtoms;
	int ret;

	if(!mol || mol->nAtoms<1) return 0;
	nAtoms = mol->nAtoms;
	for(k=0;k<3;k++) gp[k] = malloc(nAtoms*sizeof(double));
	for(k=0;k<3;k++) g0[k] = malloc(nAtoms*sizeof(double));
	for(k=0;k<3;k++) dmuX[k] = malloc(3*nAtoms*sizeof(double));

	F = malloc(3*nAtoms*(3*nAtoms+1)/2*sizeof(double));

	index = 0;
	index = computeGradientsOneStepFromFiles(mol, inputFileName, index, D0, dx);
	copyGradients(mol, g0);

	for(i=0;i<nAtoms;i++)
	for(k=0;k<3;k++)
	{
		id=3*i+k;
		mol->atoms[i].coordinates[k] += dx;
		index = computeGradientsOneStepFromFiles(mol, inputFileName, index, Dp, dx);
		copyGradients(mol, gp);
		
		for(c = 0;c<3;c++) dmuX[c][id] = (Dp[c]-D0[c])/dx;
		mol->atoms[i].coordinates[k] -= dx;
		
		for(j=0;j<=i;j++)
		{
			double invm = 1.0/sqrt( mol->atoms[i].mass* mol->atoms[j].mass);
			for(c = 0;c<3;c++) 
			{
				jd = 3*j+c;
				//printf("id = %d jd = %d\n",id,jd);
				if(jd>id) continue;
				idx = jd + id*(id+1)/2;
				//printf("index = %d i = %d k = %d j = %d c = %d\n",index,i,k,j,c);
				F[idx] = (gp[c][j]-g0[c][j])/dx; 
				F[idx] *= invm;
			}
		}
	}
	//printf("F\n");
	/*
	for(id=0;id<3*nAtoms;id++)
	{
		for(jd=0;jd<=id;jd++) 
		{
			index = jd + id*(id+1)/2;
			printf("%14.8f",F[index]);
		}
		printf("\n");
	}
	*/

	for(k=0;k<3;k++) free(gp[k]);
	for(k=0;k<3;k++) free(g0[k]);
	ret = computeIR(mol, F, dmuX);
	free(F);
	for(k=0;k<3;k++) free(dmuX[k]);
	return ret;
}
/*****************************************************************************/
static int computeFrequenciesFromGradFiles(Molecule* mol, char* inputFileName, double dx)
{
	int i;
	int j;
	int k;
	int c;
	int id,jd,index,idx;
	double* F;
	double* gp[3];
	double* gm[3];
	double* dmuX[3];
	double Dp[3];
	double Dm[3];
	int nAtoms;
	int ret;

	if(!mol || mol->nAtoms<1) return 0;
	nAtoms = mol->nAtoms;
	for(k=0;k<3;k++) gp[k] = malloc(nAtoms*sizeof(double));
	for(k=0;k<3;k++) gm[k] = malloc(nAtoms*sizeof(double));
	for(k=0;k<3;k++) dmuX[k] = malloc(3*nAtoms*sizeof(double));

	F = malloc(3*nAtoms*(3*nAtoms+1)/2*sizeof(double));

	index = 0;
	for(i=0;i<nAtoms;i++)
	for(k=0;k<3;k++)
	{
		id=3*i+k;
		mol->atoms[i].coordinates[k] += dx;
		readEnergyDipoleGradFromGabeditFile(mol, inputFileName, index,TRUE);
		copyGradients(mol, gp);
		for(c = 0;c<3;c++)  Dp[c] = mol->dipole[c];
		index++;
		
		mol->atoms[i].coordinates[k] -= 2*dx;
		readEnergyDipoleGradFromGabeditFile(mol, inputFileName, index,TRUE);
		copyGradients(mol, gm);
		for(c = 0;c<3;c++)  Dm[c] = mol->dipole[c];
		index++;
		for(c = 0;c<3;c++) dmuX[c][id] = (Dp[c]-Dm[c])/dx/2;

		mol->atoms[i].coordinates[k] += dx;
		
		for(j=0;j<=i;j++)
		{
			double invm = 1.0/sqrt( mol->atoms[i].mass* mol->atoms[j].mass);
			for(c = 0;c<3;c++) 
			{
				jd = 3*j+c;
				//printf("id = %d jd = %d\n",id,jd);
				if(jd>id) continue;
				idx = jd + id*(id+1)/2;
				//printf("index = %d i = %d k = %d j = %d c = %d\n",index,i,k,j,c);
				F[idx] = (gp[c][j]-gm[c][j])/dx/2; 
				F[idx] *= invm;
			}
		}
	}
	//printf("F\n");
	/*
	for(id=0;id<3*nAtoms;id++)
	{
		for(jd=0;jd<=id;jd++) 
		{
			index = jd + id*(id+1)/2;
			printf("%14.8f",F[index]);
		}
		printf("\n");
	}
	*/

	for(k=0;k<3;k++) free(gp[k]);
	for(k=0;k<3;k++) free(gm[k]);
	ret = computeIR(mol, F, dmuX);
	free(F);
	for(k=0;k<3;k++) free(dmuX[k]);
	return ret;
}
/*******************************************************************************************************************/
static int computeFrequenciesOneStepFromGradFiles(Molecule* mol, char* inputFileName, double dx)
{
	int i;
	int j;
	int k;
	int c;
	int id,jd,index,idx;
	double* F;
	double* gp[3];
	double* g0[3];
	double* dmuX[3];
	double Dp[3];
	double D0[3];
	int nAtoms;
	int ret;

	if(!mol || mol->nAtoms<1) return 0;
	nAtoms = mol->nAtoms;
	for(k=0;k<3;k++) gp[k] = malloc(nAtoms*sizeof(double));
	for(k=0;k<3;k++) g0[k] = malloc(nAtoms*sizeof(double));
	for(k=0;k<3;k++) dmuX[k] = malloc(3*nAtoms*sizeof(double));

	F = malloc(3*nAtoms*(3*nAtoms+1)/2*sizeof(double));

	index = 0;
	readEnergyDipoleGradFromGabeditFile(mol, inputFileName, index,TRUE);
	copyGradients(mol, g0);
	for(c = 0;c<3;c++)  D0[c] = mol->dipole[c];
	index++;

	for(i=0;i<nAtoms;i++)
	for(k=0;k<3;k++)
	{
		id=3*i+k;
		mol->atoms[i].coordinates[k] += dx;
		readEnergyDipoleGradFromGabeditFile(mol, inputFileName, index,TRUE);
		copyGradients(mol, gp);
		for(c = 0;c<3;c++)  Dp[c] = mol->dipole[c];
		index++;
		
		for(c = 0;c<3;c++) dmuX[c][id] = (Dp[c]-D0[c])/dx;
		mol->atoms[i].coordinates[k] -= dx;
		
		for(j=0;j<=i;j++)
		{
			double invm = 1.0/sqrt( mol->atoms[i].mass* mol->atoms[j].mass);
			for(c = 0;c<3;c++) 
			{
				jd = 3*j+c;
				//printf("id = %d jd = %d\n",id,jd);
				if(jd>id) continue;
				idx = jd + id*(id+1)/2;
				//printf("index = %d i = %d k = %d j = %d c = %d\n",index,i,k,j,c);
				F[idx] = (gp[c][j]-g0[c][j])/dx; 
				F[idx] *= invm;
			}
		}
	}
	//printf("F\n");
	/*
	for(id=0;id<3*nAtoms;id++)
	{
		for(jd=0;jd<=id;jd++) 
		{
			index = jd + id*(id+1)/2;
			printf("%14.8f",F[index]);
		}
		printf("\n");
	}
	*/

	for(k=0;k<3;k++) free(gp[k]);
	for(k=0;k<3;k++) free(g0[k]);
	ret = computeIR(mol, F, dmuX);
	free(F);
	for(k=0;k<3;k++) free(dmuX[k]);
	return ret;
}
/*****************************************************************************/
static boolean addInputToCChemIFile(FILE* fileOut, char* inputFileName, char* runType)
{
	boolean Ok = TRUE;
	char buffer[1024];
	int i;
	FILE* fileIn = fopen(inputFileName,"r");
	if(!fileIn) return FALSE;
        while(!feof(fileIn))
        {
               	if(!fgets(buffer,BSIZE,fileIn)){ Ok = FALSE; break;}
		for(i=0;i<strlen(buffer);i++) if(buffer[i] != ' ') { break;}
		if(buffer[i]=='#') 
		{
			char* str = strdup(buffer);
			uppercase(str);
			if(!strstr(str,"GEOMETRY")) fprintf(fileOut,"%s",buffer);
			free(str);
		}
		else
		{
			char* str = strdup(buffer);
			sscanf(buffer,"%s",str);
			uppercase(str);
			if(!strcmp(str,"GEOMETRY"))
			{
				int nA = 0;
               			if(!fgets(buffer,BSIZE,fileIn)){ Ok = FALSE; break;}
				sscanf(buffer,"%d",&nA);
				for(i=0;i<nA;i++) if(!fgets(buffer,BSIZE,fileIn)) { Ok = FALSE; break;}
				if(!Ok) break;
				
			}
			else if(strstr(str,"RUNTYPE")) fprintf(fileOut,"%s%s\n","RunType=",runType);
			else fprintf(fileOut,"%s",buffer);
			free(str);
		}
	}
	fclose(fileIn);
	return Ok;
}
/*****************************************************************************/
static int createCChemIFile(Molecule* mol, char* inputFileName, int index, char* runType)
{
	char* fileName = NULL;
	FILE* file = NULL;
	char* prefixName = NULL;

	if(!mol || mol->nAtoms<1) return 1;
	if(!inputFileName) return 1;

	prefixName = strdup_printf("%sFreq",getSuffixNameFile(inputFileName));
	fileName = strdup_printf("%s_%d.ici",prefixName,index);
	file = fopen(fileName,"w");
	addInputToCChemIFile(file, inputFileName, runType);
	mol->klass->addGeometry(mol,file);
	fclose(file);

	if(fileName) free(fileName);
	return 0;
}
/******************************************************************************************************/
static int generateCChemIFilesGradients(Molecule* mol, char* inputFileName, int indexBegin, double dx)
{
        int i;
        int k;
        int nAtoms;
	int index = indexBegin;

	if(!mol || mol->nAtoms<1) return indexBegin;
	if(!inputFileName) return indexBegin;

	nAtoms = mol->nAtoms;

        for(i=0;i<nAtoms;i++)
        for(k=0;k<3;k++)
        {
                mol->atoms[i].coordinates[k] += dx;
		createCChemIFile(mol, inputFileName, index,"Energy");
		index++;

                mol->atoms[i].coordinates[k] -= 2*dx;
		createCChemIFile(mol, inputFileName, index,"Energy");
		index++;

                mol->atoms[i].coordinates[k] += dx;
        }
	return index;
}
/******************************************************************************************************/
static int generateCChemIFilesForFrequencies(Molecule* mol, char* inputFileName, double dx)
{
	int i;
	int k;
	int index;
	int nAtoms;

	if(!mol || mol->nAtoms<1) return 1;
	if(!inputFileName) return 1;

	nAtoms = mol->nAtoms;
	printf("nAtoms = %d\n",nAtoms);

	index = 0;
	for(i=0;i<nAtoms;i++)
	for(k=0;k<3;k++)
	{
		mol->atoms[i].coordinates[k] += dx;
		index = generateCChemIFilesGradients(mol, inputFileName, index, dx);
		createCChemIFile(mol, inputFileName, index,"Energy");
		index++;
		
		mol->atoms[i].coordinates[k] -= 2*dx;
		index = generateCChemIFilesGradients(mol, inputFileName, index, dx);
		createCChemIFile(mol, inputFileName, index,"Energy");
		index++;

		mol->atoms[i].coordinates[k] += dx;
	}
	printf("see %sFreq_*.ici generated files\n",inputFileName);
	return 0;
}
/******************************************************************************************************/
static int generateCChemIFilesOneStepGradients(Molecule* mol, char* inputFileName, int indexBegin, double dx)
{
        int i;
        int k;
        int nAtoms;
	int index = indexBegin;

	if(!mol || mol->nAtoms<1) return indexBegin;
	if(!inputFileName) return indexBegin;

	nAtoms = mol->nAtoms;

	createCChemIFile(mol, inputFileName, index,"Energy");
	index++;
        for(i=0;i<nAtoms;i++)
        for(k=0;k<3;k++)
        {
                mol->atoms[i].coordinates[k] += dx;
		createCChemIFile(mol, inputFileName, index,"Energy");
		index++;

                mol->atoms[i].coordinates[k] -= dx;
        }
	return index;
}
/******************************************************************************************************/
static int generateCChemIFilesOneStepForFrequencies(Molecule* mol, char* inputFileName, double dx)
{
	int i;
	int k;
	int index;
	int nAtoms;

	if(!mol || mol->nAtoms<1) return 1;
	if(!inputFileName) return 1;

	nAtoms = mol->nAtoms;
	printf("nAtoms = %d\n",nAtoms);

	index = 0;
	index = generateCChemIFilesOneStepGradients(mol, inputFileName, index, dx);

	for(i=0;i<nAtoms;i++)
	for(k=0;k<3;k++)
	{
		mol->atoms[i].coordinates[k] += dx;
		index = generateCChemIFilesOneStepGradients(mol, inputFileName, index, dx);
		
		mol->atoms[i].coordinates[k] -= dx;
	}
	printf("see %sFreq_*.ici generated files\n",inputFileName);
	return 0;
}
/******************************************************************************************************/
static int generateCChemIGradFilesForFrequencies(Molecule* mol, char* inputFileName, double dx)
{
	int i;
	int k;
	int index;
	int nAtoms;

	if(!mol || mol->nAtoms<1) return 1;
	if(!inputFileName) return 1;

	nAtoms = mol->nAtoms;
	printf("nAtoms = %d\n",nAtoms);

	index = 0;
	for(i=0;i<nAtoms;i++)
	for(k=0;k<3;k++)
	{
		mol->atoms[i].coordinates[k] += dx;
		createCChemIFile(mol, inputFileName, index,"Gradient");
		index++;
		
		mol->atoms[i].coordinates[k] -= 2*dx;
		createCChemIFile(mol, inputFileName, index,"Gradient");
		index++;

		mol->atoms[i].coordinates[k] += dx;
	}
	printf("see %sFreq_*.ici generated files\n",inputFileName);
	return 0;
}
/******************************************************************************************************/
static int generateCChemIGradFilesOneStepForFrequencies(Molecule* mol, char* inputFileName, double dx)
{
	int i;
	int k;
	int index;
	int nAtoms;

	if(!mol || mol->nAtoms<1) return 1;
	if(!inputFileName) return 1;

	nAtoms = mol->nAtoms;
	printf("nAtoms = %d\n",nAtoms);

	index = 0;
	createCChemIFile(mol, inputFileName, index,"Gradient");
	index++;

	for(i=0;i<nAtoms;i++)
	for(k=0;k<3;k++)
	{
		mol->atoms[i].coordinates[k] += dx;
		createCChemIFile(mol, inputFileName, index,"Gradient");
		index++;
		
		mol->atoms[i].coordinates[k] -= dx;
	}
	printf("see %sFreq_*.ici generated files\n",inputFileName);
	return 0;
}
/******************************************************************************************************/
static void computeFixedNormalModesSampling(Molecule* mol, double* quantumNumbers, boolean changeGeom)
{
	int i,k,j;
	int nAtoms;
	double* Q = NULL;
	double* dQ = NULL;
	int ntr = 6;
	int nModes = 0;

	if(!mol || mol->nAtoms<1 || mol->vibration.nModes<1 ) return;
	nAtoms = mol->nAtoms;
	nModes = mol->vibration.nModes;
	if(mol->klass->isLinear(mol)) ntr = 5;
	if(nModes != 3*nAtoms) ntr = 0;
	

	Q = malloc(nModes*sizeof(double));
	dQ = malloc(nModes*sizeof(double));
	for(i=0;i<nModes;i++) Q[i] = 0.0;
	for(i=0;i<nModes;i++) dQ[i] = 0.0;

	// Q and dQ in AU
	for(i=ntr;i<nModes;i++) 
	{
		double R = (normal()+1)/2.0;
		double fi = fabs(mol->vibration.modes[i].frequency)/AUTOCM1;
		double Ei = (quantumNumbers[i]+0.5)*mol->vibration.modes[i].frequency/AUTOCM1; 
		double Ai = 0;
		if(Ei<0) Ei = 0;
		if(fi>1e-10) Ai = sqrt(2.0*fabs(Ei))/fi;
		Q[i] = Ai*cos(2*PI*R); 
		dQ[i] = -fi*Ai*sin(2*PI*R); 
	}
	// Q and dQ in AU
	for(i=ntr;i<nModes;i++)  Q[i]  /= sqrt(mol->vibration.modes[i].mass*AMUTOAU);
	for(i=ntr;i<nModes;i++)  dQ[i] /= sqrt(mol->vibration.modes[i].mass*AMUTOAU);

	// Q in Ang
	for(i=ntr;i<nModes;i++)  Q[i] *= BOHRTOANG;
	// dQ in Ang/AKMA-time 
	for(i=ntr;i<nModes;i++)  dQ[i] *= BOHRTOANG/(AUTOfs*fsInAKMA);
	
	for(j=0;j<nAtoms;j++) 
	for(k=0;k<3;k++) mol->atoms[j].velocity[k] = 0.0;

	for(i=0;i<nModes;i++) 
	{
		for(j=0;j<nAtoms;j++) 
		for(k=0;k<3;k++) 
		{
	 		 mol->atoms[j].velocity[k] += mol->vibration.modes[i].vectors[k][j]*dQ[i];
			if(changeGeom) mol->atoms[j].coordinates[k] +=  mol->vibration.modes[i].vectors[k][j]*Q[i];
		}
	}
	free(Q);
	free(dQ);
}
/*****************************************************************************************************************************************************/
static void computeHarmonicVelocitiesCoordinates(Molecule* mol, double T, int numMode, boolean changeGeom)
{
	int i;
	double* quantumNumbers = NULL;
	int nModes = 0;

	if(!mol || mol->nAtoms<1 || mol->vibration.nModes<1) return;
	nModes = mol->vibration.nModes;
	if(T<=0) T = 300;
	if(numMode>nModes) 
	{
		fprintf(stderr,"Error in HarmonicVelocityModes keyword, the mode number must be <=i %d\n",nModes);
		return;
	}
	quantumNumbers = malloc(nModes*sizeof(double));
	for(i=0;i<nModes;i++) quantumNumbers[i] = 0.0;
	if(numMode>=0) quantumNumbers[numMode-1] = 1.0;

	computeFixedNormalModesSampling(mol, quantumNumbers, changeGeom);

	mol->klass->removeTranslationAndRotation(mol);
	mol->klass->resetConstraints(mol, mol->constraints);
	mol->klass->scaleVelocities(mol, T);

	free(quantumNumbers);
}
/*****************************************************************************************************************************************************/
static double* getDeltaTable(Molecule* mol, double delta, boolean reducedCoordinates)
{
	double* deltas = malloc(mol->vibration.nModes*sizeof(double));
	int j;
	if(!reducedCoordinates)
		for(j=0;j<mol->vibration.nModes;j++) deltas[j] = delta/BOHRTOANG;
	else
	{
		double conv = delta*sqrt(AUTOCM1/AMUTOAU);
		for(j=0;j<mol->vibration.nModes;j++) 
			deltas[j] = conv/sqrt(mol->vibration.modes[j].frequency*mol->vibration.modes[j].mass);
	}
	return deltas;
}
/********************************************************************************/
/*  See 
	Calculation of NMR and EPR parameters: theory and applications
	By Martin Kaupp, Michael Buhl, Vladimir G. Malkin
	Published by Wiley-VCH, 2004,    ISBN 3527307796, 9783527307791
	Page 163, Equation 10.39
   See also : Toyama et al, J. Mol. Spec. 13,193 (1964), Eq. 7
 */
/********************************************************************************/
static double* get_centrifuge_parameters(Molecule* mol)
{
	int i;
	int j;
	int mode;
	double I[3] = {0,0,0};
	double alpha = 0;
	double beta = 0;
	double* akOverI = NULL;
	double a = 0;
	Atom* atoms = NULL;
	int nAtoms;
	int nModes;

	if(!mol || mol->nAtoms<1 || mol->vibration.nModes<1) return NULL;
	atoms = mol->atoms;
	nAtoms = mol->nAtoms;
	nModes = mol->vibration.nModes;

	akOverI = malloc(nModes*sizeof(double));

	for(i=0;i<nAtoms;i++)
	{
		for(j=0;j<3;j++)
		{
			alpha = atoms[i].coordinates[(j+1)%3];
			beta  = atoms[i].coordinates[(j+2)%3];
			I[j] += (alpha*alpha+beta*beta)*atoms[i].mass;
		}
	}
	/* printf("Ix = %lf Iyy = %lf Izz = %lf\n",I[0],I[1],I[2]);*/

	for(mode = 0;mode<nModes;mode++)
	{
		akOverI[mode] = 0;
		for(j=0;j<3;j++)
		{
			if(fabs(I[j])<1e-8) continue;
			a = 0;
			for(i=0;i<nAtoms;i++)
			{
				a += 
				atoms[i].coordinates[(j+1)%3]*mol->vibration.modes[mode].vectors[(j+1)%3][i]
			       +atoms[i].coordinates[(j+2)%3]*mol->vibration.modes[mode].vectors[(j+2)%3][i];
				/*
				printf ("%lf %lf %lf %lf \n",
				atoms[i].coordinates[(j+1)%3],mol->vibration.modes[mode].vectors[(j+1)%3][i],
				atoms[i].coordinates[(j+2)%3],mol->vibration.modes[mode].vectors[(j+2)%3][i]
						);
						*/
			}
			a *=2;
			a *=sqrt(mol->vibration.modes[mode].mass);
			/* printf("k = %d ak = %lf\n",mode+1,a);*/
			akOverI[mode] += a/I[j];
		}
	}
	return akOverI;
}
/*****************************************************************************************************************************************************/
static int createQFFOneCChemIFile(Molecule* mol, char* inputFileName, int index, double*** geoms, int mode, double delta)
{
	char* fileName = NULL;
	FILE* file = NULL;
	char* prefixName = NULL;
	char ad = '+';
	int i,j;
	Molecule* cmol = NULL;

	if(!mol || mol->nAtoms<1) return 1;
	if(!inputFileName) return 1;
	cmol = mol->klass->copy(mol);
	if(!cmol || cmol->nAtoms<1) return 1;

	if(delta<0) ad = '-';

	prefixName = strdup_printf("%sQFF",getSuffixNameFile(inputFileName));
	fileName = strdup_printf("%s_%d.ici",prefixName,index);
	file = fopen(fileName,"w");
	addInputToCChemIFile(file, inputFileName, "Energy");

	if(mode>-1) fprintf(file,"\n#Mode: Freq= %0.12lf Mass= %0.12lf Q= Qeq %c %0.12lf\n\n",
				mol->vibration.modes[mode].frequency,
				mol->vibration.modes[mode].mass,
				ad,
				fabs(delta)
				);
	for(i=0;i<mol->nAtoms;i++)
	for(j=0;j<3;j++)
		cmol->atoms[i].coordinates[j] = geoms[index][i][j];

	cmol->klass->addGeometry(cmol,file);
	fclose(file);

	if(fileName) free(fileName);
	cmol->klass->free(cmol);
	return 0;
}
/*******************************************************************************************************************************/
static int generateQFFCChemIFiles(Molecule* mol, char* inputFileName, double delta, boolean reducedCoordinates, int ordre)
{
	int index =0;
	int j;
	double* deltas = NULL;
	int nGeoms = 0;
	double*** geoms = getGeomsQFF(mol, inputFileName, delta,  reducedCoordinates, ordre, &deltas, &nGeoms);
	index = 0;
	createQFFOneCChemIFile(mol, inputFileName, index, geoms, -1, 0);
	for(j=0;j<mol->vibration.nModes;j++)
	{
		index++; createQFFOneCChemIFile(mol, inputFileName, index, geoms, j,  3*deltas[j]);
		index++; createQFFOneCChemIFile(mol, inputFileName, index, geoms, j,  2*deltas[j]);
		index++; createQFFOneCChemIFile(mol, inputFileName, index, geoms, j,   deltas[j]);
		index++; createQFFOneCChemIFile(mol, inputFileName, index, geoms, j,  -deltas[j]);
		index++; createQFFOneCChemIFile(mol, inputFileName, index, geoms, j, -2*deltas[j]);
		index++; createQFFOneCChemIFile(mol, inputFileName, index, geoms, j, -3*deltas[j]);
	}
	index++;
	for(    ;index<nGeoms;index++) createQFFOneCChemIFile(mol, inputFileName, index, geoms, -1, 0);
	printf("see %sQFF_*.ici generated files\n",inputFileName);
	for(index=0;index<nGeoms;index++) 
	{
		int i;
		for(i=0;i<mol->nAtoms;i++) free(geoms[index][i]);
		free(geoms[index]);
	}
	{
        	char* fileNameOut = strdup_printf("%sModes.gab",getSuffixNameFile(inputFileName));
		mol->klass->save(mol, fileNameOut);
		if(fileNameOut) free(fileNameOut);
	}
	return 0;
}
/*****************************************************************************************************************************************************/
static int getQFFOneGeom(Molecule* mol, int mode1, int mode2, double delta1, double delta2, double akOverI1, double** geom)
{
	int i,j;

	if(!mol || mol->nAtoms<1) return 1;

	delta1 *= BOHRTOANG;
	delta2 *= BOHRTOANG;
	for(i=0;i<mol->nAtoms;i++)
	for(j=0;j<3;j++)
		geom[i][j] = mol->atoms[i].coordinates[j];

	for(i=0;i<mol->nAtoms;i++)
	for(j=0;j<3;j++)
	{
		if(mode1>-1) geom[i][j] += mol->vibration.modes[mode1].vectors[j][i]*delta1;
		if(mode2>-1) geom[i][j] += mol->vibration.modes[mode2].vectors[j][i]*delta2;
	}
	return 0;
}
/*****************************************************************************************************************************************************/
static int getQFFOneGeom3(Molecule* mol, int mode1, int mode2, int mode3, double delta1, double delta2, double delta3, double** geom)
{
	int i,j;

	if(!mol || mol->nAtoms<1) return 1;

	delta1 *= BOHRTOANG;
	delta2 *= BOHRTOANG;
	delta3 *= BOHRTOANG;
	for(i=0;i<mol->nAtoms;i++)
	for(j=0;j<3;j++)
		geom[i][j] = mol->atoms[i].coordinates[j];

	for(i=0;i<mol->nAtoms;i++)
	for(j=0;j<3;j++)
	{
		if(mode1>-1) geom[i][j] += mol->vibration.modes[mode1].vectors[j][i]*delta1;
		if(mode2>-1) geom[i][j] += mol->vibration.modes[mode2].vectors[j][i]*delta2;
		if(mode3>-1) geom[i][j] += mol->vibration.modes[mode3].vectors[j][i]*delta3;
	}
	return 0;
}
/*******************************************************************************************************************************/
static int getQFFOneGeom4(Molecule* mol, int mode1, int mode2, int mode3, int mode4, double delta1, double delta2, double delta3, double delta4, double** geom)
{
	int i,j;

	if(!mol || mol->nAtoms<1) return 1;

	delta1 *= BOHRTOANG;
	delta2 *= BOHRTOANG;
	delta3 *= BOHRTOANG;
	delta4 *= BOHRTOANG;
	for(i=0;i<mol->nAtoms;i++)
	for(j=0;j<3;j++)
		geom[i][j] = mol->atoms[i].coordinates[j];

	for(i=0;i<mol->nAtoms;i++)
	for(j=0;j<3;j++)
	{
		if(mode1>-1) geom[i][j] += mol->vibration.modes[mode1].vectors[j][i]*delta1;
		if(mode2>-1) geom[i][j] += mol->vibration.modes[mode2].vectors[j][i]*delta2;
		if(mode3>-1) geom[i][j] += mol->vibration.modes[mode3].vectors[j][i]*delta3;
		if(mode4>-1) geom[i][j] += mol->vibration.modes[mode4].vectors[j][i]*delta4;
	}
	return 0;
}
/*****************************************************************************************************************************************************/
static double*** getGeomsQFF(Molecule* mol, char* inputFileName, double delta, boolean reducedCoordinates, int ordre, double** pDeltas, int* nGeoms)
{
	double*** geoms;
	int index =0;
	double* akOverI = NULL;
	int nAll = 0;
	double* deltas = NULL;
	int i,j,k,l;
	akOverI = get_centrifuge_parameters(mol);
	if(!akOverI) return NULL;
	deltas = getDeltaTable(mol, delta, reducedCoordinates);
	if(!deltas) return NULL;
	nAll = 1 +6* mol->vibration.nModes;
	if(ordre>=2) nAll += 6*mol->vibration.nModes*(mol->vibration.nModes-1); 
	if(ordre>=3) nAll += 8*mol->vibration.nModes*(mol->vibration.nModes-1)*(mol->vibration.nModes-2)/6;
	if(ordre>=4) nAll += 16*mol->vibration.nModes*(mol->vibration.nModes-1)*(mol->vibration.nModes-2)*(mol->vibration.nModes-3)/24;

	geoms = malloc(nAll*sizeof(double**));
	for(k=0;k<nAll;k++)
	{
		geoms[k] =  malloc(mol->nAtoms*sizeof(double*));
	       for(i=0;i<mol->nAtoms;i++) geoms[k][i] =  malloc(3*sizeof(double));
	}

	index = 0;
	getQFFOneGeom(mol, -1, -1, 0.0, 0.0, 0.0,geoms[index]);
	for(j=0;j<mol->vibration.nModes;j++)
	{
		index++; getQFFOneGeom(mol,  j, -1,   3*deltas[j], 0,akOverI[j],geoms[index]);
		index++; getQFFOneGeom(mol,  j, -1,   2*deltas[j], 0,akOverI[j],geoms[index]);
		index++; getQFFOneGeom(mol,  j, -1,     deltas[j], 0,akOverI[j],geoms[index]);
		index++; getQFFOneGeom(mol,  j, -1,    -deltas[j], 0,akOverI[j],geoms[index]);
		index++; getQFFOneGeom(mol,  j, -1,  -2*deltas[j], 0,akOverI[j],geoms[index]);
		index++; getQFFOneGeom(mol,  j, -1,  -3*deltas[j], 0,akOverI[j],geoms[index]);
	}
	if(akOverI) free(akOverI);
	if(ordre>=2)
	for(j=0;j<mol->vibration.nModes;j++)
	{
		for(i=0;i<j;i++)
		{
			index++; getQFFOneGeom(mol, j, i,  deltas[j],   deltas[i],0, geoms[index]);
			index++; getQFFOneGeom(mol, j, i,  deltas[j],  -deltas[i],0, geoms[index]);
			index++; getQFFOneGeom(mol, j, i, -deltas[j],   deltas[i],0, geoms[index]);
			index++; getQFFOneGeom(mol, j, i, -deltas[j],  -deltas[i],0, geoms[index]);
		}
		for(i=0;i<mol->vibration.nModes;i++)
		{
			if(i==j) continue;

			index++; getQFFOneGeom(mol,  j, i,  deltas[j],  3*deltas[i],0, geoms[index]);
			index++; getQFFOneGeom(mol,  j, i,  deltas[j], -3*deltas[i],0, geoms[index]);
			index++; getQFFOneGeom(mol,  j, i, -deltas[j],  3*deltas[i],0, geoms[index]);
			index++; getQFFOneGeom(mol,  j, i, -deltas[j], -3*deltas[i],0, geoms[index]);
		}
	}
	if(ordre>=3)
	for(j=0;j<mol->vibration.nModes;j++)
	{
		for(i=0;i<j;i++)
		for(k=0;k<i;k++)
		{
			/* 0  deltas[j],   deltas[i],  deltas[k] */
			index++; getQFFOneGeom3(mol, j, i, k,  deltas[j], deltas[i], deltas[k], geoms[index]);
			/* 1  deltas[j],   deltas[i], -deltas[k] */
			index++; getQFFOneGeom3(mol, j, i, k,  deltas[j], deltas[i], -deltas[k], geoms[index]);
			/* 2  deltas[j],  -deltas[i],  deltas[k] */
			index++; getQFFOneGeom3(mol, j, i, k,  deltas[j], -deltas[i], deltas[k], geoms[index]);
			/* 3  deltas[j],  -deltas[i], -deltas[k] */
			index++; getQFFOneGeom3(mol, j, i, k,  deltas[j], -deltas[i], -deltas[k], geoms[index]);
			/* 4 -deltas[j],  deltas[i],  deltas[k] */
			index++; getQFFOneGeom3(mol, j, i, k,  -deltas[j], deltas[i], deltas[k], geoms[index]);
			/* 5 -deltas[j],  deltas[i], -deltas[k] */
			index++; getQFFOneGeom3(mol, j, i, k,  -deltas[j], deltas[i], -deltas[k], geoms[index]);
			/* 6 -deltas[j], -deltas[i],  deltas[k] */
			index++; getQFFOneGeom3(mol, j, i, k,  -deltas[j], -deltas[i], deltas[k], geoms[index]);
			/* 7 -deltas[j], -deltas[i], -deltas[k]- */
			index++; getQFFOneGeom3(mol, j, i, k,  -deltas[j], -deltas[i], -deltas[k], geoms[index]);
		}
	}
	if(ordre>=4)
	for(j=0;j<mol->vibration.nModes;j++)
	{
		for(i=0;i<j;i++)
		for(k=0;k<i;k++)
		for(l=0;l<k;l++)
		{
				/* VIJKL */
				/* 0    deltas[j],   deltas[i],   deltas[k],  deltas[l] */ //+
				/* 1    deltas[j],   deltas[i],   deltas[k], -deltas[l] */ //-
				/* 2    deltas[j],   deltas[i],  -deltas[k],  deltas[l] */ //-
				/* 3    deltas[j],   deltas[i],  -deltas[k], -deltas[l] */ //+
				/* 4    deltas[j],  -deltas[i],   deltas[k],  deltas[l] */ //-
				/* 5    deltas[j],  -deltas[i],   deltas[k], -deltas[l] */ //+
				/* 6    deltas[j],  -deltas[i],  -deltas[k],  deltas[l] */ //+
				/* 7    deltas[j],  -deltas[i],  -deltas[k], -deltas[l] */ //-
				/* 8   -deltas[j],   deltas[i],   deltas[k],  deltas[l] */ //-
				/* 9   -deltas[j],   deltas[i],   deltas[k], -deltas[l] */ //+
				/* 10  -deltas[j],   deltas[i],  -deltas[k],  deltas[l] */ //+
				/* 11  -deltas[j],   deltas[i],  -deltas[k], -deltas[l] */ //-
				/* 12  -deltas[j],  -deltas[i],   deltas[k],  deltas[l] */ //+
				/* 13  -deltas[j],  -deltas[i],   deltas[k], -deltas[l] */ //-
				/* 14  -deltas[j],  -deltas[i],  -deltas[k],  deltas[l] */ //-
				/* 15  -deltas[j],  -deltas[i],  -deltas[k], -deltas[l] */ //+

			index++; getQFFOneGeom4(mol, j, i, k, l,  deltas[j], deltas[i], deltas[k], deltas[l], geoms[index]);
			index++; getQFFOneGeom4(mol, j, i, k, l,  deltas[j], deltas[i], deltas[k], -deltas[l], geoms[index]);
			index++; getQFFOneGeom4(mol, j, i, k, l,  deltas[j], deltas[i], -deltas[k], deltas[l], geoms[index]);
			index++; getQFFOneGeom4(mol, j, i, k, l,  deltas[j], deltas[i], -deltas[k], -deltas[l], geoms[index]);
			index++; getQFFOneGeom4(mol, j, i, k, l,  deltas[j], -deltas[i], deltas[k], deltas[l], geoms[index]);
			index++; getQFFOneGeom4(mol, j, i, k, l,  deltas[j], -deltas[i], deltas[k], -deltas[l], geoms[index]);
			index++; getQFFOneGeom4(mol, j, i, k, l,  deltas[j], -deltas[i], -deltas[k], deltas[l], geoms[index]);
			index++; getQFFOneGeom4(mol, j, i, k, l,  deltas[j], -deltas[i], -deltas[k], -deltas[l], geoms[index]);

			index++; getQFFOneGeom4(mol, j, i, k, l, -deltas[j], deltas[i], deltas[k], deltas[l], geoms[index]);
			index++; getQFFOneGeom4(mol, j, i, k, l, -deltas[j], deltas[i], deltas[k], -deltas[l], geoms[index]);
			index++; getQFFOneGeom4(mol, j, i, k, l, -deltas[j], deltas[i], -deltas[k], deltas[l], geoms[index]);
			index++; getQFFOneGeom4(mol, j, i, k, l, -deltas[j], deltas[i], -deltas[k], -deltas[l], geoms[index]);
			index++; getQFFOneGeom4(mol, j, i, k, l, -deltas[j], -deltas[i], deltas[k], deltas[l], geoms[index]);
			index++; getQFFOneGeom4(mol, j, i, k, l, -deltas[j], -deltas[i], deltas[k], -deltas[l], geoms[index]);
			index++; getQFFOneGeom4(mol, j, i, k, l, -deltas[j], -deltas[i], -deltas[k], deltas[l], geoms[index]);
			index++; getQFFOneGeom4(mol, j, i, k, l, -deltas[j], -deltas[i], -deltas[k], -deltas[l], geoms[index]);
		}
	}
	*pDeltas = deltas;
	*nGeoms = nAll;
	//printf("index = %d\n",index);
	//printf("nAll = %d\n",nAll);
	return geoms;
}
#define EPSILON 1.0E-12
#define SQU(x,y,z) ((x)*(x) + (y)*(y) + (z)*(z))

/************************************************************************************************************/
/* Jacobi diagonalisation of 3x3 symmetric matrix */
/* matrix mat stored like   0 3 5    
                              1 4
                                2   */
static void jacobi(double *mat, double evec[3][3])
{
  
	double t,s,u;
	double a;
	evec[0][1] = evec[0][2] = evec[1][0] = 0.0;  /* unity matrix */
	evec[1][2] = evec[2][0] = evec[2][1] = 0.0;  /* unity matrix */
	evec[0][0] = evec[1][1] = evec[2][2] = 1.0;

	/* do jacobi sweep */
	while(SQU(mat[3],mat[4],mat[5]) > EPSILON)
	{
		/* set mat[3] to zero */
		if (mat[3]*mat[3] > EPSILON)
		{
			t = (mat[1]-mat[0])/(2.*mat[3]);
	 		t = (t>0) ? 1./(t+sqrt(t*t+1.)) : -1./(-t+sqrt(t*t+1.));
	 		s = t/(sqrt(t*t+1.));
	  		u = s*t/(s+t);

	  		mat[0] -= t*mat[3];
	  		mat[1] += t*mat[3];
	  		a = mat[5];
	  		mat[5] -= s*(mat[4]+u*mat[5]);
	  		mat[4] += s*(  a   -u*mat[4]);
	  		mat[3] = 0.;
	  
	 		a = evec[0][0];
	  		evec[0][0] -= s*(evec[0][1]+u*evec[0][0]);
	  		evec[0][1] += s*(   a   -u*evec[0][1]);

	  		a = evec[1][0];
	  		evec[1][0] -= s*(evec[1][1]+u*evec[1][0]);
	  		evec[1][1] += s*(   a   -u*evec[1][1]);

	 		a = evec[2][0];
	  		evec[2][0] -= s*(evec[2][1]+u*evec[2][0]);
	  		evec[2][1] += s*(   a   -u*evec[2][1]);
		}

		/* set mat[5] to zero */
		if (mat[5]*mat[5] > EPSILON)
		{
			t = (mat[2]-mat[0])/(2.*mat[5]);
	  		t = (t>0) ? 1./(t+sqrt(t*t+1.)) : -1./(-t+sqrt(t*t+1.));
	  		s = t/(sqrt(t*t+1.));
	  		u = s*t/(s+t);

	  		mat[0] -= t*mat[5];
	  		mat[2] += t*mat[5];
	  		a = mat[3];
	  		mat[3] -= s*(mat[4]+u*mat[3]);
	  		mat[4] += s*(  a   -u*mat[4]);
	  		mat[5] = 0.;
	  
	  		a = evec[0][0];
	  		evec[0][0] -= s*(evec[0][2]+u*evec[0][0]);
	  		evec[0][2] += s*(   a   -u*evec[0][2]);

	  		a = evec[1][0];
	  		evec[1][0] -= s*(evec[1][2]+u*evec[1][0]);
	  		evec[1][2] += s*(   a   -u*evec[1][2]);

	  		a = evec[2][0];
	  		evec[2][0] -= s*(evec[2][2]+u*evec[2][0]);
	  		evec[2][2] += s*(   a   -u*evec[2][2]);
		}

		/* set mat[4] to zero */
		if (mat[4]*mat[4] > EPSILON)
		{
	  		t = (mat[2]-mat[1])/(2.*mat[4]);
	  		t = (t>0) ? 1./(t+sqrt(t*t+1.)) : -1./(-t+sqrt(t*t+1.));
	  		s = t/(sqrt(t*t+1.));
	  		u = s*t/(s+t);

	  		mat[1] -= t*mat[4];
	  		mat[2] += t*mat[4];
	  		a = mat[3];
	  		mat[3] -= s*(mat[5]+u*mat[3]);
	  		mat[5] += s*(  a   -u*mat[5]);
	  		mat[4] = 0.;

	  		a = evec[0][1];
	  		evec[0][1] -= s*(evec[0][2]+u*evec[0][1]);
	  		evec[0][2] += s*(   a   -u*evec[0][2]);

	  		a = evec[1][1];
	  		evec[1][1] -= s*(evec[1][2]+u*evec[1][1]);
	  		evec[1][2] += s*(   a   -u*evec[1][2]);

	  		a = evec[2][1];
	  		evec[2][1] -= s*(evec[2][2]+u*evec[2][1]);
	  		evec[2][2] += s*(   a   -u*evec[2][2]);
		}
	}
}
/************************************************************************************************************/
/************************************************************************************************************/
static void swap(int i,int j,double* mat, double vecs[3][3])
{
	int k;
	double t;
	t = mat[i];
	mat[i] = mat[j];
	mat[j] = t;
	for(k=0;k<3;k++)
	{
		t = vecs[k][i];
		vecs[k][i] = vecs[k][j];
		vecs[k][j] = t;
	}
}
/************************************************************************************************************/
/* inertial moment of a molecule */
/* matrix mat stored like   0 3 5    
                              1 4
                                2   */
static void buildStandardOrientation(Molecule* mol,double* centerOfGravity, int* numberOfEquivalentAxes, double* inertialMoment, double axes[3][3])
{
	int i,j;
	double mat[6];
	double m;
	double mtot = 0.0;
	double x,y,z;
	double principalAxisTolerance = 1e-6;
	x = y = z =0.0;
	for (i=0;i<mol->nAtoms;i++)	  /* center of gravity and total mass */
	{
		/* m = sqrt(prime[atomList->type]);*/
		m = fabs(mol->atoms[i].mass);
		x += m* mol->atoms[i].coordinates[0];
		y += m* mol->atoms[i].coordinates[1];
		z += m* mol->atoms[i].coordinates[2];
		mtot += m;
	  }
	centerOfGravity[0] = x/mtot;
	centerOfGravity[1] = y/mtot;
	centerOfGravity[2] = z/mtot;
	
	for(i=0;i<6;i++) mat[i]=0.0;

	for (i=0;i<mol->nAtoms;i++)	  /* build up inertial tensor */
	{
		x = (mol->atoms[i].coordinates[0] -= centerOfGravity[0]);
		y = (mol->atoms[i].coordinates[1] -= centerOfGravity[1]);
		z = (mol->atoms[i].coordinates[2] -= centerOfGravity[2]);
		/* m = sqrt(prime[atomList->type]);*/
		m = fabs(mol->atoms[i].mass);
		mat[0] += m*(y*y+z*z);
		mat[1] += m*(x*x+z*z);
		mat[2] += m*(x*x+y*y);
		mat[3] -= m*(x*y);
		mat[4] -= m*(y*z);
		mat[5] -= m*(x*z);
	}

	jacobi(mat,axes);	  /* diagonalize tensor */

	/* sort eigenvalues */
	if (mat[0]<mat[1]) swap(0,1,mat,axes);
	if (mat[1]<mat[2]) swap(1,2,mat,axes);
	if (mat[0]<mat[1]) swap(0,1,mat,axes);

	inertialMoment[0] = mat[0];
	inertialMoment[1] = mat[1];
	inertialMoment[2] = mat[2];

	/* normalize moments if not pointlike */
	if (mat[0] > 1.E-8) 
	{
		mat[1] /= mat[0];
		mat[2] /= mat[0];
		mat[0] = 1.0;
	}

	if ((mat[1]-mat[2])*(mat[1]-mat[2])< principalAxisTolerance*principalAxisTolerance) swap(0,2,mat,axes); 

	/* determin number of equivalent axes */
	*numberOfEquivalentAxes = 1;  
	if ((mat[0]-mat[1])*(mat[0]-mat[1]) < principalAxisTolerance*principalAxisTolerance) (*numberOfEquivalentAxes)++; /* 2 axes equiv. */

	if ((mat[0]-mat[2])*(mat[0]-mat[2]) < principalAxisTolerance*principalAxisTolerance) (*numberOfEquivalentAxes)++; /* 3 axes equiv. */
	if (mat[2] < principalAxisTolerance) *numberOfEquivalentAxes = -*numberOfEquivalentAxes; /* linear or point */

	/* multiply atom vectors v_i by eigenvector matrix v_i' = v_i * V
	   to rotate molecule - principal axes will be equivalent to coordinate
	   axes
	 */
	for (i=0;i<mol->nAtoms;i++)	  /* perform rotation */
	{
		x = mol->atoms[i].coordinates[0];
		y = mol->atoms[i].coordinates[1];
		for (j=0;j<3;j++)
			mol->atoms[i].coordinates[j] = x*axes[0][j] + y*axes[1][j] + mol->atoms[i].coordinates[2]*axes[2][j];
	}
}
/*************************************************************************************************************************/
static char* saveFirstDerivatives(char* inputFileName, Molecule* mol)
{
	if(mol && mol->vibration.nModes>0 && mol->vibration.nProperties>=5)
	{
        	char* fileNameOut = strdup_printf("%sFirstDerivatives.txt",getSuffixNameFile(inputFileName));
        	FILE* file = fopen(fileNameOut,"w");
        	fprintf(stdout,"First derivatives saved in %s file\n", fileNameOut);
		mol->klass->addFirstDerivativeToFile(mol, file);
        	fclose(file);
		return fileNameOut;
	}
	return NULL;

}
/*************************************************************************************************************************/
static void computePseudoInertia(Molecule* mol, double*pI, double* pI4)
{
	int nAtoms = mol->nAtoms;
	if(nAtoms<1)
	{
		*pI = 0;
		*pI4 = 0;
		return;
	}
	int nTypes;
	char** types = getTypesOfAtoms(mol, &nTypes);
	int* m = malloc(nAtoms*sizeof(int));
	int* m4 = malloc(nAtoms*sizeof(int));
	double C[3];
	int i,j;

        for (j=0;j<3;j++) C[j] = 0;
        for (i=0;i<mol->nAtoms;i++)
	{
		m[i]=1;
		int it;
        	for (it=0;it<nTypes;it++)
		if(!strcmp(mol->atoms[i].prop.symbol,types[it]))
		{
			m[i]=it+1;
			m4[i]=nTypes-it;
			break;
		}
	}
	freeTypesOfAtoms(types,nTypes);

        for (i=0;i<mol->nAtoms;i++) for (j=0;j<3;j++) C[j] += mol->atoms[i].mass*mol->atoms[i].coordinates[j];
	double mt =0;
        for (i=0;i<mol->nAtoms;i++) mt += mol->atoms[i].mass;
	if(mt>0) for (j=0;j<3;j++) C[j] /= mt;

	double mt2 =0;
        for (i=0;i<mol->nAtoms;i++) mt2 += m[i];
	double mt4 =0;
        for (i=0;i<mol->nAtoms;i++) mt4 += m4[i];

	double I=0;
	double I4=0;
        for (i=0;i<mol->nAtoms;i++)
        {
		double d =0;
                for (j=0;j<3;j++)
                {
                	double dif= mol->atoms[i].coordinates[j]-C[j];
                	d += dif*dif;
                }
		I+= m[i]*d;
		I4+= m4[i]*d;
        }
	if(mt2>0) I /= mt2;
	if(mt4>0) I4 /= mt4;
	*pI = I;
	*pI4 = I4;
        if(m) free(m);
        if(m4) free(m4);
}
/****************************************************************************************************************************/
/* Jijun Zhao, Ruili Shi, Linwei Sai, Xiaoming Huang & Yan Su (2016)
 * Comprehensive genetic algorithm for ab initio global optimisation of clusters, Molecular Simulation,
 * 42:10, 809-819, DOI: 10.1080/08927022.2015.1121386
*/
static  boolean similarInertia(Molecule* mol1, Molecule* mol2, double precision)
{

	double I1,I2;
	double I41,I42;
	computePseudoInertia(mol1, &I1, &I41);
	computePseudoInertia(mol2, &I2, &I42);
	if(fabs(I2-I1)<precision && fabs(I42-I41)<precision) return TRUE;
	return FALSE;
}
File: ./cchemilib/src/MolecularMechanics/ForceField.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* ForceField.c */
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>

#include "../Utils/Utils.h"
#include "../Utils/CLProp.h"
#include "../Utils/AtomsProp.h"
#include "../Utils/Constants.h"
#include "../Utils/Types.h"
#include "../Molecule/Molecule.h"
#include "../MolecularMechanics/ForceField.h"
#include "../Utils/QL.h"

static void computeGradientNumeric(ForceField* forceField);
/**********************************************************************/
ForceField newForceField()
{
	int i;
	ForceField forceField;

	forceField.molecule = *(newMolecule());

	forceField.klass = malloc(sizeof(ForceFieldClass));
	forceField.klass->calculateGradient = NULL;
	forceField.klass->calculateGradientNumeric = computeGradientNumeric;
	forceField.klass->calculateEnergy = NULL;
	forceField.klass->calculateEnergyTmp = NULL;
	forceField.klass->printEnergies = NULL;


	forceField.numberOfRattleConstraintsTerms = 0;
	forceField.numberOfStretchTerms = 0;
	forceField.numberOfBendTerms = 0;
	forceField.numberOfStrBendTerms = 0;
	forceField.numberOfDihedralTerms = 0;
	forceField.numberOfImproperTorsionTerms = 0;
	forceField.numberOfOutOfPlaneTerms = 0;
	forceField.numberOfVdw612 = 0;
	forceField.numberOfVdw714 = 0;
	forceField.numberOfCoulomb = 0;
	forceField.numberOfHydrogenBonded = 0;
	forceField.numberOfSuttonChen = 0;

	for(i=0;i<STRETCHDIM;i++) forceField.bondStretchTerms[i] = NULL;

	for(i=0;i<BENDDIM;i++) forceField.angleBendTerms[i] = NULL;
	for(i=0;i<STRBENDDIM;i++) forceField.strBendTerms[i] = NULL;

	for(i=0;i<DIHEDRALDIM;i++) forceField.dihedralAngleTerms[i] = NULL;
	for(i=0;i<IMPROPERDIHEDRALDIM;i++) forceField.improperTorsionTerms[i] = NULL;
	for(i=0;i<OUTOFPLANEDIM;i++) forceField.outOfPlaneTerms[i] = NULL;

	for(i=0;i<VDW612DIM;i++) forceField.vdw612Terms[i] = NULL;
	for(i=0;i<VDW714DIM;i++) forceField.vdw714Terms[i] = NULL;
	for(i=0;i<COULOMBDIM;i++) forceField.coulombTerms[i] = NULL;
	for(i=0;i<HYDROGENBONDEDDIM;i++) forceField.hydrogenBondedTerms[i] = NULL;

	forceField.numberOfPairWise = 0;
	for(i=0;i<PAIRWISEDIM;i++)
		forceField.pairWiseTerms[i] = NULL;
	forceField.logfile = stdout;

	forceField.options.type = AMBER;
	forceField.options.coulomb = TRUE;
	forceField.options.numeric = FALSE;
	forceField.options.hydrogenBonded612 = FALSE;
	forceField.options.hydrogenBonded1012 = TRUE;
	forceField.options.hydrogenBondedMorse = FALSE;
	forceField.options.improperTorsion = TRUE;
	forceField.options.outOfPlane = TRUE;
	forceField.options.vdw612 = TRUE;
	forceField.options.vdw714 = TRUE;
	forceField.options.hbDirectional = FALSE;
	forceField.options.bondStretch = TRUE;
	forceField.options.angleBend = TRUE;
	forceField.options.rattleConstraints = NOCONSTRAINTS;
	forceField.options.dx = 1e-5;
	sprintf(forceField.options.chargesType,"DEFAULT");
	return forceField;

}
/**********************************************************************/
void freeForceField(ForceField* forceField)
{

	int i;
	forceField->molecule.klass->free(&forceField->molecule);

	if(forceField->klass != NULL)
	{
		free(forceField->klass);
		forceField->klass = NULL;
	}
	for(i=0;i<STRETCHDIM;i++)
		if(forceField->bondStretchTerms[i] !=NULL)
		{
			free(forceField->bondStretchTerms[i]);
			forceField->bondStretchTerms[i] = NULL;
		}
	for(i=0;i<BENDDIM;i++)
		if(forceField->angleBendTerms[i] != NULL)
		{
			free(forceField->angleBendTerms[i]);
			forceField->angleBendTerms[i] = NULL;
		}
	for(i=0;i<STRBENDDIM;i++)
		if(forceField->strBendTerms[i] != NULL)
		{
			free(forceField->strBendTerms[i]);
			forceField->strBendTerms[i] = NULL;
		}
	for(i=0;i<DIHEDRALDIM;i++)
		if(forceField->dihedralAngleTerms[i] != NULL)
		{
			free(forceField->dihedralAngleTerms[i]);
			forceField->dihedralAngleTerms[i] = NULL;
		}
	for(i=0;i<IMPROPERDIHEDRALDIM;i++)
	if(forceField->improperTorsionTerms[i] != NULL)
	{
		free(forceField->improperTorsionTerms[i]);
		forceField->improperTorsionTerms[i] = NULL;
	}

	for(i=0;i<OUTOFPLANEDIM;i++)
	if(forceField->outOfPlaneTerms[i] != NULL)
	{
		free(forceField->outOfPlaneTerms[i]);
		forceField->outOfPlaneTerms[i] = NULL;
	}

	for(i=0;i<VDW612DIM;i++)
		if(forceField->vdw612Terms[i] != NULL)
		{
			free(forceField->vdw612Terms[i]);
			forceField->vdw612Terms[i] = NULL;
		}
	for(i=0;i<VDW714DIM;i++)
		if(forceField->vdw714Terms[i] != NULL)
		{
			free(forceField->vdw714Terms[i]);
			forceField->vdw714Terms[i] = NULL;
		}


	for(i=0;i<COULOMBDIM;i++)
		if(forceField->coulombTerms[i] != NULL)
		{
			free(forceField->coulombTerms[i]);
			forceField->coulombTerms[i] = NULL;
		}
	for(i=0;i<HYDROGENBONDEDDIM;i++)
		if(forceField->hydrogenBondedTerms[i] != NULL)
		{
			free(forceField->hydrogenBondedTerms[i]);
			forceField->hydrogenBondedTerms[i] = NULL;
		}

	forceField->numberOfStretchTerms = 0;
	forceField->numberOfBendTerms = 0;
	forceField->numberOfStrBendTerms = 0;
	forceField->numberOfDihedralTerms = 0;
	forceField->numberOfImproperTorsionTerms = 0;
	forceField->numberOfVdw612 = 0;
	forceField->numberOfVdw714 = 0;
	forceField->numberOfCoulomb = 0;
	forceField->numberOfHydrogenBonded = 0;
	forceField->numberOfSuttonChen = 0;
	forceField->numberOfRattleConstraintsTerms = 0;

	for(i=0;i<PAIRWISEDIM;i++)
		if(forceField->pairWiseTerms[i] != NULL)
		{
			free(forceField->pairWiseTerms[i]);
			forceField->pairWiseTerms[i] = NULL;
		}
	forceField->numberOfPairWise = 0;
}
/*****************************************************************************/
ForceField copyForceField(ForceField* f)
{
	int i;
	int j;
	int k;
	ForceField forceField = newForceField();
#ifdef ENABLE_CL
	forceField = *f;
#endif

	forceField.molecule = *(f->molecule.klass->copy(&f->molecule));
	//printf("End copyMolecule\n");
	fflush(stdout);

	/* already in newForceField */
	/* forceField.klass = malloc(sizeof(ForceFieldClass));*/
	forceField.klass->calculateGradient = f->klass->calculateGradient;
	forceField.klass->calculateGradientNumeric = f->klass->calculateGradientNumeric;
	forceField.klass->calculateEnergy = f->klass->calculateEnergy;
	forceField.klass->calculateEnergyTmp = f->klass->calculateEnergyTmp;
	forceField.klass->printEnergies = f->klass->printEnergies;


	forceField.numberOfStretchTerms = f->numberOfStretchTerms;
	forceField.numberOfBendTerms = f->numberOfBendTerms;
	forceField.numberOfStrBendTerms = f->numberOfStrBendTerms;
	forceField.numberOfDihedralTerms = f->numberOfDihedralTerms;
	forceField.numberOfImproperTorsionTerms = f->numberOfImproperTorsionTerms;
	forceField.numberOfOutOfPlaneTerms = f->numberOfOutOfPlaneTerms;
	forceField.numberOfVdw612 = f->numberOfVdw612;
	forceField.numberOfVdw714 = f->numberOfVdw714;
	forceField.numberOfCoulomb = f->numberOfCoulomb;
	forceField.numberOfHydrogenBonded = f->numberOfHydrogenBonded;
	forceField.numberOfSuttonChen = f->numberOfSuttonChen;
	forceField.numberOfRattleConstraintsTerms = f->numberOfRattleConstraintsTerms;
	forceField.numberOfPairWise = f->numberOfPairWise;

	k = forceField.numberOfStretchTerms;
	if(k>0)
	for(i=0;i<STRETCHDIM;i++)
	{
		forceField.bondStretchTerms[i] = malloc(k*sizeof(double));
		for(j=0;j<k;j++) forceField.bondStretchTerms[i][j] = f->bondStretchTerms[i][j];
	}

	k = forceField.numberOfBendTerms;
	if(k>0)
	for(i=0;i<BENDDIM;i++)
	{
		forceField.angleBendTerms[i] = malloc(k*sizeof(double));
		for(j=0;j<k;j++) forceField.angleBendTerms[i][j] = f->angleBendTerms[i][j];
	}

	k = forceField.numberOfStrBendTerms;
	if(k>0)
	for(i=0;i<STRBENDDIM;i++)
	{
		forceField.strBendTerms[i] = malloc(k*sizeof(double));
		for(j=0;j<k;j++) forceField.strBendTerms[i][j] = f->strBendTerms[i][j];
	}


	k = forceField.numberOfDihedralTerms;
	if(k>0)
	for(i=0;i<DIHEDRALDIM;i++)
	{
		forceField.dihedralAngleTerms[i] = malloc(k*sizeof(double));
		for(j=0;j<k;j++) forceField.dihedralAngleTerms[i][j] = f->dihedralAngleTerms[i][j];
	}

	k = forceField.numberOfImproperTorsionTerms;
	if(k>0)
	for(i=0;i<IMPROPERDIHEDRALDIM;i++)
	{
		forceField.improperTorsionTerms[i] = malloc(k*sizeof(double));
		for(j=0;j<k;j++) forceField.improperTorsionTerms[i][j] = f->improperTorsionTerms[i][j];
	}

	k = forceField.numberOfOutOfPlaneTerms;
	if(k>0)
	for(i=0;i<OUTOFPLANEDIM;i++)
	{
		forceField.outOfPlaneTerms[i] = malloc(k*sizeof(double));
		for(j=0;j<k;j++) forceField.outOfPlaneTerms[i][j] = f->outOfPlaneTerms[i][j];
	}


	k = forceField.numberOfVdw612;
	if(k>0)
	for(i=0;i<VDW612DIM;i++)
	{
		forceField.vdw612Terms[i] = malloc(k*sizeof(double));
		for(j=0;j<k;j++) forceField.vdw612Terms[i][j] = f->vdw612Terms[i][j];
	}

	k = forceField.numberOfVdw714;
	if(k>0)
	for(i=0;i<VDW714DIM;i++)
	{
		forceField.vdw714Terms[i] = malloc(k*sizeof(double));
		for(j=0;j<k;j++) forceField.vdw714Terms[i][j] = f->vdw714Terms[i][j];
	}

	k = forceField.numberOfCoulomb;
	if(k>0)
	for(i=0;i<COULOMBDIM;i++)
	{
		forceField.coulombTerms[i] = malloc(k*sizeof(double));
		for(j=0;j<k;j++) forceField.coulombTerms[i][j] = f->coulombTerms[i][j];
	}


	k = forceField.numberOfHydrogenBonded;
	if(k>0)
	for(i=0;i<HYDROGENBONDEDDIM;i++)
	{
		forceField.hydrogenBondedTerms[i] = malloc(k*sizeof(double));
		for(j=0;j<k;j++) forceField.hydrogenBondedTerms[i][j] = f->hydrogenBondedTerms[i][j];
	}

	k = forceField.numberOfSuttonChen;
	if(k>0)
	for(i=0;i<SUTTONCHENDIM;i++)
	{
		forceField.suttonChenTerms[i] = malloc(k*sizeof(double));
		for(j=0;j<k;j++) forceField.suttonChenTerms[i][j] = f->suttonChenTerms[i][j];
	}

	k = forceField.numberOfPairWise = f->numberOfPairWise;
	if(k>0)
	for(i=0;i<PAIRWISEDIM;i++)
	{
		forceField.pairWiseTerms[i] = malloc(k*sizeof(double));
		for(j=0;j<k;j++) forceField.pairWiseTerms[i][j] = f->pairWiseTerms[i][j];
	}
	forceField.logfile = f->logfile;

	forceField.options.type = f->options.type;
	forceField.options.coulomb = f->options.coulomb;
	forceField.options.numeric = f->options.numeric;
	forceField.options.hydrogenBonded612 = f->options.hydrogenBonded612;
	forceField.options.hydrogenBonded1012 = f->options.hydrogenBonded1012;
	forceField.options.hydrogenBondedMorse = f->options.hydrogenBondedMorse;
	forceField.options.improperTorsion = f->options.improperTorsion;
	forceField.options.outOfPlane = f->options.outOfPlane;
	forceField.options.vdw612 = f->options.vdw612;
	forceField.options.vdw714 = f->options.vdw714;
	forceField.options.hbDirectional = f->options.hbDirectional;
	forceField.options.bondStretch = f->options.bondStretch;
	forceField.options.angleBend = f->options.angleBend;
	forceField.options.dihedralAngle = f->options.dihedralAngle;
	forceField.options.rattleConstraints = f->options.rattleConstraints;
	forceField.options.dx = f->options.dx;
	sprintf(forceField.options.chargesType,"%s",f->options.chargesType);

	return forceField;

}
/*****************************************************************************/
void setForceFieldOptions(FILE* file, ForceFieldOptions* forceFieldOptions)
{
	char* tmp = NULL;
	int itmp;
	//forceFieldOptions->type = PAIRWISE;
	forceFieldOptions->type = AMBER;
	forceFieldOptions->bondStretch = TRUE;
	forceFieldOptions->angleBend = TRUE;
	forceFieldOptions->dihedralAngle = TRUE;
	forceFieldOptions->improperTorsion = FALSE;
	forceFieldOptions->strBend = FALSE;
	forceFieldOptions->outOfPlane = FALSE;
	forceFieldOptions->vdw612 = TRUE;
	forceFieldOptions->vdw714 = FALSE;
	forceFieldOptions->hbDirectional = FALSE;
	forceFieldOptions->hydrogenBonded612 = FALSE;
	forceFieldOptions->hydrogenBonded1012 = FALSE;
	forceFieldOptions->hydrogenBondedMorse = FALSE;
	forceFieldOptions->coulomb = TRUE;
	forceFieldOptions->numeric = FALSE;
	forceFieldOptions->dx = 1e-5;
	sprintf(forceFieldOptions->chargesType,"DEFAULT");

	if(readOneInt(file,"ForceFieldType",&itmp)) forceFieldOptions->type = itmp;
	readOneBoolean(file,"ForceFieldUseBond",&forceFieldOptions->bondStretch);
	readOneBoolean(file,"ForceFieldUseBend",&forceFieldOptions->angleBend);
	readOneBoolean(file,"ForceFieldUseStrBend",&forceFieldOptions->strBend);
	readOneBoolean(file,"ForceFieldUseDihedral",&forceFieldOptions->dihedralAngle);
	readOneBoolean(file,"ForceFieldUseImproper",&forceFieldOptions->improperTorsion);
	readOneBoolean(file,"ForceFieldUseOutOfPlane",&forceFieldOptions->outOfPlane);
	readOneBoolean(file,"ForceFieldUseSuttonChen",&forceFieldOptions->suttonChen);
	readOneBoolean(file,"ForceFieldUseCoulomb",&forceFieldOptions->coulomb);
	readOneBoolean(file,"ForceFieldUseNumericalGradient",&forceFieldOptions->numeric);
	readOneString(file,"ForceFieldVanderWals",&tmp);
	if(tmp) uppercase(tmp);
	if(tmp && strstr(tmp,"NONE")) forceFieldOptions->vdw612=FALSE;
	if(tmp && strstr(tmp,"6-12")) { forceFieldOptions->vdw612=TRUE; forceFieldOptions->vdw714=FALSE;}
	if(tmp && strstr(tmp,"7-14")) { forceFieldOptions->vdw612=FALSE; forceFieldOptions->vdw714=TRUE;}
	if(tmp) free(tmp);

	tmp = NULL;
	readOneString(file,"Wall",&tmp);
	if(tmp)  forceFieldOptions->addWallCorrection = TRUE;
	if(tmp) free(tmp);
	tmp = NULL;

	readOneString(file,"ForceFieldHydrogenBonded",&tmp);
	if(tmp) uppercase(tmp);
	if(tmp && strstr(tmp,"NONE")) 
	{
		forceFieldOptions->hydrogenBonded612=FALSE; 
		forceFieldOptions->hydrogenBonded1012=FALSE; 
		forceFieldOptions->hydrogenBondedMorse=FALSE; 
		forceFieldOptions->hbDirectional = FALSE;
	}
	if(tmp && strstr(tmp,"10-12"))
	{
		forceFieldOptions->hydrogenBonded612=FALSE; 
		forceFieldOptions->hydrogenBonded1012=TRUE; 
		forceFieldOptions->hydrogenBondedMorse=FALSE; 
		forceFieldOptions->hbDirectional = FALSE;
	}
	if(tmp && strstr(tmp,"ANGLE-10-12"))
	{
		forceFieldOptions->hydrogenBonded612=FALSE;
		forceFieldOptions->hydrogenBonded1012=TRUE;
		forceFieldOptions->hydrogenBondedMorse=FALSE; 
		forceFieldOptions->hbDirectional = TRUE;
	}
	if(tmp && strstr(tmp,"6-12"))
	{
		forceFieldOptions->hydrogenBonded612=TRUE;
		forceFieldOptions->hydrogenBonded1012=FALSE;
		forceFieldOptions->hydrogenBondedMorse=FALSE; 
		forceFieldOptions->hbDirectional = FALSE;
	}
	if(tmp && strstr(tmp,"ANGLE-6-12"))
	{
		forceFieldOptions->hydrogenBonded612=TRUE;
		forceFieldOptions->hydrogenBonded1012=FALSE;
		forceFieldOptions->hydrogenBondedMorse=FALSE; 
		forceFieldOptions->hbDirectional = TRUE;
	}
	if(tmp && strstr(tmp,"MORSE"))
	{
		forceFieldOptions->hydrogenBonded612=FALSE;
		forceFieldOptions->hydrogenBonded1012=FALSE;
		forceFieldOptions->hydrogenBondedMorse=TRUE; 
		forceFieldOptions->hbDirectional = FALSE;
	}
	if(tmp && strstr(tmp,"ANGLE-MORSE"))
	{
		forceFieldOptions->hydrogenBonded612=FALSE;
		forceFieldOptions->hydrogenBonded1012=FALSE;
		forceFieldOptions->hydrogenBondedMorse=TRUE; 
		forceFieldOptions->hbDirectional = TRUE;
	}
	if(tmp) free(tmp);
	tmp = NULL;

	readOneString(file,"ForceFieldChargesType",&tmp);
	if(tmp) uppercase(tmp);
	if(tmp && strstr(tmp,"MM")) sprintf(forceFieldOptions->chargesType,"MM");
	if(tmp && strstr(tmp,"SCALED")) sprintf(forceFieldOptions->chargesType,"SCALED");
	if(tmp && strstr(tmp,"EEM")) sprintf(forceFieldOptions->chargesType,"EEM");
	if(tmp && strstr(tmp,"ACKH2")) sprintf(forceFieldOptions->chargesType,"ACKS2");
	if(tmp && strstr(tmp,"ACKS2")) sprintf(forceFieldOptions->chargesType,"ACKS2");
	if(tmp && strstr(tmp,"ACKS2-BEGIN")) sprintf(forceFieldOptions->chargesType,"ACKS2-BEGIN");
	if(tmp && strstr(tmp,"EEM-BEGIN")) sprintf(forceFieldOptions->chargesType,"EEM-BEGIN");
	if(tmp) free(tmp);
	tmp = NULL;
	

	forceFieldOptions->rattleConstraints = NOCONSTRAINTS;
	//forceFieldOptions->rattleConstraints = BONDSCONSTRAINTS;
	//forceFieldOptions->rattleConstraints = BONDSANGLESCONSTRAINTS;
	if(readOneInt(file,"Constraints",&itmp))forceFieldOptions->rattleConstraints = itmp;

	readOneReal(file,"dx",&forceFieldOptions->dx);

}
/**********************************************************************/
void updateGeometryVelocitiesCL(ForceField* forceField, Molecule* mol)
{
#ifdef ENABLE_CL
	int i;
	CLProp clProp = getCLProp();
	if(!mol) mol = &forceField->molecule;
	for(i=0;i<mol->nAtoms;i++)
	{
		forceField->atomsCPU[i].s[0] = mol->atoms[i].coordinates[0];
		forceField->atomsCPU[i].s[1] = mol->atoms[i].coordinates[1];
		forceField->atomsCPU[i].s[2] = mol->atoms[i].coordinates[2];
		forceField->atomsCPU[i].s[3] = mol->atoms[i].charge;
		forceField->atomsCPU[i].s[4] = mol->atoms[i].mass;
		//printf("Mass = %f\n",mol->atoms[i].mass);
		// velocity
		{
			forceField->atomsCPU[i].s[5] = mol->atoms[i].velocity[0];
			forceField->atomsCPU[i].s[6] = mol->atoms[i].velocity[1];
			forceField->atomsCPU[i].s[7] = mol->atoms[i].velocity[2];
		}
	}
	clEnqueueWriteBuffer(clProp.command_queue, forceField->atomsCL, CL_TRUE, 0, sizeof(cl_float8) * mol->nAtoms, forceField->atomsCPU, 0, NULL, NULL);
#endif
}
/**********************************************************************/
void updateGeometryCL(ForceField* forceField, Molecule* mol)
{
	updateGeometryVelocitiesCL(forceField, mol);
}
/**********************************************************************/
void getGeometryVelocitiesCL(ForceField* forceField, Molecule* mol)
{
#ifdef ENABLE_CL
	int i,j;
	CLProp clProp = getCLProp();
	if(!mol) mol = &forceField->molecule;
	clEnqueueReadBuffer(clProp.command_queue, forceField->atomsCL, CL_TRUE, 0, sizeof(cl_float8)* mol->nAtoms, forceField->atomsCPU, 0, NULL, NULL);
	for(i=0;i<mol->nAtoms;i++)
	{
		for(j=0;j<3;j++) mol->atoms[i].coordinates[j] = forceField->atomsCPU[i].s[j];
		// velocity
		for(j=0;j<3;j++) mol->atoms[i].velocity[j] = forceField->atomsCPU[i].s[j+5];
	}
#endif
}
/*****************************************************************************/
/* in Debye */
static void calculDipole(Molecule* mol, double D[])
{
	int i,k;
	for(k=0;k<3;k++) D[k] = 0;
	for(i=0;i<mol->nAtoms;i++)
	for(k=0;k<3;k++)
		D[k] += mol->atoms[i].charge*mol->atoms[i].coordinates[k];
	for(k=0;k<3;k++) D[k] *= ANGTOBOHR*AUTODEB;
}
/*****************************************************************************/
static void copyGradients(Molecule* mol, double* g[])
{
	int i,k;
	if(!mol) return;
	for(i=0;i<mol->nAtoms;i++)
		for(k=0;k<3;k++)
			g[k][i] = mol->atoms[i].gradient[k];
}
/*****************************************************************************/
static void sortFrequencies(int nModes, double* frequencies, double** modes, double* reducedMasses, double* IRIntensities)
{
	int i;
	int j;
	int k;
	double dum;
	if(nModes<1 || !frequencies || !modes || !reducedMasses || !IRIntensities) return;
	for(i=0;i<nModes;i++)
	{
		k = i;
		for(j=i+1;j<nModes;j++)
			if(frequencies[j]<frequencies[k]) k = j;
		if(k==i) continue;
		/* swap i and k modes */
		dum = frequencies[i];
		frequencies[i] = frequencies[k];
		frequencies[k] = dum;
		dum = reducedMasses[i];
		reducedMasses[i] = reducedMasses[k];
		reducedMasses[k] = dum;
		dum = IRIntensities[i];
		IRIntensities[i] = IRIntensities[k];
		IRIntensities[k] = dum;
		for(j=0;j<nModes;j++)
		{
			dum =  modes[j][i];
			modes[j][i] = modes[j][k];
			modes[j][k] = dum;
		}
	}
}

/*****************************************************************************/
int computeMMFrequencies(ForceField* forceField, double** frequencies, double*** modes, double** reducedMasses, double** IRIntensities)
{
	int i;
	int j;
	int k;
	int c;
	int id,jd,index;
	double* F;
	double* gp[3];
	double* gm[3];
	double* dmuX[3];
	Molecule* mol;
	int nAtoms;
	double Dp[3];
	double Dm[3];
	double dx;

	if(!forceField || forceField->molecule.nAtoms<1) return 0;
	dx = forceField->options.dx;

	//printf("Begin calcul F\n");

	mol = &forceField->molecule;
	nAtoms = mol->nAtoms;
	for(k=0;k<3;k++) gp[k] = malloc(nAtoms*sizeof(double));
	for(k=0;k<3;k++) gm[k] = malloc(nAtoms*sizeof(double));
	for(k=0;k<3;k++) dmuX[k] = malloc(3*nAtoms*sizeof(double));

	F = malloc(3*nAtoms*(3*nAtoms+1)/2*sizeof(double));

	//printf("End alloc calcul F\n");

	index = 0;
	for(i=0;i<nAtoms;i++)
	for(k=0;k<3;k++)
	{
		id=3*i+k;
		mol->atoms[i].coordinates[k] += dx;
		forceField->klass->calculateGradient(forceField);
		copyGradients(mol, gp);
		calculDipole(mol, Dp);

		mol->atoms[i].coordinates[k] -= 2*dx;
		forceField->klass->calculateGradient(forceField);
		copyGradients(mol, gm);
		calculDipole(mol, Dm);

		for(c = 0;c<3;c++) dmuX[c][id] = (Dp[c]-Dm[c])/dx/2;
		mol->atoms[i].coordinates[k] += dx;
		for(j=0;j<=i;j++)
		{
			double invm = 1.0/sqrt( mol->atoms[i].mass* mol->atoms[j].mass);
			for(c = 0;c<3;c++) 
			{
				jd = 3*j+c;
				if(jd>id) continue;
				index = jd + id*(id+1)/2;
				F[index] = (gp[c][j]-gm[c][j])/dx/2; 
				F[index] *= invm;
			}
		}
	}
	//printf("En calcul F\n");
	for(k=0;k<3;k++) free(gp[k]);
	for(k=0;k<3;k++) free(gm[k]);
	*frequencies = malloc(3*nAtoms*sizeof(double));
	*reducedMasses = malloc(3*nAtoms*sizeof(double));
	*IRIntensities = malloc(3*nAtoms*sizeof(double));
	*modes = malloc(3*nAtoms*sizeof(double*));
	for(i=0;i<3*nAtoms;i++) (*modes)[i] = malloc(3*nAtoms*sizeof(double));

	eigenQL(3*nAtoms, F, *frequencies, *modes);
	free(F);
	/* convert in atomic unit  from kcal/Ang^2/amu */
	for(i=0;i<3*nAtoms;i++) (*frequencies)[i] *= 1.59360150e-03*0.529177*0.529177*5.48579911e-04; 
	/* convert frequencies in cm-1 */
	for(i=0;i<3*nAtoms;i++) 
		if( (*frequencies)[i]>0) (*frequencies)[i] = sqrt((*frequencies)[i])*219474.63633664;
		else (*frequencies)[i] = -sqrt(-(*frequencies)[i])*219474.63633664;

	/* compute the IR intensities */
	for(i=0;i<nAtoms;i++)
	for(k=0;k<3;k++)
	{
		int id=3*i+k;
		double IRI = 0;
		double D[3] = {0,0,0};
		int kp;
		for(c = 0;c<3;c++)
		for(j=0;j<nAtoms;j++)
		for(kp = 0;kp<3;kp++) 
		{
			int jd = 3*j+kp;
			double Lji = (*modes)[jd][id];
			double a=dmuX[c][jd]*Lji/sqrt(mol->atoms[j].mass);
			D[c]+=a;
		}
		IRI = 0;
		for(c = 0;c<3;c++)  IRI+= D[c]*D[c];
		(*IRIntensities)[id] = IRI;
	}
	for(k=0;k<3;k++) free(dmuX[k]);
	/* Intensities in 1 (D/Ang)^2 amu^-1 = 42.255 km/mol=171.65 cm^-2 atm^-1 at 0 C and 1 atm */
	/* Refs : D. Porezag and M. R. Pederson, Phys. Rev. B 54, 7830 (1996). and Y. Yamaguchi el al., J. Chem. Phys. 84,2262(1986)*/
	/* conversion in km/mol*/
	for(i=0;i<3*nAtoms;i++) (*IRIntensities)[i] *= 42.255;

	/* compute the reduced mass */
	for(i=0;i<3*nAtoms;i++) 
	{
		double m = 0;
		for(j=0;j<mol->nAtoms;j++)
		{
			double r2 = 0;
			for(c=0;c<3;c++) r2+= (*modes)[3*j+c][i]*(*modes)[3*j+c][i];
			m+= r2/(mol->atoms[j].mass); 
		}
		if(m<=0) m = 1;
		m = 1/m;
		for(j=0;j<mol->nAtoms;j++)
		{
			double r =sqrt(m)/sqrt(mol->atoms[j].mass);
			for(c=0;c<3;c++) (*modes)[3*j+c][i]*=r;
		}

		(*reducedMasses)[i] = m;
	}
	sortFrequencies(3*nAtoms, *frequencies, *modes, *reducedMasses, *IRIntensities);

	return 3*nAtoms;

}
/*****************************************************************************/
static void computeGradientNumeric(ForceField* forceField)
{
	int i;
	int k;
	Molecule* mol;
	int nAtoms;
	double Ep, Em;
	double dx;

	if(!forceField || forceField->molecule.nAtoms<1) return;
	dx = forceField->options.dx;

	mol = &forceField->molecule;
	nAtoms = mol->nAtoms;
	for(i=0;i<nAtoms;i++)
	for(k=0;k<3;k++)
		mol->atoms[i].gradient[k] = 0.0;

	for(i=0;i<nAtoms;i++)
	for(k=0;k<3;k++)
	{
		mol->atoms[i].coordinates[k] += dx;
		forceField->klass->calculateEnergy(forceField);
		Ep = mol->potentialEnergy;
		

		mol->atoms[i].coordinates[k] -= 2*dx;
		forceField->klass->calculateEnergy(forceField);
		Em = mol->potentialEnergy;

		mol->atoms[i].gradient[k] = (Ep-Em)/dx/2;
		mol->atoms[i].coordinates[k] += dx;
	}
	forceField->klass->calculateEnergy(forceField);
	//printf("End computeGradientNumeric\n");
}
/*****************************************************************************/
File: ./cchemilib/src/MolecularMechanics/SteepestDescent.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* SteepestDescent.c  */
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>

#include "../Utils/Utils.h"
#include "../Utils/AtomsProp.h"
#include "../Utils/Constants.h"
#include "../Utils/Types.h"
#include "../Molecule/Molecule.h"
#include "../MolecularMechanics/SteepestDescent.h"

static void Minimize(SteepestDescent* steepestDescent);
/**********************************************************************/
void	runSteepestDescent(
		SteepestDescent* steepestDescent, ForceField* forceField, 
		int updateFrequency, int maxIterations, double epsilon,
		int maxLines
		)
{

	steepestDescent->forceField = forceField;
	steepestDescent->numberOfAtoms = forceField->molecule.nAtoms;
	steepestDescent->updateFrequency = updateFrequency;
	steepestDescent->maxIterations = maxIterations;
	steepestDescent->updateNumber = 0;
	steepestDescent->epsilon = epsilon;
	steepestDescent->rmsDeplacment = 0;
	steepestDescent->maxDeplacment = 0;
	steepestDescent->gradientNorm = 0;
	steepestDescent->maxLines=maxLines;

	Minimize(steepestDescent);
}
/**********************************************************************/
void	freeSteepestDescent(SteepestDescent* steepestDescent)
{

	steepestDescent->forceField = NULL;
	steepestDescent->numberOfAtoms = 0;
	steepestDescent->updateFrequency = 0;
	steepestDescent->maxIterations = 0;
	steepestDescent->updateNumber = 0;
	steepestDescent->epsilon = 0;
	steepestDescent->rmsDeplacment = 0;
	steepestDescent->maxDeplacment = 0;
	steepestDescent->gradientNorm = 0;
	steepestDescent->maxLines=0;

}
/**********************************************************************/
static void Minimize(SteepestDescent* steepestDescent)
{
	double energy;
	int iteration = 0;
	double lastGradientNorm = 1;
	double term = 1;
	char* str = strdup(" ");
	int i;
	int j;
	double f0,f1;
	int ii;
	double fg;

	steepestDescent->updateNumber = 0;

	steepestDescent->forceField->klass->calculateGradient(steepestDescent->forceField);

	steepestDescent->gradientNorm = 0;
	for (  i = 0; i < steepestDescent->numberOfAtoms; i++ )
		for(j=0;j<3;j++)
			steepestDescent->gradientNorm += 
				steepestDescent->forceField->molecule.atoms[i].gradient[j] *
				steepestDescent->forceField->molecule.atoms[i].gradient[j]; 

	lastGradientNorm = sqrt( steepestDescent->gradientNorm );

	while( 
			( lastGradientNorm > steepestDescent->epsilon ) && 
			( iteration++ < steepestDescent->maxIterations )
	     )
	{

		steepestDescent->forceField->klass->calculateGradient(steepestDescent->forceField);
		steepestDescent->gradientNorm = 0;
		for (  i = 0; i < steepestDescent->numberOfAtoms; i++ )
			for(j=0;j<3;j++)
				steepestDescent->gradientNorm += 
					steepestDescent->forceField->molecule.atoms[i].gradient[j] *
					steepestDescent->forceField->molecule.atoms[i].gradient[j]; 

		steepestDescent->gradientNorm = sqrt( steepestDescent->gradientNorm );
		
	
		if(steepestDescent->gradientNorm<1e-12)
			break;

        	f0 = steepestDescent->forceField->klass->calculateEnergyTmp(
		      steepestDescent->forceField,&steepestDescent->forceField->molecule);
		term = 0;
		fg = 1.0;
		if(steepestDescent->gradientNorm>1)
			fg = 1.0/steepestDescent->gradientNorm;

		for(ii=steepestDescent->maxLines;ii>=1;ii--)
		{
			term = ii*0.01;
			for (  i = 0; i < steepestDescent->numberOfAtoms; i++ )
			{
				for(j=0;j<3;j++)
					steepestDescent->forceField->molecule.atoms[i].coordinates[j]-=
					fg*term*steepestDescent->forceField->molecule.atoms[i].gradient[j]; 
			}
			updateGeometryCL(steepestDescent->forceField,NULL);

        		f1 = steepestDescent->forceField->klass->calculateEnergyTmp(
		      	steepestDescent->forceField,&steepestDescent->forceField->molecule);
			if(f1<f0)
				break;
			for (  i = 0; i < steepestDescent->numberOfAtoms; i++ )
			{
				for(j=0;j<3;j++)
					steepestDescent->forceField->molecule.atoms[i].coordinates[ j ] += 
					fg*term*steepestDescent->forceField->molecule.atoms[i].gradient[j]; 
			}
			updateGeometryCL(steepestDescent->forceField,NULL);
		}
		if(ii<=1)
			break;
		lastGradientNorm = steepestDescent->gradientNorm;

		if ( steepestDescent->updateNumber++ >= steepestDescent->updateFrequency )
		{
			free(str);
			str = strdup_printf(("Gradient = %f "),(double)steepestDescent->gradientNorm); 
			/* redrawMolecule(&steepestDescent->forceField->molecule,str);*/
			fprintf(steepestDescent->logfile,"%s\n",str);
			fflush(steepestDescent->logfile);
			steepestDescent->updateNumber = 0;
		}
	}

	steepestDescent->forceField->klass->calculateGradient(steepestDescent->forceField);
	steepestDescent->gradientNorm = 0;
	for (  i = 0; i < steepestDescent->numberOfAtoms; i++ )
		for(j=0;j<3;j++)
			steepestDescent->gradientNorm += 
				steepestDescent->forceField->molecule.atoms[i].gradient[j] *
				steepestDescent->forceField->molecule.atoms[i].gradient[j]; 

	steepestDescent->gradientNorm = sqrt( steepestDescent->gradientNorm );
        energy = steepestDescent->forceField->klass->calculateEnergyTmp(
		      steepestDescent->forceField,&steepestDescent->forceField->molecule);
	free(str);
	str = strdup_printf(("Gradient = %f  Energy = %f (Kcal/mol)"),
			(double)steepestDescent->gradientNorm,(double)energy); 

	/* redrawMolecule(&steepestDescent->forceField->molecule,str);*/
	fprintf(steepestDescent->logfile,"%s\n",str);
	fflush(steepestDescent->logfile);
	free(str);
}
/********************************************************************************/
File: ./cchemilib/src/MolecularMechanics/MolecularDynamics.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* MolecularDynamics.c  */
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <time.h>

#ifdef ENABLE_MPI
#include <mpi.h>
#endif

#include "../Utils/Utils.h"
#include "../Utils/AtomsProp.h"
#include "../Utils/Constants.h"
#include "../Utils/Timer.h"
#include "../Utils/Types.h"
#include "../Molecule/Molecule.h"
#include "../MolecularMechanics/MolecularDynamics.h"
#include "../MolecularMechanics/MolecularMechanics.h"
#ifdef ENABLE_CL
#include "../Utils/CLProp.h"
#include "../MolecularMechanics/MolecularDynamicsCL.h"
#endif


/*********************************************************************************/
static void initMD(MolecularDynamics* molecularDynamics, double temperature, double stepSize, MDIntegratorType integratorType, MDThermostatType thermostat, double friction, double omegaMax, int Nf, double collide, double qNH, char* fileNameTraj, char* fileNameProp, int numberOfRunSteps, int index);
static void berendsen(MolecularDynamics* molecularDynamics);
static void scaleV(MolecularDynamics* molecularDynamics);
static void andersen(MolecularDynamics* molecularDynamics);
static void bussi(MolecularDynamics* molecularDynamics);
static void nose_hoover(MolecularDynamics* molecularDynamics);
static void rescaleVelocities(MolecularDynamics* molecularDynamics);
static void computeEnergies(MolecularDynamics* molecularDynamics);
static void applyLangevin(MolecularDynamics* molecularDynamics);
static void updateLangevin(MolecularDynamics* molecularDynamics);
static void resetLangevin(MolecularDynamics* molecularDynamics);
static void applyQTB(MolecularDynamics* molecularDynamics);
static void updateQTB(MolecularDynamics* molecularDynamics);
static void resetQTB(MolecularDynamics* molecularDynamics);
static void applyOneStep(MolecularDynamics* molecularDynamics, int iStep);
static void applyThermostat(MolecularDynamics* molecularDynamics);
static void applyVerlet(MolecularDynamics* molecularDynamics);
static void applyMartynaTuckerman(MolecularDynamics* molecularDynamics);
static void applyBeeman(MolecularDynamics* molecularDynamics);
static void applyStochastic(MolecularDynamics* molecularDynamics);
static void newProperties(MolecularDynamics* molecularDynamics, char* comments);
static void saveProperties(MolecularDynamics* molecularDynamics, int iStep0, int iStep, char* comments);
static void saveTrajectory(MolecularDynamics* molecularDynamics, int iStep);
static double getEKin(MolecularDynamics* molecularDynamics);
static double getKelvin(MolecularDynamics* molecularDynamics);
static void removeTranslationAndRotation(MolecularDynamics* molecularDynamics);
#ifdef ENABLE_CL
static void scaleCLVelocities(MolecularDynamics* molecularDynamics, double scale);
#endif

/**********************************************************************/
#ifdef ENABLE_CL
void resetRandomNumbers(MolecularDynamics* molecularDynamics)
{
	size_t global =  molecularDynamics->nRandomsCL;
	cl_int err;
	CLProp clProp = getCLProp();
	err = clEnqueueNDRangeKernel(clProp.command_queue, molecularDynamics->generateRandomNumbers, 1, NULL, &global, NULL, 0, NULL, NULL);
	if(err != CL_SUCCESS)
	{
		printErrorCLRun(err);
       		printf("I cannot execute generateRandomNumbers\n");
		exit(1);
	}
/*
	clFinish(clProp.command_queue);
	{
		int i;
		cl_float4 r[molecularDynamics->forceField->molecule.nAtoms*2];
		clEnqueueReadBuffer(clProp.command_queue, molecularDynamics->randomsCL, CL_TRUE, 0, sizeof(cl_float4)*molecularDynamics->forceField->molecule.nAtoms*2, r, 0, NULL, NULL);
		for(i=0;i<molecularDynamics->forceField->molecule.nAtoms*2;i++)
		printf("rrrrrrrrrrr=%f %f %f %f\n",r[i].s[0], r[i].s[1], r[i].s[2], r[i].s[3]);
	}
*/
}
void initRandomNumberGenerator(MolecularDynamics* molecularDynamics, unsigned int randomNumberSeed)
{
	int n = molecularDynamics->forceField->molecule.nAtoms*2;
	cl_uint4* seed = malloc(sizeof(cl_uint4)*n);
	unsigned int r = randomNumberSeed;
	cl_int err;
	CLProp clProp = getCLProp();
	int i;
	for (i = 0; i < n; i++)
	{
        	seed[i].x = r = (1664525*r + 1013904223) & 0xFFFFFFFF;
        	seed[i].y = r = (1664525*r + 1013904223) & 0xFFFFFFFF;
        	seed[i].z = r = (1664525*r + 1013904223) & 0xFFFFFFFF;
        	seed[i].w = r = (1664525*r + 1013904223) & 0xFFFFFFFF;
	}
	molecularDynamics->seedCL = clCreateBuffer(clProp.context, CL_MEM_READ_WRITE, sizeof(cl_uint4) * n, NULL, NULL);
	molecularDynamics->randomsCL = clCreateBuffer(clProp.context, CL_MEM_READ_WRITE, sizeof(cl_float4) * n, NULL, NULL);
	molecularDynamics->nRandomsCL = n;
	clEnqueueWriteBuffer(clProp.command_queue, molecularDynamics->seedCL, CL_TRUE, 0, sizeof(cl_uint4) * n, seed, 0, NULL, NULL);
	free(seed);

	molecularDynamics->generateRandomNumbers = clCreateKernel(molecularDynamics->programMD, "generateRandomNumbers", &err);
	clSetKernelArg(molecularDynamics->generateRandomNumbers, 0, sizeof(cl_mem),   &molecularDynamics->randomsCL);
	clSetKernelArg(molecularDynamics->generateRandomNumbers, 1, sizeof(cl_mem),   &molecularDynamics->seedCL);
	clSetKernelArg(molecularDynamics->generateRandomNumbers, 2, sizeof(cl_int), &n);

	resetRandomNumbers(molecularDynamics);
}
#endif
/**********************************************************************************************************/
// return # temperatures
static int getNumExchangeReplica(double* energies, double* temperatures, int nTemperatures, int* numMDForTemperatures)
{
	int it = rand()%(nTemperatures-1);
	int n = numMDForTemperatures[it];
	int next = numMDForTemperatures[it+1];
	double delta = (1.0/(Kb*temperatures[n])- 1.0/(Kb*temperatures[next]))*(energies[n]-energies[next]);
	boolean exchange= FALSE;
	printf("n=%d next=%d delta = %f\n",n,next, delta);
	if(delta<0) exchange= TRUE;
	else
	{
		if(rand()/(double)RAND_MAX>exp(-delta)) exchange = TRUE;
	}
	if(exchange) return it;
	else return -1;
}
/*****************************************************************************************************************/
static void applyExchangeReplica(MolecularDynamics* md, int nTemperatures, int n, int next)
{
	double r;
	int i,j;
	double t;
	FILE* f;
	r = sqrt(md[next].temperature/md[n].temperature);
	/* exchange temperatures */
	t = md[n].temperature;
	md[n].temperature = md[next].temperature;
	md[next].temperature = t;
	/* exchange filesoutput */
	f = md[n].fileProp;
	md[n].fileProp = md[next].fileProp;
	md[next].fileProp = f;

	f = md[n].fileTraj;
	md[n].fileTraj = md[next].fileTraj;
	md[next].fileTraj = f;

	/* scale velocity */
	for ( i = 0; i < md[n].numberOfAtoms; i++)
	{
		for ( j = 0; j < 3; j++)
		{
			 md[n].forceField->molecule.atoms[i].velocity[j] *= r;
			 md[next].forceField->molecule.atoms[i].velocity[j] /= r;
		}
	}
#ifdef ENABLE_CL
	scaleCLVelocities(&md[n], r);
	scaleCLVelocities(&md[next], 1.0/r);
#endif
	removeTranslationAndRotation(&md[n]);
	removeTranslationAndRotation(&md[next]);
	resetQTB(&md[n]);
	resetQTB(&md[next]);
	resetLangevin(&md[n]);
	resetLangevin(&md[next]);
}
/*****************************************************************************************************************/
static void changeOneReplica(MolecularDynamics* md, int n, double newTemperature, char* fileNamePrefixProp,  char* fileNamePrefixTraj)
{
	double r;
	int i,j;
	char*  fileNameProp = NULL;
	char*  fileNameTraj = NULL;
	r = sqrt(newTemperature/md[n].temperature);
	/* change temperature */
//	printf("Old temp = %f newTemp = %f\n", md[n].temperature, newTemperature);
	md[n].temperature = newTemperature;
	/* close old file and open file for new temperture*/
	if(fileNamePrefixProp) fileNameProp = strdup_printf("%s%0.0f.txt", fileNamePrefixProp, newTemperature);
	if(fileNamePrefixTraj)  fileNameTraj = strdup_printf("%s%0.0f.gab", fileNamePrefixTraj, newTemperature);
	if(fileNameProp) md[n].fileProp = fopen(fileNameProp,"a");
	if(fileNameTraj) md[n].fileTraj = fopen(fileNameTraj,"a");

	/* scale velocity */
	for ( i = 0; i < md[n].numberOfAtoms; i++)
	{
		for ( j = 0; j < 3; j++)
			 md[n].forceField->molecule.atoms[i].velocity[j] *= r;
	}
#ifdef ENABLE_CL
	scaleCLVelocities(&md[n], r);
#endif
	removeTranslationAndRotation(&md[n]);
	if(fileNameProp) free(fileNameProp);
	if(fileNameTraj) free(fileNameTraj);
}
/**********************************************************************/
/*
static void exchangeReplicaLocalAll(MolecularDynamics* md, int nTemperatures, int* numMDForTemperatures)
{
	int it = rand()%(nTemperatures-1);
	int n = numMDForTemperatures[it];
	int next =  numMDForTemperatures[it+1];
	double delta = (1.0/(Kb*md[n].temperature)- 1.0/(Kb*md[next].temperature))*(md[n].potentialEnergy-md[next].potentialEnergy);
	boolean exchange= FALSE;
	double t;
	double r = 1.0;
	int i,j;
	FILE* f;
	printf("n=%d delta = %f\n",n,delta);
	if(delta<0) exchange= TRUE;
	else
	{
		if(rand()/(double)RAND_MAX>exp(-delta)) exchange = TRUE;
	}
	if(!exchange)return;
	r = sqrt(md[next].temperature/md[n].temperature);
	t = md[n].temperature;
	md[n].temperature = md[next].temperature;
	md[next].temperature = t;
	numMDForTemperatures[it]=next;
	numMDForTemperatures[it+1]=n;
	f = md[n].fileProp;
	md[n].fileProp = md[next].fileProp;
	md[next].fileProp = f;
	f = md[n].fileTraj;
	md[n].fileTraj = md[next].fileTraj;
	md[next].fileTraj = f;

	for ( i = 0; i < md[n].numberOfAtoms; i++)
	{
		for ( j = 0; j < 3; j++)
		{
			 md[n].forceField->molecule.atoms[i].velocity[j] *= r;
			 md[next].forceField->molecule.atoms[i].velocity[j] /= r;
		}
	}
#ifdef ENABLE_CL
	scaleCLVelocities(&md[n], r);
	scaleCLVelocities(&md[next], 1.0/r);
#endif
	removeTranslationAndRotation(&md[n]);
	removeTranslationAndRotation(&md[next]);
}
*/
/**********************************************************************/
static void exchangeReplica(MolecularDynamics* md,  double* energiesAll, double* energies,  double* temperaturesAll, int* numMDForTemperatures, int* nTemperaturesLocal,
	int nTemperaturesAll, int nTemperatures, int nproc, int rank, int iBegin, char* fileNamePrefixProp, char* fileNamePrefixTraj)
{
	if(nproc ==1) 
	{
		//exchangeReplicaLocalAll(md, nTemperatures, numMDForTemperatures);
		int n=-1,next=-1;
		int it;
		int k;
		for(k=0;k<nTemperatures;k++) energiesAll[k] = md[k].potentialEnergy;
		it = getNumExchangeReplica(energiesAll, temperaturesAll, nTemperaturesAll, numMDForTemperatures);
		if(it>=0)
		{
			n = numMDForTemperatures[it];
			next = numMDForTemperatures[it+1];
			numMDForTemperatures[it]=next;
			numMDForTemperatures[it+1]=n;
		}
		if(n>=0 && n<nTemperatures && next>=0 && next<nTemperatures)
		{
			applyExchangeReplica(md, nTemperatures, n,next);
		}
	}
	else
	{
		if(rank==0)
		{
#ifdef ENABLE_MPI
			MPI_Status status ;
			int dum;
			int code;
			int tag=100;
#endif
			int it;
			int n=-1,next=-1;
			int ii;
			int k;
			int j;
			for(k=0;k<nTemperatures;k++) energiesAll[k] = md[k].potentialEnergy;
			for(j=1;j<nproc;j++) 
			{
#if DEBUG
				fprintf(md[0].forceField->logfile, "Get energies from rank %d\n",j);
#endif
#ifdef ENABLE_MPI
				code = MPI_Recv(energies,nTemperaturesLocal[j],MPI_DOUBLE,j,tag,MPI_COMM_WORLD,&status) ;
#endif
#if DEBUG
				fprintf(md[0].forceField->logfile, "End Get energies from rank %d\n",j);
#endif
				for(ii=0;ii<nTemperaturesLocal[j];ii++) energiesAll[k++] = energies[ii];
			}
			it = getNumExchangeReplica(energiesAll, temperaturesAll, nTemperaturesAll, numMDForTemperatures);
#if DEBUG
			fprintf(md[0].forceField->logfile, "\n\nn=%d\n",it);
#endif
			if(it>=0)
			{
				n = numMDForTemperatures[it];
				next = numMDForTemperatures[it+1];
				numMDForTemperatures[it]=next;
				numMDForTemperatures[it+1]=n;
			}
			// send it to all others 
#ifdef ENABLE_MPI
			tag = 200;
#endif
#if DEBUG
			fprintf(md[0].forceField->logfile, "Send n from 0 to all others rank\n");
#endif
#ifdef ENABLE_MPI
			for(j=1;j<nproc;j++) code = MPI_Send(&it,1,MPI_INT,j,tag,MPI_COMM_WORLD) ;
#endif
#if DEBUG
			fprintf(md[0].forceField->logfile, "End Send n from 0 to all others rank\n");
#endif
			// close file for n and next if nessesary
			if(n>=0 && n<nTemperatures && (next<0 || next>=nTemperatures))
			{
				 if(md[n].fileProp) fclose(md[n].fileProp);
				 if(md[n].fileTraj) fclose(md[n].fileTraj);
			}
			if(next>=0 && next<nTemperatures && (n<0||n>=nTemperatures) )
			{
				 if(md[next].fileProp) fclose(md[next].fileProp);
				 if(md[next].fileTraj) fclose(md[next].fileTraj);
			}
#ifdef ENABLE_MPI
			tag = 300;
			for(j=1;j<nproc;j++) 
			{
#if DEBUG
				fprintf(md[0].forceField->logfile, "Get dum val for check close file at rank %d\n",j);
#endif
				code = MPI_Recv(&dum,1,MPI_INT,j,tag,MPI_COMM_WORLD,&status) ;
#if DEBUG
				fprintf(md[0].forceField->logfile, "End Get dum val for check close file at rank %d\n",j);
#endif
			}
#endif
			/// all files closed on other rank
#if DEBUG
			fprintf(md[0].forceField->logfile, "Send n from 0 to all others rank\n");
#endif
#ifdef ENABLE_MPI
			tag = 400;
			for(j=1;j<nproc;j++) code = MPI_Send(&it,1,MPI_INT,j,tag,MPI_COMM_WORLD) ;
#endif

			if(n>=0 && n<nTemperatures && next>=0 && next<nTemperatures)
			{
#if DEBUG
				fprintf(md[0].forceField->logfile, " Exchange between 2 trajs on one proc rank = 0\n");
#endif
				// 2 trajs on one proc
				applyExchangeReplica(md, nTemperatures, n,next);
			}
			else 
			{
				if(n>=0 && n<nTemperatures) changeOneReplica(md,  n, temperaturesAll[it+1], fileNamePrefixProp, fileNamePrefixTraj);
				if(next>=0 && next<nTemperatures) changeOneReplica(md, next, temperaturesAll[it], fileNamePrefixProp, fileNamePrefixTraj);
			}
		}
#ifdef ENABLE_MPI
		else
		{
			int code, tag=100;
			MPI_Status status ;
			int it;
			int n=-1,next=-1;
			int k;
			for(k=0;k<nTemperatures;k++) energies[k] = md[k].potentialEnergy;
#if DEBUG
			fprintf(md[0].forceField->logfile, "Send energies from %d to 0\n",rank);
#endif
			code = MPI_Send(energies,nTemperatures,MPI_DOUBLE,0,tag,MPI_COMM_WORLD) ;
#if DEBUG
			fprintf(md[0].forceField->logfile, "End Send energies from %d to 0\n",rank);
#endif
			tag = 200;
			code = MPI_Recv(&it,1,MPI_INT,0,tag,MPI_COMM_WORLD,&status) ;
			if(it>=0)
			{
				n = numMDForTemperatures[it];
				next = numMDForTemperatures[it+1];
				numMDForTemperatures[it]=next;
				numMDForTemperatures[it+1]=n;
			}
			n -= iBegin;
			next -= iBegin;
			// close file for n and next if nessesar
			if(n>=0 && n<nTemperatures && (next<0 || next>=nTemperatures))
			{
				 if(md[n].fileProp) fclose(md[n].fileProp);
				 if(md[n].fileTraj) fclose(md[n].fileTraj);
			}
			if(next>=0 && next<nTemperatures && (n<0||n>=nTemperatures) )
			{
				 if(md[next].fileProp) fclose(md[next].fileProp);
				 if(md[next].fileTraj) fclose(md[next].fileTraj);
			}
			// send to 0 for tell it all files closed
			tag = 300;
			code = MPI_Send(&it,1,MPI_INT,0,tag,MPI_COMM_WORLD) ;
			tag = 400;
			code = MPI_Recv(&it,1,MPI_INT,0,tag,MPI_COMM_WORLD,&status) ;
			if(n>=0 && n<nTemperatures && next>=0 && next<nTemperatures)
			{
#if DEBUG
				fprintf(md[0].forceField->logfile, " Exchange between 2 trajs on one proc rank = 0\n");
#endif
				// 2 trajs on one proc
				applyExchangeReplica(md, nTemperatures, n,next);
			}
			else 
			{
				if(n>=0 && n<nTemperatures) changeOneReplica(md,  n, temperaturesAll[it+1], fileNamePrefixProp, fileNamePrefixTraj);
				if(next>=0 && next<nTemperatures) changeOneReplica(md, next, temperaturesAll[it], fileNamePrefixProp, fileNamePrefixTraj);
			}
		}
#endif
	}
}
/**********************************************************************/
ForceField**   runREMD(
		MolecularDynamics* molecularDynamics, ForceField* forceField, 
		int updateFrequency, 
		double heatTime, double equiTime, double runTime, 
		double heatTemperature, double runTemperature, double runTemperatureMax,
		double stepSize,
		MDIntegratorType integratorType,
		MDThermostatType thermostat,
		double friction,
		double omegaMax,
		int Nf,
		double collide,
		double qNH,
		int numberOfGeometries,
		int nTemperaturesAll,
		int numberOfExchanges,
		char* fileNameTraj,
		char* fileNameProp
		)
{
	char* fileNamePrefixProp = NULL;
	char* fileNamePrefixTraj = NULL;
	int i;
	int j;
	int k;
	char* str = NULL;
        double gradientNorm = 0;
	int numberOfHeatSteps = 0;
	int numberOfEquiSteps = 0;
	int numberOfRunSteps = 0;
	double currentTemp;
	int* updateNumber = NULL;
	int n0 = 0;
	ForceField** geometries = NULL;
	int iSel = 0;
	int stepSel = 1;
	int stepExchange = 1;
	MolecularDynamics* md = NULL;
	double* runTemps = NULL;
	double a = 1.0;
	double b = 1.0;
	int nproc = 1;
	int* nTemperaturesLocal = NULL;
	int rank = 0;
	int n = 0;
	int nTemperatures = 0;
	int iBegin = 0;
	double* energies = NULL;
	double* energiesAll = NULL;
	double* temperaturesAll = NULL;
	int* numMDForTemperatures = NULL;
	FILE* logfile = forceField->logfile;

	if(nTemperaturesAll<1) return NULL;
	if(forceField->molecule.nAtoms<1) return NULL;
	if(numberOfGeometries<2) return NULL;

#ifdef ENABLE_MPI
	MPI_Comm_rank( MPI_COMM_WORLD,&rank);
	MPI_Comm_size( MPI_COMM_WORLD,&nproc );
	fprintf(logfile, "Rank#=%d  nproc = %d\n", rank, nproc );
	if(nTemperaturesAll<nproc)
	{
		fprintf(logfile, "nTemperatures<number of procs. I set #proc to nTemperatures=%d\n", nTemperaturesAll);
		nproc = nTemperaturesAll;
	}
	if(rank>nproc-1) return NULL;
#else
	rank = 0;
	nproc = 1;
#endif
	nTemperaturesLocal = malloc(nproc*sizeof(int));
	for(i=0;i<nproc;i++) nTemperaturesLocal[i] = 0;
	n = 0;
	i = nproc-1;
	do{
		nTemperaturesLocal[i]++;
		i--;
		if(i<0) i = nproc-1;
		n++;
		fprintf(logfile,"i=%d n = %d\n",i,n);
	}while(n<nTemperaturesAll);
	/* fprintf(logfile, "basname = %s\n",g_path_get_basename(fileNameTraj));*/
	nTemperatures = nTemperaturesLocal[rank];
	energies = malloc(nTemperaturesAll*sizeof(double));
	energiesAll = malloc(nTemperaturesAll*sizeof(double));
	temperaturesAll = malloc(nTemperaturesAll*sizeof(double));

	iBegin = 0;
	for(i=0;i<rank;i++) iBegin += nTemperaturesLocal[i];
	fprintf(logfile, "Rank#=%d  nTemperatures at this proc  = %d nTemperaturesAll = %d iBegin = %d\n", rank, nTemperatures, nTemperaturesAll,iBegin);

	runTemps = malloc(nTemperatures*sizeof(double));
	if(nTemperaturesAll>1) a = pow(runTemperatureMax/runTemperature,1.0/(nTemperaturesAll-1));
	b = 1.0;
	for(i=0;i<nTemperaturesAll;i++) 
	{
		if(i>=iBegin && i<iBegin+nTemperatures) runTemps[i-iBegin] = runTemperature*b;
		temperaturesAll[i] = runTemperature*b;
		b = b*a;
	}
	fprintf(logfile, "\nTemperatures = ");
	for(k=0;k<nTemperatures;k++) fprintf(logfile, "%f ", runTemps[k]);
	fprintf(logfile, "\n\n");
	fflush(logfile);
	numMDForTemperatures = malloc(nTemperaturesAll*sizeof(int));
	for(i=0;i<nTemperaturesAll;i++)  numMDForTemperatures[i] = i;

	md = malloc(nTemperatures*sizeof(MolecularDynamics));
	for(k=0;k<nTemperatures;k++) 
	{
		md[k] = *molecularDynamics;
		md[k].forceField = malloc(sizeof(ForceField)); 
		*md[k].forceField = copyForceField(forceField);

#ifdef ENABLE_CL
		if(k!=0) initCLForceField (md[k].forceField);
#endif
		md[k].numberOfAtoms = forceField->molecule.nAtoms;
		fprintf(logfile, "nAtoms = %d\n",md[k].numberOfAtoms);
		md[k].updateFrequency = updateFrequency;
	}
	updateNumber = malloc(nTemperatures*sizeof(int));
	for(k=0;k<nTemperatures;k++) updateNumber[k] = 0;

	//if(rank==0)
	{
		geometries = malloc(numberOfGeometries*sizeof(ForceField*));
		for(i=0;i<numberOfGeometries;i++) geometries[i] = NULL;
	}

	currentTemp = heatTemperature/2;
	numberOfHeatSteps = heatTime/stepSize*1000;
	numberOfEquiSteps = equiTime/stepSize*1000;; 
	numberOfRunSteps = runTime/stepSize*1000;; 

	for(k=0;k<nTemperatures;k++) 
	{
		char* fileNamePropk = NULL;
		char* fileNameTrajk = NULL;
		{
			if(fileNameProp) fileNamePrefixProp = getSuffixNameFile(fileNameProp);
			if(fileNamePrefixProp) fileNamePropk = strdup_printf("%s%0.0f.txt",fileNamePrefixProp,runTemps[k]);
			if(fileNameTraj) fileNamePrefixTraj = getSuffixNameFile(fileNameTraj);
			if(fileNamePrefixTraj) fileNameTrajk = strdup_printf("%s%0.0f.gab",fileNamePrefixTraj,runTemps[k]);
		}
		currentTemp = heatTemperature;
		if(numberOfHeatSteps==0) currentTemp = runTemps[k];
		/* printf("Begin initMD\n");*/
		initMD(&md[k],currentTemp,stepSize, integratorType, thermostat, friction, omegaMax, Nf, collide, qNH, fileNameTrajk, fileNamePropk, numberOfRunSteps,k+iBegin);
		/* printf("End initMD\n");*/
	}
	for(k=0;k<nTemperatures;k++) 
	{
		md[k].forceField->klass->calculateGradient(md[k].forceField);
		computeEnergies(&md[k]);
	}
	/* printf("End computeEnergies\n");*/

	iSel = -1;
	if(rank==0)
	{
		if(str) free(str);
		str = strdup_printf("Geometry selected Potential energy =  %0.4f", md[0].potentialEnergy);
		/* redrawMolecule(&md[0].forceField->molecule,str);*/
		fprintf(logfile, "%s\n",str);
		iSel++;
		geometries[iSel] = malloc(sizeof(ForceField));
		*geometries[iSel] = copyForceField(md[0].forceField);
		/* waiting(0.1);*/
	}


	for(k=0;k<nTemperatures;k++) 
	{
		md[k].temperature = heatTemperature;
		rescaleVelocities(&md[k]);
		newProperties(&md[k]," ");
	}

	currentTemp = heatTemperature;
	n0 = 0;
	for (i = 0; i < numberOfHeatSteps; i++ )
	for(k=0;k<nTemperatures;k++) 
	{
		applyOneStep(&md[k],i);
		currentTemp = heatTemperature + ( runTemps[k] - heatTemperature ) * ( ( double )( i + 1 )/ numberOfHeatSteps );
		md[k].temperature = currentTemp;
		rescaleVelocities(&md[k]);
		if (++updateNumber[k] >= md[k].updateFrequency )
		{
			if(str) free(str);
			str = strdup_printf(("MD Heating: %0.2f fs, T = %0.2f K T(t) = %8.2f Kin = %0.4f Pot =  %0.4f Tot =  %0.4f"), 
					i*stepSize,
					md[k].temperature, 
					md[k].kelvin, 
					md[k].kineticEnergy,
					md[k].potentialEnergy,
					md[k].totalEnergy
					);
			/* redrawMolecule(&md[k].forceField->molecule,str);*/
			fprintf(logfile, "%s\n",str);
			updateNumber[k] = 0;
		}
		//saveProperties(&md[k], n0+i+1, i+1," Heating");
	}

	for(k=0;k<nTemperatures;k++) 
	{
		md[k].temperature = runTemps[k];
		rescaleVelocities(&md[k]);
		updateNumber[k] = md[k].updateFrequency;
	}

	n0 += numberOfHeatSteps;
	for (i = 0; i < numberOfEquiSteps; i++ )
	for(k=0;k<nTemperatures;k++) 
	{
		md[k].temperature = runTemps[k];
		applyOneStep(&md[k],i);
		md[k].temperature = runTemps[k];
		/* rescaleVelocities(&md[k]);*/
		applyThermostat(&md[k]);
		if (++updateNumber[k] >= md[k].updateFrequency )
		{
			currentTemp =  runTemps[k];
			if(str) free(str);
			str = strdup_printf(("MD Equilibrium: %0.2f fs, T = %0.2f K  T(t) = %8.2f K Kin = %0.4f Pot =  %0.4f Tot =  %0.4f"), 
					i*stepSize,
					md[k].temperature, 
					md[k].kelvin, 
					md[k].kineticEnergy,
					md[k].potentialEnergy,
					md[k].totalEnergy
					);
			//redrawMolecule(&md[k].forceField->molecule,str);
			fprintf(logfile, "%s\n",str);
			updateNumber[k] = 0;
		}
		//saveProperties(&md[k], n0+i+1, i+1, " Equilibrium");
	}
	for(k=0;k<nTemperatures;k++) 
	{
		md[k].temperature = runTemps[k];
		rescaleVelocities(&md[k]);
		updateNumber[k] = md[k].updateFrequency;
	}

	n0 += numberOfEquiSteps;
/*
	if(str) free(str);
	str = strdup_printf(("Geometry selected Potential energy =  %0.4f"), md[0].potentialEnergy);
	fprintf(logfile, "%s\n",str);
*/
	if(numberOfGeometries>2) stepSel = numberOfRunSteps/(numberOfGeometries-1);
	else stepSel = numberOfRunSteps;
	if(numberOfExchanges>2) stepExchange =  numberOfRunSteps/(numberOfExchanges-1);
	else stepExchange = numberOfRunSteps;

	for(k=0;k<nTemperatures;k++) 
			md[k].temperature = runTemps[k];
	for (i = 0; i < numberOfRunSteps; i++ )
	{
		for(k=0;k<nTemperatures;k++) 
		{
			applyOneStep(&md[k],i);
			applyThermostat(&md[k]);
			if (++updateNumber[k] >= md[k].updateFrequency )
			{
				if(str) free(str);
				str = strdup_printf(("MD Running: %0.2f fs, T = %0.2f K  T(t) = %8.2f K Kin = %0.4f Pot =  %0.4f Tot =  %0.4f"), 
					i*stepSize, 
					md[k].temperature, 
					md[k].kelvin, 
					md[k].kineticEnergy,
					md[k].potentialEnergy,
					md[k].totalEnergy
					);
				//redrawMolecule(&md[k].forceField->molecule,str);
				fprintf(logfile, "%s\n",str);
				updateNumber[k] = 0;
				saveTrajectory(&md[k], i+1);
			}
			saveProperties(&md[k], n0+i+1, i+1," Running");
		}
		for(k=0;k<nTemperatures;k++) 
		if(fabs(temperaturesAll[0]-md[k].temperature)<1e-10 && (i+1)%stepSel==0 && (iSel+1)<numberOfGeometries)
		{
			if(str) free(str);
			str = strdup_printf(("Geometry selected Potential energy =  %0.4f"), md[k].potentialEnergy);
			//redrawMolecule(&md[k].forceField->molecule,str);
			fprintf(logfile, "%s\n",str);
			iSel++;
			geometries[iSel] = malloc(sizeof(ForceField));
			*geometries[iSel] = copyForceField(md[k].forceField);
			/* waiting(0.1);*/
		}
/* Exchange here */
		if((i+1)%stepExchange==0&&nTemperaturesAll>1)
		{
			exchangeReplica(md,  energiesAll, energies,  temperaturesAll, numMDForTemperatures, nTemperaturesLocal,
			nTemperaturesAll, nTemperatures, nproc, rank, iBegin, fileNamePrefixProp, fileNamePrefixTraj);
		}
	}
	for(k=0;k<nTemperatures;k++) 
	if(fabs(temperaturesAll[0]-md[k].temperature)<1e-10 && iSel<numberOfGeometries-1)
	{
		if(str) free(str);
		str = strdup_printf(("Geometry selected Potential energy =  %0.4f"), md[k].potentialEnergy);
		//redrawMolecule(&md[0].forceField->molecule,str);
		fprintf(logfile, "%s\n",str);
		iSel++;
		geometries[iSel] = malloc(sizeof(ForceField));
		*geometries[iSel] = copyForceField(md[k].forceField);
		/* waiting(0.1);*/
	}

	n0 += numberOfRunSteps;

	fprintf(logfile,"End of MD Simulation on rank # %d.\n",rank);
	for(k=0;k<nTemperatures;k++) 
	{
		md[k].forceField->klass->calculateGradient(md[k].forceField);
        	gradientNorm = 0;
		for (i = 0; i < md[k].numberOfAtoms; i++)
			for ( j = 0; j < 3; j++)
                        	gradientNorm += 
					md[k].forceField->molecule.atoms[i].gradient[j] * 
					md[k].forceField->molecule.atoms[i].gradient[j]; 

        	gradientNorm = sqrt( gradientNorm );
		if(str) free(str);
		str = strdup_printf(("T(K)=%0.2f Gradient = %f Ekin = %f (Kcal/mol) EPot =  %0.4f ETot =  %0.4f T(t) = %0.2f"),
			runTemps[k],
			(double)gradientNorm,
			md[k].kineticEnergy,
			md[k].potentialEnergy,
			md[k].totalEnergy,
			md[k].kelvin 
			); 
		//redrawMolecule(&md[0].forceField->molecule,str);
		fprintf(logfile, "%s\n",str);
	}
	if(str) free(str);

	for(k=0;k<nTemperatures;k++) 
	{
		if(md[k].fileTraj)fclose(md[k].fileTraj);
		if(md[k].fileProp)fclose(md[k].fileProp);
	}
	
#if DEBUG
	fprintf(logfile, "Begin freeMolecularDynamics in REMD\n");
	fflush(logfile);
#endif
	for(k=0;k<nTemperatures;k++) 
	{
		freeMolecularDynamics(&md[k]);
	}
#if DEBUG
	fprintf(logfile, "End freeMolecularDynamics in REMD\n");
	fflush(logfile);
#endif

	if(updateNumber) free(updateNumber);
#if DEBUG
	fprintf(logfile, "End free updateNumber\n");
	fflush(logfile);
#endif

	if(runTemps) free(runTemps);

#if DEBUG
	fprintf(logfile, "End free runTemps\n");
	fflush(logfile);
#endif

	fflush(logfile);
	return geometries;
}
/**********************************************************************/
ForceField**    runMolecularDynamicsConfo(
		MolecularDynamics* molecularDynamics, ForceField* forceField, 
		int updateFrequency, 
		double heatTime, double equiTime, double runTime,
		double heatTemperature, double equiTemperature, double runTemperature,
		double stepSize,
		MDIntegratorType integratorType,
		MDThermostatType thermostat,
		double friction,
		double omegaMax,
		int Nf,
		double collide,
		double qNH,
		int numberOfGeometries,
		char* fileNameTraj,
		char* fileNameProp
		)
{
	int i;
	int j;
	char* str = NULL;
        double gradientNorm = 0;
	int numberOfHeatSteps = 0;
	int numberOfEquiSteps = 0;
	int numberOfRunSteps = 0;
	double currentTemp;
	int updateNumber = 0;
	int n0 = 0;
	ForceField** geometries = NULL;
	int iSel = 0;
	int stepSel = 1;
	double e0 = 0;
	double esum = 0;
	double e2sum = 0;
	/* 
	 *  physical constants in SI units
	 *   ------------------------------
	 *      Kb = 1.380662 E-23 J/K
	 *      Na = 6.022045 E23  1/mol
	 *      e = 1.6021892 E-19 C
	 *      eps = 8.85418782 E-12 F/m
	 *                       
	 *      1 Kcal = 4184.0 J
	 *      1 amu = 1.6605655 E-27 Kg
	 *      1 A = 1.0 E-10 m
	 *                                       
	 *       Internally, AKMA units are used:
	 *                                        
	 *       timeFactor = SQRT ( ( 1A )**2 * 1amu * Na  / 1Kcal )
	 *       kBoltzmann = Na *Kb  / 1 Kcal
	*/ 

	/* printf("basname = %s\n",g_path_get_basename(fileNameTraj));*/

	if(forceField->molecule.nAtoms<1) return NULL;
	if(numberOfGeometries<2) return NULL;
	geometries = malloc(numberOfGeometries*sizeof(ForceField*));
	for(i=0;i<numberOfGeometries;i++) geometries[i] = NULL;

	molecularDynamics->forceField = forceField;
	molecularDynamics->numberOfAtoms = forceField->molecule.nAtoms;
	molecularDynamics->updateFrequency = updateFrequency;

	currentTemp = heatTemperature/2;
	
	numberOfHeatSteps = heatTime/stepSize*1000;
	numberOfEquiSteps = equiTime/stepSize*1000;; 
	numberOfRunSteps = runTime/stepSize*1000;; 


	currentTemp = heatTemperature;
	if(numberOfHeatSteps==0) currentTemp = equiTemperature; 
	if(numberOfHeatSteps==0 && numberOfEquiSteps==0 ) currentTemp = runTemperature; 

	initMD(molecularDynamics,currentTemp,stepSize, integratorType, thermostat, friction, omegaMax, Nf, collide, qNH, fileNameTraj, fileNameProp, numberOfRunSteps,0);
	molecularDynamics->forceField->klass->calculateGradient(molecularDynamics->forceField);
	computeEnergies(molecularDynamics);
	e0 = molecularDynamics->potentialEnergy;
	printf("E0 = The first potential energy in kcal = %f\n",e0); 

	iSel = -1;
	{
		if(str) free(str);
		str = strdup_printf(("Geometry #%d selected Potential energy =  %0.4f"), iSel+1,molecularDynamics->potentialEnergy);
		/* redrawMolecule(&molecularDynamics->forceField->molecule,str);*/
		printf("%s\n",str);
		iSel++;
		geometries[iSel] = malloc(sizeof(ForceField));
		*geometries[iSel] = copyForceField(molecularDynamics->forceField);
		/* waiting(0.1);*/
	}

	molecularDynamics->temperature = heatTemperature;
	rescaleVelocities(molecularDynamics);

	currentTemp = heatTemperature;
	n0 = 0;
	newProperties(molecularDynamics," ");
	/*newProperties(molecularDynamics," ----> Heating");*/
	for (i = 0; i < numberOfHeatSteps; i++ )
	{
		molecularDynamics->temperature = currentTemp;
		applyOneStep(molecularDynamics,i);
		currentTemp = heatTemperature + ( runTemperature - heatTemperature ) *
				( ( double )( i + 1 )/ numberOfHeatSteps );
		molecularDynamics->temperature = currentTemp;
		rescaleVelocities(molecularDynamics);
		if (++updateNumber >= molecularDynamics->updateFrequency )
		{
			if(str) free(str);
			str = strdup_printf(("MD Heating: %0.2f fs, T = %0.2f K T(t) = %8.2f Kin = %0.4f Pot =  %0.4f Tot =  %0.4f"), 
					i*stepSize, 
					molecularDynamics->temperature, 
					molecularDynamics->kelvin, 
					molecularDynamics->kineticEnergy,
					molecularDynamics->potentialEnergy,
					molecularDynamics->totalEnergy
					);
			/* redrawMolecule(&molecularDynamics->forceField->molecule,str);*/
			printf("%s\n",str);
			updateNumber = 0;
		}
		//saveProperties(molecularDynamics, n0+i+1, i+1," Heating");
	}

	currentTemp = equiTemperature;
	molecularDynamics->temperature = currentTemp;
	rescaleVelocities(molecularDynamics);
	updateNumber = molecularDynamics->updateFrequency;
	n0 += numberOfHeatSteps;
	/* newProperties(molecularDynamics," ----> Equilibrium");*/
	for (i = 0; i < numberOfEquiSteps; i++ )
	{
		molecularDynamics->temperature = currentTemp;
		applyOneStep(molecularDynamics,i);
		molecularDynamics->temperature = currentTemp;
		/*rescaleVelocities(molecularDynamics);*/
		applyThermostat(molecularDynamics);
		if (++updateNumber >= molecularDynamics->updateFrequency )
		{
			if(str) free(str);
			str = strdup_printf(("MD Equilibrium: %0.2f fs, T = %0.2f K  T(t) = %8.2f K Kin = %0.4f Pot =  %0.4f Tot =  %0.4f"), 
					i*stepSize,
					molecularDynamics->temperature, 
					molecularDynamics->kelvin, 
					molecularDynamics->kineticEnergy,
					molecularDynamics->potentialEnergy,
					molecularDynamics->totalEnergy
					);
			//redrawMolecule(&molecularDynamics->forceField->molecule,str);
			printf("%s\n",str);
			updateNumber = 0;
		}
		//saveProperties(molecularDynamics, n0+i+1, i+1, " Equilibrium");
	}
	updateNumber = molecularDynamics->updateFrequency;

	currentTemp = runTemperature;
	molecularDynamics->temperature = currentTemp;
	rescaleVelocities(molecularDynamics);
	updateNumber = molecularDynamics->updateFrequency;
	n0 += numberOfEquiSteps;
	/* newProperties(molecularDynamics," ----> Runing");*/
	//if(str) free(str);
	//str = strdup_printf(("Geometry selected Potential energy =  %0.4f"), molecularDynamics->potentialEnergy);
	//redrawMolecule(&molecularDynamics->forceField->molecule,str);
	//printf("%s\n",str);
	if(numberOfGeometries>2) stepSel = numberOfRunSteps/(numberOfGeometries-1);
	else stepSel = numberOfRunSteps;
	/* printf("Isel = %d\n",stepSel);*/
	esum = 0;
	e2sum = 0;
	for (i = 0; i < numberOfRunSteps; i++ )
	{
		molecularDynamics->temperature = currentTemp;
		applyOneStep(molecularDynamics,i);
		applyThermostat(molecularDynamics);
		esum  += molecularDynamics->totalEnergy;
		e2sum += molecularDynamics->totalEnergy*molecularDynamics->totalEnergy;
		if (++updateNumber >= molecularDynamics->updateFrequency )
		{
			if(str) free(str);
			str = strdup_printf(("MD Running: %0.2f fs, T = %0.2f K  T(t) = %8.2f K Kin = %0.4f Pot =  %0.4f Tot =  %0.4f Eav = %0.4f sigE = %0.4f Eav-E0(cm^-1) = %0.2f"), 
					i*stepSize, 
					molecularDynamics->temperature, 
					molecularDynamics->kelvin, 
					molecularDynamics->kineticEnergy,
					molecularDynamics->potentialEnergy,
					molecularDynamics->totalEnergy,
					esum/(i+1),
					sqrt(fabs(e2sum/(i+1)-esum/(i+1)*esum/(i+1))),
					(esum/(i+1)-e0)*349.75511054
					);
			//redrawMolecule(&molecularDynamics->forceField->molecule,str);
			printf("%s\n",str);
			updateNumber = 0;
			saveTrajectory(molecularDynamics, i+1);
		}
		if((i+1)%stepSel==0 && (iSel+1)<numberOfGeometries)
		{
			if(str) free(str);
			str = strdup_printf(("Geometry #%d selected Potential energy =  %0.4f"), iSel+1,molecularDynamics->potentialEnergy);
			//redrawMolecule(&molecularDynamics->forceField->molecule,str);
			printf("%s\n",str);
			fflush(stdout);
			iSel++;
			geometries[iSel] = malloc(sizeof(ForceField));
			printf("Begin copy\n");
			fflush(stdout);
			*geometries[iSel] = copyForceField(molecularDynamics->forceField);
			printf("End copy\n");
			fflush(stdout);
			/* waiting(0.1);*/
		}
		saveProperties(molecularDynamics, n0+i+1, i+1," Running");
	}
	if(iSel<numberOfGeometries-1)
	{
		if(str) free(str);
		str = strdup_printf(("Geometry selected Potential energy =  %0.4f"), molecularDynamics->potentialEnergy);
		//redrawMolecule(&molecularDynamics->forceField->molecule,str);
		printf("%s\n",str);
		iSel++;
		geometries[iSel] = malloc(sizeof(ForceField));
		*geometries[iSel] = copyForceField(molecularDynamics->forceField);
		/* waiting(0.1);*/
	}

	updateNumber = molecularDynamics->updateFrequency;
	n0 += numberOfRunSteps;

	molecularDynamics->forceField->klass->calculateGradient(molecularDynamics->forceField);
        gradientNorm = 0;
	for (i = 0; i < molecularDynamics->numberOfAtoms; i++)
		for ( j = 0; j < 3; j++)
                        gradientNorm += 
				molecularDynamics->forceField->molecule.atoms[i].gradient[j] * 
				molecularDynamics->forceField->molecule.atoms[i].gradient[j]; 

        gradientNorm = sqrt( gradientNorm );
	if(str) free(str);
	str = strdup_printf(("End of MD Simulation. Gradient = %f Ekin = %f (Kcal/mol) EPot =  %0.4f ETot =  %0.4f T(t) = %0.2f"),
			(double)gradientNorm,
			molecularDynamics->kineticEnergy,
			molecularDynamics->potentialEnergy,
			molecularDynamics->totalEnergy,
			molecularDynamics->kelvin 
			); 
	//redrawMolecule(&molecularDynamics->forceField->molecule,str);
	printf("%s\n",str);
	free(str);
	if(molecularDynamics->fileTraj)fclose(molecularDynamics->fileTraj);
	if(molecularDynamics->fileProp)fclose(molecularDynamics->fileProp);
	freeMolecularDynamics(molecularDynamics);
	return geometries;
}
/**********************************************************************/
static void printGeometryAndVelocities(MolecularDynamics* molecularDynamics, char* title)
{
	fprintf(stdout,"========================================================================================================================\n");
	fprintf(stdout,"#  Geometry and velocities at %s ; T0(K) = %0.2f\n", title,molecularDynamics->kelvin);
	molecularDynamics->forceField->molecule.klass->addGeometry(& molecularDynamics->forceField->molecule,stdout);
	molecularDynamics->forceField->molecule.klass->addVelocities(& molecularDynamics->forceField->molecule,stdout);
	fprintf(stdout,"========================================================================================================================\n");
}
/**********************************************************************/
void	runMolecularDynamics(
		MolecularDynamics* molecularDynamics, ForceField* forceField, 
		int updateFrequency, 
		double heatTime, double equiTime, double runTime, double coolTime, 
		double heatTemperature, double equiTemperature, double runTemperature, double coolTemperature, 
		double stepSize,
		MDIntegratorType integratorType,
		MDThermostatType thermostat,
		double friction,
		double omegaMax,
		int Nf,
		double collide,
		double qNH,
		char* fileNameTraj,
		char* fileNameProp
		)
{
	int i;
	int j;
	char* str = NULL;
        double gradientNorm = 0;
	int numberOfHeatSteps = 0;
	int numberOfEquiSteps = 0;
	int numberOfRunSteps = 0;
	int numberOfCoolSteps = 0;
	double currentTemp;
	int updateNumber = 0;
	int n0 = 0;
	double e0 = 0;
	double esum = 0;
	double e2sum = 0;
	/* 
	 *  physical constants in SI units
	 *   ------------------------------
	 *      Kb = 1.380662 E-23 J/K
	 *      Na = 6.022045 E23  1/mol
	 *      e = 1.6021892 E-19 C
	 *      eps = 8.85418782 E-12 F/m
	 *                       
	 *      1 Kcal = 4184.0 J
	 *      1 amu = 1.6605655 E-27 Kg
	 *      1 A = 1.0 E-10 m
	 *                                       
	 *       Internally, AKMA units are used:
	 *                                        
	 *       timeFactor = SQRT ( ( 1A )**2 * 1amu * Na  / 1Kcal )
	 *       kBoltzmann = Na *Kb  / 1 Kcal
	*/ 

	/* printf("basname = %s\n",g_path_get_basename(fileNameTraj));*/

	if(forceField->molecule.nAtoms<1) return;

	molecularDynamics->forceField = forceField;
	molecularDynamics->numberOfAtoms = forceField->molecule.nAtoms;
	molecularDynamics->updateFrequency = updateFrequency;

	currentTemp = heatTemperature/2;
	
	numberOfHeatSteps = heatTime/stepSize*1000;
	numberOfEquiSteps = equiTime/stepSize*1000;; 
	numberOfRunSteps = runTime/stepSize*1000;; 
	numberOfCoolSteps = coolTime/stepSize*1000;;


	currentTemp = heatTemperature;
	if(numberOfHeatSteps==0) currentTemp = equiTemperature; 
	if(numberOfHeatSteps==0 && numberOfEquiSteps==0 ) currentTemp = runTemperature; 
	if(numberOfHeatSteps==0 && numberOfEquiSteps==0 && numberOfRunSteps==0 ) currentTemp = coolTemperature; 

	initMD(molecularDynamics,currentTemp,stepSize, integratorType, thermostat, friction, omegaMax, Nf, collide, qNH, fileNameTraj, fileNameProp, numberOfRunSteps,0);
	molecularDynamics->forceField->klass->calculateGradient(molecularDynamics->forceField);

	computeEnergies(molecularDynamics);

	e0 = molecularDynamics->potentialEnergy;
	printf("E0 = The first potential energy in kcal = %f\n",e0); 

	molecularDynamics->temperature = heatTemperature;
	if(numberOfHeatSteps>0) rescaleVelocities(molecularDynamics);

	currentTemp = heatTemperature;
	n0 = 0;
	newProperties(molecularDynamics," ");
	/*newProperties(molecularDynamics," ----> Heating");*/
	if(numberOfHeatSteps>0) printGeometryAndVelocities(molecularDynamics, "the begining of Heating stage");
	for (i = 0; i < numberOfHeatSteps; i++ )
	{
		molecularDynamics->temperature = currentTemp;
		applyOneStep(molecularDynamics,i);
		currentTemp = heatTemperature + ( runTemperature - heatTemperature ) *
				( ( double )( i + 1 )/ numberOfHeatSteps );
		molecularDynamics->temperature = currentTemp;
		rescaleVelocities(molecularDynamics);
		if (++updateNumber >= molecularDynamics->updateFrequency )
		{
			if(str) free(str);
			str = strdup_printf(("MD Heating: %0.2f fs, T = %0.2f K T(t) = %0.2f Kin = %0.4f Pot =  %0.4f Tot =  %0.4f"), 
					i*stepSize, 
					molecularDynamics->temperature, 
					molecularDynamics->kelvin, 
					molecularDynamics->kineticEnergy,
					molecularDynamics->potentialEnergy,
					molecularDynamics->totalEnergy
					);
			//redrawMolecule(&molecularDynamics->forceField->molecule,str);
			printf("%s\n",str);
			updateNumber = 0;
		}
		saveProperties(molecularDynamics, n0+i+1, i+1," Heating");
	}

	currentTemp = equiTemperature;
	molecularDynamics->temperature = currentTemp;
	if(numberOfHeatSteps>0) rescaleVelocities(molecularDynamics);
	updateNumber = molecularDynamics->updateFrequency;
	n0 += numberOfHeatSteps;
	/* newProperties(molecularDynamics," ----> Equilibrium");*/
	if(numberOfEquiSteps) 
	{
		printGeometryAndVelocities(molecularDynamics, "the begining of Equilibrium stage");
	}
	for (i = 0; i < numberOfEquiSteps; i++ )
	{
		molecularDynamics->temperature = currentTemp;
		applyOneStep(molecularDynamics,i);
		molecularDynamics->temperature = currentTemp;
		/* rescaleVelocities(molecularDynamics);*/
		applyThermostat(molecularDynamics);
		if (++updateNumber >= molecularDynamics->updateFrequency )
		{
			if(str) free(str);
			str = strdup_printf(("MD Equilibrium: %0.2f fs, T = %0.2f K  T(t) = %0.2f K Kin = %0.4f Pot =  %0.4f Tot =  %0.4f"), 
					i*stepSize, 
					molecularDynamics->temperature, 
					molecularDynamics->kelvin, 
					molecularDynamics->kineticEnergy,
					molecularDynamics->potentialEnergy,
					molecularDynamics->totalEnergy
					);
			//redrawMolecule(&molecularDynamics->forceField->molecule,str);
			printf("%s\n",str);
			updateNumber = 0;
		}
		saveProperties(molecularDynamics, n0+i+1, i+1, " Equilibrium");
	}
	updateNumber = molecularDynamics->updateFrequency;

	currentTemp = runTemperature;
	molecularDynamics->temperature = currentTemp;
	/* rescaleVelocities(molecularDynamics);*/
	updateNumber = molecularDynamics->updateFrequency;
	n0 += numberOfEquiSteps;
	/* newProperties(molecularDynamics," ----> Runing");*/
	if(numberOfRunSteps>0) printGeometryAndVelocities(molecularDynamics, "the begining of Production stage");
	esum = 0;
	e2sum = 0;
	for (i = 0; i < numberOfRunSteps; i++ )
	{
		molecularDynamics->temperature = currentTemp;
		applyOneStep(molecularDynamics,i);
		applyThermostat(molecularDynamics);
		esum  += molecularDynamics->totalEnergy;
		e2sum += molecularDynamics->totalEnergy*molecularDynamics->totalEnergy;
		if (++updateNumber >= molecularDynamics->updateFrequency )
		{
			if(str) free(str);
			str = strdup_printf(("MD Running: %0.2f fs, T = %0.2f K  T(t) = %8.2f K Kin = %0.4f Pot =  %0.4f Tot =  %0.4f Eav =  %0.4f sigE =  %0.4f Eav-E0(cm^-1) = %0.2f"), 
					i*stepSize, 
					molecularDynamics->temperature, 
					molecularDynamics->kelvin, 
					molecularDynamics->kineticEnergy,
					molecularDynamics->potentialEnergy,
					molecularDynamics->totalEnergy,
					esum/(i+1),
					sqrt(fabs(e2sum/(i+1)-esum/(i+1)*esum/(i+1))),
					(esum/(i+1)-e0)*349.75511054
					);
			//redrawMolecule(&molecularDynamics->forceField->molecule,str);
			printf("%s\n",str);
			updateNumber = 0;
			saveTrajectory(molecularDynamics, i+1);
		}
		saveProperties(molecularDynamics, n0+i+1, i+1," Running");
	}
	if(numberOfCoolSteps>0) printGeometryAndVelocities(molecularDynamics, "the beginning of Cooling stage");
	updateNumber = molecularDynamics->updateFrequency;
	n0 += numberOfRunSteps;
	/* newProperties(molecularDynamics," ----> Cooling");*/
	for (i = 0; i < numberOfCoolSteps; i++ )
	{
		currentTemp = runTemperature - ( runTemperature - coolTemperature ) * 
				( ( double )( i + 1 )/ numberOfCoolSteps );
		molecularDynamics->temperature = currentTemp;
		rescaleVelocities(molecularDynamics);
		molecularDynamics->temperature = currentTemp;
		applyOneStep(molecularDynamics,i);
		if (++updateNumber >= molecularDynamics->updateFrequency )
		{
			if(str) free(str);
			str = strdup_printf(("MD Cooling: %0.2f fs, T = %0.2f K T(t) = %0.2f K Kin = %0.4f Pot =  %0.4f Tot =  %0.4f"), 
					i*stepSize, 
					molecularDynamics->temperature, 
					molecularDynamics->kelvin, 
					molecularDynamics->kineticEnergy,
					molecularDynamics->potentialEnergy,
					molecularDynamics->totalEnergy
					);
			//redrawMolecule(&molecularDynamics->forceField->molecule,str);
			printf("%s\n",str);
			updateNumber = 0;
		}
		saveProperties(molecularDynamics, n0+i+1, i+1," Cooling");
	}
	molecularDynamics->forceField->klass->calculateGradient(molecularDynamics->forceField);
        gradientNorm = 0;
	for (i = 0; i < molecularDynamics->numberOfAtoms; i++)
		for ( j = 0; j < 3; j++)
                        gradientNorm += 
				molecularDynamics->forceField->molecule.atoms[i].gradient[j] * 
				molecularDynamics->forceField->molecule.atoms[i].gradient[j]; 

        gradientNorm = sqrt( gradientNorm );
	if(str) free(str);
	str = strdup_printf(("End of MD Simulation. Gradient = %f Ekin = %f (Kcal/mol) EPot =  %0.4f ETot =  %0.4f T(t) = %0.2f"),
			(double)gradientNorm,
			molecularDynamics->kineticEnergy,
			molecularDynamics->potentialEnergy,
			molecularDynamics->totalEnergy,
			molecularDynamics->kelvin 
			); 
	//redrawMolecule(&molecularDynamics->forceField->molecule,str);
	printf("%s\n",str);
	free(str);
	printGeometryAndVelocities(molecularDynamics, "the end of simulation");
	if(molecularDynamics->fileTraj)fclose(molecularDynamics->fileTraj);
	if(molecularDynamics->fileProp)fclose(molecularDynamics->fileProp);
	freeMolecularDynamics(molecularDynamics);
}
/*********************************************************************************/
static void removeTranslation(MolecularDynamics* molecularDynamics)
{
#ifdef ENABLE_CL
	//size_t global = molecularDynamics->numberOfAtoms;
	size_t global = 1;
	CLProp clProp=getCLProp();
	cl_int err = clEnqueueNDRangeKernel(clProp.command_queue, molecularDynamics->removeTranslation, 1, NULL, &global, NULL, 0, NULL, NULL);
	if(err != CL_SUCCESS)
	{
		printErrorCLRun(err);
       		printf("I cannot execute removeTranslation\n");
		exit(1);
	}
	clFinish(clProp.command_queue);
#else
	Molecule* mol = &molecularDynamics->forceField->molecule;
	mol->klass->removeTranslation(mol); 
#endif
}
/*********************************************************************************/
static void removeRotation(MolecularDynamics* molecularDynamics)
{
#ifdef ENABLE_CL
	//size_t global = molecularDynamics->numberOfAtoms;
	size_t global = 1;
	CLProp clProp=getCLProp();
	cl_int err = clEnqueueNDRangeKernel(clProp.command_queue, molecularDynamics->removeRotation, 1, NULL, &global, NULL, 0, NULL, NULL);
	if(err != CL_SUCCESS)
	{
		printErrorCLRun(err);
       		printf("I cannot execute removeRotation\n");
		exit(1);
	}
	clFinish(clProp.command_queue);
#else
	Molecule* mol = &molecularDynamics->forceField->molecule;
	mol->klass->removeRotation(mol); 
#endif

}
/*********************************************************************************/
static void removeTranslationAndRotation(MolecularDynamics* molecularDynamics)
{
	removeTranslation(molecularDynamics);
	removeRotation(molecularDynamics);
}
/*********************************************************************************/
static void initNH(MolecularDynamics* molecularDynamics, double qNH)
{
	int i;

	if(molecularDynamics->thermostat != NOSEHOOVER) return;
	for(i=0;i<MAXNH;i++)
	{
		molecularDynamics->xNH[i] = 0;
		molecularDynamics->vNH[i] = 0;
		molecularDynamics->qNH[i] = qNH;
		molecularDynamics->gNH[i] = 0;
	}
}
/*********************************************************************************/
static void initSD(MolecularDynamics* molecularDynamics, double friction)
{
	int i;
	if(friction<0) friction = 40;
	molecularDynamics->friction = friction/(fsInAKMA)/1000;

	molecularDynamics->positionFriction = NULL;
	molecularDynamics->velocityFriction = NULL;
	molecularDynamics->accelarationFriction = NULL;
	molecularDynamics->gamma = NULL;
	molecularDynamics->positionRandom = NULL;
	molecularDynamics->velocityRandom = NULL;

	if(molecularDynamics->integratorType != STOCHASTIC) return;

	molecularDynamics->positionFriction = malloc(molecularDynamics->numberOfAtoms *sizeof(double)); 
	molecularDynamics->velocityFriction = malloc(molecularDynamics->numberOfAtoms *sizeof(double)); 
	molecularDynamics->accelarationFriction = malloc(molecularDynamics->numberOfAtoms *sizeof(double)); 
	molecularDynamics->gamma = malloc(molecularDynamics->numberOfAtoms *sizeof(double)); 

	molecularDynamics->positionRandom = malloc(molecularDynamics->numberOfAtoms *sizeof(double*)); 
	for(i=0;i<molecularDynamics->numberOfAtoms;i++)
		molecularDynamics->positionRandom[i] = malloc(3*sizeof(double));

	molecularDynamics->velocityRandom = malloc(molecularDynamics->numberOfAtoms *sizeof(double*)); 
	for(i=0;i<molecularDynamics->numberOfAtoms;i++)
		molecularDynamics->velocityRandom[i] = malloc(3*sizeof(double));

}
/* Martyna&Tuckerman Symplectic reversible integrators: Predictor-corrector methods */
/* Ref : JCP 102, 8071 (1995) */
/*********************************************************************************/
static void initMartynaTuckerman(MolecularDynamics* molecularDynamics)
{
	int i,j;

	//printf("Begin initMartynaTuckerman\n");
	for(j=0;j<3;j++) molecularDynamics->Ftilde[j] = NULL;
	for(j=0;j<3;j++) molecularDynamics->VF[j] = NULL;
	for(j=0;j<3;j++) molecularDynamics->VJ[j] = NULL;

	if(molecularDynamics->integratorType != MARTYNATUCKERMAN) return;

	for(j=0;j<3;j++) molecularDynamics->Ftilde[j] = malloc(molecularDynamics->numberOfAtoms *sizeof(double)); 
	for(j=0;j<3;j++) molecularDynamics->VF[j] = malloc(molecularDynamics->numberOfAtoms *sizeof(double)); 
	for(j=0;j<3;j++) molecularDynamics->VJ[j] = malloc(molecularDynamics->numberOfAtoms *sizeof(double)); 

	for(i=0;i<molecularDynamics->numberOfAtoms;i++)
		for ( j = 0; j < 3; j++)
			molecularDynamics->Ftilde[j][i] =-molecularDynamics->forceField->molecule.atoms[i].gradient[j]/molecularDynamics->forceField->molecule.atoms[i].mass;

	for(i=0;i<molecularDynamics->numberOfAtoms;i++) for ( j = 0; j < 3; j++) molecularDynamics->VF[j][i] = 0.0;
	for(i=0;i<molecularDynamics->numberOfAtoms;i++) for ( j = 0; j < 3; j++) molecularDynamics->VJ[j][i] = 0.0;
	//printf("End initMartynaTuckerman\n");
}
/*********************************************************************************/
static void removeTranslationAndRotationTheta(MolecularDynamics* molecularDynamics)
{
	Molecule* mol = &molecularDynamics->forceField->molecule;
	mol->klass->removeTranslationAndRotationAcceleration(mol,molecularDynamics->theta); 
}
/*********************************************************************************/
static void computeThetaQTB(MolecularDynamics* molecularDynamics)
{
	double sigma=sqrt(2.*molecularDynamics->friction*Kb*molecularDynamics->temperature/molecularDynamics->h);
	int i,j,k;

	/* thetaProg = thetaPaper*sigma/sqrt(m) */
	for(i=0;i<molecularDynamics->numberOfAtoms;i++)
	for(j=0;j<3;j++)
	{
		molecularDynamics->theta[3*i+j] = 0.0;
		for(k=0;k<2*molecularDynamics->Nf;k++)
			molecularDynamics->theta[3*i+j] += molecularDynamics->rnoise[3*i+j][2*molecularDynamics->Nf-1-k]*molecularDynamics->Ht[k];
		molecularDynamics->theta[3*i+j] *= sigma/sqrt(molecularDynamics->forceField->molecule.atoms[i].mass); 
	}
	removeTranslationAndRotationTheta(molecularDynamics);
}
/*********************************************************************************/
static void resetQTB(MolecularDynamics* molecularDynamics)
{
	double* Filter = NULL;
	int k;
	double hbarwOverkT;
	double hbardwOverkT;
	int i,j;
	double T;
	

	if(molecularDynamics->integratorType != QTB) return;
	T = molecularDynamics->temperature;
	if(T<=0) return;

	/* computing of Filter */
	/* Htild/sqrt(kT), sqrt(kT) in sigma */
	Filter = malloc((2*molecularDynamics->Nf)*sizeof(double)); 
	/* h dOmega = pi /Nf */
	hbardwOverkT = 1.0/(molecularDynamics->Nf*molecularDynamics->h*Kb*T);
	for(k=0;k<2*molecularDynamics->Nf;k++)
	{
		int kk= k-molecularDynamics->Nf;
		if(kk==0) Filter[k] = 1.0;
		else
		{
			hbarwOverkT = fabs(kk)*hbardwOverkT;
			Filter[k] = sqrt(hbarwOverkT*(0.5+1./(exp(hbarwOverkT)-1.0)));
			//Filter[k] = 1.0; // to test classic
			Filter[k] *= (kk*M_PI/molecularDynamics->Nf/2)/sin(kk*M_PI/molecularDynamics->Nf/2);
		}
	}
	/* compute Ht */
	for(j=0;j<2*molecularDynamics->Nf;j++)
	{
                molecularDynamics->Ht[j] = 0;
		for(k=0; k<2*molecularDynamics->Nf;k++)
                	molecularDynamics->Ht[j] += Filter[k]*cos(M_PI*(k-molecularDynamics->Nf)*(j-molecularDynamics->Nf)*1.0/molecularDynamics->Nf);
		
               	molecularDynamics->Ht[j] /= 2*molecularDynamics->Nf;
	}
	free(Filter);
	
	for(i=0;i<molecularDynamics->numberOfAtoms;i++)
	for(j=0;j<3;j++)
	for(k=0;k<2*molecularDynamics->Nf;k++)
		 molecularDynamics->rnoise[3*i+j][k] = normal();/* sqrt(h) is in sigma */

	computeThetaQTB(molecularDynamics);

}
/*********************************************************************************/
/* omegaMax in cm-1 */
static void initQTB(MolecularDynamics* molecularDynamics, double omegaMax, double friction, int Nf)
{
/* Refs 
Jean-Louis Barrat , David Rodney
Portable implementation of a quantum thermal bath for molecular dynamics simulations
JOURNAL OF STATISTICAL PHYSICS 670, 144, (2011)
*/
	static double cmM1fsM1 = 2.99792458e-5;
	double Omegafs = omegaMax*cmM1fsM1;/* fs^-1 */ 
	int i,j;
	

	if(Nf<1) Nf = 50;

	molecularDynamics->Ht = NULL;
	molecularDynamics->theta = NULL;
	molecularDynamics->rnoise = NULL;
	molecularDynamics->Nf = 0;
	molecularDynamics->M = 0;

	if(molecularDynamics->integratorType != QTB) return;

	molecularDynamics->Nf = Nf;
	molecularDynamics->h = 1/Omegafs*(fsInAKMA);
	molecularDynamics->M = (int)(molecularDynamics->h/molecularDynamics->dt);
	if(molecularDynamics->M<1) molecularDynamics->M = 1;
	molecularDynamics->h = molecularDynamics->M *molecularDynamics->dt;
	omegaMax = 1.0/molecularDynamics->h*(fsInAKMA)/cmM1fsM1; /* cm-1 */
	if(friction<0) molecularDynamics->friction = (1.0/ molecularDynamics->h)/50;
	else  molecularDynamics->friction = friction/fsInAKMA/1000.0;

	molecularDynamics->Ht = malloc((2*Nf)*sizeof(double)); 
	molecularDynamics->theta = malloc(3*molecularDynamics->numberOfAtoms *sizeof(double)); 
	molecularDynamics->rnoise = malloc(3*molecularDynamics->numberOfAtoms *sizeof(double*)); 
	for(i=0;i<molecularDynamics->numberOfAtoms;i++)
	for(j=0;j<3;j++)
		molecularDynamics->rnoise[3*i+j] = malloc((2*Nf)*sizeof(double)); 
	

	printf("\n");
	printf("*************** QTB Parameters ******************************************************************\n");
	printf("Nf\t\t= %d\n",molecularDynamics->Nf);
	printf("M\t\t= %d\n",molecularDynamics->M);
	printf("dt(fs)\t\t= %f\n",molecularDynamics->dt/fsInAKMA);
	printf("h(fs)\t\t= %f\n",molecularDynamics->h/fsInAKMA);
	printf("gamma(ps^-1)\t= %f\n",molecularDynamics->friction*fsInAKMA*1000);
	printf("omegaMax(cm^-1)\t= %f\n",omegaMax);
	printf("*************************************************************************************************\n");
	printf("\n");

	resetQTB(molecularDynamics);

}
/*********************************************************************************/
static void updateQTB(MolecularDynamics* molecularDynamics)
{
	int i,j,k;

	if(molecularDynamics->temperature<=0) return;
	computeThetaQTB(molecularDynamics);
	/* shift rnoise */
	for(i=0;i<molecularDynamics->numberOfAtoms;i++)
	for(j=0;j<3;j++)
	for(k=0;k<2*molecularDynamics->Nf-1;k++)
		 molecularDynamics->rnoise[3*i+j][k] = molecularDynamics->rnoise[3*i+j][k+1];

	/* add one value to the end */
	for(i=0;i<molecularDynamics->numberOfAtoms;i++)
	for(j=0;j<3;j++)
		 molecularDynamics->rnoise[3*i+j][2*molecularDynamics->Nf-1] = normal(); /* sqrt(h) in sigma */

}
/*********************************************************************************/
static void resetLangevin(MolecularDynamics* molecularDynamics)
{
	if(molecularDynamics->integratorType != LANGEVIN) return;
	updateLangevin(molecularDynamics);
}
/*********************************************************************************/
/* omegaMax in cm-1 */
static void initLangevin(MolecularDynamics* molecularDynamics, double friction)
{
	if(molecularDynamics->integratorType != LANGEVIN) return;

	if(friction<0) friction = 40;
	molecularDynamics->friction = friction/1000.0/fsInAKMA;
	molecularDynamics->theta = malloc(3*molecularDynamics->numberOfAtoms *sizeof(double)); 
	
	printf("\n");
	printf("*************** Langevin Parameters ******************************************************************\n");
	printf("dt(fs)\t\t= %f\n",molecularDynamics->dt/fsInAKMA);
	printf("gamma(ps^-1)\t= %f\n",molecularDynamics->friction*fsInAKMA*1000);
	printf("*************************************************************************************************\n");
	printf("\n");

	resetLangevin(molecularDynamics);

}
/*********************************************************************************/
static void updateLangevin(MolecularDynamics* molecularDynamics)
{
	int i,j;
	double sigma;
	/* update theta */
	if(molecularDynamics->integratorType != LANGEVIN) return;
	sigma=sqrt(2.*molecularDynamics->friction*Kb*molecularDynamics->temperature/molecularDynamics->dt);
	for(i=0;i<molecularDynamics->numberOfAtoms;i++)
	for(j=0;j<3;j++)
	{
		molecularDynamics->theta[3*i+j] = normal();
		molecularDynamics->theta[3*i+j] *= sigma/sqrt(molecularDynamics->forceField->molecule.atoms[i].mass); 
	}
}
/******************************************************************************************************************/
/*********************************************************************************/
static void initMD(MolecularDynamics* molecularDynamics, double temperature, double stepSize, MDIntegratorType integratorType, MDThermostatType thermostat, double friction, double omegaMax, int Nf, double collide, double qNH, char* fileNameTraj, char* fileNameProp, int numberOfRunSteps, int index)
{

#ifdef DEBUG
	printf("Begin initMD\n");
#endif
#ifdef ENABLE_CL
	CLProp clProp=getCLProp();
	cl_int err;
	cl_float dtf;
	cl_float frictionf;
	cl_float temp = molecularDynamics->temperature;
#endif
	int i;
	int j;
	double dt = stepSize * fsInAKMA;

	molecularDynamics->collide = collide;
	molecularDynamics->potentialEnergy = 0;
	molecularDynamics->kineticEnergy = 0;
	molecularDynamics->totalEnergy = 0;
	molecularDynamics->kelvin = 0;
	molecularDynamics->temperature = temperature;
	molecularDynamics->thermostat = NONE;

	molecularDynamics->integratorType = integratorType;
	molecularDynamics->thermostat = thermostat;
	molecularDynamics->fileTraj = NULL;
	molecularDynamics->fileProp = NULL;

	molecularDynamics->index = index;

	molecularDynamics->a = malloc(molecularDynamics->numberOfAtoms *sizeof(double*)); 
	for(i=0;i<molecularDynamics->numberOfAtoms;i++)
		molecularDynamics->a[i] = malloc(3*sizeof(double));

	molecularDynamics->aold = NULL;
	if(molecularDynamics->integratorType==BEEMAN)
	{
		molecularDynamics->aold = malloc(molecularDynamics->numberOfAtoms *sizeof(double*)); 
		for(i=0;i<molecularDynamics->numberOfAtoms;i++)
			molecularDynamics->aold[i] = malloc(3*sizeof(double));
	}
	molecularDynamics->coordinatesOld = NULL;
	molecularDynamics->moved = NULL;
	molecularDynamics->update = NULL;
	if(molecularDynamics->forceField->molecule.constraints!=NOCONSTRAINTS)
	{
		molecularDynamics->coordinatesOld = malloc(molecularDynamics->numberOfAtoms *sizeof(double*)); 
		for(i=0;i<molecularDynamics->numberOfAtoms;i++)
			molecularDynamics->coordinatesOld[i] = malloc(3*sizeof(double));
		molecularDynamics->moved = malloc(molecularDynamics->numberOfAtoms *sizeof(boolean)); 
		molecularDynamics->update = malloc(molecularDynamics->numberOfAtoms *sizeof(boolean)); 

	}

	if(fileNameTraj)
	{
 		molecularDynamics->fileTraj = fopen(fileNameTraj, "w");
		if(molecularDynamics->fileTraj != NULL)
		{
			fprintf(molecularDynamics->fileTraj,"[Gabedit Format]\n");
			fprintf(molecularDynamics->fileTraj,"\n");
			fprintf(molecularDynamics->fileTraj,"[MD]\n");
			if(molecularDynamics->updateFrequency>0) numberOfRunSteps/=molecularDynamics->updateFrequency;
			fprintf(molecularDynamics->fileTraj," %d\n",numberOfRunSteps);
		}
	}
	if(fileNameProp)
	{
 		molecularDynamics->fileProp = fopen(fileNameProp, "w");
	}

	/* srand ( (unsigned)time (NULL));*/
	
	molecularDynamics->dt = dt;
	molecularDynamics->dt_2 = dt/2.0;
	molecularDynamics->dt_4 = dt/4.0;
	molecularDynamics->dt2_2 = dt*dt/2;;
	molecularDynamics->dt_8 = dt/8.0;
	molecularDynamics->dt2_8 = dt*dt/8.0;
	molecularDynamics->dt2 = dt*dt;;
	molecularDynamics->dt3_6 = dt*dt*dt/6;
	molecularDynamics->dt4_48 = dt*dt*dt*dt/48;

#ifdef DEBUG
	printf("Begin initSD\n");
#endif
	initSD(molecularDynamics, friction);
	//printf("End initSD\n");
	initNH(molecularDynamics,qNH);
	//printf("End initNH\n");
	initQTB(molecularDynamics, omegaMax, friction, Nf);
	initLangevin(molecularDynamics, friction);
#ifdef DEBUG
	printf("Begin calcGrad\n");
#endif

#ifndef ENABLE_CL
	molecularDynamics->forceField->klass->calculateGradient(molecularDynamics->forceField);
#endif

#ifdef DEBUG
	//printf("End calcGrad\n");
#endif
	initMartynaTuckerman(molecularDynamics);
	for ( i = 0; i < molecularDynamics->numberOfAtoms; i++)
	{
		double m = molecularDynamics->forceField->molecule.atoms[i].mass;
		for ( j = 0; j < 3; j++) molecularDynamics->a[i][j] = -molecularDynamics->forceField->molecule.atoms[i].gradient[j]/m;
		if(molecularDynamics->aold) 
			for ( j = 0; j < 3; j++) molecularDynamics->aold[i][j]  = molecularDynamics->a[i][j];
		if(molecularDynamics->coordinatesOld)
		       	for ( j = 0; j < 3; j++) molecularDynamics->coordinatesOld[i][j]  = molecularDynamics->forceField->molecule.atoms[i].coordinates[j];
		if(molecularDynamics->moved) molecularDynamics->moved[i] = FALSE; 
		if(molecularDynamics->update) molecularDynamics->update[i] = FALSE; 
	}
	//printf("End initAl\n");
	/* set velocities */
	/* check if velocities are already read from the input file */
	if(molecularDynamics->forceField->molecule.klass->setMaxwellVelocitiesIfNull(&molecularDynamics->forceField->molecule, temperature)) rescaleVelocities(molecularDynamics);
#ifdef DEBUG
	molecularDynamics->forceField->molecule.klass->print(&molecularDynamics->forceField->molecule,stdout);
	printf("Velocity init\n");
	for ( i = 0; i < molecularDynamics->numberOfAtoms; i++)
	{
		for ( j = 0; j < 3; j++) fprintf(stdout, "%f ",molecularDynamics->forceField->molecule.atoms[i].velocity[j]);
		fprintf(stdout,"\n");

	}
#endif
#ifdef ENABLE_CL
#ifdef DEBUG
	printf("Begin CL\n");
#endif
	dtf =  molecularDynamics->dt;
	frictionf = molecularDynamics->friction;
#ifdef DEBUG
	printf("Begin clBuildProgram\n");
#endif
	// create a program from the kernel source code
	printf("Begin molecularDynamics->programMD\n");
	molecularDynamics->programMD = clCreateProgramWithSource(clProp.context,1,(const char **) &mdCLSource, NULL, &err);
	printf("End molecularDynamics->programMD\n");
#ifdef DEBUG
	printf("err = %d\n",err);
#endif
	// compile the program
	if (clBuildProgram(molecularDynamics->programMD, 0, NULL, NULL, NULL, NULL) != CL_SUCCESS)
	{
		char build[2048];
		printf("Error building MD CL program\n");
		clGetProgramBuildInfo(molecularDynamics->programMD, clProp.device_id, CL_PROGRAM_BUILD_LOG, 2048, build, NULL);
		printf("Build Log:\n%s\n",build);
		exit(1);
	}
#ifdef DEBUG
	printf("End clBuildProgram\n");
#endif
	molecularDynamics->aCL = clCreateBuffer(clProp.context, CL_MEM_READ_WRITE, sizeof(cl_float4) * forceField->molecule.nAtoms*2, NULL, NULL);


	// create kernels
	molecularDynamics->copyAccelarations = clCreateKernel(molecularDynamics->programMD, "copyAccelarations", &err);
	clSetKernelArg(molecularDynamics->copyAccelarations, 0, sizeof(cl_mem), &molecularDynamics->aCL);
	clSetKernelArg(molecularDynamics->copyAccelarations, 1, sizeof(cl_int), &forceField->molecule.nAtoms);
#ifdef DEBUG
	printf("End create kernel copyAccelarations err = %d\n",err);
#endif

	molecularDynamics->computeAccelarationsFromGradients = clCreateKernel(molecularDynamics->programMD, "computeAccelarationsFromGradients", &err);
	printf("ok  clCreateKernel(molecularDynamics->programMD  &err)\n");
	clSetKernelArg(molecularDynamics->computeAccelarationsFromGradients, 0, sizeof(cl_mem),   &forceField->gradientBufferCL);
	printf("ok  gradientBufferCL)\n");
	clSetKernelArg(molecularDynamics->computeAccelarationsFromGradients, 1, sizeof(cl_mem),   &molecularDynamics->aCL);
	printf("ok  aCL\n");
	clSetKernelArg(molecularDynamics->computeAccelarationsFromGradients, 2, sizeof(cl_mem),   &forceField->atomsCL);
	printf("ok  atomsCL\n");
	clSetKernelArg(molecularDynamics->computeAccelarationsFromGradients, 3, sizeof(cl_int), &forceField->molecule.nAtoms);
#ifdef DEBUG
	printf("End create kernel computeAccelarationsFromGradients\n");
#endif

	molecularDynamics->initAccelarations = clCreateKernel(molecularDynamics->programMD, "initAccelarations", &err);
	clSetKernelArg(molecularDynamics->initAccelarations, 0, sizeof(cl_mem), &molecularDynamics->aCL);
	clSetKernelArg(molecularDynamics->initAccelarations, 1, sizeof(cl_int), &forceField->molecule.nAtoms);
#ifdef DEBUG
	printf("End create kernel initAccelarations\n");
#endif


	molecularDynamics->computeKineticEnergy = clCreateKernel(molecularDynamics->programMD, "computeKineticEnergy", &err);
	clSetKernelArg(molecularDynamics->computeKineticEnergy, 0, sizeof(cl_mem),   &forceField->energyBufferCL);
	clSetKernelArg(molecularDynamics->computeKineticEnergy, 1, sizeof(cl_mem),   &forceField->atomsCL);
	clSetKernelArg(molecularDynamics->computeKineticEnergy, 2, sizeof(cl_int), &forceField->molecule.nAtoms);
#ifdef DEBUG
	printf("End create kernel computeKineticEnergy\n");
#endif

	molecularDynamics->scaleVelocities = clCreateKernel(molecularDynamics->programMD, "scaleVelocities", &err);
	clSetKernelArg(molecularDynamics->scaleVelocities, 0, sizeof(cl_mem),   &forceField->atomsCL);
	clSetKernelArg(molecularDynamics->scaleVelocities, 1, sizeof(cl_int), &forceField->molecule.nAtoms);

	molecularDynamics->removeTranslation = clCreateKernel(molecularDynamics->programMD, "removeTranslation", &err);
	clSetKernelArg(molecularDynamics->removeTranslation, 0, sizeof(cl_mem), &forceField->atomsCL);
	clSetKernelArg(molecularDynamics->removeTranslation, 1, sizeof(cl_int), &forceField->molecule.nAtoms);
	if(err != CL_SUCCESS) 
	{
		printf("I cannot create removeTranslation\n");
		exit(1);
	}

	molecularDynamics->removeRotation = clCreateKernel(molecularDynamics->programMD, "removeRotation", &err);
	clSetKernelArg(molecularDynamics->removeRotation, 0, sizeof(cl_mem), &forceField->atomsCL);
	clSetKernelArg(molecularDynamics->removeRotation, 1, sizeof(cl_int), &forceField->molecule.nAtoms);
	if(err != CL_SUCCESS) 
	{
		printf("I cannot create removeRotation\n");
		exit(1);
	}

	if(molecularDynamics->integratorType==VERLET) 
	{
		molecularDynamics->applyVerlet1 = clCreateKernel(molecularDynamics->programMD, "applyVerlet1", &err);
		clSetKernelArg(molecularDynamics->applyVerlet1, 0, sizeof(cl_mem),   &molecularDynamics->aCL);
		clSetKernelArg(molecularDynamics->applyVerlet1, 1, sizeof(cl_mem),   &forceField->atomsCL);
		clSetKernelArg(molecularDynamics->applyVerlet1, 2, sizeof(cl_float), &dtf);
		clSetKernelArg(molecularDynamics->applyVerlet1, 3, sizeof(cl_int), &forceField->molecule.nAtoms);

		molecularDynamics->applyVerlet2 = clCreateKernel(molecularDynamics->programMD, "applyVerlet2", &err);
		clSetKernelArg(molecularDynamics->applyVerlet2, 0, sizeof(cl_mem),   &molecularDynamics->aCL);
		clSetKernelArg(molecularDynamics->applyVerlet2, 1, sizeof(cl_mem),   &forceField->atomsCL);
		clSetKernelArg(molecularDynamics->applyVerlet2, 2, sizeof(cl_float), &dtf);
		clSetKernelArg(molecularDynamics->applyVerlet2, 3, sizeof(cl_int), &forceField->molecule.nAtoms);
#ifdef DEBUG
		printf("End create kernel applyVerlet1&2\n");
#endif
	}
	if(molecularDynamics->integratorType==BEEMAN) 
	{
#ifdef DEBUG
		printf("Begin create kernel applyBeeman1&2\n");
#endif
		molecularDynamics->applyBeeman1 = clCreateKernel(molecularDynamics->programMD, "applyBeeman1", &err);
		clSetKernelArg(molecularDynamics->applyBeeman1, 0, sizeof(cl_mem),   &molecularDynamics->aCL);
		clSetKernelArg(molecularDynamics->applyBeeman1, 1, sizeof(cl_mem),   &forceField->atomsCL);
		clSetKernelArg(molecularDynamics->applyBeeman1, 2, sizeof(cl_float), &dtf);
		clSetKernelArg(molecularDynamics->applyBeeman1, 3, sizeof(cl_int), &forceField->molecule.nAtoms);
#ifdef DEBUG
		printf("End create kernel applyBeeman1\n");
#endif

		molecularDynamics->applyBeeman2 = clCreateKernel(molecularDynamics->programMD, "applyBeeman2", &err);
		clSetKernelArg(molecularDynamics->applyBeeman2, 0, sizeof(cl_mem),   &molecularDynamics->aCL);
		clSetKernelArg(molecularDynamics->applyBeeman2, 1, sizeof(cl_mem),   &forceField->atomsCL);
		clSetKernelArg(molecularDynamics->applyBeeman2, 2, sizeof(cl_float), &dtf);
		clSetKernelArg(molecularDynamics->applyBeeman2, 3, sizeof(cl_int), &forceField->molecule.nAtoms);
#ifdef DEBUG
		printf("End create kernel applyBeeman1&2\n");
#endif
	}
	if(molecularDynamics->integratorType==STOCHASTIC) 
	{
		molecularDynamics->frictionBufferCL = clCreateBuffer(clProp.context, CL_MEM_READ_WRITE, sizeof(cl_float4) * forceField->molecule.nAtoms*3, NULL, NULL);
#ifdef DEBUG
		printf("Begin applyStochastic\n");
#endif
		molecularDynamics->applyStochastic1 = clCreateKernel(molecularDynamics->programMD, "applyStochastic1", &err);
		clSetKernelArg(molecularDynamics->applyStochastic1, 0, sizeof(cl_mem),  &molecularDynamics->frictionBufferCL);
		clSetKernelArg(molecularDynamics->applyStochastic1, 1, sizeof(cl_mem),  &molecularDynamics->aCL);
		clSetKernelArg(molecularDynamics->applyStochastic1, 2, sizeof(cl_mem),  &forceField->atomsCL);
		clSetKernelArg(molecularDynamics->applyStochastic1, 3, sizeof(cl_float), &dtf);
		clSetKernelArg(molecularDynamics->applyStochastic1, 4, sizeof(cl_int), &forceField->molecule.nAtoms);
#ifdef DEBUG
		printf("End applyStochastic1\n");
#endif

		molecularDynamics->applyStochastic2 = clCreateKernel(molecularDynamics->programMD, "applyStochastic2", &err);
		clSetKernelArg(molecularDynamics->applyStochastic2, 0, sizeof(cl_mem),   &molecularDynamics->frictionBufferCL);
		clSetKernelArg(molecularDynamics->applyStochastic2, 1, sizeof(cl_mem),   &molecularDynamics->aCL);
		clSetKernelArg(molecularDynamics->applyStochastic2, 2, sizeof(cl_mem),   &forceField->atomsCL);
		clSetKernelArg(molecularDynamics->applyStochastic2, 3, sizeof(cl_float), &dtf);
		clSetKernelArg(molecularDynamics->applyStochastic2, 4, sizeof(cl_int), &forceField->molecule.nAtoms);
#ifdef DEBUG
		printf("End applyStochastic2\n");
#endif
	}
	initRandomNumberGenerator(molecularDynamics, (unsigned int)(time(NULL)));
	if(molecularDynamics->thermostat==ANDERSEN) 
	{
		molecularDynamics->andersen = clCreateKernel(molecularDynamics->programMD, "andersen", &err);
		clSetKernelArg(molecularDynamics->andersen, 0, sizeof(cl_mem),   &molecularDynamics->randomsCL);
		clSetKernelArg(molecularDynamics->andersen, 1, sizeof(cl_mem),   &forceField->atomsCL);
		clSetKernelArg(molecularDynamics->andersen, 2, sizeof(cl_mem),   &molecularDynamics->nRandomsCL);
		clSetKernelArg(molecularDynamics->andersen, 3, sizeof(cl_int), &forceField->molecule.nAtoms);
		clSetKernelArg(molecularDynamics->andersen, 4, sizeof(cl_float), &temp);
#ifdef DEBUG
		printf("End ANDERSEN\n");
#endif
	}

#ifdef DEBUG
	printf("Begin updateGeometryVelocitiesCL--------------->\n");
#endif
	updateGeometryVelocitiesCL(forceField,&forceField->molecule);
	{
		size_t global = molecularDynamics->forceField->molecule.nAtoms;
		cl_int err = clEnqueueNDRangeKernel(clProp.command_queue, molecularDynamics->initAccelarations, 1, NULL, &global, NULL, 0, NULL, NULL);
		if(err != CL_SUCCESS)
		{
			printErrorCLRun(err);
        		printf("I cannot execute initAccelarations\n");
			exit(1);
		}
		clFinish(clProp.command_queue);
	}
	if(molecularDynamics->integratorType==STOCHASTIC) 
	{
		printf("---------->frictionf=%f\n",frictionf);
		molecularDynamics->setFrictionalAndRandomForce = clCreateKernel(molecularDynamics->programMD, "setFrictionalAndRandomForce", &err);
		clSetKernelArg(molecularDynamics->setFrictionalAndRandomForce, 0, sizeof(cl_mem), &molecularDynamics->frictionBufferCL);
		clSetKernelArg(molecularDynamics->setFrictionalAndRandomForce, 1, sizeof(cl_mem), &forceField->atomsCL);
		clSetKernelArg(molecularDynamics->setFrictionalAndRandomForce, 2, sizeof(cl_mem), &molecularDynamics->randomsCL);
		clSetKernelArg(molecularDynamics->setFrictionalAndRandomForce, 3, sizeof(cl_int), &molecularDynamics->nRandomsCL);
		clSetKernelArg(molecularDynamics->setFrictionalAndRandomForce, 4, sizeof(cl_int), &forceField->molecule.nAtoms);
		clSetKernelArg(molecularDynamics->setFrictionalAndRandomForce, 5, sizeof(cl_float), &temp);
		clSetKernelArg(molecularDynamics->setFrictionalAndRandomForce, 6, sizeof(cl_float), &dtf);
		clSetKernelArg(molecularDynamics->setFrictionalAndRandomForce, 7, sizeof(cl_float), &frictionf);
#ifdef DEBUG
		printf("End create kernel setFrictionalAndRandomForce\n");
#endif
	}
#ifdef DEBUG
	printf("Begin calcGrad2\n");
#endif
	molecularDynamics->forceField->klass->calculateGradient(molecularDynamics->forceField);
#ifdef DEBUG
	printf("End calcGrad2\n");
#endif
	{
		size_t global = molecularDynamics->forceField->molecule.nAtoms;
		cl_int err = clEnqueueNDRangeKernel(clProp.command_queue, molecularDynamics->computeAccelarationsFromGradients, 1, NULL, &global, NULL, 0, NULL, NULL);
		if(err != CL_SUCCESS)
		{
			printErrorCLRun(err);
        		printf("I cannot execute computeAccelarationsFromGradients\n");
			exit(1);
		}
		clFinish(clProp.command_queue);
	}
	if(molecularDynamics->aold)
	{
		size_t global = molecularDynamics->forceField->molecule.nAtoms;
		cl_int err = clEnqueueNDRangeKernel(clProp.command_queue, molecularDynamics->copyAccelarations, 1, NULL, &global, NULL, 0, NULL, NULL);
		if(err != CL_SUCCESS)
		{
			printErrorCLRun(err);
        		printf("I cannot execute copyAccelarations\n");
			exit(1);
		}
		clFinish(clProp.command_queue);
	}
	if(molecularDynamics->forceField->molecule.constraints!=NOCONSTRAINTS)
	{
		molecularDynamics->oldPositionBufferCL = clCreateBuffer(clProp.context, CL_MEM_READ_WRITE, sizeof(cl_float4) * forceField->molecule.nAtoms, NULL, NULL);
		molecularDynamics->copyPositions = clCreateKernel(molecularDynamics->programMD, "copyPositions", &err);
		clSetKernelArg(molecularDynamics->copyPositions, 0, sizeof(cl_mem), &molecularDynamics->oldPositionBufferCL);
		clSetKernelArg(molecularDynamics->copyPositions, 1, sizeof(cl_mem), &forceField->atomsCL);
		clSetKernelArg(molecularDynamics->copyPositions, 2, sizeof(cl_int), &forceField->molecule.nAtoms);

		molecularDynamics->initRattles = clCreateKernel(molecularDynamics->programMD, "initRattles", &err);
		clSetKernelArg(molecularDynamics->initRattles, 0, sizeof(cl_mem), &forceField->rattledeltaPositionBufferCL);
		clSetKernelArg(molecularDynamics->initRattles, 1, sizeof(cl_mem), &forceField->rattledeltaVelocityBufferCL);
		clSetKernelArg(molecularDynamics->initRattles, 2, sizeof(cl_mem), &forceField->rattleUpdateBufferCL);
		clSetKernelArg(molecularDynamics->initRattles, 3, sizeof(cl_mem), &forceField->rattleMovedBufferCL);
		clSetKernelArg(molecularDynamics->initRattles, 4, sizeof(cl_int), &forceField->molecule.nAtoms);
		clSetKernelArg(molecularDynamics->initRattles, 5, sizeof(cl_int), &forceField->nBlockRattleBuffer);
#ifdef DEBUG
		printf("End create kernel initRattles\n");
#endif

		molecularDynamics->updateRattle1 = clCreateKernel(molecularDynamics->programMD, "updateRattle1", &err);
		clSetKernelArg(molecularDynamics->updateRattle1, 0, sizeof(cl_mem), &forceField->rattledeltaPositionBufferCL);
		clSetKernelArg(molecularDynamics->updateRattle1, 1, sizeof(cl_mem), &forceField->rattledeltaVelocityBufferCL);
		clSetKernelArg(molecularDynamics->updateRattle1, 2, sizeof(cl_mem), &forceField->rattleUpdateBufferCL);
		clSetKernelArg(molecularDynamics->updateRattle1, 3, sizeof(cl_mem), &forceField->rattleMovedBufferCL);
		clSetKernelArg(molecularDynamics->updateRattle1, 4, sizeof(cl_mem), &forceField->atomsCL);
		clSetKernelArg(molecularDynamics->updateRattle1, 5, sizeof(cl_int), &forceField->molecule.nAtoms);
		clSetKernelArg(molecularDynamics->updateRattle1, 6, sizeof(cl_int), &forceField->nBlockRattleBuffer);
#ifdef DEBUG
		printf("End create kernel updateRattle1\n");
#endif

		molecularDynamics->testDoneRattle = clCreateKernel(molecularDynamics->programMD, "testDoneRattle", &err);
		clSetKernelArg(molecularDynamics->testDoneRattle, 0, sizeof(cl_mem), &forceField->rattleMovedBufferCL);
		clSetKernelArg(molecularDynamics->testDoneRattle, 1, sizeof(cl_mem), &forceField->rattleDoneBufferCL);
		clSetKernelArg(molecularDynamics->testDoneRattle, 2, sizeof(cl_int), &forceField->molecule.nAtoms);
#ifdef DEBUG
		printf("End create kernel testDoneRattle\n");
#endif

		molecularDynamics->applyRattle1 = clCreateKernel(molecularDynamics->programMD, "applyRattle1", &err);
		clSetKernelArg(molecularDynamics->applyRattle1, 0, sizeof(cl_mem), &molecularDynamics->oldPositionBufferCL);
		clSetKernelArg(molecularDynamics->applyRattle1, 1, sizeof(cl_mem), &forceField->rattleConstraintsIndexCL);
		clSetKernelArg(molecularDynamics->applyRattle1, 2, sizeof(cl_mem), &forceField->rattleConstraintsTermsCL);
		clSetKernelArg(molecularDynamics->applyRattle1, 3, sizeof(cl_mem), &forceField->rattledeltaPositionBufferCL);
		clSetKernelArg(molecularDynamics->applyRattle1, 4, sizeof(cl_mem), &forceField->rattledeltaVelocityBufferCL);
		clSetKernelArg(molecularDynamics->applyRattle1, 5, sizeof(cl_mem), &forceField->rattleUpdateBufferCL);
		clSetKernelArg(molecularDynamics->applyRattle1, 6, sizeof(cl_mem), &forceField->rattleMovedBufferCL);
		clSetKernelArg(molecularDynamics->applyRattle1, 7, sizeof(cl_mem), &forceField->atomsCL);
		clSetKernelArg(molecularDynamics->applyRattle1, 8, sizeof(cl_int), &forceField->molecule.nAtoms);
		clSetKernelArg(molecularDynamics->applyRattle1, 9, sizeof(cl_int), &forceField->numberOfRattleConstraintsTerms);
		clSetKernelArg(molecularDynamics->applyRattle1, 10, sizeof(cl_int), &dtf);
#ifdef DEBUG
		printf("End create kernel applyRattle1\n");
#endif


		molecularDynamics->updateRattle2 = clCreateKernel(molecularDynamics->programMD, "updateRattle2", &err);
		clSetKernelArg(molecularDynamics->updateRattle2, 0, sizeof(cl_mem), &forceField->rattledeltaVelocityBufferCL);
		clSetKernelArg(molecularDynamics->updateRattle2, 1, sizeof(cl_mem), &forceField->rattleUpdateBufferCL);
		clSetKernelArg(molecularDynamics->updateRattle2, 2, sizeof(cl_mem), &forceField->rattleMovedBufferCL);
		clSetKernelArg(molecularDynamics->updateRattle2, 3, sizeof(cl_mem), &forceField->atomsCL);
		clSetKernelArg(molecularDynamics->updateRattle2, 4, sizeof(cl_int), &forceField->molecule.nAtoms);
		clSetKernelArg(molecularDynamics->updateRattle2, 5, sizeof(cl_int), &forceField->nBlockRattleBuffer);
#ifdef DEBUG
		printf("End create kernel updateRattle2\n");
#endif

		molecularDynamics->applyRattle2 = clCreateKernel(molecularDynamics->programMD, "applyRattle2", &err);
		clSetKernelArg(molecularDynamics->applyRattle2, 0, sizeof(cl_mem), &forceField->rattleConstraintsIndexCL);
		clSetKernelArg(molecularDynamics->applyRattle2, 1, sizeof(cl_mem), &forceField->rattleConstraintsTermsCL);
		clSetKernelArg(molecularDynamics->applyRattle2, 2, sizeof(cl_mem), &forceField->rattledeltaVelocityBufferCL);
		clSetKernelArg(molecularDynamics->applyRattle2, 3, sizeof(cl_mem), &forceField->rattleUpdateBufferCL);
		clSetKernelArg(molecularDynamics->applyRattle2, 4, sizeof(cl_mem), &forceField->rattleMovedBufferCL);
		clSetKernelArg(molecularDynamics->applyRattle2, 5, sizeof(cl_mem), &forceField->atomsCL);
		clSetKernelArg(molecularDynamics->applyRattle2, 6, sizeof(cl_int), &forceField->molecule.nAtoms);
		clSetKernelArg(molecularDynamics->applyRattle2, 7, sizeof(cl_int), &forceField->numberOfRattleConstraintsTerms);
		clSetKernelArg(molecularDynamics->applyRattle2, 8, sizeof(cl_int), &dtf);
#ifdef DEBUG
		printf("End create kernel applyRattle2\n");
#endif
	}

/* TO DO for rattle
	for ( i = 0; i < molecularDynamics->numberOfAtoms; i++)
	{
		if(molecularDynamics->coordinatesOld)
		       	for ( j = 0; j < 3; j++) molecularDynamics->coordinatesOld[i][j]  = molecularDynamics->forceField->molecule.atoms[i].coordinates[j];
		if(molecularDynamics->moved) molecularDynamics->moved[i] = FALSE; 
		if(molecularDynamics->update) molecularDynamics->update[i] = FALSE; 
	}
*/
#endif

#ifdef DEBUG
	printf("End initMD--------------->\n");
#endif
}
/*********************************************************************************/
static void rescaleVelocities(MolecularDynamics* molecularDynamics)
{
	/* berendsen(molecularDynamics);*/
	if(molecularDynamics->temperature<=0) return;
	scaleV(molecularDynamics);
	resetQTB(molecularDynamics);
	resetLangevin(molecularDynamics);
}
/*********************************************************************************/
#ifdef ENABLE_CL
static void scaleCLVelocities(MolecularDynamics* molecularDynamics, double scale)
{
	{
		size_t global = 1;
		global =  molecularDynamics->numberOfAtoms;
		cl_float s = (cl_float)scale;
		cl_int err;
		CLProp clProp = getCLProp();

		clSetKernelArg(molecularDynamics->scaleVelocities, 2, sizeof(cl_float), &s);
		err = clEnqueueNDRangeKernel(clProp.command_queue, molecularDynamics->scaleVelocities, 1, NULL, &global, NULL, 0, NULL, NULL);
		if(err != CL_SUCCESS)
		{
			printErrorCLRun(err);
        		printf("I cannot execute scaleVelocities\n");
			exit(1);
		}
		clFinish(clProp.command_queue);
	}
//	printf("End scaleCLVelocities\n");
}
#endif
/*********************************************************************************/
static void scaleV(MolecularDynamics* molecularDynamics)
{
	double kelvin = 0;
	int nfree = molecularDynamics->forceField->molecule.nFree;
	double scale = 1.0;
#ifndef ENABLE_CL
	//double mass = 1.0;
	double ekin = 0;
	int i;
	int j;
#endif
	if(molecularDynamics->temperature<=0) return;
	if(nfree<1) return;
#ifdef ENABLE_CL
	{
		size_t global = 1;
		cl_float ekin;
		ekin = getEKin(molecularDynamics);
		kelvin = 2*ekin / ( nfree * Kb);
		scale = sqrt(molecularDynamics->temperature/kelvin);
		global =  molecularDynamics->numberOfAtoms;

#ifdef DEBUG
		printf("temp = %f kelvin = %f scale = %f\n",molecularDynamics->temperature, kelvin, scale);
		printf("===========> Call scaleVelocities\n");
#endif
		scaleCLVelocities(molecularDynamics, scale);
	}
#else 
	ekin = getEKin(molecularDynamics);
	kelvin = 2*ekin / ( nfree * Kb);

	scale = sqrt(molecularDynamics->temperature/kelvin);
#ifdef DEBUG
	printf("temp = %f kelvin = %f scale = %f\n",molecularDynamics->temperature, kelvin, scale);
#endif
	for ( i = 0; i < molecularDynamics->numberOfAtoms; i++)
		if(molecularDynamics->forceField->molecule.atoms[i].variable)
		for ( j = 0; j < 3; j++)
			molecularDynamics->forceField->molecule.atoms[i].velocity[j] *= scale;
#endif
	removeTranslationAndRotation(molecularDynamics);

/*
	ekin = getEKin(molecularDynamics);
	kelvin = 2*ekin / ( nfree * Kb);
	scale = sqrt(molecularDynamics->temperature/kelvin);
	printf("REM temp = %f kelvin = %f scale = %f\n",molecularDynamics->temperature, kelvin, scale);
*/

}
/*********************************************************************************/
static void berendsen(MolecularDynamics* molecularDynamics)
{
	double kelvin = 0;
	int nfree = molecularDynamics->forceField->molecule.nFree;
	double scale = 1.0;
	double dt = molecularDynamics->dt;
	double tautemp = 1.0/(molecularDynamics->collide)*1000*fsInAKMA;
#ifndef ENABLE_CL
	//double mass = 1.0;
	double ekin = 0;
	int i;
	int j;
#endif
	if(molecularDynamics->temperature<=0) return;
	if(nfree<1) return;
#ifdef ENABLE_CL
	{
		size_t global = 1;
		cl_float ekin;
		ekin = getEKin(molecularDynamics);
		kelvin = 2*ekin / ( nfree * Kb);
		scale = sqrt(1.0 + (dt/tautemp)*(molecularDynamics->temperature/kelvin-1.0));
		global =  molecularDynamics->numberOfAtoms;

#ifdef DEBUG
		printf("temp = %f kelvin = %f scale = %f\n",molecularDynamics->temperature, kelvin, scale);
		printf("===========> Call scaleVelocities\n");
#endif
		scaleCLVelocities(molecularDynamics, scale);
	}
#else 
/*
	for ( i = 0; i < molecularDynamics->numberOfAtoms; i++)
	{
		mass = molecularDynamics->forceField->molecule.atoms[i].mass;
		for ( j = 0; j < 3; j++)
			ekin += molecularDynamics->forceField->molecule.atoms[i].velocity[j]*molecularDynamics->forceField->molecule.atoms[i].velocity[j]*
				mass;
	}
	//ekin /= 2;
	//kelvin = 2* ekin / ( nfree * Kb);
	kelvin = ekin / ( nfree * Kb);
*/
	ekin = getEKin(molecularDynamics);
	kelvin = 2*ekin / ( nfree * Kb);

	scale = sqrt(1.0 + (dt/tautemp)*(molecularDynamics->temperature/kelvin-1.0));
#ifdef DEBUG
	printf("temp = %f kelvin = %f scale = %f\n",molecularDynamics->temperature, kelvin, scale);
#endif
	for ( i = 0; i < molecularDynamics->numberOfAtoms; i++)
		if(molecularDynamics->forceField->molecule.atoms[i].variable)
		for ( j = 0; j < 3; j++)
			molecularDynamics->forceField->molecule.atoms[i].velocity[j] *= scale;
#endif
	removeTranslationAndRotation(molecularDynamics);
}
/*********************************************************************************/
static void andersen(MolecularDynamics* molecularDynamics)
{
	double tau = 1.0/molecularDynamics->collide*1000*fsInAKMA; /* in fs */
	double rate;
	if(molecularDynamics->temperature<=0) return;
	if(molecularDynamics->numberOfAtoms<1) return;

	rate = molecularDynamics->dt / tau;
	rate /= pow(molecularDynamics->nvariables,2.0/3.0);

#ifdef ENABLE_CL
	size_t global =  molecularDynamics->forceField->molecule.nAtoms;
	cl_int err;
	CLProp clProp = getCLProp();
	cl_float r = rate;
	cl_float temp = molecularDynamics->temperature;
	resetRandomNumbers(molecularDynamics);
	clSetKernelArg(molecularDynamics->andersen, 4, sizeof(cl_float), &temp);
	clSetKernelArg(molecularDynamics->andersen, 5, sizeof(cl_float), &r);
	err = clEnqueueNDRangeKernel(clProp.command_queue, molecularDynamics->andersen, 1, NULL, &global, NULL, 0, NULL, NULL);
	if(err != CL_SUCCESS)
	{
		printErrorCLRun(err);
       		printf("I cannot execute andersen\n");
		exit(1);
	}
	clFinish(clProp.command_queue);
#else
	int i;
	/* printf("------->rate=%f\n",rate);*/
	for ( i = 0; i < molecularDynamics->numberOfAtoms; i++)
	{
		double trial = drandom();
		double m = molecularDynamics->forceField->molecule.atoms[i].mass;
		if(molecularDynamics->forceField->molecule.atoms[i].variable)
		if(trial<rate)
		{
	/*
			double speed = maxwel(
					molecularDynamics->forceField->molecule.atoms[i].mass,
					molecularDynamics->temperature
					);
			getRandVect(speed, molecularDynamics->forceField->molecule.atoms[i].velocity);
	*/
			double speed = sqrt(Kb* molecularDynamics->temperature/m);
                	double pnorm = normal();
			molecularDynamics->forceField->molecule.atoms[i].velocity[0] = pnorm*speed;
                	pnorm = normal();
			molecularDynamics->forceField->molecule.atoms[i].velocity[1] = pnorm*speed;
                	pnorm = normal();
			molecularDynamics->forceField->molecule.atoms[i].velocity[2] = pnorm*speed;
		}
	}
#endif
}
/*********************************************************************************/
static void bussi(MolecularDynamics* molecularDynamics)
{
	int nfree = molecularDynamics->forceField->molecule.nFree;
	double scale = 1.0;
	double dt = molecularDynamics->dt;
	double tautemp = 1.0/(molecularDynamics->collide)*1000*fsInAKMA;
        double c = exp(-dt/tautemp);
	double ekin = getEKin(molecularDynamics);
	double kelvin = 2*ekin / ( nfree * Kb);
	double d = (1.0-c) * (molecularDynamics->temperature/kelvin) / (nfree);
	double r = normal ();
	double si = 0.0;
	double s = 0.0;
	int i;
#ifndef ENABLE_CL
	int j;
#endif
	if(molecularDynamics->temperature<=0) return;
	if(nfree<1) return;
        for(i=0;i<nfree-1;i++)
	{
            si = normal ();
            s += si*si;
	}
	scale = c + (s+r*r)*d + 2.0*r*sqrt(c*d);
	scale = sqrt(scale);
	if (r+sqrt(c/d)<0)  scale = -scale;
#ifdef ENABLE_CL
	{
		size_t global = 1;
		cl_float s;
		cl_int err;
		CLProp clProp = getCLProp();
		global =  molecularDynamics->numberOfAtoms;
		s = (cl_float)scale;

#ifdef DEBUG
		printf("temp = %f kelvin = %f scale = %f\n",molecularDynamics->temperature, kelvin, scale);
		printf("===========> Call scaleVelocities\n");
#endif

		clSetKernelArg(molecularDynamics->scaleVelocities, 2, sizeof(cl_float), &s);
		err = clEnqueueNDRangeKernel(clProp.command_queue, molecularDynamics->scaleVelocities, 1, NULL, &global, NULL, 0, NULL, NULL);
		if(err != CL_SUCCESS)
		{
			printErrorCLRun(err);
        		printf("I cannot execute scaleVelocities\n");
			exit(1);
		}
		clFinish(clProp.command_queue);
	}
#else 
#ifdef DEBUG
	printf("temp = %f kelvin = %f scale = %f\n",molecularDynamics->temperature, kelvin, scale);
#endif
	for ( i = 0; i < molecularDynamics->numberOfAtoms; i++)
		if(molecularDynamics->forceField->molecule.atoms[i].variable)
		for ( j = 0; j < 3; j++)
			molecularDynamics->forceField->molecule.atoms[i].velocity[j] *= scale;
#endif
	removeTranslationAndRotation(molecularDynamics);
}
/*********************************************************************************/
static void nose_hoover(MolecularDynamics* molecularDynamics)
{
	int nfree = molecularDynamics->forceField->molecule.nFree;
	double scale = 1.0;
	double ekin = getEKin(molecularDynamics);
	double kT = Kb* molecularDynamics->temperature;
	int i,j;
	if(molecularDynamics->temperature<=0) return;
	if(nfree<1) return;
	molecularDynamics->gNH[1] = (molecularDynamics->qNH[0]*molecularDynamics->vNH[0]*molecularDynamics->vNH[0]-kT) / molecularDynamics->qNH[1];
	//printf("gNH = %f\n",molecularDynamics->gNH[1]);
	molecularDynamics->vNH[1] = molecularDynamics->vNH[1] + molecularDynamics->gNH[1]*molecularDynamics->dt_4;
	molecularDynamics->vNH[0] = molecularDynamics->vNH[0] * exp(-molecularDynamics->vNH[1]*molecularDynamics->dt_8);
	molecularDynamics->gNH[0] = (2.0*ekin-nfree*kT) / molecularDynamics->qNH[0];
	molecularDynamics->vNH[0] = molecularDynamics->vNH[0] + molecularDynamics->gNH[0]*molecularDynamics->dt_4;
	molecularDynamics->vNH[0] = molecularDynamics->vNH[0] * exp(-molecularDynamics->vNH[1]*molecularDynamics->dt_8);
	molecularDynamics->xNH[0] = molecularDynamics->xNH[0] + molecularDynamics->vNH[0]*molecularDynamics->dt_2;
	molecularDynamics->xNH[1] = molecularDynamics->xNH[1] + molecularDynamics->vNH[1]*molecularDynamics->dt_2;
	//printf("vnH0 = %f\n",molecularDynamics->vNH[0]);
	scale = exp(-molecularDynamics->vNH[0]*molecularDynamics->dt_2);
	//printf("scale = %f\n",scale);
#ifdef ENABLE_CL
	{
		size_t global = 1;
		cl_float s;
		cl_int err;
		CLProp clProp = getCLProp();
		global =  molecularDynamics->numberOfAtoms;
		s = (cl_float)scale;

#ifdef DEBUG
		printf("===========> Call scaleVelocities\n");
#endif
		clSetKernelArg(molecularDynamics->scaleVelocities, 2, sizeof(cl_float), &s);
		err = clEnqueueNDRangeKernel(clProp.command_queue, molecularDynamics->scaleVelocities, 1, NULL, &global, NULL, 0, NULL, NULL);
		if(err != CL_SUCCESS)
		{
			printErrorCLRun(err);
        		printf("I cannot execute scaleVelocities\n");
			exit(1);
		}
		clFinish(clProp.command_queue);
	}
#else 
	for ( i = 0; i < molecularDynamics->numberOfAtoms; i++)
		if(molecularDynamics->forceField->molecule.atoms[i].variable)
		for ( j = 0; j < 3; j++)
			molecularDynamics->forceField->molecule.atoms[i].velocity[j] *= scale;
#endif
	ekin = ekin * scale * scale;
	molecularDynamics->vNH[0] = molecularDynamics->vNH[0] * exp(-molecularDynamics->vNH[1]*molecularDynamics->dt_8);
	molecularDynamics->gNH[0] = (2.0*ekin-nfree*kT) /  molecularDynamics->qNH[0];
	molecularDynamics->vNH[0] = molecularDynamics->vNH[0] + molecularDynamics->gNH[0]*molecularDynamics->dt_4;
	molecularDynamics->vNH[0] = molecularDynamics->vNH[0] * exp(-molecularDynamics->vNH[1]*molecularDynamics->dt_8);
	molecularDynamics->gNH[1] = ( molecularDynamics->qNH[0]*molecularDynamics->vNH[0]*molecularDynamics->vNH[0]-kT) /  molecularDynamics->qNH[1];
	molecularDynamics->vNH[1] = molecularDynamics->vNH[1] + molecularDynamics->gNH[1]*molecularDynamics->dt_4;

	removeTranslationAndRotation(molecularDynamics);

}
/*********************************************************************************/
static void newAccelaration(MolecularDynamics* molecularDynamics)
{
#ifdef DEBUG
	TimerType timer;
	TimerType timer2;
        timer_init(timer);
       	timer_start( timer );
        timer_init(timer2);
       	timer_start( timer2 );
#endif
#ifdef ENABLE_CL
	CLProp clProp=getCLProp();

#ifdef DEBUG
        printf("Begin newAcc\n");
#endif
	molecularDynamics->forceField->klass->calculateGradient(molecularDynamics->forceField);
#ifdef DEBUG
       	timer_stop(timer2);
        printf("time newAccCalcG (s) = %f\n", timer_get(timer2)*1e-6);
#endif
	if(molecularDynamics->aold)
	{
		size_t global = molecularDynamics->forceField->molecule.nAtoms;
		cl_int err = clEnqueueNDRangeKernel(clProp.command_queue, molecularDynamics->copyAccelarations, 1, NULL, &global, NULL, 0, NULL, NULL);
		if(err != CL_SUCCESS)
		{
			printErrorCLRun(err);
        		printf("I cannot execute copyAccelarations\n");
			exit(1);
		}
		clFinish(clProp.command_queue);
	}
	{
		size_t global = molecularDynamics->forceField->molecule.nAtoms;
		cl_int err = clEnqueueNDRangeKernel(clProp.command_queue, molecularDynamics->computeAccelarationsFromGradients, 1, NULL, &global, NULL, 0, NULL, NULL);
		if(err != CL_SUCCESS)
		{
			printErrorCLRun(err);
        		printf("I cannot execute computeAccelarationsFromGradients\n");
			exit(1);
		}
		clFinish(clProp.command_queue);
	}
#else
	int i;
	int j;
	molecularDynamics->forceField->klass->calculateGradient(molecularDynamics->forceField);
#ifdef DEBUG
       	timer_stop(timer2);
        printf("time newAccCalcG (s) = %f\n", timer_get(timer2)*1e-6);
#endif
	for ( i = 0; i < molecularDynamics->numberOfAtoms; i++)
	{
		double m = molecularDynamics->forceField->molecule.atoms[i].mass;
		if(molecularDynamics->aold)
			for ( j = 0; j < 3; j++)
				molecularDynamics->aold[i][j]  = molecularDynamics->a[i][j];

		for ( j = 0; j < 3; j++)
			molecularDynamics->a[i][j] = -molecularDynamics->forceField->molecule.atoms[i].gradient[j]/m;
	}
#endif
#ifdef DEBUG
       	timer_stop(timer);
        printf("time newAcc (s) = %f\n", timer_get(timer)*1e-6);
#endif
}
/*********************************************************************************/
static void computeEnergies(MolecularDynamics* molecularDynamics)
{
	molecularDynamics->kineticEnergy = getEKin(molecularDynamics);
	//molecularDynamics->potentialEnergy = molecularDynamics->forceField->klass->calculateEnergyTmp(
	//	      molecularDynamics->forceField,&molecularDynamics->forceField->molecule);
	molecularDynamics->potentialEnergy = molecularDynamics->forceField->molecule.potentialEnergy;
	molecularDynamics->totalEnergy = molecularDynamics->kineticEnergy + molecularDynamics->potentialEnergy;
	molecularDynamics->kelvin = getKelvin(molecularDynamics);
}
/*********************************************************************************/
static void applyThermostat(MolecularDynamics* molecularDynamics)
{
	if(molecularDynamics->integratorType == STOCHASTIC) return;
	if(molecularDynamics->integratorType == QTB) return;
	if(molecularDynamics->integratorType == LANGEVIN) return;
	if(molecularDynamics->thermostat == ANDERSEN) andersen(molecularDynamics);
	if(molecularDynamics->thermostat == BERENDSEN) berendsen(molecularDynamics);
	if(molecularDynamics->thermostat == BUSSI) bussi(molecularDynamics);
}
/*********************************************************************************/
static void applyOneStep(MolecularDynamics* molecularDynamics, int iStep)
{
#ifdef DEBUG
	TimerType timer;
        timer_init(timer);
       	timer_start( timer );
#endif
	//printf("molecularDynamics->integratorType=%d Tuckerman=%d\n",molecularDynamics->integratorType,MARTYNATUCKERMAN);
	if(molecularDynamics->integratorType==VERLET) applyVerlet(molecularDynamics);
	else if(molecularDynamics->integratorType==BEEMAN) applyBeeman(molecularDynamics);
	else if(molecularDynamics->integratorType==STOCHASTIC) applyStochastic(molecularDynamics);
	else if(molecularDynamics->integratorType==MARTYNATUCKERMAN) applyMartynaTuckerman(molecularDynamics);
	else if(molecularDynamics->integratorType==LANGEVIN) {
		updateLangevin(molecularDynamics);
		applyLangevin(molecularDynamics);
	}
	else {
		if((iStep+1)%molecularDynamics->M==0) 
				updateQTB(molecularDynamics);
		applyQTB(molecularDynamics);
	}
#ifdef DEBUG
       	timer_stop(timer);
        printf("time applyOneStape (s) = %f\n", timer_get(timer)*1e-6);
#endif
	computeEnergies(molecularDynamics);
}
/*********************************************************************************/
static void applyRattleFirstPortion(MolecularDynamics* molecularDynamics)
{
#ifdef ENABLE_CL
	ForceField* forceField = molecularDynamics->forceField;
	CLProp clProp=getCLProp();
	cl_int done=1;
	int nIter = 0;
	int maxIter = 1000;
	cl_int err;
	size_t global = forceField->molecule.nAtoms*forceField->nBlockRattleBuffer;
	err = clEnqueueNDRangeKernel(clProp.command_queue, molecularDynamics->initRattles, 1, NULL, &global, NULL, 0, NULL, NULL);
	if(err != CL_SUCCESS)
	{
		printErrorCLRun(err);
       		printf("I cannot execute initRattles,\n");
		exit(1);
	}
	clFinish(clProp.command_queue);
#ifdef DEBUG
	printf("applyRattleFirstPortion : end initRattles\n");
#endif
	do{
		nIter++;
		//printf("applyRattleFirstPortion : nIter =%d\n",nIter);
		global =  molecularDynamics->forceField->numberOfRattleConstraintsTerms;
		err = clEnqueueNDRangeKernel(clProp.command_queue, molecularDynamics->applyRattle1, 1, NULL, &global, NULL, 0, NULL, NULL);
		global = forceField->molecule.nAtoms;
		err = clEnqueueNDRangeKernel(clProp.command_queue, molecularDynamics->updateRattle1, 1, NULL, &global, NULL, 0, NULL, NULL);
		global = 1;
		err = clEnqueueNDRangeKernel(clProp.command_queue, molecularDynamics->testDoneRattle, 1, NULL, &global, NULL, 0, NULL, NULL);
		clEnqueueReadBuffer(clProp.command_queue, forceField->rattleDoneBufferCL, CL_TRUE, 0, sizeof(cl_int)*1, &done, 0, NULL, NULL);
		//printf("applyRattleFirstPortion : Done =%d\n",done);
	}while(done<1 && nIter<maxIter);
	if(nIter>=maxIter)
	{
		printf(("Rattle first portion : Warning, distance constraints not satisfied\n"));
		exit(1);
	}
#else
	int i;
	int k;
	int maxIter = 1000;
	double omega = 1.0; 
	double tolerance = 1e-6;
	boolean done = FALSE;
	int nIter = 0;
	int a1 = 0;
	int a2 = 0;
	double r2ij;
	double dot;
	double invMass1;
	double invMass2;
	double delta;
	double term = 0;
	double terms[3];
	double d;
	Molecule* m = &molecularDynamics->forceField->molecule;
	ForceField* forceField = molecularDynamics->forceField;
	double deltaMax = 0;

	if(forceField->molecule.constraints==NOCONSTRAINTS) return;
	for (i = 0; i < molecularDynamics->numberOfAtoms; i++)
	{
			molecularDynamics->moved[i] = molecularDynamics->forceField->molecule.atoms[i].variable;
			//molecularDynamics->moved[i] = TRUE;
			molecularDynamics->update[i] = FALSE;
	}
	/* maxIter *= molecularDynamics->forceField->numberOfRattleConstraintsTerms;*/
	do{
		nIter++;
		done=TRUE;
		deltaMax = 0;
		for (i = 0; i < molecularDynamics->forceField->molecule.numberOfRattleConstraintsTerms; i++)
		{
			a1 = (int)molecularDynamics->forceField->molecule.rattleConstraintsTerms[0][i];
			a2 = (int)molecularDynamics->forceField->molecule.rattleConstraintsTerms[1][i];
			if( !molecularDynamics->moved[a1] && !molecularDynamics->moved[a2] ) continue;
			r2ij = 0;
			for (k=0;k<3;k++)
			{
				d = m->atoms[a2].coordinates[k]-m->atoms[a1].coordinates[k];
				r2ij +=d*d;
			}
			delta = molecularDynamics->forceField->molecule.rattleConstraintsTerms[2][i]-r2ij;
			/* if(fabs(delta)<=tolerance) continue;*/
			if(r2ij>0 && fabs(delta/r2ij)<=tolerance) continue;
			if(deltaMax<fabs(delta)) deltaMax = fabs(delta);
			done = FALSE;
			molecularDynamics->update[a1] = TRUE;
			molecularDynamics->update[a2] = TRUE;
			/* here : rattle image for PBC, not yet implemented */
			dot = 0;
			for (k=0;k<3;k++)
			{
				d = m->atoms[a2].coordinates[k]-m->atoms[a1].coordinates[k];
				dot +=d*(molecularDynamics->coordinatesOld[a2][k]-molecularDynamics->coordinatesOld[a1][k]);
			}
			invMass1 = 1/m->atoms[a1].mass;
			invMass2 = 1/m->atoms[a2].mass;
		        term = omega*delta / (2.0*(invMass1+invMass2)*dot);
			for (k=0;k<3;k++)
			{
				terms[k] = (molecularDynamics->coordinatesOld[a2][k]-molecularDynamics->coordinatesOld[a1][k])*term;
			}
			for (k=0;k<3;k++) m->atoms[a1].coordinates[k] -= terms[k]*invMass1;
			for (k=0;k<3;k++) m->atoms[a2].coordinates[k] += terms[k]*invMass2;

			invMass1 /= molecularDynamics->dt;
			invMass2 /= molecularDynamics->dt;
			for (k=0;k<3;k++) molecularDynamics->forceField->molecule.atoms[a1].velocity[k] -= terms[k]*invMass1;
			for (k=0;k<3;k++) molecularDynamics->forceField->molecule.atoms[a2].velocity[k] += terms[k]*invMass2;
		}
		for (i = 0; i < molecularDynamics->numberOfAtoms; i++)
		{
			molecularDynamics->moved[i] = molecularDynamics->update[i];
			molecularDynamics->update[i] = FALSE;
		}
	}while(!done && nIter<maxIter);
	if(nIter>=maxIter && deltaMax>tolerance*10)
	{
		printf(("Rattle first portion : Warning, distance constraints not satisfied\n"));
		/*
		for (i = 0; i < molecularDynamics->numberOfAtoms; i++)
		{
			printf("atom#%d\n",i);
			printf("Old coord\n");
			for (k=0;k<3;k++) printf("%f ",molecularDynamics->coordinatesOld[i][k]);
			printf("\n");
			printf("New coord\n");
			for (k=0;k<3;k++) printf("%f ",m->atoms[i].coordinates[k]);
			printf("\n");
		}
		exit(1);
		*/
		for (i = 0; i < molecularDynamics->forceField->molecule.numberOfRattleConstraintsTerms; i++)
		{
			a1 = (int)molecularDynamics->forceField->molecule.rattleConstraintsTerms[0][i];
			a2 = (int)molecularDynamics->forceField->molecule.rattleConstraintsTerms[1][i];
			r2ij = 0;
			for (k=0;k<3;k++)
			{
				d = m->atoms[a2].coordinates[k]-m->atoms[a1].coordinates[k];
				r2ij +=d*d;
			}
			delta = molecularDynamics->forceField->molecule.rattleConstraintsTerms[2][i]-r2ij;
			printf("%d %d %s %s r2ij=%f r2Old=%f delta=%f\n",
			a1,a2,
			molecularDynamics->forceField->molecule.atoms[a1].mmType,
			molecularDynamics->forceField->molecule.atoms[a2].mmType,
			r2ij, molecularDynamics->forceField->molecule.rattleConstraintsTerms[2][i],delta);
		}
	}
	for (i = 0; i < molecularDynamics->numberOfAtoms; i++)
	{
		if(!molecularDynamics->forceField->molecule.atoms[i].variable)
		{
			for (k=0;k<3;k++) molecularDynamics->forceField->molecule.atoms[i].velocity[k] = 0.0;
			for (k=0;k<3;k++) m->atoms[i].coordinates[k] =  molecularDynamics->coordinatesOld[i][k];
		}
	}
#endif /* ENABLE_CL*/

}
/*********************************************************************************/
static void applyRattleSecondPortion(MolecularDynamics* molecularDynamics)
{
#ifdef ENABLE_CL
	ForceField* forceField = molecularDynamics->forceField;
	CLProp clProp=getCLProp();
	cl_int done=1;
	int nIter = 0;
	cl_int err;
	int maxIter = 1000;
	size_t global = forceField->molecule.nAtoms*forceField->nBlockRattleBuffer;
	err = clEnqueueNDRangeKernel(clProp.command_queue, molecularDynamics->initRattles, 1, NULL, &global, NULL, 0, NULL, NULL);
	if(err != CL_SUCCESS)
	{
		printErrorCLRun(err);
       		printf("I cannot execute initRattles,\n");
		exit(1);
	}
	clFinish(clProp.command_queue);
#ifdef DEBUG
	printf("applyRattleSecondPortion : End initRattles\n");
#endif
	do{
		nIter++;
		//printf("applyRattleSecondPortion : nIter =%d\n",nIter);
		global =  molecularDynamics->forceField->numberOfRattleConstraintsTerms;
		err = clEnqueueNDRangeKernel(clProp.command_queue, molecularDynamics->applyRattle2, 1, NULL, &global, NULL, 0, NULL, NULL);
		global = forceField->molecule.nAtoms;
		err = clEnqueueNDRangeKernel(clProp.command_queue, molecularDynamics->updateRattle2, 1, NULL, &global, NULL, 0, NULL, NULL);
		global = 1;
		err = clEnqueueNDRangeKernel(clProp.command_queue, molecularDynamics->testDoneRattle, 1, NULL, &global, NULL, 0, NULL, NULL);
		clEnqueueReadBuffer(clProp.command_queue, forceField->rattleDoneBufferCL, CL_TRUE, 0, sizeof(cl_int)*1, &done, 0, NULL, NULL);
	}while(done<1 && nIter<maxIter);
	if(nIter>=maxIter)
	{
		printf(("Rattle second portion : Warning, velocity constraints not satisfied\n"));
		exit(1);
	}
#else
	int i;
	int k;
	int maxIter = 1000;
	double omega = 1.0;
	double tolerance = 1e-6; 
	boolean done = FALSE;
	int nIter = 0;
	int a1 = 0;
	int a2 = 0;
	double r2ij;
	double dot;
	double invMass1;
	double invMass2;
	double term = 0;
	double terms[3];
	double d;
	Molecule* m = &molecularDynamics->forceField->molecule;
	ForceField* forceField = molecularDynamics->forceField;
	double deltaMax = 0;

	if(forceField->molecule.constraints==NOCONSTRAINTS) return;
	tolerance /= molecularDynamics->dt;
	for (i = 0; i < molecularDynamics->numberOfAtoms; i++)
	{
			molecularDynamics->moved[i] = molecularDynamics->forceField->molecule.atoms[i].variable;
			//molecularDynamics->moved[i] = TRUE;
			molecularDynamics->update[i] = FALSE;
	}
	/* maxIter *= molecularDynamics->forceField->numberOfRattleConstraintsTerms;*/
	do{
		nIter++;
		done=TRUE;
		deltaMax = 0;
		for (i = 0; i < molecularDynamics->forceField->molecule.numberOfRattleConstraintsTerms; i++)
		{
			a1 = (int)molecularDynamics->forceField->molecule.rattleConstraintsTerms[0][i];
			a2 = (int)molecularDynamics->forceField->molecule.rattleConstraintsTerms[1][i];
			r2ij = molecularDynamics->forceField->molecule.rattleConstraintsTerms[2][i];
			if( !molecularDynamics->moved[a1] && !molecularDynamics->moved[a2] ) continue;
			/* here : rattle image for PBC, not yet implemented */
			dot = 0;
			for (k=0;k<3;k++)
			{
				d = m->atoms[a2].coordinates[k]-m->atoms[a1].coordinates[k];
				dot +=d*(molecularDynamics->forceField->molecule.atoms[a2].velocity[k]-molecularDynamics->forceField->molecule.atoms[a1].velocity[k]);
			}
			invMass1 = 1/molecularDynamics->forceField->molecule.atoms[a1].mass;
			invMass2 = 1/molecularDynamics->forceField->molecule.atoms[a2].mass;
		        term = -dot / ((invMass1+invMass2)*r2ij);
			if(fabs(term)<=tolerance) continue;
			/* if(fabs(dot/r2ij)<=tolerance) continue;*/
			if(deltaMax<fabs(term)) deltaMax = fabs(term);

			done = FALSE;
			molecularDynamics->update[a1] = TRUE;
			molecularDynamics->update[a2] = TRUE;
		        term *= omega;

			for (k=0;k<3;k++)
			{
				d = m->atoms[a2].coordinates[k]-m->atoms[a1].coordinates[k];
				terms[k] = d*term;
			}
			for (k=0;k<3;k++) molecularDynamics->forceField->molecule.atoms[a1].velocity[k] -= terms[k]*invMass1;
			for (k=0;k<3;k++) molecularDynamics->forceField->molecule.atoms[a2].velocity[k] += terms[k]*invMass2;
		}
		for (i = 0; i < molecularDynamics->numberOfAtoms; i++)
		{
			molecularDynamics->moved[i] = molecularDynamics->update[i];
			molecularDynamics->update[i] = FALSE;
		}
	}while(!done && nIter<maxIter);
	if(nIter>=maxIter && deltaMax>tolerance*10)
	{
		printf(("Rattle second portion : Warning, velocity constraints not satisfied\n"));
		for (i = 0; i < molecularDynamics->forceField->numberOfRattleConstraintsTerms; i++)
		{
			a1 = (int)molecularDynamics->forceField->molecule.rattleConstraintsTerms[0][i];
			a2 = (int)molecularDynamics->forceField->molecule.rattleConstraintsTerms[1][i];
			r2ij = 0;
			for (k=0;k<3;k++)
			{
				d = m->atoms[a2].coordinates[k]-m->atoms[a1].coordinates[k];
				r2ij +=d*d;
			}
			dot = 0;
			for (k=0;k<3;k++)
			{
				d = m->atoms[a2].coordinates[k]-m->atoms[a1].coordinates[k];
				dot +=d*(molecularDynamics->forceField->molecule.atoms[a2].velocity[k]-molecularDynamics->forceField->molecule.atoms[a1].velocity[k]);
			}
			invMass1 = 1/molecularDynamics->forceField->molecule.atoms[a1].mass;
			invMass2 = 1/molecularDynamics->forceField->molecule.atoms[a2].mass;
		        term = -dot / ((invMass1+invMass2)*r2ij);
			printf("%d %d %s %s r2ij=%f r2Old=%f term=%f\n",
			a1,a2,
			molecularDynamics->forceField->molecule.atoms[a1].mmType,
			molecularDynamics->forceField->molecule.atoms[a2].mmType,
			r2ij, molecularDynamics->forceField->molecule.rattleConstraintsTerms[2][i],term);
		}
	}
	for (i = 0; i < molecularDynamics->numberOfAtoms; i++)
			if(!molecularDynamics->forceField->molecule.atoms[i].variable)
			for (k=0;k<3;k++) molecularDynamics->forceField->molecule.atoms[i].velocity[k] = 0.0;
					
#endif /* ENABLE_CL*/
}
/*********************************************************************************/
static void applyVerlet(MolecularDynamics* molecularDynamics)
{
#ifdef ENABLE_CL
	size_t global = molecularDynamics->forceField->molecule.nAtoms;
	cl_int err;
	CLProp clProp=getCLProp();

/*
	{
		size_t global = molecularDynamics->forceField->molecule.nAtoms;
		CLProp clProp = getCLProp();
		cl_int err = clEnqueueNDRangeKernel(clProp.command_queue, molecularDynamics->initAccelarations, 1, NULL, &global, NULL, 0, NULL, NULL);
		if(err != CL_SUCCESS)
		{
			printErrorCLRun(err);
        		printf("I cannot execute computeAccelarationsFromGradients\n");
			exit(1);
		}
		clFinish(clProp.command_queue);
	}
*/
	//newAccelaration(molecularDynamics);
	if(molecularDynamics->forceField->molecule.constraints!=NOCONSTRAINTS)
	{
		size_t global = molecularDynamics->forceField->molecule.nAtoms;
		cl_int err = clEnqueueNDRangeKernel(clProp.command_queue, molecularDynamics->copyPositions, 1, NULL, &global, NULL, 0, NULL, NULL);
		if(err != CL_SUCCESS)
		{
			printErrorCLRun(err);
        		printf("I cannot execute copyPositions\n");
			exit(1);
		}
		clFinish(clProp.command_queue);
	}
	err = clEnqueueNDRangeKernel(clProp.command_queue, molecularDynamics->applyVerlet1, 1, NULL, &global, NULL, 0, NULL, NULL);
	if(err != CL_SUCCESS)
	{
		printErrorCLRun(err);
        	printf("I cannot execute  applyVerlet1\n");
		exit(1);
	}
	clFinish(clProp.command_queue);
	if(molecularDynamics->forceField->molecule.constraints!=NOCONSTRAINTS) applyRattleFirstPortion(molecularDynamics);
	if(molecularDynamics->thermostat == NOSEHOOVER) nose_hoover(molecularDynamics);
	newAccelaration(molecularDynamics);
	err = clEnqueueNDRangeKernel(clProp.command_queue, molecularDynamics->applyVerlet2, 1, NULL, &global, NULL, 0, NULL, NULL);
	if(err != CL_SUCCESS)
	{
		printErrorCLRun(err);
        	printf("I cannot execute  applyVerlet2\n");
		exit(1);
	}
	clFinish(clProp.command_queue);
	if(molecularDynamics->forceField->molecule.constraints!=NOCONSTRAINTS) applyRattleSecondPortion(molecularDynamics);
	if(molecularDynamics->thermostat == NOSEHOOVER) nose_hoover(molecularDynamics);
#else
	int i;
	int j;

	if(molecularDynamics->forceField->molecule.constraints!=NOCONSTRAINTS)
	for (i = 0; i < molecularDynamics->numberOfAtoms; i++)
		for ( j = 0; j < 3; j++)
				molecularDynamics->coordinatesOld[i][j]= molecularDynamics->forceField->molecule.atoms[i].coordinates[j];

	for (i = 0; i < molecularDynamics->numberOfAtoms; i++)
	{
		if(!molecularDynamics->forceField->molecule.atoms[i].variable) continue;
		for ( j = 0; j < 3; j++)
		{
			molecularDynamics->forceField->molecule.atoms[i].coordinates[j] += 
				molecularDynamics->forceField->molecule.atoms[i].velocity[j] * molecularDynamics->dt +
				molecularDynamics->a[i][j]*molecularDynamics->dt2_2;	
		}
		for ( j = 0; j < 3; j++)
			molecularDynamics->forceField->molecule.atoms[i].velocity[j] += molecularDynamics->a[i][j] * molecularDynamics->dt_2;
	}

	if(molecularDynamics->forceField->molecule.constraints!=NOCONSTRAINTS) applyRattleFirstPortion(molecularDynamics);
	if(molecularDynamics->thermostat == NOSEHOOVER) nose_hoover(molecularDynamics);

	newAccelaration(molecularDynamics);

	for (i = 0; i < molecularDynamics->numberOfAtoms; i++)
	{
		if(!molecularDynamics->forceField->molecule.atoms[i].variable) continue;
		for ( j = 0; j < 3; j++)
			molecularDynamics->forceField->molecule.atoms[i].velocity[j] += molecularDynamics->a[i][j] * molecularDynamics->dt_2;
	}
	if(molecularDynamics->forceField->molecule.constraints!=NOCONSTRAINTS) applyRattleSecondPortion(molecularDynamics);
	if(molecularDynamics->thermostat == NOSEHOOVER) nose_hoover(molecularDynamics);
#endif
}
/*********************************************************************************/
static void applyBeeman(MolecularDynamics* molecularDynamics)
{
#ifdef ENABLE_CL
	size_t global = molecularDynamics->forceField->molecule.nAtoms;
	cl_int err;
	CLProp clProp=getCLProp();
	if(molecularDynamics->forceField->molecule.constraints!=NOCONSTRAINTS)
	{
		size_t global = molecularDynamics->forceField->molecule.nAtoms;
		cl_int err = clEnqueueNDRangeKernel(clProp.command_queue, molecularDynamics->copyPositions, 1, NULL, &global, NULL, 0, NULL, NULL);
		if(err != CL_SUCCESS)
		{
			printErrorCLRun(err);
        		printf("I cannot execute copyPositions\n");
			exit(1);
		}
		clFinish(clProp.command_queue);
	}
	err = clEnqueueNDRangeKernel(clProp.command_queue, molecularDynamics->applyBeeman1, 1, NULL, &global, NULL, 0, NULL, NULL);
	if(err != CL_SUCCESS)
	{
		printErrorCLRun(err);
        	printf("I cannot execute applyBeeman1\n");
		exit(1);
	}
	clFinish(clProp.command_queue);
	if(molecularDynamics->forceField->molecule.constraints!=NOCONSTRAINTS) applyRattleFirstPortion(molecularDynamics);
	newAccelaration(molecularDynamics);
	err = clEnqueueNDRangeKernel(clProp.command_queue, molecularDynamics->applyBeeman2, 1, NULL, &global, NULL, 0, NULL, NULL);
	if(err != CL_SUCCESS)
	{
		printErrorCLRun(err);
        	printf("I cannot execute applyBeeman2\n");
		exit(1);
	}
	clFinish(clProp.command_queue);
	if(molecularDynamics->forceField->molecule.constraints!=NOCONSTRAINTS) applyRattleSecondPortion(molecularDynamics);
#else
	int i;
	int j;
	double terms[3];

	if(molecularDynamics->forceField->molecule.constraints!=NOCONSTRAINTS)
	for (i = 0; i < molecularDynamics->numberOfAtoms; i++)
		for ( j = 0; j < 3; j++)
				molecularDynamics->coordinatesOld[i][j]= molecularDynamics->forceField->molecule.atoms[i].coordinates[j];
	for (i = 0; i < molecularDynamics->numberOfAtoms; i++)
	{
		if(!molecularDynamics->forceField->molecule.atoms[i].variable) continue;
		for ( j = 0; j < 3; j++)
			terms[j] = 5.0*molecularDynamics->a[i][j]-molecularDynamics->aold[i][j];

		for ( j = 0; j < 3; j++)
		{
			molecularDynamics->forceField->molecule.atoms[i].coordinates[j] += 
				molecularDynamics->forceField->molecule.atoms[i].velocity[j] * molecularDynamics->dt +
				terms[j]*molecularDynamics->dt2_8;	
		}
		for ( j = 0; j < 3; j++)
			molecularDynamics->forceField->molecule.atoms[i].velocity[j] += terms[j] * molecularDynamics->dt_8;
	}

	if(molecularDynamics->forceField->molecule.constraints!=NOCONSTRAINTS) applyRattleFirstPortion(molecularDynamics);

	newAccelaration(molecularDynamics);

	for (i = 0; i < molecularDynamics->numberOfAtoms; i++)
	{
		if(!molecularDynamics->forceField->molecule.atoms[i].variable) continue;
		for ( j = 0; j < 3; j++)
			molecularDynamics->forceField->molecule.atoms[i].velocity[j] += (3.0*molecularDynamics->a[i][j]+molecularDynamics->aold[i][j]) * molecularDynamics->dt_8;
	}

	if(molecularDynamics->forceField->molecule.constraints!=NOCONSTRAINTS) applyRattleSecondPortion(molecularDynamics);
#endif
}
/*********************************************************************************/
static void applyMartynaTuckerman(MolecularDynamics* molecularDynamics)
{
#ifdef ENABLE_CL
	printf("Sorry, Martyna&Tuckerman  integrator not yet implemented in GPU\n");
	exit(1);
#else
	int i;
	int j;
	Constraints constraints = molecularDynamics->forceField->molecule.constraints;
	Atom* atoms = molecularDynamics->forceField->molecule.atoms;
	
	//printf("Begin applyMartynaTuckerman\n");

	if(constraints!=NOCONSTRAINTS)
	for (i = 0; i < molecularDynamics->numberOfAtoms; i++)
		for ( j = 0; j < 3; j++)
				molecularDynamics->coordinatesOld[i][j]= atoms[i].coordinates[j];

	for (i = 0; i < molecularDynamics->numberOfAtoms; i++)
	{
		if(!atoms[i].variable) continue;
		for ( j = 0; j < 3; j++)
		{
			atoms[i].coordinates[j] += atoms[i].velocity[j] * molecularDynamics->dt +
					(5*molecularDynamics->a[i][j]-molecularDynamics->Ftilde[j][i])*molecularDynamics->dt2_8 +
					molecularDynamics->VF[j][i]*molecularDynamics->dt3_6 +
					molecularDynamics->VJ[j][i]*molecularDynamics->dt4_48;
		}
		for ( j = 0; j < 3; j++)
			atoms[i].velocity[j] += (4*molecularDynamics->a[i][j]+molecularDynamics->Ftilde[j][i]) * molecularDynamics->dt_8+
						molecularDynamics->VF[j][i]*molecularDynamics->dt2_8;
	}
	for (i = 0; i < molecularDynamics->numberOfAtoms; i++)
	for ( j = 0; j < 3; j++)
	{
		double f =  molecularDynamics->Ftilde[j][i];
		molecularDynamics->Ftilde[j][i] = 0.5*(2*molecularDynamics->a[i][j]-molecularDynamics->Ftilde[j][i]) + molecularDynamics->VF[j][i]*molecularDynamics->dt_2;
		molecularDynamics->VJ[j][i] = -molecularDynamics->VJ[j][i]-3.0/molecularDynamics->dt* molecularDynamics->VF[j][i]-1.5/molecularDynamics->dt2*f;
		molecularDynamics->VF[j][i] = -0.5*molecularDynamics->VF[j][i]-1.5/molecularDynamics->dt*f;
	}

	if(constraints!=NOCONSTRAINTS) applyRattleFirstPortion(molecularDynamics);
	if(molecularDynamics->thermostat == NOSEHOOVER) nose_hoover(molecularDynamics);

	//printf("End half applyMartynaTuckerman\n");

	newAccelaration(molecularDynamics);

	for (i = 0; i < molecularDynamics->numberOfAtoms; i++)
	{
		if(!atoms[i].variable) continue;
		for ( j = 0; j < 3; j++)
			atoms[i].velocity[j] += 3*molecularDynamics->a[i][j] * molecularDynamics->dt_8;
	}
	for (i = 0; i < molecularDynamics->numberOfAtoms; i++)
	for ( j = 0; j < 3; j++)
	{
		molecularDynamics->Ftilde[j][i] += 0.5*molecularDynamics->a[i][j];
		molecularDynamics->VF[j][i] += 1.5*molecularDynamics->a[i][j]/molecularDynamics->dt;
		molecularDynamics->VJ[j][i] += 1.5*molecularDynamics->a[i][j]/molecularDynamics->dt2;
	}

	if(constraints!=NOCONSTRAINTS) applyRattleSecondPortion(molecularDynamics);
	if(molecularDynamics->thermostat == NOSEHOOVER) nose_hoover(molecularDynamics);
	//printf("End applyMartynaTuckerman\n");
#endif
}
/*********************************************************************************/
static void newProperties(MolecularDynamics* molecularDynamics, char* comments)
{
	if( molecularDynamics->fileProp == NULL) return;
	fprintf(molecularDynamics->fileProp,"Time0(fs)\tTime(fs)\tTotal Energy(Kcal/mol)\tPotential Energy(kcal/mol)\tKinetic Energy(Kcal/mol)\tT(t) (K)\tTaver(K)\tsigma(T)(K)\tIndex");
	if(molecularDynamics->thermostat==NOSEHOOVER) fprintf(molecularDynamics->fileProp,"\tEtot+Etherm");
	if(comments) fprintf(molecularDynamics->fileProp,"%s\n", comments);
	else fprintf(molecularDynamics->fileProp,"\n");
}
/*********************************************************************************/
static void saveProperties(MolecularDynamics* molecularDynamics, int iStep0, int iStep, char* comments)
{
	double dt = molecularDynamics->dt/(fsInAKMA);
	static double Ttot = 0;
	static double T2tot = 0;
	double Taver = 0;
	double T2aver = 0;

	double totalEnergy =  molecularDynamics->totalEnergy;

	if( molecularDynamics->fileProp == NULL) return;
	if(molecularDynamics->thermostat==NOSEHOOVER)
	{
		int i;
		double kT = Kb* molecularDynamics->temperature;
		double e = molecularDynamics->vNH[0]*molecularDynamics->vNH[0]* molecularDynamics->qNH[0]/2 + (molecularDynamics->forceField->molecule.nFree)*kT* molecularDynamics->xNH[0];
		for(i=1;i<MAXNH;i++) e += molecularDynamics->vNH[i]*molecularDynamics->vNH[i]* molecularDynamics->qNH[i]/2 + kT* molecularDynamics->xNH[i];
		
		totalEnergy += e;
	}
	

	if(iStep==1)
	{
			Ttot = 0;
			T2tot = 0;
	}
	Ttot += molecularDynamics->kelvin;
	T2tot += molecularDynamics->kelvin*molecularDynamics->kelvin;
	Taver = Ttot/iStep;
	T2aver = T2tot/iStep;


	fprintf(molecularDynamics->fileProp,"%f\t%f\t%f\t\t%f\t\t\t%f\t\t\t%f\t%f\t%f\t%d\t", 
			(iStep0)*dt, 
			(iStep)*dt, 
			molecularDynamics->totalEnergy,
			molecularDynamics->potentialEnergy,
			molecularDynamics->kineticEnergy,
			molecularDynamics->kelvin,
			Taver,
			sqrt(fabs(T2aver-Taver*Taver)),
			molecularDynamics->index
			 );
	if( molecularDynamics->thermostat==NOSEHOOVER) fprintf(molecularDynamics->fileProp,"%f\t",totalEnergy);
	if(comments) fprintf(molecularDynamics->fileProp,"%s\n", comments);
	else fprintf(molecularDynamics->fileProp,"\n");
}
/*********************************************************************************/
static void saveTrajectory(MolecularDynamics* molecularDynamics, int iStep)
{
	double dt = molecularDynamics->dt/(fsInAKMA);
	int i;
	if( molecularDynamics->fileTraj == NULL) return;
	// Get geometry from Devices

	getGeometryVelocitiesCL( molecularDynamics->forceField,  &molecularDynamics->forceField->molecule);

	fprintf(molecularDynamics->fileTraj," %d %f %f %f %f nAtoms time(fs) TotalEnery(Kcal/mol) Kinetic Potential\n", 
			molecularDynamics->numberOfAtoms,
			 (iStep)*dt, 
			molecularDynamics->totalEnergy,
			molecularDynamics->kineticEnergy,
			molecularDynamics->potentialEnergy
			 );
	fprintf(molecularDynamics->fileTraj," %s\n", "Coord in Ang, Velocity in AKMA, time in fs");

	for (i = 0; i < molecularDynamics->numberOfAtoms; i++)
	{
		fprintf(molecularDynamics->fileTraj," %s %f %f %f %f %f %f %f %s %s %s %d %d\n", 
				molecularDynamics->forceField->molecule.atoms[i].prop.symbol,
				molecularDynamics->forceField->molecule.atoms[i].coordinates[0],
				molecularDynamics->forceField->molecule.atoms[i].coordinates[1],
				molecularDynamics->forceField->molecule.atoms[i].coordinates[2],
				molecularDynamics->forceField->molecule.atoms[i].velocity[0],
				molecularDynamics->forceField->molecule.atoms[i].velocity[1],
				molecularDynamics->forceField->molecule.atoms[i].velocity[2],
				molecularDynamics->forceField->molecule.atoms[i].charge,
				molecularDynamics->forceField->molecule.atoms[i].mmType,
				molecularDynamics->forceField->molecule.atoms[i].pdbType,
				molecularDynamics->forceField->molecule.atoms[i].residueName,
				molecularDynamics->forceField->molecule.atoms[i].residueNumber,
				molecularDynamics->forceField->molecule.atoms[i].variable
				);
	}
}

/**********************************************************************/
void	freeMolecularDynamics(MolecularDynamics* molecularDynamics)
{

	int i;
	if(molecularDynamics->a)
	{
		int i;
		for(i=0;i<molecularDynamics->numberOfAtoms;i++)
			if(molecularDynamics->a[i]) free(molecularDynamics->a[i]);
		free(molecularDynamics->a);
	}
	if(molecularDynamics->aold)
	{
		int i;
		for(i=0;i<molecularDynamics->numberOfAtoms;i++)
			if(molecularDynamics->aold[i]) free(molecularDynamics->aold[i]);
		free(molecularDynamics->aold);
	}
	if(molecularDynamics->coordinatesOld)
	{
		int i;
		for(i=0;i<molecularDynamics->numberOfAtoms;i++)
			if(molecularDynamics->coordinatesOld[i]) free(molecularDynamics->coordinatesOld[i]);
		free(molecularDynamics->coordinatesOld);
	}
	if(molecularDynamics->moved) free(molecularDynamics->moved);
	if(molecularDynamics->update) free(molecularDynamics->update);
	if(molecularDynamics->positionFriction) free(molecularDynamics->positionFriction);
	if(molecularDynamics->velocityFriction) free(molecularDynamics->velocityFriction);
	if(molecularDynamics->accelarationFriction) free(molecularDynamics->accelarationFriction);
	if(molecularDynamics->gamma) free(molecularDynamics->gamma);
	if(molecularDynamics->positionRandom) free(molecularDynamics->positionRandom);
	if(molecularDynamics->velocityRandom) free(molecularDynamics->velocityRandom);
	if(molecularDynamics->Ht) free(molecularDynamics->Ht);
	if(molecularDynamics->theta) free(molecularDynamics->theta);
	if(molecularDynamics->rnoise)
	{
		for(i=0;i<3*molecularDynamics->numberOfAtoms;i++)
			if(molecularDynamics->rnoise[i]) free(molecularDynamics->rnoise[i]);
		free(molecularDynamics->rnoise);
	}
	for(i=0;i<3;i++) if(molecularDynamics->Ftilde[i]) free(molecularDynamics->Ftilde[i]);
	for(i=0;i<3;i++) if(molecularDynamics->VF[i]) free(molecularDynamics->VF[i]);
	for(i=0;i<3;i++) if(molecularDynamics->VJ[i]) free(molecularDynamics->VJ[i]);
	molecularDynamics->forceField = NULL;
	molecularDynamics->numberOfAtoms = 0;
	molecularDynamics->updateFrequency = 0;
}
/********************************************************************************/
static double getEKin(MolecularDynamics* molecularDynamics)
{
#ifdef ENABLE_CL
	static cl_float ekin;
	CLProp clProp=getCLProp();

	size_t global = 1;
	cl_int err = clEnqueueNDRangeKernel(clProp.command_queue, molecularDynamics->computeKineticEnergy, 1, NULL, &global, NULL, 0, NULL, NULL);
	if(err != CL_SUCCESS)
	{
		printErrorCLRun(err);
       		printf("I cannot execute computeKineticEnergies\n");
		exit(1);
	}
	clFinish(clProp.command_queue);
	clEnqueueReadBuffer(clProp.command_queue, molecularDynamics->forceField->energyBufferCL, CL_TRUE, 0, sizeof(cl_float)*1, &ekin, 0, NULL, NULL);

/*
	int i,j;
	double mass;
	ForceField* forceField = molecularDynamics->forceField;
	clEnqueueReadBuffer(clProp.command_queue, forceField->atomsCL, CL_TRUE, 0, sizeof(cl_float8)*forceField->molecule.nAtoms, forceField->atomsCPU, 0, NULL, NULL);
	ekin = 0;
	for( i=0; i<forceField->molecule.nAtoms;i++)
	{
		mass = molecularDynamics->forceField->molecule.atoms[i].mass;
		for ( j = 0; j < 3; j++)
			ekin += forceField->atomsCPU[i].s[j+5]*forceField->atomsCPU[i].s[j+5]*mass;
	}
	ekin /=2;
*/
#else 
	double ekin = 0;
	int i;
	int j;
	double mass;
	for ( i = 0; i < molecularDynamics->numberOfAtoms; i++)
	{
		mass = molecularDynamics->forceField->molecule.atoms[i].mass;
		for ( j = 0; j < 3; j++)
			ekin += molecularDynamics->forceField->molecule.atoms[i].velocity[j]*molecularDynamics->forceField->molecule.atoms[i].velocity[j]*
				mass;
	}
	ekin /=2;
#endif
	return ekin;
}
/********************************************************************************/
static double getKelvin(MolecularDynamics* molecularDynamics)
{
	int nfree = molecularDynamics->forceField->molecule.nFree;
	if(nfree<1) return 0;
	return 2*getEKin(molecularDynamics) / ( nfree * Kb);
}
/********************************************************************************/
/*
     literature references:

     M. P. Allen, "Brownian Dynamics Simulation of a Chemical
     Reaction in Solution", Molecular Physics, 40, 1073-1087 (1980)

     F. Guarnieri and W. C. Still, "A Rapidly Convergent Simulation
     Method: Mixed Monte Carlo / Stochastic Dynamics", Journal of
     Computational Chemistry, 15, 1302-1310 (1994)
*/
/*********************************************************************************/
#ifndef ENABLE_CL
static void getFrictionalAndRandomForce(MolecularDynamics* molecularDynamics)
{
	double* gamma = molecularDynamics->gamma;
	double* positionFriction = molecularDynamics->positionFriction;
	double* velocityFriction = molecularDynamics->velocityFriction;
	double* accelarationFriction = molecularDynamics->accelarationFriction;
	double** positionRandom = molecularDynamics->positionRandom;
	double** velocityRandom = molecularDynamics->velocityRandom;
	double dt = molecularDynamics->dt;
	
	int n = molecularDynamics->numberOfAtoms;

	int i;
	int j;
	double gdt;
	double egdt;
	double ktm = 0;
	double pterm;
	double vterm;
        double psig;
        double vsig;
        double rho;
        double rhoc;
	double pnorm;
	double vnorm;

	for(i=0;i<n;i++)
        	gamma[i] = molecularDynamics->friction;

	/* printf(" friction = %f\n", molecularDynamics->friction);*/
	for(i=0;i<n;i++)
	{
		gdt = gamma[i] * dt;
		/* printf("gdt = %f\n",gdt);*/
		if (gdt <= 0.0)
		{
               		positionFriction[i] = 1.0;
			velocityFriction[i] = dt;
			accelarationFriction[i] = 0.5 * dt * dt;
			for(j=0;j<3;j++)
			{
                  		positionRandom[i][j] = 0.0;
                  		velocityRandom[i][j] = 0.0;
			}
		}
            	else
		{
			/* analytical expressions when friction coefficient is large */
               		if (gdt>=0.05)
			{
                  		egdt = exp(-gdt);
                  		positionFriction[i] = egdt;
                  		velocityFriction[i] = (1.0-egdt) / gamma[i];
                  		accelarationFriction[i] = (dt-velocityFriction[i]) / gamma[i];
                  		pterm = 2.0*gdt - 3.0 + (4.0-egdt)*egdt;
                  		vterm = 1.0 - egdt*egdt;
                  		rho = (1.0-egdt)*(1.0-egdt) / sqrt(pterm*vterm);
			}
			/* use series expansions when friction coefficient is small */
			else
			{
                  		double gdt2 = gdt * gdt;
                  		double gdt3 = gdt * gdt2;
                  		double gdt4 = gdt2 * gdt2;
                  		double gdt5 = gdt2 * gdt3;
                  		double gdt6 = gdt3 * gdt3;
                  		double gdt7 = gdt3 * gdt4;
                  		double gdt8 = gdt4 * gdt4;
                  		double gdt9 = gdt4 * gdt5;
                  		accelarationFriction[i] = (gdt2/2.0 - gdt3/6.0 + gdt4/24.0
                               	- gdt5/120.0 + gdt6/720.0
                               	- gdt7/5040.0 + gdt8/40320.0
                               	- gdt9/362880.0) / gamma[i]/gamma[i];
                  		velocityFriction[i] = dt - gamma[i]*accelarationFriction[i];
                  		positionFriction[i] = 1.0 - gamma[i]*velocityFriction[i];
                  		pterm = 2.0*gdt3/3.0 - gdt4/2.0
                            	+ 7.0*gdt5/30.0 - gdt6/12.0
                            	+ 31.0*gdt7/1260.0 - gdt8/160.0
                            	+ 127.0*gdt9/90720.0;
                  		vterm = 2.0*gdt - 2.0*gdt2 + 4.0*gdt3/3.0
                            	- 2.0*gdt4/3.0 + 4.0*gdt5/15.0
                            	- 4.0*gdt6/45.0 + 8.0*gdt7/315.0
                            	- 2.0*gdt8/315.0 + 4.0*gdt9/2835.0;
                  		rho = sqrt(3.0) * (0.5 - 3.0*gdt/16.0
                            	- 17.0*gdt2/1280.0
                            	+ 17.0*gdt3/6144.0
                            	+ 40967.0*gdt4/34406400.0
                            	- 57203.0*gdt5/275251200.0
                            	- 1429487.0*gdt6/13212057600.0);
			}
               		ktm = Kb * molecularDynamics->temperature / molecularDynamics->forceField->molecule.atoms[i].mass;
               		psig = sqrt(ktm*pterm) / gamma[i];
               		vsig = sqrt(ktm*vterm);
               		rhoc = sqrt(1.0 - rho*rho);
			for(j=0;j<3;j++)
			{
                		pnorm = normal();
             			vnorm = normal ();
				positionRandom[i][j] = psig * pnorm;
                  		velocityRandom[i][j] = vsig * (rho*pnorm+rhoc*vnorm);
			}
		}
	}
}
#endif
/*********************************************************************************/
static void applyStochastic(MolecularDynamics* molecularDynamics)
{
#ifdef ENABLE_CL
	size_t global = molecularDynamics->forceField->molecule.nAtoms;
	cl_int err;
	CLProp clProp=getCLProp();
	cl_float temp = molecularDynamics->temperature;
	resetRandomNumbers(molecularDynamics);
	clSetKernelArg(molecularDynamics->setFrictionalAndRandomForce, 5, sizeof(cl_float), &temp);
	printf("Call setFrictionalAndRandomForce\n");
	err = clEnqueueNDRangeKernel(clProp.command_queue, molecularDynamics->setFrictionalAndRandomForce, 1, NULL, &global, NULL, 0, NULL, NULL);
	if(err != CL_SUCCESS)
	{
		printErrorCLRun(err);
        	printf("I cannot execute setFrictionalAndRandomForce\n");
		exit(1);
	}
	clFinish(clProp.command_queue);
	printf("Call applyStochastic1\n");
	if(molecularDynamics->forceField->molecule.constraints!=NOCONSTRAINTS)
	{
		size_t global = molecularDynamics->forceField->molecule.nAtoms;
		cl_int err = clEnqueueNDRangeKernel(clProp.command_queue, molecularDynamics->copyPositions, 1, NULL, &global, NULL, 0, NULL, NULL);
		if(err != CL_SUCCESS)
		{
			printErrorCLRun(err);
        		printf("I cannot execute copyPositions\n");
			exit(1);
		}
		clFinish(clProp.command_queue);
	}
	err = clEnqueueNDRangeKernel(clProp.command_queue, molecularDynamics->applyStochastic1, 1, NULL, &global, NULL, 0, NULL, NULL);
	if(err != CL_SUCCESS)
	{
		printErrorCLRun(err);
        	printf("I cannot execute applyStochastic1\n");
		exit(1);
	}
	clFinish(clProp.command_queue);
	if(molecularDynamics->forceField->molecule.constraints!=NOCONSTRAINTS) applyRattleFirstPortion(molecularDynamics);
	printf("Call newAccelaration\n");
	newAccelaration(molecularDynamics);
	printf("Call applyStochastic2\n");

	err = clEnqueueNDRangeKernel(clProp.command_queue, molecularDynamics->applyStochastic2, 1, NULL, &global, NULL, 0, NULL, NULL);
	if(err != CL_SUCCESS)
	{
		printErrorCLRun(err);
        	printf("I cannot execute applyStochastic2\n");
		exit(1);
	}
	clFinish(clProp.command_queue);

	if(molecularDynamics->forceField->molecule.constraints!=NOCONSTRAINTS) applyRattleSecondPortion(molecularDynamics);
	// TO DO remove translation and rotation
	computeEnergies(molecularDynamics);
#else
	double* positionFriction = molecularDynamics->positionFriction;
	double* velocityFriction = molecularDynamics->velocityFriction;
	double* accelarationFriction = molecularDynamics->accelarationFriction;
	double** positionRandom = molecularDynamics->positionRandom;
	double** velocityRandom = molecularDynamics->velocityRandom;
	double**a = molecularDynamics->a;
	int n = molecularDynamics->numberOfAtoms;
	int i;
	int j;
	Atom* atoms = molecularDynamics->forceField->molecule.atoms;

	getFrictionalAndRandomForce(molecularDynamics);

	if(molecularDynamics->forceField->molecule.constraints!=NOCONSTRAINTS)
	for(i=0;i<n;i++)
		for(j=0;j<3;j++)
			molecularDynamics->coordinatesOld[i][j]= molecularDynamics->forceField->molecule.atoms[i].coordinates[j];
	for(i=0;i<n;i++)
	{
		if(!molecularDynamics->forceField->molecule.atoms[i].variable) continue;
		for(j=0;j<3;j++)
			atoms[i].coordinates[j] += molecularDynamics->forceField->molecule.atoms[i].velocity[j]*velocityFriction[i] + a[i][j]*accelarationFriction[i] + positionRandom[i][j];
		for(j=0;j<3;j++)
			molecularDynamics->forceField->molecule.atoms[i].velocity[j] = molecularDynamics->forceField->molecule.atoms[i].velocity[j]*positionFriction[i] + 0.5*a[i][j]*velocityFriction[i];
	}
	if(molecularDynamics->forceField->molecule.constraints!=NOCONSTRAINTS) applyRattleFirstPortion(molecularDynamics);
	newAccelaration(molecularDynamics);

	for (i = 0; i < n; i++)
	{
		if(!molecularDynamics->forceField->molecule.atoms[i].variable) continue;
		for ( j = 0; j < 3; j++)
			molecularDynamics->forceField->molecule.atoms[i].velocity[j] += 0.5*a[i][j]*velocityFriction[i] + velocityRandom[i][j];
	}
	if(molecularDynamics->forceField->molecule.constraints!=NOCONSTRAINTS) applyRattleSecondPortion(molecularDynamics);
	computeEnergies(molecularDynamics);

	removeTranslationAndRotation(molecularDynamics);
#endif
}
/*********************************************************************************/
static void applyQTB(MolecularDynamics* molecularDynamics)
{
	
	int n = molecularDynamics->numberOfAtoms;
	int i;
	int j;
	//double gp = 1.0/(1.0+molecularDynamics->friction*molecularDynamics->dt_2);
	//double gm = (1.0-molecularDynamics->friction*molecularDynamics->dt_2)*gp;
	double gf = (1.0-molecularDynamics->friction*molecularDynamics->dt_2);

#ifdef ENABLE_CL
	printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
	printf("Sorry, QTB dynamics is not yet implemented on GPU\n");
	printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
	exit(1);
#endif
	/* printf("gm = %f gp =%f\n",gm,gp);*/
	if(molecularDynamics->forceField->molecule.constraints!=NOCONSTRAINTS)
	for (i = 0; i < n; i++)
		for ( j = 0; j < 3; j++)
				molecularDynamics->coordinatesOld[i][j]= molecularDynamics->forceField->molecule.atoms[i].coordinates[j];

	for (i = 0; i < n; i++)
	if(molecularDynamics->forceField->molecule.atoms[i].variable)
	for ( j = 0; j < 3; j++)
	{
		molecularDynamics->forceField->molecule.atoms[i].coordinates[j] += 
		molecularDynamics->forceField->molecule.atoms[i].velocity[j]*molecularDynamics->dt +
		(molecularDynamics->a[i][j]+molecularDynamics->theta[3*i+j]-molecularDynamics->forceField->molecule.atoms[i].velocity[j]*molecularDynamics->friction)*molecularDynamics->dt2_2;	
	}
	for (i = 0; i < n; i++)
	if(molecularDynamics->forceField->molecule.atoms[i].variable)
	for ( j = 0; j < 3; j++)
			molecularDynamics->forceField->molecule.atoms[i].velocity[j] = 
			gf*molecularDynamics->forceField->molecule.atoms[i].velocity[j] +
			(molecularDynamics->a[i][j]+molecularDynamics->theta[3*i+j])*molecularDynamics->dt_2;
            
	if(molecularDynamics->forceField->molecule.constraints!=NOCONSTRAINTS) applyRattleFirstPortion(molecularDynamics);

	newAccelaration(molecularDynamics);

	for (i = 0; i < n; i++)
	if(molecularDynamics->forceField->molecule.atoms[i].variable)
	for ( j = 0; j < 3; j++)
			molecularDynamics->forceField->molecule.atoms[i].velocity[j] = 
			gf*molecularDynamics->forceField->molecule.atoms[i].velocity[j] +
			(molecularDynamics->a[i][j]+molecularDynamics->theta[3*i+j])*molecularDynamics->dt_2;

	if(molecularDynamics->forceField->molecule.constraints!=NOCONSTRAINTS) applyRattleSecondPortion(molecularDynamics);

	removeTranslationAndRotation(molecularDynamics);

	computeEnergies(molecularDynamics);
}
/*********************************************************************************/
static void applyLangevin(MolecularDynamics* molecularDynamics)
{
	
	int n = molecularDynamics->numberOfAtoms;
	int i;
	int j;
	//double gp = 1.0/(1.0+molecularDynamics->friction*molecularDynamics->dt_2);
	//double gm = (1.0-molecularDynamics->friction*molecularDynamics->dt_2)*gp;
	double gf = (1.0-molecularDynamics->friction*molecularDynamics->dt_2);

#ifdef ENABLE_CL
	printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
	printf("Sorry, Langevin dynamics is not yet implemented on GPU\n");
	printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
	exit(1);
#endif
	/* printf("gm = %f gp =%f\n",gm,gp);*/
	if(molecularDynamics->forceField->molecule.constraints!=NOCONSTRAINTS)
	for (i = 0; i < n; i++)
		for ( j = 0; j < 3; j++)
				molecularDynamics->coordinatesOld[i][j]= molecularDynamics->forceField->molecule.atoms[i].coordinates[j];

	for (i = 0; i < n; i++)
	if(molecularDynamics->forceField->molecule.atoms[i].variable)
	for ( j = 0; j < 3; j++)
	{
		molecularDynamics->forceField->molecule.atoms[i].coordinates[j] += 
		molecularDynamics->forceField->molecule.atoms[i].velocity[j]*molecularDynamics->dt +
		(molecularDynamics->a[i][j]+molecularDynamics->theta[3*i+j]-molecularDynamics->forceField->molecule.atoms[i].velocity[j]*molecularDynamics->friction)*molecularDynamics->dt2_2;	
	}
	for (i = 0; i < n; i++)
	if(molecularDynamics->forceField->molecule.atoms[i].variable)
	for ( j = 0; j < 3; j++)
			molecularDynamics->forceField->molecule.atoms[i].velocity[j] = 
			gf*molecularDynamics->forceField->molecule.atoms[i].velocity[j] +
			(molecularDynamics->a[i][j]+molecularDynamics->theta[3*i+j])*molecularDynamics->dt_2;
            
	if(molecularDynamics->forceField->molecule.constraints!=NOCONSTRAINTS) applyRattleFirstPortion(molecularDynamics);

	newAccelaration(molecularDynamics);

	for (i = 0; i < n; i++)
	if(molecularDynamics->forceField->molecule.atoms[i].variable)
	for ( j = 0; j < 3; j++)
			molecularDynamics->forceField->molecule.atoms[i].velocity[j] = 
			gf*molecularDynamics->forceField->molecule.atoms[i].velocity[j] +
			(molecularDynamics->a[i][j]+molecularDynamics->theta[3*i+j])*molecularDynamics->dt_2;

	if(molecularDynamics->forceField->molecule.constraints!=NOCONSTRAINTS) applyRattleSecondPortion(molecularDynamics);

	removeTranslationAndRotation(molecularDynamics);

	computeEnergies(molecularDynamics);
}
File: ./cchemilib/src/MolecularMechanics/CreateMolecularMechanicsFile.c

/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* CreateMolecularMechanicsFile.c */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>

#include "../Utils/Utils.h"
#include "../Utils/AtomsProp.h"
#include "../Utils/Constants.h"
#include "../Utils/Types.h"
#include "../Molecule/Molecule.h"
#include "../MolecularMechanics/MolecularMechanics.h"
#include "../MolecularMechanics/LoadMMParameters.h"
#include "../MolecularMechanics/CreateMolecularMechanicsFile.h"

static char atomTypesTitle[]       = "Begin  INPUT FOR ATOM TYPES, MASSE AND POLARISABILITIES";
static char bondStretchTitle[]     = "Begin INPUT FOR BOND LENGTH PARAMETERS";
static char angleBendTitle[]       = "Begin INPUT FOR BOND ANGLE PARAMETERS";
static char strBendTitle[]       = "Begin INPUT FOR STRETCH-BEND PARAMETERS";
static char hydrogenBondedTitle[]  = "Begin INPUT FOR H-BOND 10-12 POTENTIAL PARAMETERS";
static char suttonChenTitle[]      = "Begin INPUT FOR SUTTON-CHEN POTENTIAL PARAMETERS";
static char improperTorsionTitle[] ="Begin INPUT FOR IMPROPER DIHEDRAL PARAMETERS";
static char nonBondedTitle[]       ="Begin INPUT FOR THE NON-BONDED 6-12 POTENTIAL PARAMETERS";
static char dihedralAngleTitle[]   = "Begin INPUT FOR DIHEDRAL PARAMETERS";
static char pairWiseTitle[]   = "Begin INPUT FOR PAIR WISE PARAMETERS";

boolean createMMFile()
{

	char* filename = strdup_printf("%s%sMolecularMechanics.prm",cchemiDirectory(), DIR_SEPARATOR_S);
	FILE* fout = fopen(filename,"w");

	if(fout==NULL)
	{
		return FALSE;
	}
	fprintf(fout,"Begin Title\n");
	fprintf(fout,"	Atom Types         : Ty(Type) Symbol Numero Masse(C12 UMA) Polarisablities(Ang**3) \n");
	fprintf(fout,"	Bond Length        : N1-N2 Force(kcal/mol/A**2) Re [h3] [h4] h5] [h6] where h3, h4, h5, h6 are the anharmonic term in Ang-1, Ang-2, ...\n");
	fprintf(fout,"	Bond Angle         : N1-N2-N3 Force(kcal/mol/rad**2) Angle(Deg) [h3] [h4] h5] [h6] where h3, h4, h5, h6 are the anharmonic term in Deg-1, Deg-2, ...\n");
	fprintf(fout,"	Str Bend           : N1-N2-N3 N1-N2-N3 Force12(kcal/mol/rad**2) Force23(kcal/mol/rad**2)\n");
	fprintf(fout,"	Dihedral           : N1-N2-N3-N4 Idiv Pk Phase(Deg) Pn \n");
	fprintf(fout,"	                     E = Pk/Idiv*(1 + cos(P,*Phi - Phase)\n");
	fprintf(fout,"	                     Pk = Barrier/2 kcal/mol\n");
	fprintf(fout,"	                     Idiv barrier is divised by Idiv\n");
	fprintf(fout,"	                     Pn = periodicity fo the torional barrier\n");
	fprintf(fout,"	                     if Pn<0 the tosional potential is \n");
	fprintf(fout,"	                     assumed to have more than one term\n");
	fprintf(fout,"	                     if Ni=0 => N is a number for any one Type\n");
	fprintf(fout,"	Improper Dihedral  : N1-N2-N3-N4 Pk Phase(Deg) Pn \n");
	fprintf(fout,"	H-Bond             : N1-N2   A(coef. 1/r**12)  B(coef. -B/r**10)\n");
	fprintf(fout,"\tPair Wise          :N1-N2  A(kcal/mol)  B(Ang-1) C6(kcal*Ang**6) C8 C10 b(Ang-1)\n");
	fprintf(fout,"\t                   V(r) = A*exp(-B*r) -Somme(C2n*f2n/r**(2*n))[n=3,4,5]\n");
	fprintf(fout,"\t                   f2n = 1- exp(-b*r)*Somme((b*r)**k/k!,k=1..2*n)\n");
	fprintf(fout,"End\n");
	fprintf(fout,"%s\n",atomTypesTitle);
	fprintf(fout,"C	C	1	12.010	 0.616		sp2 C carbonyl group \n");
	fprintf(fout,"CA	C	2	12.010	 0.360		sp2 C pure aromatic (benzene)\n");
	fprintf(fout,"CB	C	3	12.010	 0.360		sp2 aromatic C, 5&6 membered ring junction\n");
	fprintf(fout,"CC	C	4	12.010	 0.360		sp2 aromatic C, 5 memb. ring HIS\n");
	fprintf(fout,"CD	C	5	12.010	 0.360		sp2 C atom in the middle of: C=CD-CD=C\n");
	fprintf(fout,"CK	C	6	12.010	 0.360		sp2 C 5 memb.ring in purines\n");
	fprintf(fout,"CM	C	7	12.010	 0.360		sp2 C  pyrimidines in pos. 5 & 6\n");
	fprintf(fout,"CN	C	8	12.010	 0.360		sp2 C aromatic 5&6 memb.ring junct.(TRP)\n");
	fprintf(fout,"CQ	C	9	12.010	 0.360		sp2 C in 5 mem.ring of purines between 2 N\n");
	fprintf(fout,"CR	C	10	12.010	 0.360		sp2 arom as CQ but in HIS\n");
	fprintf(fout,"CT	C	11	12.010	 0.878		sp3 aliphatic C\n");
	fprintf(fout,"CV	C	12	12.010	 0.360		sp2 arom. 5 memb.ring w/1 N and 1 H (HIS)\n");
	fprintf(fout,"CW	C	13	12.010	 0.360		sp2 arom. 5 memb.ring w/1 N-H and 1 H (HIS)\n");
	fprintf(fout,"C*	C	14	12.010	 0.360		sp2 arom. 5 memb.ring w/1 subst. (TRP)\n");
	fprintf(fout,"CY	C	15	12.010	 0.360		nitrile C (Howard et al.JCC,16,243,1995)\n");
	fprintf(fout,"CZ	C	16	12.010	 0.360		sp C (Howard et al.JCC,16,243,1995)\n");
	fprintf(fout,"C0	Ca	17	40.080	 0.000		calcium\n");
	fprintf(fout,"H	H	18	 1.008	 0.161		H bonded to nitrogen atoms\n");
	fprintf(fout,"HC	H	19	 1.008	 0.135		H aliph. bond. to C without electrwd.group\n");
	fprintf(fout,"H1	H	20	 1.008	 0.135		H aliph. bond. to C with 1 electrwd. group\n");
	fprintf(fout,"H2	H	21	 1.008	 0.135		H aliph. bond. to C with 2 electrwd.groups\n");
	fprintf(fout,"H3	H	22	 1.008	 0.135		H aliph. bond. to C with 3 eletrwd.groups\n");
	fprintf(fout,"HA	H	23	 1.008	 0.167		H arom. bond. to C without elctrwd. groups\n");
	fprintf(fout,"H4	H	24	 1.008	 0.167		H arom. bond. to C with 1 electrwd. group\n");
	fprintf(fout,"H5	H	25	 1.008	 0.167		H arom.at C with 2 elctrwd. gr,+HCOO group\n");
	fprintf(fout,"HO	H	26	 1.008	 0.135		hydroxyl group\n");
	fprintf(fout,"HS	H	27	 1.008	 0.135		hydrogen bonded to sulphur (pol?)\n");
	fprintf(fout,"HW	H	28	 1.008	 0.000		H in TIP3P water\n");
	fprintf(fout,"HP	H	29	 1.008	 0.135		H bonded to C next to positively charged gr\n");
	fprintf(fout,"HZ	H	30	 1.008	 0.161		H bond sp C (Howard et al.JCC,16,243,1995)\n");
	fprintf(fout,"F	F	31	19.000	 0.320		fluorine\n");
	fprintf(fout,"Cl	Cl	32	35.450	 1.910		chlorine  (Applequist)\n");
	fprintf(fout,"Br	Br	33	79.900	 2.880		bromine  (Applequist)\n");
	fprintf(fout,"I	I	34	126.900	 4.690		iodine   (Applequist)\n");
	fprintf(fout,"IM	Cl	35	35.450	 3.235		assumed to be Cl- (ion minus)\n");
	fprintf(fout,"IB	I	36	131.000	 0.000		'big ion w/ waters' for vacuum (Na+, 6H2O)\n");
	fprintf(fout,"MG	Mg	37	24.305	 0.120		magnesium\n");
	fprintf(fout,"N	N	38	14.010	 0.530		sp2 nitrogen in amide groups\n");
	fprintf(fout,"NA	N	39	14.010	 0.530		sp2 N in 5 memb.ring w/H atom (HIS)\n");
	fprintf(fout,"NB	N	40	14.010	 0.530		sp2 N in 5 memb.ring w/LP (HIS,ADE,GUA)\n");
	fprintf(fout,"NC	N	41	14.010	 0.530		sp2 N in 6 memb.ring w/LP (ADE,GUA)\n");
	fprintf(fout,"N2	N	42	14.010	 0.530		sp2 N in amino groups\n");
	fprintf(fout,"N3	N	43	14.010	 0.530		sp3 N for charged amino groups (Lys, etc)\n");
	fprintf(fout,"NT	N	44	14.010	 0.530		sp3 N for amino groups amino groups \n");
	fprintf(fout,"N*	N	45	14.010	 0.530		sp2 N \n");
	fprintf(fout,"NY	N	46	14.010	 0.530		nitrile N (Howard et al.JCC,16,243,1995)\n");
	fprintf(fout,"O	O	47	16.000	 0.434		carbonyl group oxygen\n");
	fprintf(fout,"O2	O	48	16.000	 0.434		carboxyl and phosphate group oxygen\n");
	fprintf(fout,"OW	O	49	16.000	 0.000		oxygen in TIP3P water\n");
	fprintf(fout,"OH	O	50	16.000	 0.465		oxygen in hydroxyl group\n");
	fprintf(fout,"OS	O	51	16.000	 0.465		ether and ester oxygen\n");
	fprintf(fout,"P	P	52	30.970	 1.538		phosphate,pol:JACS,112,8543,90,K.J.Miller\n");
	fprintf(fout,"S	S	53	32.060	 2.900		S in disulfide linkage,pol:JPC,102,2399,98\n");
	fprintf(fout,"SH	S	54	32.060	 2.900		S in cystine\n");
	fprintf(fout,"CU	Cu	55	63.550	 0.000		copper\n");
	fprintf(fout,"FE	Fe	56	55.000	 0.000		iron\n");
	fprintf(fout,"Li	Li	57	 6.940	 0.029		lithium, ions pol:J.PhysC,11,1541,(1978)\n");
	fprintf(fout,"IP	Na	58	22.990	 0.250		assumed to be Na+ (ion plus)\n");
	fprintf(fout,"Na	Na	59	22.990	 0.250		Na+, ions pol:J.PhysC,11,1541,(1978)\n");
	fprintf(fout,"K	K	60	39.100	 1.060		potassium\n");
	fprintf(fout,"Rb	Rb	61	85.470	 0.000		rubidium\n");
	fprintf(fout,"Cs	Cs	62	132.910	 0.000		cesium\n");
	fprintf(fout,"Zn	Zn	63	65.400	 0.000		Zn2+ \n");
	fprintf(fout,"Ba	Ba	64	137.327	 0.000		Ba\n");
	fprintf(fout,"Au	Au	65	196.967	 0.000		Au\n");
	fprintf(fout,"Ag	Ag	66	107.870	 0.000		Ag\n");
	fprintf(fout,"Ni	Ni	67	58.71	 0.000		Ni\n");
	fprintf(fout,"End\n");
	fprintf(fout,"%s\n",bondStretchTitle);
	fprintf(fout,"49	28	 553.0	 0.9572		TIP3P water\n");
	fprintf(fout,"28	28	 553.0	 1.5136		TIP3P water\n");
	fprintf(fout,"1	1	 310.0	 1.5250		Junmei et al, 1999\n");
	fprintf(fout,"1	2	 469.0	 1.4090		JCC,7,(1986),230; (not used any more in TYR)\n");
	fprintf(fout,"1	3	 447.0	 1.4190		JCC,7,(1986),230; GUA\n");
	fprintf(fout,"1	7	 410.0	 1.4440		JCC,7,(1986),230; THY,URA\n");
	fprintf(fout,"1	11	 317.0	 1.5220		JCC,7,(1986),230; AA\n");
	fprintf(fout,"1	38	 490.0	 1.3350		JCC,7,(1986),230; AA\n");
	fprintf(fout,"1	45	 424.0	 1.3830		JCC,7,(1986),230; CYT,URA\n");
	fprintf(fout,"1	39	 418.0	 1.3880		JCC,7,(1986),230; GUA.URA\n");
	fprintf(fout,"1	41	 457.0	 1.3580		JCC,7,(1986),230; CYT\n");
	fprintf(fout,"1	47	 570.0	 1.2290		JCC,7,(1986),230; AA,CYT,GUA,THY,URA\n");
	fprintf(fout,"1	48	 656.0	 1.2500		JCC,7,(1986),230; GLU,ASP\n");
	fprintf(fout,"1	50	 450.0	 1.3640		JCC,7,(1986),230; (not used any more for TYR) \n");
	fprintf(fout,"1	51	 450.0	 1.3230		Junmei et al, 1999\n");
	fprintf(fout,"1	24	 367.0	 1.0800		Junmei et al, 1999\n");
	fprintf(fout,"1	25	 367.0	 1.0800		Junmei et al, 1999\n");
	fprintf(fout,"2	2	 469.0	 1.4000		JCC,7,(1986),230; BENZENE,PHE,TRP,TYR\n");
	fprintf(fout,"2	3	 469.0	 1.4040		JCC,7,(1986),230; ADE,TRP\n");
	fprintf(fout,"2	7	 427.0	 1.4330		JCC,7,(1986),230; CYT\n");
	fprintf(fout,"2	8	 469.0	 1.4000		JCC,7,(1986),230; TRP\n");
	fprintf(fout,"2	11	 317.0	 1.5100		JCC,7,(1986),230; PHE,TYR\n");
	fprintf(fout,"2	23	 367.0	 1.0800		changed from 340. bsd on C6H6 nmodes; PHE,TRP,TYR\n");
	fprintf(fout,"2	24	 367.0	 1.0800		changed from 340. bsd on C6H6 nmodes; no assigned\n");
	fprintf(fout,"2	42	 481.0	 1.3400		JCC,7,(1986),230; ARG,CYT,GUA\n");
	fprintf(fout,"2	39	 427.0	 1.3810		JCC,7,(1986),230; GUA\n");
	fprintf(fout,"2	41	 483.0	 1.3390		JCC,7,(1986),230; ADE,CYT,GUA\n");
	fprintf(fout,"2	50	 450.0	 1.3640		substituted for C-OH in tyr \n");
	fprintf(fout,"3	3	 520.0	 1.3700		JCC,7,(1986),230; ADE,GUA\n");
	fprintf(fout,"3	45	 436.0	 1.3740		JCC,7,(1986),230; ADE,GUA\n");
	fprintf(fout,"3	40	 414.0	 1.3910		JCC,7,(1986),230; ADE,GUA\n");
	fprintf(fout,"3	41	 461.0	 1.3540		JCC,7,(1986),230; ADE,GUA\n");
	fprintf(fout,"5	23	 367.0	 1.0800		Junmei et al, 1999 \n");
	fprintf(fout,"5	5	 469.0	 1.4000		Junmei et al, 1999\n");
	fprintf(fout,"5	7	 549.0	 1.3500		Junmei et al, 1999\n");
	fprintf(fout,"5	11	 317.0	 1.5100		Junmei et al, 1999\n");
	fprintf(fout,"6	25	 367.0	 1.0800		changed from 340. bsd on C6H6 nmodes; ADE,GUA\n");
	fprintf(fout,"6	45	 440.0	 1.3710		JCC,7,(1986),230; ADE,GUA\n");
	fprintf(fout,"6	40	 529.0	 1.3040		JCC,7,(1986),230; ADE,GUA\n");
	fprintf(fout,"7	7	 549.0	 1.3500		JCC,7,(1986),230; CYT,THY,URA\n");
	fprintf(fout,"7	11	 317.0	 1.5100		JCC,7,(1986),230; THY\n");
	fprintf(fout,"7	23	 367.0	 1.0800		changed from 340. bsd on C6H6 nmodes; CYT,URA\n");
	fprintf(fout,"7	24	 367.0	 1.0800		changed from 340. bsd on C6H6 nmodes; CYT,URA\n");
	fprintf(fout,"7	25	 367.0	 1.0800		changed from 340. bsd on C6H6 nmodes; not assigned\n");
	fprintf(fout,"7	45	 448.0	 1.3650		JCC,7,(1986),230; CYT,THY,URA\n");
	fprintf(fout,"7	51	 480.0	 1.2400		Junmei et al, 1999\n");
	fprintf(fout,"9	25	 367.0	 1.0800		changed from 340. bsd on C6H6 nmodes; ADE\n");
	fprintf(fout,"9	41	 502.0	 1.3240		JCC,7,(1986),230; ADE\n");
	fprintf(fout,"11	11	 310.0	 1.5260		JCC,7,(1986),230; AA, SUGARS\n");
	fprintf(fout,"11	19	 340.0	 1.0900		changed from 331 bsd on NMA nmodes; AA, SUGARS\n");
	fprintf(fout,"11	20	 340.0	 1.0900		changed from 331 bsd on NMA nmodes; AA, RIBOSE\n");
	fprintf(fout,"11	21	 340.0	 1.0900		changed from 331 bsd on NMA nmodes; SUGARS\n");
	fprintf(fout,"11	22	 340.0	 1.0900		changed from 331 bsd on NMA nmodes; not assigned\n");
	fprintf(fout,"11	29	 340.0	 1.0900		changed from 331; AA-lysine, methyl ammonium cation\n");
	fprintf(fout,"11	45	 337.0	 1.4750		JCC,7,(1986),230; ADE,CYT,GUA,THY,URA\n");
	fprintf(fout,"11	42	 337.0	 1.4630		JCC,7,(1986),230; ARG\n");
	fprintf(fout,"11	50	 320.0	 1.4100		JCC,7,(1986),230; SUGARS\n");
	fprintf(fout,"11	51	 320.0	 1.4100		JCC,7,(1986),230; NUCLEIC ACIDS\n");
	fprintf(fout,"14	19	 367.0	 1.0800		changed from 340. bsd on C6H6 nmodes, not needed AA\n");
	fprintf(fout,"14	3	 388.0	 1.4590		JCC,7,(1986),230; TRP\n");
	fprintf(fout,"14	11	 317.0	 1.4950		JCC,7,(1986),230; TRP\n");
	fprintf(fout,"14	13	 546.0	 1.3520		JCC,7,(1986),230; TRP\n");
	fprintf(fout,"3	8	 447.0	 1.4190		JCC,7,(1986),230; TRP\n");
	fprintf(fout,"4	11	 317.0	 1.5040		JCC,7,(1986),230; HIS\n");
	fprintf(fout,"4	12	 512.0	 1.3750		JCC,7,(1986),230; HIS(delta)\n");
	fprintf(fout,"4	13	 518.0	 1.3710		JCC,7,(1986),230; HIS(epsilon)\n");
	fprintf(fout,"4	39	 422.0	 1.3850		JCC,7,(1986),230; HIS\n");
	fprintf(fout,"4	40	 410.0	 1.3940		JCC,7,(1986),230; HIS\n");
	fprintf(fout,"8	39	 428.0	 1.3800		JCC,7,(1986),230; TRP\n");
	fprintf(fout,"10	25	 367.0	 1.0800		changed from 340. bsd on C6H6 nmodes;HIS\n");
	fprintf(fout,"10	39	 477.0	 1.3430		JCC,7,(1986),230; HIS\n");
	fprintf(fout,"10	40	 488.0	 1.3350		JCC,7,(1986),230; HIS\n");
	fprintf(fout,"11	38	 337.0	 1.4490		JCC,7,(1986),230; AA\n");
	fprintf(fout,"11	43	 367.0	 1.4710		JCC,7,(1986),230; LYS\n");
	fprintf(fout,"11	44	 367.0	 1.4710		for neutral amines \n");
	fprintf(fout,"11	53	 227.0	 1.8100		changed from 222.0 based on dimethylS nmodes\n");
	fprintf(fout,"11	54	 237.0	 1.8100		changed from 222.0 based on methanethiol nmodes\n");
	fprintf(fout,"11	15	 400.0	 1.4580		Howard et al JCC.16,243,1995\n");
	fprintf(fout,"11	16	 400.0	 1.4590		Howard et al JCC,16,243,1995\n");
	fprintf(fout,"12	24	 367.0	 1.0800		changed from 340. bsd on C6H6 nmodes; HIS\n");
	fprintf(fout,"12	40	 410.0	 1.3940		JCC,7,(1986),230; HIS\n");
	fprintf(fout,"13	24	 367.0	 1.0800		changed from 340. bsd on C6H6 nmodes;HIS(epsilon,+)\n");
	fprintf(fout,"13	39	 427.0	 1.3810		JCC,7,(1986),230; HIS,TRP\n");
	fprintf(fout,"15	46	 600.0	 1.1500		Howard et al JCC,16,243,1995\n");
	fprintf(fout,"16	16	 600.0	 1.2060		Howard et al JCC,16,243,1995\n");
	fprintf(fout,"16	30	 400.0	 1.0560		Howard et al JCC,16,243,1995\n");
	fprintf(fout,"48	52	 525.0	 1.4800		JCC,7,(1986),230; NA PHOSPHATES\n");
	fprintf(fout,"50	52	 230.0	 1.6100		JCC,7,(1986),230; NA PHOSPHATES\n");
	fprintf(fout,"51	52	 230.0	 1.6100		JCC,7,(1986),230; NA PHOSPHATES\n");
	fprintf(fout,"18	42	 434.0	 1.0100		JCC,7,(1986),230; ADE,CYT,GUA,ARG\n");
	fprintf(fout,"18	45	 434.0	 1.0100		for plain unmethylated bases ADE,CYT,GUA,ARG\n");
	fprintf(fout,"18	39	 434.0	 1.0100		JCC,7,(1986),230; GUA,URA,HIS\n");
	fprintf(fout,"18	38	 434.0	 1.0100		JCC,7,(1986),230; AA\n");
	fprintf(fout,"18	43	 434.0	 1.0100		JCC,7,(1986),230; LYS    \n");
	fprintf(fout,"18	44	 434.0	 1.0100		for neutral amines \n");
	fprintf(fout,"26	50	 553.0	 0.9600		JCC,7,(1986),230; SUGARS,SER,TYR\n");
	fprintf(fout,"26	51	 553.0	 0.9600		JCC,7,(1986),230; NUCLEOTIDE ENDS\n");
	fprintf(fout,"27	54	 274.0	 1.3360		JCC,7,(1986),230; CYS\n");
	fprintf(fout,"53	53	 166.0	 2.0380		JCC,7,(1986),230; CYX   (SCHERAGA)\n");
	fprintf(fout,"31	11	 367.0	 1.3800		JCC,13,(1992),963;CF4; R0=1.332 FOR CHF3\n");
	fprintf(fout,"32	11	 232.0	 1.7660		6-31g* opt\n");
	fprintf(fout,"33	11	 159.0	 1.9440		Junmei et al,99 \n");
	fprintf(fout,"34	11	 148.0	 2.1660		Junmei et al,99 \n");
	fprintf(fout,"31	2	 386.0	 1.3590		Junmei et al,99 \n");
	fprintf(fout,"32	2	 193.0	 1.7270		Junmei et al,99 \n");
	fprintf(fout,"34	2	 171.0	 2.0750		Junmei et al,99 \n");
	fprintf(fout,"33	2	 172.0	 1.8900		Junmei et al,99\n");
	fprintf(fout,"24	11	 340.0	 1.0900		\n");
	fprintf(fout,"53	65	 96.0	 2.3900		\n");
	fprintf(fout,"End\n");
	fprintf(fout,"%s\n",angleBendTitle);
	fprintf(fout,"28	49	28	100.000	104.52		TIP3P water\n");
	fprintf(fout,"28	28	49	 0.000	127.74		(found in crystallographic water with 3 bonds)\n");
	fprintf(fout,"1	1	47	80.000	120.00		Junmei et al, 1999 acrolein\n");
	fprintf(fout,"1	1	50	80.000	120.00		Junmei et al, 1999\n");
	fprintf(fout,"2	1	2	63.000	120.00		changed from 85.0  bsd on C6H6 nmodes; AA\n");
	fprintf(fout,"2	1	50	70.000	120.00		AA (not used in tyr)\n");
	fprintf(fout,"3	1	39	70.000	111.30		NA\n");
	fprintf(fout,"3	1	47	80.000	128.80		 \n");
	fprintf(fout,"7	1	39	70.000	114.10		 \n");
	fprintf(fout,"7	1	47	80.000	125.30		 \n");
	fprintf(fout,"11	1	47	80.000	120.40		 \n");
	fprintf(fout,"11	1	48	70.000	117.00		 \n");
	fprintf(fout,"11	1	38	70.000	116.60		AA general\n");
	fprintf(fout,"11	1	11	63.000	117.00		Junmei et al, 1999\n");
	fprintf(fout,"11	1	51	80.000	115.00		Junmei et al, 1999\n");
	fprintf(fout,"11	1	50	80.000	110.00		Junmei et al, 1999\n");
	fprintf(fout,"45	1	39	70.000	115.40		 \n");
	fprintf(fout,"45	1	41	70.000	118.60		 \n");
	fprintf(fout,"45	1	47	80.000	120.90		 \n");
	fprintf(fout,"39	1	47	80.000	120.60		 \n");
	fprintf(fout,"41	1	47	80.000	122.50		 \n");
	fprintf(fout,"38	1	47	80.000	122.90		AA general\n");
	fprintf(fout,"47	1	47	80.000	126.00		AA COO- terminal residues\n");
	fprintf(fout,"47	1	50	80.000	120.00		(check with Junmei for: theta0:120.0?)\n");
	fprintf(fout,"47	1	51	80.000	125.00		Junmei et al, 1999\n");
	fprintf(fout,"48	1	48	80.000	126.00		AA GLU            (SCH JPC 79,2379)\n");
	fprintf(fout,"24	1	1	50.000	120.00		Junmei et al, 1999 \n");
	fprintf(fout,"24	1	7	50.000	115.00		Junmei et al, 1999 \n");
	fprintf(fout,"24	1	11	50.000	115.00		Junmei et al, 1999\n");
	fprintf(fout,"24	1	47	50.000	120.00		Junmei et al, 1999\n");
	fprintf(fout,"24	1	50	50.000	120.00		Junmei et al, 1999\n");
	fprintf(fout,"25	1	38	50.000	120.00		Junmei et al, 1999\n");
	fprintf(fout,"25	1	47	50.000	119.00		Junmei et al, 1999\n");
	fprintf(fout,"25	1	50	50.000	107.00		Junmei et al, 1999\n");
	fprintf(fout,"25	1	51	50.000	107.00		Junmei et al, 1999\n");
	fprintf(fout,"1	2	2	63.000	120.00		changed from 85.0  bsd on C6H6 nmodes\n");
	fprintf(fout,"1	2	23	50.000	120.00		AA (not used in tyr)\n");
	fprintf(fout,"2	2	2	63.000	120.00		changed from 85.0  bsd on C6H6 nmodes\n");
	fprintf(fout,"2	2	3	63.000	120.00		changed from 85.0  bsd on C6H6 nmodes\n");
	fprintf(fout,"2	2	11	70.000	120.00		 \n");
	fprintf(fout,"2	2	23	50.000	120.00		 \n");
	fprintf(fout,"2	2	24	50.000	120.00		 \n");
	fprintf(fout,"2	2	50	70.000	120.00		replacement in tyr\n");
	fprintf(fout,"2	2	8	63.000	120.00		changed from 85.0  bsd on C6H6 nmodes; AA trp\n");
	fprintf(fout,"3	2	23	50.000	120.00		 \n");
	fprintf(fout,"3	2	24	50.000	120.00		 \n");
	fprintf(fout,"3	2	42	70.000	123.50		 \n");
	fprintf(fout,"3	2	41	70.000	117.30		 \n");
	fprintf(fout,"7	2	42	70.000	120.10		 \n");
	fprintf(fout,"7	2	41	70.000	121.50		 \n");
	fprintf(fout,"8	2	23	50.000	120.00		AA trp\n");
	fprintf(fout,"39	2	41	70.000	123.30		 \n");
	fprintf(fout,"42	2	39	70.000	116.00		 \n");
	fprintf(fout,"42	2	41	70.000	119.30		 \n");
	fprintf(fout,"42	2	42	70.000	120.00		AA arg\n");
	fprintf(fout,"31	2	2	70.000	121.00		Junmei et al,99 \n");
	fprintf(fout,"32	2	2	70.000	118.80		Junmei et al,99 \n");
	fprintf(fout,"33	2	2	70.000	118.80		Junmei et al,99\n");
	fprintf(fout,"34	2	2	70.000	118.80		Junmei et al,99 \n");
	fprintf(fout,"1	3	3	63.000	119.20		changed from 85.0  bsd on C6H6 nmodes; NA gua\n");
	fprintf(fout,"1	3	40	70.000	130.00		 \n");
	fprintf(fout,"2	3	3	63.000	117.30		changed from 85.0  bsd on C6H6 nmodes; NA ade\n");
	fprintf(fout,"2	3	40	70.000	132.40		\n");
	fprintf(fout,"3	3	45	70.000	106.20		 \n");
	fprintf(fout,"3	3	40	70.000	110.40		 \n");
	fprintf(fout,"3	3	41	70.000	127.70		 \n");
	fprintf(fout,"14	3	2	63.000	134.90		changed from 85.0  bsd on C6H6 nmodes; AA trp\n");
	fprintf(fout,"14	3	8	63.000	108.80		changed from 85.0  bsd on C6H6 nmodes; AA trp\n");
	fprintf(fout,"2	3	8	63.000	116.20		changed from 85.0  bsd on C6H6 nmodes; AA trp\n");
	fprintf(fout,"45	3	41	70.000	126.20		 \n");
	fprintf(fout,"5	5	7	63.000	120.00		Junmei et al, 1999\n");
	fprintf(fout,"5	5	11	70.000	120.00		Junmei et al, 1999\n");
	fprintf(fout,"7	5	11	70.000	120.00		Junmei et al, 1999\n");
	fprintf(fout,"23	5	23	35.000	119.00		Junmei et al, 1999\n");
	fprintf(fout,"23	5	5	50.000	120.00		Junmei et al, 1999\n");
	fprintf(fout,"23	5	7	50.000	120.00		Junmei et al, 1999\n");
	fprintf(fout,"25	6	45	50.000	123.05		 \n");
	fprintf(fout,"25	6	40	50.000	123.05		 \n");
	fprintf(fout,"45	6	40	70.000	113.90		 \n");
	fprintf(fout,"1	7	7	63.000	120.70		changed from 85.0  bsd on C6H6 nmodes; NA thy\n");
	fprintf(fout,"1	7	11	70.000	119.70		 \n");
	fprintf(fout,"1	7	23	50.000	119.70		 \n");
	fprintf(fout,"1	7	24	50.000	119.70		 \n");
	fprintf(fout,"2	7	7	63.000	117.00		changed from 85.0  bsd on C6H6 nmodes; NA cyt\n");
	fprintf(fout,"2	7	23	50.000	123.30		 \n");
	fprintf(fout,"2	7	24	50.000	123.30		 \n");
	fprintf(fout,"7	7	11	70.000	119.70		 \n");
	fprintf(fout,"7	7	23	50.000	119.70		 \n");
	fprintf(fout,"7	7	24	50.000	119.70		 \n");
	fprintf(fout,"7	7	45	70.000	121.20		 \n");
	fprintf(fout,"7	7	51	80.000	125.00		Junmei et al, 1999\n");
	fprintf(fout,"24	7	45	50.000	119.10		 \n");
	fprintf(fout,"24	7	51	50.000	113.00		Junmei et al, 1999\n");
	fprintf(fout,"23	7	23	35.000	120.00		Junmei et al, 1999\n");
	fprintf(fout,"23	7	5	50.000	120.00		Junmei et al, 1999\n");
	fprintf(fout,"23	7	11	50.000	120.00		Junmei et al, 1999\n");
	fprintf(fout,"41	9	41	70.000	129.10		 \n");
	fprintf(fout,"25	9	41	50.000	115.45		 \n");
	fprintf(fout,"20	11	20	35.000	109.50		 \n");
	fprintf(fout,"20	11	45	50.000	109.50		changed based on NMA nmodes\n");
	fprintf(fout,"20	11	50	50.000	109.50		changed based on NMA nmodes \n");
	fprintf(fout,"20	11	51	50.000	109.50		changed based on NMA nmodes \n");
	fprintf(fout,"20	11	7	50.000	109.50		Junmei et al, 1999 \n");
	fprintf(fout,"20	11	15	50.000	110.00		Junmei et al, 1999\n");
	fprintf(fout,"20	11	16	50.000	110.00		Junmei et al, 1999\n");
	fprintf(fout,"20	11	38	50.000	109.50		AA general  changed based on NMA nmodes\n");
	fprintf(fout,"20	11	53	50.000	109.50		AA cys     changed based on NMA nmodes\n");
	fprintf(fout,"20	11	54	50.000	109.50		AA cyx     changed based on NMA nmodes\n");
	fprintf(fout,"20	11	42	50.000	109.50		AA arg     changed based on NMA nmodes\n");
	fprintf(fout,"20	11	44	50.000	109.50		neutral amines \n");
	fprintf(fout,"21	11	21	35.000	109.50		AA lys\n");
	fprintf(fout,"21	11	45	50.000	109.50		changed based on NMA nmodes\n");
	fprintf(fout,"21	11	51	50.000	109.50		changed based on NMA nmodes\n");
	fprintf(fout,"29	11	29	35.000	109.50		AA lys, ch3nh4+\n");
	fprintf(fout,"29	11	43	50.000	109.50		AA lys, ch3nh3+, changed based on NMA nmodes\n");
	fprintf(fout,"19	11	19	35.000	109.50		 \n");
	fprintf(fout,"19	11	7	50.000	109.50		changed based on NMA nmodes\n");
	fprintf(fout,"19	11	5	50.000	109.50		Junmei et al, 1999\n");
	fprintf(fout,"19	11	16	50.000	110.00		Junmei et al, 1999\n");
	fprintf(fout,"1	11	20	50.000	109.50		AA general  changed based on NMA nmodes\n");
	fprintf(fout,"1	11	29	50.000	109.50		AA zwitterion  changed based on NMA nmodes\n");
	fprintf(fout,"1	11	19	50.000	109.50		AA gln      changed based on NMA nmodes\n");
	fprintf(fout,"1	11	38	63.000	110.10		AA general\n");
	fprintf(fout,"1	11	43	80.000	111.20		AA amino terminal residues\n");
	fprintf(fout,"1	11	11	63.000	111.10		AA general\n");
	fprintf(fout,"1	11	51	60.000	109.50		Junmei et al, 1999\n");
	fprintf(fout,"2	11	19	50.000	109.50		AA tyr     changed based on NMA nmodes\n");
	fprintf(fout,"4	11	11	63.000	113.10		AA his\n");
	fprintf(fout,"4	11	19	50.000	109.50		AA his     changed based on NMA nmodes\n");
	fprintf(fout,"7	11	11	63.000	111.00		Junmei et al, 1999 (last change: Mar24,99)\n");
	fprintf(fout,"7	11	51	50.000	109.50		Junmei et al, 1999\n");
	fprintf(fout,"11	11	11	40.000	109.50		 \n");
	fprintf(fout,"11	11	19	50.000	109.50		changed based on NMA nmodes\n");
	fprintf(fout,"11	11	20	50.000	109.50		changed based on NMA nmodes\n");
	fprintf(fout,"11	11	21	50.000	109.50		changed based on NMA nmodes\n");
	fprintf(fout,"11	11	29	50.000	109.50		changed based on NMA nmodes\n");
	fprintf(fout,"11	11	45	50.000	109.50		 \n");
	fprintf(fout,"11	11	50	50.000	109.50		 \n");
	fprintf(fout,"11	11	51	50.000	109.50		 \n");
	fprintf(fout,"11	11	53	50.000	114.70		AA cyx            (SCHERAGA  JPC 79,1428)\n");
	fprintf(fout,"11	11	54	50.000	108.60		AA cys\n");
	fprintf(fout,"11	11	2	63.000	114.00		AA phe tyr          (SCH JPC  79,2379)\n");
	fprintf(fout,"11	11	42	80.000	111.20		AA arg             (JCP 76, 1439)\n");
	fprintf(fout,"11	11	38	80.000	109.70		AA ala, general    (JACS 94, 2657)\n");
	fprintf(fout,"11	11	43	80.000	111.20		AA lys             (JCP 76, 1439)\n");
	fprintf(fout,"11	11	44	80.000	111.20		neutral amines \n");
	fprintf(fout,"11	11	15	63.000	110.00		Junmei et al, 1999    \n");
	fprintf(fout,"11	11	16	63.000	110.00		Junmei et al, 1999\n");
	fprintf(fout,"14	11	11	63.000	115.60		AA trp\n");
	fprintf(fout,"14	11	19	50.000	109.50		AA trp    changed based on NMA nmodes\n");
	fprintf(fout,"51	11	51	160.000	101.00		Junmei et al, 1999\n");
	fprintf(fout,"51	11	15	50.000	110.00		Junmei et al, 1999\n");
	fprintf(fout,"51	11	16	50.000	110.00		Junmei et al, 1999\n");
	fprintf(fout,"51	11	16	50.000	110.00		Junmei et al, 1999\n");
	fprintf(fout,"51	11	15	50.000	110.00		Junmei et al, 1999\n");
	fprintf(fout,"51	11	45	50.000	109.50		 \n");
	fprintf(fout,"31	11	31	77.000	109.10		JCC,13,(1992),963;\n");
	fprintf(fout,"31	11	20	50.000	109.50		JCC,13,(1992),963;\n");
	fprintf(fout,"31	11	11	50.000	109.00		\n");
	fprintf(fout,"31	11	21	50.000	109.50		 \n");
	fprintf(fout,"32	11	11	50.000	108.50		(6-31g* opt value)\n");
	fprintf(fout,"32	11	20	50.000	108.50		(6-31g* opt value)  \n");
	fprintf(fout,"33	11	11	50.000	108.00		Junmei et al 99 \n");
	fprintf(fout,"33	11	20	50.000	106.50		Junmei et al 99 \n");
	fprintf(fout,"34	11	11	50.000	106.00		Junmei et al,99 \n");
	fprintf(fout,"11	4	39	70.000	120.00		AA his\n");
	fprintf(fout,"11	4	12	70.000	120.00		AA his\n");
	fprintf(fout,"11	4	40	70.000	120.00		AA his\n");
	fprintf(fout,"12	4	39	70.000	120.00		AA his\n");
	fprintf(fout,"13	4	39	70.000	120.00		AA his\n");
	fprintf(fout,"13	4	40	70.000	120.00		AA his\n");
	fprintf(fout,"11	4	13	70.000	120.00		AA his\n");
	fprintf(fout,"25	10	39	50.000	120.00		AA his\n");
	fprintf(fout,"25	10	40	50.000	120.00		AA his\n");
	fprintf(fout,"39	10	39	70.000	120.00		AA his\n");
	fprintf(fout,"39	10	40	70.000	120.00		AA his\n");
	fprintf(fout,"4	12	24	50.000	120.00		AA his\n");
	fprintf(fout,"4	12	40	70.000	120.00		AA his\n");
	fprintf(fout,"24	12	40	50.000	120.00		AA his\n");
	fprintf(fout,"4	13	24	50.000	120.00		AA his\n");
	fprintf(fout,"4	13	39	70.000	120.00		AA his\n");
	fprintf(fout,"14	13	24	50.000	120.00		AA trp\n");
	fprintf(fout,"14	13	39	70.000	108.70		AA trp\n");
	fprintf(fout,"24	13	39	50.000	120.00		AA his\n");
	fprintf(fout,"3	14	11	70.000	128.60		AA trp\n");
	fprintf(fout,"3	14	13	63.000	106.40		changed from 85.0  bsd on C6H6 nmodes; AA trp\n");
	fprintf(fout,"11	14	13	70.000	125.00		AA trp\n");
	fprintf(fout,"2	8	3	63.000	122.70		changed from 85.0  bsd on C6H6 nmodes; AA trp\n");
	fprintf(fout,"2	8	39	70.000	132.80		AA trp\n");
	fprintf(fout,"3	8	39	70.000	104.40		AA trp\n");
	fprintf(fout,"11	15	46	80.000	180.00		Junmei et al, 1999\n");
	fprintf(fout,"11	16	16	80.000	180.00		Junmei et al, 1999\n");
	fprintf(fout,"16	16	30	50.000	180.00		Junmei et al, 1999\n");
	fprintf(fout,"1	38	11	50.000	121.90		AA general\n");
	fprintf(fout,"1	38	18	50.000	120.00		AA general, gln, asn,changed based on NMA nmodes\n");
	fprintf(fout,"11	38	18	50.000	118.04		AA general,     changed based on NMA nmodes\n");
	fprintf(fout,"11	38	11	50.000	118.00		AA pro             (DETAR JACS 99,1232)\n");
	fprintf(fout,"18	38	18	35.000	120.00		ade,cyt,gua,gln,asn     **\n");
	fprintf(fout,"1	45	7	70.000	121.60		 \n");
	fprintf(fout,"1	45	11	70.000	117.60		 \n");
	fprintf(fout,"1	45	18	50.000	119.20		changed based on NMA nmodes\n");
	fprintf(fout,"3	45	6	70.000	105.40		 \n");
	fprintf(fout,"3	45	11	70.000	125.80		 \n");
	fprintf(fout,"3	45	18	50.000	125.80		for unmethylated n.a. bases,chngd bsd NMA nmodes\n");
	fprintf(fout,"6	45	11	70.000	128.80		 \n");
	fprintf(fout,"6	45	18	50.000	128.80		for unmethylated n.a. bases,chngd bsd NMA nmodes\n");
	fprintf(fout,"7	45	11	70.000	121.20		 \n");
	fprintf(fout,"7	45	18	50.000	121.20		for unmethylated n.a. bases,chngd bsd NMA nmodes\n");
	fprintf(fout,"2	42	18	50.000	120.00		\n");
	fprintf(fout,"2	42	11	50.000	123.20		AA arg\n");
	fprintf(fout,"11	42	18	50.000	118.40		AA arg\n");
	fprintf(fout,"18	42	18	35.000	120.00		\n");
	fprintf(fout,"11	43	18	50.000	109.50		AA lys,     changed based on NMA nmodes\n");
	fprintf(fout,"11	43	11	50.000	109.50		AA pro/nt\n");
	fprintf(fout,"18	43	18	35.000	109.50		AA lys, AA(end)\n");
	fprintf(fout,"11	44	18	50.000	109.50		neutral amines \n");
	fprintf(fout,"11	44	11	50.000	109.50		neutral amines \n");
	fprintf(fout,"18	44	18	35.000	109.50		neutral amines \n");
	fprintf(fout,"1	39	1	70.000	126.40		 \n");
	fprintf(fout,"1	39	2	70.000	125.20		 \n");
	fprintf(fout,"1	39	18	50.000	116.80		changed based on NMA nmodes\n");
	fprintf(fout,"2	39	18	50.000	118.00		changed based on NMA nmodes\n");
	fprintf(fout,"4	39	10	70.000	120.00		AA his\n");
	fprintf(fout,"4	39	18	50.000	120.00		AA his,    changed based on NMA nmodes\n");
	fprintf(fout,"10	39	13	70.000	120.00		AA his\n");
	fprintf(fout,"10	39	18	50.000	120.00		AA his,    changed based on NMA nmodes\n");
	fprintf(fout,"13	39	18	50.000	120.00		AA his,    changed based on NMA nmodes\n");
	fprintf(fout,"8	39	13	70.000	111.60		AA trp\n");
	fprintf(fout,"8	39	18	50.000	123.10		AA trp,    changed based on NMA nmodes\n");
	fprintf(fout,"3	40	6	70.000	103.80		 \n");
	fprintf(fout,"4	40	10	70.000	117.00		AA his\n");
	fprintf(fout,"10	40	12	70.000	117.00		AA his\n");
	fprintf(fout,"1	41	2	70.000	120.50		 \n");
	fprintf(fout,"2	41	3	70.000	112.20		 \n");
	fprintf(fout,"2	41	9	70.000	118.60		 \n");
	fprintf(fout,"3	41	9	70.000	111.00		 \n");
	fprintf(fout,"1	50	26	50.000	113.00		(not used in tyr anymore)\n");
	fprintf(fout,"2	50	26	50.000	113.00		replacement in tyr\n");
	fprintf(fout,"11	50	26	55.000	108.50		 \n");
	fprintf(fout,"26	50	52	45.000	108.50		 \n");
	fprintf(fout,"1	51	11	60.000	117.00		Junmei et al, 1999\n");
	fprintf(fout,"7	51	11	60.000	117.00		Junmei et al, 1999\n");
	fprintf(fout,"11	51	11	60.000	109.50		 \n");
	fprintf(fout,"11	51	52	100.000	120.50		 \n");
	fprintf(fout,"52	51	52	100.000	120.50		 \n");
	fprintf(fout,"48	52	50	45.000	108.23		 \n");
	fprintf(fout,"48	52	48	140.000	119.90		 \n");
	fprintf(fout,"48	52	51	100.000	108.23		 \n");
	fprintf(fout,"50	52	51	45.000	102.60		 \n");
	fprintf(fout,"51	52	51	45.000	102.60		 \n");
	fprintf(fout,"11	53	11	62.000	 98.90		AA met\n");
	fprintf(fout,"11	53	53	68.000	103.70		AA cyx             (SCHERAGA  JPC 79,1428)\n");
	fprintf(fout,"11	54	27	43.000	 96.00		changed from 44.0 based on methanethiol nmodes\n");
	fprintf(fout,"27	54	27	35.000	 92.07		AA cys\n");
	fprintf(fout,"11	11	24	50.000	 109.5		\n");
	fprintf(fout,"24	11	24	35.000	 109.5		\n");
	fprintf(fout,"1		11	24	50.000	 109.5		\n");
	fprintf(fout,"38	11	24	50.000	 120.0		\n");
	fprintf(fout,"50	1	48	60.000	 115.0		\n");
	fprintf(fout,"38	11	53	50.000	 109.0		\n");
	fprintf(fout,"53	11	1	50.000	 109.0		\n");
	fprintf(fout,"53	11	24	50.000	 109.0		\n");
	fprintf(fout,"65	53	11	46.35	 104.0		\n");
	fprintf(fout,"End\n");
	fprintf(fout,"%s\n",dihedralAngleTitle);
	fprintf(fout,"0	1	1	0	 4.0	14.500	180.00	 2.0		Junmei et al, 1999\n");
	fprintf(fout,"0	1	2	0	 4.0	14.500	180.00	 2.0		intrpol.bsd.on C6H6\n");
	fprintf(fout,"0	1	3	0	 4.0	12.000	180.00	 2.0		intrpol.bsd.on C6H6\n");
	fprintf(fout,"0	1	7	0	 4.0	 8.700	180.00	 2.0		intrpol.bsd.on C6H6\n");
	fprintf(fout,"0	1	11	0	 6.0	 0.000	  0.00	 2.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	1	38	0	 4.0	10.000	180.00	 2.0		AA,NMA\n");
	fprintf(fout,"0	1	45	0	 4.0	 5.800	180.00	 2.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	1	39	0	 4.0	 5.400	180.00	 2.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	1	41	0	 2.0	 8.000	180.00	 2.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	1	47	0	 4.0	11.200	180.00	 2.0		Junmei et al, 1999\n");
	fprintf(fout,"0	1	50	0	 2.0	 4.600	180.00	 2.0		Junmei et al, 1999\n");
	fprintf(fout,"0	1	51	0	 2.0	 5.400	180.00	 2.0		Junmei et al, 1999\n");
	fprintf(fout,"0	2	2	0	 4.0	14.500	180.00	 2.0		intrpol.bsd.on C6H6\n");
	fprintf(fout,"0	2	3	0	 4.0	14.000	180.00	 2.0		intrpol.bsd.on C6H6\n");
	fprintf(fout,"0	2	7	0	 4.0	10.200	180.00	 2.0		intrpol.bsd.on C6H6\n");
	fprintf(fout,"0	2	8	0	 4.0	14.500	180.00	 2.0		reinterpolated 93'\n");
	fprintf(fout,"0	2	11	0	 6.0	 0.000	  0.00	 2.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	2	42	0	 4.0	 9.600	180.00	 2.0		reinterpolated 93'\n");
	fprintf(fout,"0	2	39	0	 4.0	 6.000	180.00	 2.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	2	41	0	 2.0	 9.600	180.00	 2.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	2	50	0	 2.0	 1.800	180.00	 2.0		Junmei et al, 99\n");
	fprintf(fout,"0	3	3	0	 4.0	21.800	180.00	 2.0		intrpol.bsd.on C6H6\n");
	fprintf(fout,"0	3	8	0	 4.0	12.000	180.00	 2.0		reinterpolated 93'\n");
	fprintf(fout,"0	3	45	0	 4.0	 6.600	180.00	 2.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	3	40	0	 2.0	 5.100	180.00	 2.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	3	41	0	 2.0	 8.300	180.00	 2.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	4	11	0	 6.0	 0.000	  0.00	 2.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	4	12	0	 4.0	20.600	180.00	 2.0		intrpol.bsd.on C6H6\n");
	fprintf(fout,"0	4	13	0	 4.0	21.500	180.00	 2.0		intrpol.bsd.on C6H6\n");
	fprintf(fout,"0	4	39	0	 4.0	 5.600	180.00	 2.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	4	40	0	 2.0	 4.800	180.00	 2.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	5	5	0	 4.0	 4.000	180.00	 2.0		Junmei et al, 1999\n");
	fprintf(fout,"0	5	11	0	 6.0	 0.000	  0.00	 2.0		Junmei et al, 1999\n");
	fprintf(fout,"0	5	7	0	 4.0	26.600	180.00	 2.0		Junmei et al, 1999\n");
	fprintf(fout,"0	6	45	0	 4.0	 6.800	180.00	 2.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	6	40	0	 2.0	20.000	180.00	 2.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	7	7	0	 4.0	26.600	180.00	 2.0		intrpol.bsd.on C6H6\n");
	fprintf(fout,"0	7	11	0	 6.0	 0.000	  0.00	 3.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	7	45	0	 4.0	 7.400	180.00	 2.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	7	51	0	 2.0	 2.100	180.00	 2.0		Junmei et al, 1999\n");
	fprintf(fout,"0	8	39	0	 4.0	 6.100	180.00	 2.0		reinterpolated 93'\n");
	fprintf(fout,"0	9	41	0	 2.0	13.600	180.00	 2.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	11	11	0	 9.0	 1.400	  0.00	 3.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	11	15	0	 3.0	 0.000	  0.00	 1.0		Junmei et al, 1999\n");
	fprintf(fout,"0	11	16	0	 3.0	 0.000	  0.00	 1.0		Junmei et al, 1999\n");
	fprintf(fout,"0	11	38	0	 6.0	 0.000	  0.00	 2.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	11	45	0	 6.0	 0.000	  0.00	 2.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	11	42	0	 6.0	 0.000	  0.00	 3.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	11	44	0	 6.0	 1.800	  0.00	 3.0		Junmei et al, 1999\n");
	fprintf(fout,"0	11	43	0	 9.0	 1.400	  0.00	 3.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	11	50	0	 3.0	 0.500	  0.00	 3.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	11	51	0	 3.0	 1.150	  0.00	 3.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	11	53	0	 3.0	 1.000	  0.00	 3.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	11	54	0	 3.0	 0.750	  0.00	 3.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	14	3	0	 4.0	 6.700	180.00	 2.0		intrpol.bsd.onC6H6aa\n");
	fprintf(fout,"0	14	11	0	 6.0	 0.000	  0.00	 2.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	14	13	0	 4.0	26.100	180.00	 2.0		intrpol.bsd.on C6H6\n");
	fprintf(fout,"0	10	39	0	 4.0	 9.300	180.00	 2.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	10	40	0	 2.0	10.000	180.00	 2.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	12	40	0	 2.0	 4.800	180.00	 2.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	13	39	0	 4.0	 6.000	180.00	 2.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	50	52	0	 3.0	 0.750	  0.00	 3.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	51	52	0	 3.0	 0.750	  0.00	 3.0		JCC,7,(1986),230\n");
	fprintf(fout,"38	11	1	38	 1.0	 1.700	180.00	-1.0		 \n");
	fprintf(fout,"38	11	1	38	 1.0	 2.000	180.00	 2.0		 \n");
	fprintf(fout,"1	38	11	1	 1.0	 0.850	180.00	-2.0		 \n");
	fprintf(fout,"1	38	11	1	 1.0	 0.800	  0.00	 1.0		 \n");
	fprintf(fout,"11	11	38	1	 1.0	 0.500	180.00	-4.0		phi,psi,parm94\n");
	fprintf(fout,"11	11	38	1	 1.0	 0.150	180.00	-3.0		phi,psi,parm94\n");
	fprintf(fout,"11	11	38	1	 1.0	 0.530	  0.00	 1.0		phi,psi,parm94\n");
	fprintf(fout,"11	11	1	38	 1.0	 0.100	  0.00	-4.0		phi,psi,parm94\n");
	fprintf(fout,"11	11	1	38	 1.0	 0.070	  0.00	 2.0		phi,psi,parm94\n");
	fprintf(fout,"18	38	1	47	 1.0	 2.500	180.00	-2.0		JCC,7,(1986),230\n");
	fprintf(fout,"18	38	1	47	 1.0	 2.000	  0.00	 1.0		JCC,7,(1986),230\n");
	fprintf(fout,"11	53	53	11	 1.0	 3.500	  0.00	-2.0		JCC,7,(1986),230\n");
	fprintf(fout,"11	53	53	11	 1.0	 0.600	  0.00	 3.0		JCC,7,(1986),230\n");
	fprintf(fout,"50	52	51	11	 1.0	 0.250	  0.00	-3.0		JCC,7,(1986),230\n");
	fprintf(fout,"50	52	51	11	 1.0	 1.200	  0.00	 2.0		JCC,7,(1986),230\n");
	fprintf(fout,"51	52	51	11	 1.0	 0.250	  0.00	-3.0		JCC,7,(1986),230\n");
	fprintf(fout,"51	52	51	11	 1.0	 1.200	  0.00	 2.0		JCC,7,(1986),230\n");
	fprintf(fout,"20	11	1	47	 1.0	 0.800	  0.00	-1.0		Junmei et al, 1999\n");
	fprintf(fout,"20	11	1	47	 1.0	 0.080	180.00	 3.0		Junmei et al, 1999\n");
	fprintf(fout,"19	11	1	47	 1.0	 0.800	  0.00	-1.0		Junmei et al, 1999\n");
	fprintf(fout,"19	11	1	47	 1.0	 0.080	180.00	 3.0		Junmei et al, 1999\n");
	fprintf(fout,"19	11	11	19	 1.0	 0.150	  0.00	 3.0		Junmei et al, 1999\n");
	fprintf(fout,"19	11	11	11	 1.0	 0.160	  0.00	 3.0		Junmei et al, 1999\n");
	fprintf(fout,"19	11	7	7	 1.0	 0.380	180.00	-3.0		Junmei et al, 1999\n");
	fprintf(fout,"19	11	7	7	 1.0	 1.150	  0.00	 1.0		Junmei et al, 1999\n");
	fprintf(fout,"26	50	11	11	 1.0	 0.160	  0.00	-3.0		Junmei et al, 1999\n");
	fprintf(fout,"26	50	11	11	 1.0	 0.250	  0.00	 1.0		Junmei et al, 1999\n");
	fprintf(fout,"26	50	1	47	 1.0	 2.300	180.00	-2.0		Junmei et al, 1999\n");
	fprintf(fout,"26	50	1	47	 1.0	 1.900	  0.00	 1.0		Junmei et al, 1999\n");
	fprintf(fout,"7	7	1	47	 1.0	 2.175	180.00	-2.0		Junmei et al, 1999\n");
	fprintf(fout,"7	7	1	47	 1.0	 0.300	  0.00	 3.0		Junmei et al, 1999\n");
	fprintf(fout,"11	7	7	11	 1.0	 6.650	180.00	-2.0		Junmei et al, 1999\n");
	fprintf(fout,"11	7	7	11	 1.0	 1.900	180.00	 1.0		Junmei et al, 1999\n");
	fprintf(fout,"11	11	11	11	 1.0	 0.180	  0.00	-3.0		Junmei et al, 1999\n");
	fprintf(fout,"11	11	11	11	 1.0	 0.250	180.00	-2.0		Junmei et al, 1999\n");
	fprintf(fout,"11	11	11	11	 1.0	 0.200	180.00	 1.0		Junmei et al, 1999\n");
	fprintf(fout,"11	11	44	11	 1.0	 0.300	  0.00	-3.0		Junmei et al, 1999\n");
	fprintf(fout,"11	11	44	11	 1.0	 0.480	180.00	 2.0		Junmei et al, 1999\n");
	fprintf(fout,"11	11	51	11	 1.0	 0.383	  0.00	-3.0		 \n");
	fprintf(fout,"11	11	51	11	 1.0	 0.100	180.00	 2.0		 \n");
	fprintf(fout,"11	11	51	1	 1.0	 0.383	  0.00	-3.0		Junmei et al, 1999\n");
	fprintf(fout,"11	11	51	1	 1.0	 0.800	180.00	 1.0		Junmei et al, 1999\n");
	fprintf(fout,"11	51	11	51	 1.0	 0.100	  0.00	-3.0		Junmei et al, 1999\n");
	fprintf(fout,"11	51	11	51	 1.0	 0.850	180.00	-2.0		Junmei et al, 1999\n");
	fprintf(fout,"11	51	11	51	 1.0	 1.350	180.00	 1.0		Junmei et al, 1999\n");
	fprintf(fout,"11	51	11	45	 1.0	 0.383	  0.00	-3.0		parm98.dat, TC,PC,PAK\n");
	fprintf(fout,"11	51	11	45	 1.0	 0.650	  0.00	 2.0		parm98.dat, TC,PC,PAK\n");
	fprintf(fout,"11	16	16	30	 1.0	 0.000	  0.00	 1.0		Junmei et al, 1999\n");
	fprintf(fout,"47	1	51	11	 1.0	 2.700	180.00	-2.0		Junmei et al, 1999\n");
	fprintf(fout,"47	1	51	11	 1.0	 1.400	180.00	 1.0		Junmei et al, 1999\n");
	fprintf(fout,"51	11	45	6	 1.0	 0.000	  0.00	-2.0		parm98, TC,PC,PAK\n");
	fprintf(fout,"51	11	45	6	 1.0	 2.500	  0.00	 1.0		parm98, TC,PC,PAK\n");
	fprintf(fout,"51	11	45	7	 1.0	 0.000	  0.00	-2.0		parm98, TC,PC,PAK\n");
	fprintf(fout,"51	11	45	7	 1.0	 2.500	  0.00	 1.0		parm98, TC,PC,PAK\n");
	fprintf(fout,"51	11	11	51	 1.0	 0.144	  0.00	-3.0		parm98, TC,PC,PAK\n");
	fprintf(fout,"51	11	11	51	 1.0	 1.175	  0.00	 2.0		parm98, TC,PC,PAK\n");
	fprintf(fout,"51	11	11	50	 1.0	 0.144	  0.00	-3.0		parm98, TC,PC,PAK\n");
	fprintf(fout,"51	11	11	50	 1.0	 1.175	  0.00	 2.0		parm98, TC,PC,PAK\n");
	fprintf(fout,"50	11	11	50	 1.0	 0.144	  0.00	-3.0		parm98, TC,PC,PAK\n");
	fprintf(fout,"50	11	11	50	 1.0	 1.175	  0.00	 2.0		parm98, TC,PC,PAK\n");
	fprintf(fout,"31	11	11	31	 1.0	 1.200	180.00	 1.0		Junmei et al, 1999\n");
	fprintf(fout,"32	11	11	32	 1.0	 0.450	180.00	 1.0		Junmei et al, 1999\n");
	fprintf(fout,"33	11	11	33	 1.0	 0.000	180.00	 1.0		Junmei et al, 1999\n");
	fprintf(fout,"20	11	11	51	 1.0	 0.250	  0.00	 1.0		Junmei et al, 1999\n");
	fprintf(fout,"20	11	11	50	 1.0	 0.250	  0.00	 1.0		Junmei et al, 1999\n");
	fprintf(fout,"20	11	11	31	 1.0	 0.190	  0.00	 1.0		Junmei et al, 1999\n");
	fprintf(fout,"20	11	11	32	 1.0	 0.250	  0.00	 1.0		Junmei et al, 1999\n");
	fprintf(fout,"20	11	11	33	 1.0	 0.550	  0.00	 1.0		Junmei et al, 1999\n");
	fprintf(fout,"19	11	11	51	 1.0	 0.250	  0.00	 1.0		Junmei et al, 1999\n");
	fprintf(fout,"19	11	11	50	 1.0	 0.250	  0.00	 1.0		Junmei et al, 1999\n");
	fprintf(fout,"19	11	11	31	 1.0	 0.190	  0.00	 1.0		Junmei et al, 1999\n");
	fprintf(fout,"19	11	11	32	 1.0	 0.250	  0.00	 1.0		Junmei et al, 1999\n");
	fprintf(fout,"19	11	11	33	 1.0	 0.550	  0.00	 1.0		Junmei et al, 1999\n");
	fprintf(fout,"End\n");
	fprintf(fout,"%s\n",strBendTitle);
//	fprintf(fout,"28	49	28	1.0	1.0\n");
	fprintf(fout,"End\n");
	fprintf(fout,"%s\n",improperTorsionTitle);
	fprintf(fout,"0	0	1	47	10.500	180.00	 2.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	48	1	48	10.500	180.00	 2.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	0	38	18	 1.000	180.00	 2.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	0	42	18	 1.000	180.00	 2.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	0	39	18	 1.000	180.00	 2.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	42	2	42	10.500	180.00	 2.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	11	38	11	 1.000	180.00	 2.0		JCC,7,(1986),230\n");
	fprintf(fout,"0	0	2	23	 1.100	180.00	 2.0		bsd.on C6H6 nmodes\n");
	fprintf(fout,"0	0	13	24	 1.100	180.00	 2.0		 \n");
	fprintf(fout,"0	0	10	25	 1.100	180.00	 2.0		 \n");
	fprintf(fout,"0	0	12	24	 1.100	180.00	 2.0		 \n");
	fprintf(fout,"0	0	9	25	 1.100	180.00	 2.0		 \n");
	fprintf(fout,"0	0	6	25	 1.100	180.00	 2.0		 \n");
	fprintf(fout,"0	0	7	24	 1.100	180.00	 2.0		 \n");
	fprintf(fout,"0	0	7	23	 1.100	180.00	 2.0		 \n");
	fprintf(fout,"0	0	2	24	 1.100	180.00	 2.0		bsd.on C6H6 nmodes \n");
	fprintf(fout,"0	0	2	25	 1.100	180.00	 2.0		bsd.on C6H6 nmodes\n");
	fprintf(fout,"6	3	45	11	 1.000	180.00	 2.0		 \n");
	fprintf(fout,"7	1	45	11	 1.000	180.00	 2.0		dac guess, 9/94\n");
	fprintf(fout,"7	1	7	11	 1.100	180.00	 2.0		 \n");
	fprintf(fout,"11	47	1	50	10.500	180.00	 2.0		 \n");
	fprintf(fout,"39	12	4	11	 1.100	180.00	 2.0		 \n");
	fprintf(fout,"40	13	4	11	 1.100	180.00	 2.0		 \n");
	fprintf(fout,"39	13	4	11	 1.100	180.00	 2.0		 \n");
	fprintf(fout,"13	3	14	11	 1.100	180.00	 2.0		 \n");
	fprintf(fout,"2	2	2	11	 1.100	180.00	 2.0		 \n");
	fprintf(fout,"1	7	7	11	 1.100	180.00	 2.0		dac guess, 9/94\n");
	fprintf(fout,"41	7	2	42	 1.100	180.00	 2.0		dac guess, 9/94\n");
	fprintf(fout,"3	41	2	42	 1.100	180.00	 2.0		dac, 10/94\n");
	fprintf(fout,"39	41	2	42	 1.100	180.00	 2.0		dac, 10/94\n");
	fprintf(fout,"2	2	1	50	 1.100	180.00	 2.0		(not used in tyr!)\n");
	fprintf(fout,"2	2	2	50	 1.100	180.00	 2.0		in tyr\n");
	fprintf(fout,"25	47	1	50	 1.100	180.00	 2.0		Junmei et al.1999\n");
	fprintf(fout,"25	47	1	51	 1.100	180.00	 2.0		\n");
	fprintf(fout,"7	11	7	23	 1.100	180.00	 2.0		Junmei et al.1999\n");
	fprintf(fout,"2	2	2	33	 1.100	180.00	 2.0		Junmei et al.1999\n");
	fprintf(fout,"7	24	1	47	 1.100	180.00	 2.0		Junmei et al.1999\n");
	fprintf(fout,"1	11	38	18	 1.100	180.00	 2.0		Junmei et al.1999\n");
	fprintf(fout,"1	11	38	47	 1.100	180.00	 2.0		Junmei et al.1999\n");
	fprintf(fout,"End\n");
	fprintf(fout,"%s\n",hydrogenBondedTitle);
	fprintf(fout,"18	40	  7557.0	  2385.0		 \n");
	fprintf(fout,"18	41	 10238.0	  3071.0		 \n");
	fprintf(fout,"18	47	  7557.0	  2385.0		 \n");
	fprintf(fout,"18	48	  4019.0	  1409.0		 \n");
	fprintf(fout,"18	50	  7557.0	  2385.0		 \n");
	fprintf(fout,"18	53	265720.0	 35429.0		 \n");
	fprintf(fout,"18	54	265720.0	 35429.0		 \n");
	fprintf(fout,"26	40	  7557.0	  2385.0		 \n");
	fprintf(fout,"26	47	  7557.0	  2385.0		 \n");
	fprintf(fout,"26	48	  4019.0	  1409.0		 \n");
	fprintf(fout,"26	50	  7557.0	  2385.0		 \n");
	fprintf(fout,"26	53	265720.0	 35429.0		 \n");
	fprintf(fout,"26	54	265720.0	 35429.0		 \n");
	fprintf(fout,"27	40	 14184.0	  3082.0		 \n");
	fprintf(fout,"27	47	 14184.0	  3082.0		 \n");
	fprintf(fout,"27	48	  4019.0	  1409.0		 \n");
	fprintf(fout,"27	50	 14184.0	  3082.0		 \n");
	fprintf(fout,"27	53	265720.0	 35429.0		 \n");
	fprintf(fout,"27	54	265720.0	 35429.0		 \n");
	fprintf(fout,"21	40	  4019.0	  1409.0		 \n");
	fprintf(fout,"21	47	 10238.0	  3071.0		 \n");
	fprintf(fout,"21	48	  4019.0	  1409.0		 \n");
	fprintf(fout,"21	50	  4019.0	  1409.0		 \n");
	fprintf(fout,"21	53	  7557.0	  2385.0		 \n");
	fprintf(fout,"21	54	  7557.0	  2385.0		 \n");
	fprintf(fout,"22	40	  4019.0	  1409.0		 \n");
	fprintf(fout,"22	47	  4019.0	  1409.0		 \n");
	fprintf(fout,"22	48	  4019.0	  1409.0		 \n");
	fprintf(fout,"22	50	  4019.0	  1409.0		 \n");
	fprintf(fout,"22	53	  7557.0	  2385.0		 \n");
	fprintf(fout,"22	54	  7557.0	  2385.0		 \n");
	fprintf(fout,"End\n");
	fprintf(fout,"%s\n",suttonChenTitle);
	fprintf(fout,"65	65	0.29501359 	4.08 34.408 10.0 8.0\n");
	fprintf(fout,"66	66	0.05860838 	4.09 144.41 12.0 6.0\n");
	fprintf(fout,"67	67	0.36221203 	3.52 39.432 9.0 6.0\n");
	fprintf(fout,"End\n");
	fprintf(fout,"%s\n",nonBondedTitle);
	fprintf(fout,"18	  0.6000	  0.0157		Ferguson base pair geom.\n");
	/* fprintf(fout,"26	  0.0000	  0.0000		OPLS Jorgensen, JACS,110,(1988),1657\n");*/
	fprintf(fout,"26	  0.2000	  0.0200		OPLS Jorgensen, JACS,110,(1988),1657\n");
	fprintf(fout,"27	  0.6000	  0.0157		W. Cornell CH3SH --> CH3OH FEP\n");
	fprintf(fout,"19	  1.4870	  0.0157		OPLS\n");
	fprintf(fout,"20	  1.3870	  0.0157		Veenstra et al JCC,8,(1992),963 \n");
	fprintf(fout,"21	  1.2870	  0.0157		Veenstra et al JCC,8,(1992),963 \n");
	fprintf(fout,"22	  1.1870	  0.0157		Veenstra et al JCC,8,(1992),963 \n");
	fprintf(fout,"29	  1.1000	  0.0157		Veenstra et al JCC,8,(1992),963\n");
	fprintf(fout,"23	  1.4590	  0.0150		Spellmeyer \n");
	fprintf(fout,"24	  1.4090	  0.0150		Spellmeyer, one electrowithdr. neighbor\n");
	fprintf(fout,"25	  1.3590	  0.0150		Spellmeyer, two electrowithdr. neighbor\n");
	fprintf(fout,"28	  0.0000	  0.0000		TIP3P water model\n");
	fprintf(fout,"30	  1.4590	  0.0150		H bonded to sp C (Howard et al JCC 16)\n");
	fprintf(fout,"47	  1.6612	  0.2100		OPLS\n");
	fprintf(fout,"48	  1.6612	  0.2100		OPLS\n");
	fprintf(fout,"49	  1.7683	  0.1520		TIP3P water model\n");
	fprintf(fout,"50	  1.7210	  0.2104		OPLS \n");
	fprintf(fout,"51	  1.6837	  0.1700		OPLS ether\n");
	fprintf(fout,"14	  1.9080	  0.0860		Spellmeyer\n");
	fprintf(fout,"2	  1.9080	  0.0860		Spellmeyer\n");
	fprintf(fout,"3	  1.9080	  0.0860		Spellmeyer\n");
	fprintf(fout,"4	  1.9080	  0.0860		Spellmeyer\n");
	fprintf(fout,"5	  1.9080	  0.0860		Spellmeyer\n");
	fprintf(fout,"6	  1.9080	  0.0860		Spellmeyer\n");
	fprintf(fout,"7	  1.9080	  0.0860		Spellmeyer\n");
	fprintf(fout,"8	  1.9080	  0.0860		Spellmeyer\n");
	fprintf(fout,"9	  1.9080	  0.0860		Spellmeyer\n");
	fprintf(fout,"10	  1.9080	  0.0860		Spellmeyer\n");
	fprintf(fout,"12	  1.9080	  0.0860		Spellmeyer\n");
	fprintf(fout,"13	  1.9080	  0.0860		Spellmeyer\n");
	fprintf(fout,"15	  1.9080	  0.0860		Spellmeyer\n");
	fprintf(fout,"16	  1.9080	  0.0860		Spellmeyer\n");
	fprintf(fout,"11	  1.9080	  0.1094		Spellmeyer\n");
	fprintf(fout,"1	  1.9080	  0.0860		OPLS\n");
	fprintf(fout,"38	  1.8240	  0.1700		OPLS\n");
	fprintf(fout,"39	  1.8240	  0.1700		OPLS\n");
	fprintf(fout,"42	  1.8240	  0.1700		OPLS\n");
	fprintf(fout,"45	  1.8240	  0.1700		OPLS\n");
	fprintf(fout,"41	  1.8240	  0.1700		OPLS\n");
	fprintf(fout,"40	  1.8240	  0.1700		OPLS\n");
	fprintf(fout,"43	  1.8240	  0.1700		OPLS\n");
	fprintf(fout,"44	  1.8240	  0.1700		OPLS\n");
	fprintf(fout,"46	  1.8240	  0.1700		OPLS\n");
	fprintf(fout,"46	  1.8240	  0.1700		N in nitrile\n");
	fprintf(fout,"38	  1.8240	  0.1700		N in nitrile\n");
	fprintf(fout,"39	  1.8240	  0.1700		N in nitrile\n");
	fprintf(fout,"42	  1.8240	  0.1700		N in nitrile\n");
	fprintf(fout,"45	  1.8240	  0.1700		N in nitrile\n");
	fprintf(fout,"41	  1.8240	  0.1700		N in nitrile\n");
	fprintf(fout,"40	  1.8240	  0.1700		N in nitrile\n");
	fprintf(fout,"43	  1.8240	  0.1700		N in nitrile\n");
	fprintf(fout,"44	  1.8240	  0.1700		N in nitrile\n");
	fprintf(fout,"53	  2.0000	  0.2500		W. Cornell CH3SH and CH3SCH3 FEP's\n");
	fprintf(fout,"54	  2.0000	  0.2500		W. Cornell CH3SH and CH3SCH3 FEP's\n");
	fprintf(fout,"52	  2.1000	  0.2000		JCC,7,(1986),230; \n");
	fprintf(fout,"35	  2.4700	  0.1000		Cl- Smith & Dang, JCP 1994,100:5,3757\n");
	fprintf(fout,"57	  1.1370	  0.0183		Li+ Aqvist JPC 1990,94,8021. (adapted)\n");
	fprintf(fout,"58	  1.8680	  0.0028		Na+ Aqvist JPC 1990,94,8021. (adapted)\n");
	fprintf(fout,"59	  1.8680	  0.0028		Na+ Aqvist JPC 1990,94,8021. (adapted)\n");
	fprintf(fout,"60	  2.6580	  0.0003		K+  Aqvist JPC 1990,94,8021. (adapted)\n");
	fprintf(fout,"61	  2.9560	  0.0002		Rb+ Aqvist JPC 1990,94,8021. (adapted)\n");
	fprintf(fout,"62	  3.3950	  0.0001		Cs+ Aqvist JPC 1990,94,8021. (adapted)\n");
	fprintf(fout,"37	  0.7926	  0.8947		Mg2+ Aqvist JPC 1990,94,8021.(adapted)\n");
	fprintf(fout,"17	  1.7131	  0.4598		Ca2+ Aqvist JPC 1990,94,8021.(adapted)\n");
	fprintf(fout,"63	  1.1000	  0.0125		Zn2+, Merz,PAK, JACS,113,8262,(1991) \n");
	fprintf(fout,"31	  1.7500	  0.0610		Gough et al. JCC 13,(1992),963.\n");
	fprintf(fout,"32	  1.9480	  0.2650		Fox, JPCB,102,8070,(98),flex.mdl CHCl3\n");
	fprintf(fout,"33	  2.2200	  0.3200		Junmei(?)\n");
	fprintf(fout,"34	  2.3500	  0.4000		JCC,7,(1986),230;  \n");
	fprintf(fout,"36	  5.0000	  0.1000		solvated ion for vacuum approximation\n");
	fprintf(fout,"65          1.6600	  0.4674		Au\n");
	fprintf(fout,"66          1.7200	  0.3446		Ag\n");
	fprintf(fout,"67          1.6300	  11.9675		Ni\n");
	fprintf(fout,"End\n");
	fprintf(fout,"%s\n",pairWiseTitle);
	fprintf(fout,"64	64	10000.0	1.584	100.0	0.0	0.0	2.168\n");
	fprintf(fout,"End\n");
	fclose(fout);
	return TRUE;
}
File: ./cchemilib/src/MolecularMechanics/LoadMMParameters.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* LoadMMParameters.c */
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>

#include "../Utils/Utils.h"
#include "../Utils/AtomsProp.h"
#include "../Utils/Constants.h"
#include "../Utils/Types.h"
#include "../Molecule/Molecule.h"
#include "../MolecularMechanics/MolecularMechanics.h"

static char atomTypesTitle[]       = "Begin  INPUT FOR ATOM TYPES, MASSE AND POLARISABILITIES";
static char bondStretchTitle[]     = "Begin INPUT FOR BOND LENGTH PARAMETERS";
static char angleBendTitle[]       = "Begin INPUT FOR BOND ANGLE PARAMETERS";
static char strBendTitle[]       = "Begin INPUT FOR STRETCH-BEND PARAMETERS";
static char hydrogenBonded1012Title[]  = "Begin INPUT FOR H-BOND 10-12 POTENTIAL PARAMETERS";
static char hydrogenBondedMorseTitle[]  = "Begin INPUT FOR H-BOND MORSE POTENTIAL PARAMETERS";
static char suttonChenTitle[]      = "Begin INPUT FOR SUTTON-CHEN POTENTIAL PARAMETERS";
static char improperTorsionTitle[] ="Begin INPUT FOR IMPROPER DIHEDRAL PARAMETERS";
static char outOfPlaneTitle[]      ="Begin INPUT FOR OUT OF PLANE PARAMETERS";
static char vdw612Title[]       ="Begin INPUT FOR THE NON-BONDED 6-12 POTENTIAL PARAMETERS";
static char vdw714Title[]       ="Begin INPUT FOR THE NON-BONDED 7-14 POTENTIAL PARAMETERS";
static char dihedralAngleTitle[]   = "Begin INPUT FOR DIHEDRAL PARAMETERS";
static char pairWiseTitle[]        = "Begin INPUT FOR PAIR WISE PARAMETERS";
static char bondHardnessTitle[]    = "Begin INPUT FOR BOND HARDNESS PARAMETERS";

/**********************************************************************/
static boolean readAmberTypes(AmberParameters* amberParameters, FILE* file)
{
	char t[BSIZE];
	char dumpName[BSIZE];
	char dumpSymb[BSIZE];
	int len = BSIZE;
	boolean Ok = FALSE;
	int n = 0;
	int nt;
	AmberAtomTypes* types = NULL;
	/* Search Begin INPUT FOR  ATOM TYPES */ 

	rewind(file);
	while(!feof(file))
	{
		if(fgets(t,len,file))
		{
			if(strstr(t,atomTypesTitle))
			{
				Ok = TRUE;
				break;
			}
		}
	}
	if(!Ok)
		return FALSE;

	types = malloc(sizeof(AmberAtomTypes));
	n = 0;
	Ok = FALSE;
	while(!feof(file))
	{
		if(fgets(t,len,file))
		{
			if(strstr(t,"End") || strstr(t,"END"))
			{
				Ok = TRUE;
				break;
			}
		}
		else 
		{
			Ok = FALSE;
			break;
		}



		nt = sscanf(t,"%s %s %d %lf %lf %lf %lf %lf %lf",
			dumpName,
			dumpSymb,
			&types[n].number,
			&types[n].mass,
			&types[n].polarisability, &types[n].charge, &types[n].electronegativity, &types[n].hardness, &types[n].width);
		if(nt<9) types[n].width = 0.0;
		if(nt<8) types[n].hardness = 0.0;
		if(nt<7) types[n].electronegativity = 0.0;
		if(nt<6) types[n].charge = 0.0;
		if(nt<5) types[n].polarisability = 0.0;
		if(nt<4) types[n].mass = 1.0;

	      	types[n].name = strdup(dumpName);	
	      	types[n].symbol = strdup(dumpSymb);
		types[n].number--;

		n++;
		types = realloc(types,(n+1)*sizeof(AmberAtomTypes));
	}
	if(n==0 || !Ok )
		free(types);
	else
	{
		amberParameters->numberOfTypes = n;
		amberParameters->atomTypes = types;
	}
	/* printing for test*/
	/*
	printf("umber of types = %d \n",amberParameters->numberOfTypes);
	for(n=0;n<amberParameters->numberOfTypes;n++)
	{
		printf("%s\t %d\t",
				amberParameters->atomTypes[n].name,
				amberParameters->atomTypes[n].number
				);
	}
	printf("\n");
	*/

	return TRUE;
			

}
/**********************************************************************/
static boolean readAmberBondStretchTerms(AmberParameters* amberParameters,FILE* file)
{
	char t[BSIZE];
	int len = BSIZE;
	boolean Ok = FALSE;
	int n = 0;
	AmberBondStretchTerms* terms = NULL;
	int nt = 0;

	/* Search Begin INPUT FOR  ATOM TYPES */ 

	rewind(file);
	while(!feof(file))
	{
		if(fgets(t,len,file))
		{
			if(strstr(t,bondStretchTitle))
			{
				Ok = TRUE;
				break;
			}
		}
	}
	if(!Ok)
		return FALSE;

	terms = malloc(sizeof(AmberBondStretchTerms));
	n = 0;
	Ok = FALSE;
	while(!feof(file))
	{
		if(fgets(t,len,file))
		{
			if(strstr(t,"End") || strstr(t,"END"))
			{
				Ok = TRUE;
				break;
			}
		}
		else 
		{
			Ok = FALSE;
			break;
		}

		// add anharmonic terms
		//sscanf(t,"%d %d %lf %lf", &terms[n].numbers[0], &terms[n].numbers[1], &terms[n].forceConstant, &terms[n].equilibriumDistance);
		terms[n].h3 = 0;
		terms[n].h4 = 0;
		terms[n].h5 = 0;
		terms[n].h6 = 0;
		nt = sscanf(t,"%d %d %lf %lf %lf %lf %lf %lf", &terms[n].numbers[0], &terms[n].numbers[1], 
				&terms[n].forceConstant, &terms[n].equilibriumDistance,
				&terms[n].h3, &terms[n].h4,
				&terms[n].h5, &terms[n].h6
				);
		if(nt<8) terms[n].h6 = 0;
		if(nt<7) terms[n].h5 = 0;
		if(nt<6) terms[n].h4 = 0;
		if(nt<5) terms[n].h3 = 0;
		terms[n].type = 0;// harmonic
		uppercase(t);
		if(strstr(t,"MORSE")) terms[n].type = 1;//Morse, h3 = De in kcal/mol
		if( terms[n].type ==1 && fabs(terms[n].h3)<1e-13)
		{
			fprintf(stderr,"===================================================================\n");
			fprintf(stderr,"Error in Molecular mechanics parameters file : De = 0 for Morse type \n");
			fprintf(stderr,"Check Strech terms  for type numbers : %d %d \n",terms[n].numbers[0],terms[n].numbers[1]);
			fprintf(stderr,"===================================================================\n");
			exit(1);
		}

	      	terms[n].numbers[0]--;
	      	terms[n].numbers[1]--;
		if(terms[n].numbers[0]>terms[n].numbers[1])
		{
			int t = terms[n].numbers[0];
			terms[n].numbers[0] = terms[n].numbers[1];
			terms[n].numbers[1] = t;
		}

		n++;
		terms = realloc(terms,(n+1)*sizeof(AmberBondStretchTerms));
	}
	if(n==0 || !Ok )
		free(terms);
	else
	{
		amberParameters->numberOfStretchTerms = n;
		amberParameters->bondStretchTerms = terms;
	}
	/* printing for test*/
	/*
	printf("number of bonds = %d \n",amberParameters->numberOfStretchTerms);
	for(n=0;n<amberParameters->numberOfStretchTerms;n++)
	{
		printf("%d %d %f %f\n",
				amberParameters->bondStretchTerms[n].numbers[0],
				amberParameters->bondStretchTerms[n].numbers[1],
				amberParameters->bondStretchTerms[n].forceConstant,
				amberParameters->bondStretchTerms[n].equilibriumDistance
				);
	}
	printf("\n");
	*/

	return TRUE;
			

}
/**********************************************************************/
static boolean readAmberAngleBendTerms(AmberParameters* amberParameters,FILE* file)
{
	char t[BSIZE];
	int len = BSIZE;
	boolean Ok = FALSE;
	int n = 0;
	AmberAngleBendTerms* terms = NULL;
	int nt = 0;

	/* Search Begin INPUT FOR  ATOM TYPES */ 

	rewind(file);
	while(!feof(file))
	{
		if(fgets(t,len,file))
		{
			if(strstr(t,angleBendTitle))
			{
				Ok = TRUE;
				break;
			}
		}
	}
	if(!Ok)
		return FALSE;

	terms = malloc(sizeof(AmberAngleBendTerms));
	n = 0;
	Ok = FALSE;
	while(!feof(file))
	{
		if(fgets(t,len,file))
		{
			if(strstr(t,"End") || strstr(t,"END"))
			{
				Ok = TRUE;
				break;
			}
		}
		else 
		{
			Ok = FALSE;
			break;
		}

		// ad anharmonic
		//sscanf(t,"%d %d %d %lf %lf", &terms[n].numbers[0], &terms[n].numbers[1], &terms[n].numbers[2], &terms[n].forceConstant, &terms[n].equilibriumAngle);
                terms[n].h3 = 0;
                terms[n].h4 = 0;
                terms[n].h5 = 0;
                terms[n].h6 = 0;
                nt = sscanf(t,"%d %d %d %lf %lf %lf %lf %lf %lf", &terms[n].numbers[0], &terms[n].numbers[1], &terms[n].numbers[2],
                                &terms[n].forceConstant, &terms[n].equilibriumAngle,
                                &terms[n].h3, &terms[n].h4,
                                &terms[n].h5, &terms[n].h6
                                );
		if(nt<9) terms[n].h6 = 0;
		if(nt<8) terms[n].h5 = 0;
		if(nt<7) terms[n].h4 = 0;
		if(nt<6) terms[n].h3 = 0;

		terms[n].numbers[0]--;
		terms[n].numbers[1]--;
		terms[n].numbers[2]--;
		if(terms[n].numbers[0]>terms[n].numbers[2])
		{
			int t = terms[n].numbers[0];
			terms[n].numbers[0] = terms[n].numbers[2];
			terms[n].numbers[2] = t;
		}
		

		n++;
		terms = realloc(terms,(n+1)*sizeof(AmberAngleBendTerms));
	}
	if(n==0 || !Ok )
		free(terms);
	else
	{
		amberParameters->numberOfBendTerms = n;
		amberParameters->angleBendTerms = terms;
	}
	/* printing for test*/
	/*
	printf("number of bonds = %d \n",amberParameters->numberOfBendTerms);
	for(n=0;n<amberParameters->numberOfBendTerms;n++)
	{
		printf("%d %d %d %f %f\n",
				amberParameters->angleBendTerms[n].numbers[0],
				amberParameters->angleBendTerms[n].numbers[1],
				amberParameters->angleBendTerms[n].numbers[2],
				amberParameters->angleBendTerms[n].forceConstant,
				amberParameters->angleBendTerms[n].equilibriumAngle
				);
	}
	printf("\n");
	*/

	return TRUE;
			

}
/**********************************************************************/
static boolean readAmberStrBendTerms(AmberParameters* amberParameters,FILE* file)
{
	char t[BSIZE];
	int len = BSIZE;
	boolean Ok = FALSE;
	int n = 0;
	AmberStrBendTerms* terms = NULL;
	int nt = 0;

	/* Begin INPUT FOR STRETCH-BEND PARAMETER */ 

	rewind(file);
	while(!feof(file))
	{
		if(fgets(t,len,file))
		{
			if(strstr(t,strBendTitle))
			{
				Ok = TRUE;
				break;
			}
		}
	}
	if(!Ok)
		return FALSE;

	terms = malloc(sizeof(AmberStrBendTerms));
	n = 0;
	Ok = FALSE;
	while(!feof(file))
	{
		if(fgets(t,len,file))
		{
			if(strstr(t,"End") || strstr(t,"END"))
			{
				Ok = TRUE;
				break;
			}
		}
		else 
		{
			Ok = FALSE;
			break;
		}

                nt = sscanf(t,"%d %d %d %lf %lf", &terms[n].numbers[0], &terms[n].numbers[1], &terms[n].numbers[2],
                                &terms[n].forceConstant12, &terms[n].forceConstant23
                                );
		if(nt<5) terms[n].forceConstant23 = terms[n].forceConstant12;

		terms[n].numbers[0]--;
		terms[n].numbers[1]--;
		terms[n].numbers[2]--;
		if(terms[n].numbers[0]>terms[n].numbers[2])
		{
			int t = terms[n].numbers[0];
			terms[n].numbers[0] = terms[n].numbers[2];
			terms[n].numbers[2] = t;
		}
		

		n++;
		terms = realloc(terms,(n+1)*sizeof(AmberStrBendTerms));
	}
	if(n==0 || !Ok )
		free(terms);
	else
	{
		amberParameters->numberOfStrBendTerms = n;
		amberParameters->strBendTerms = terms;
	}
	/* printing for test*/
	
	/*
	printf("number of bonds = %d \n",amberParameters->numberOfStrBendTerms);
	for(n=0;n<amberParameters->numberOfStrBendTerms;n++)
	{
		printf("%d %d %d %f %f\n",
				amberParameters->strBendTerms[n].numbers[0],
				amberParameters->strBendTerms[n].numbers[1],
				amberParameters->strBendTerms[n].numbers[2],
				amberParameters->strBendTerms[n].forceConstant12,
				amberParameters->strBendTerms[n].forceConstant23
				);
	}
	printf("\n");
	*/
	
	return TRUE;
}
/**********************************************************************/
static boolean readAmberDihedralAngleTerms(AmberParameters* amberParameters,FILE* file)
{
	char t[BSIZE];
	int len = BSIZE;
	boolean Ok = FALSE;
	int n = 0;
	AmberDihedralAngleTerms* terms = NULL;
	double divisor = 1;
	double barrier = 0;
	double phase = 0;
	double nN = 0;
	int d;

	/* Search Begin INPUT FOR  DIHEDRAL PARAMETERS */

	rewind(file);
	while(!feof(file))
	{
		if(fgets(t,len,file))
		{
			if(strstr(t,dihedralAngleTitle))
			{
				Ok = TRUE;
				break;
			}
		}
	}
	if(!Ok)
		return FALSE;

	terms = malloc(sizeof(AmberDihedralAngleTerms));

	n = 0;
	Ok = FALSE;
	while(!feof(file))
	{
		if(fgets(t,len,file))
		{
			if(strstr(t,"End") || strstr(t,"END"))
			{
				Ok = TRUE;
				break;
			}
		}
		else 
		{
			Ok = FALSE;
			break;
		}

		terms[n].nSomme = 1;
		terms[n].divisor = malloc(sizeof(double));
		terms[n].barrier = malloc(sizeof(double));
		terms[n].phase   = malloc(sizeof(double));
		terms[n].n       = malloc(sizeof(double));

		sscanf(t,"%d %d %d %d %lf %lf %lf %lf",
			&terms[n].numbers[0],
			&terms[n].numbers[1],
			&terms[n].numbers[2],
			&terms[n].numbers[3],
			&divisor,
			&barrier,
			&phase,
			&nN);

		terms[n].divisor[0] = divisor;
		terms[n].barrier[0] = barrier;
		terms[n].phase[0]   = phase;
		terms[n].n[0]       = fabs(nN);

	    terms[n].numbers[0]--;
	    terms[n].numbers[1]--;
	    terms[n].numbers[2]--;
	    terms[n].numbers[3]--;

	    if(terms[n].numbers[0]>terms[n].numbers[3])
	    {
		int t = terms[n].numbers[0];
		terms[n].numbers[0] = terms[n].numbers[3];
		terms[n].numbers[3] = t;

		t =  terms[n].numbers[1];
		terms[n].numbers[1] = terms[n].numbers[2];
		terms[n].numbers[2] = t;
	     }

		Ok = TRUE;
		while(!feof(file) && nN<0)
		{
			if(!fgets(t,len,file))
			{
				Ok = FALSE;
				break;
			}

			terms[n].nSomme++;
			terms[n].divisor = realloc(terms[n].divisor,terms[n].nSomme*sizeof(double));
			terms[n].barrier = realloc(terms[n].barrier,terms[n].nSomme*sizeof(double));
			terms[n].phase   = realloc(terms[n].phase,terms[n].nSomme*sizeof(double));
			terms[n].n       = realloc(terms[n].n,terms[n].nSomme*sizeof(double));

			sscanf(t,"%d %d %d %d %lf %lf %lf %lf",
					  &d,&d,&d,&d,
					  &divisor,&barrier,&phase,&nN);

			terms[n].divisor[terms[n].nSomme-1] = divisor;
			terms[n].barrier[terms[n].nSomme-1] = barrier;
			terms[n].phase[terms[n].nSomme-1]   = phase;
			terms[n].n[terms[n].nSomme-1]       = fabs(nN);
		}
		if(!Ok)
			break;
		n++;
		terms = realloc(terms,(n+1)*sizeof(AmberDihedralAngleTerms));
	}
	if(n==0 || !Ok )
		free(terms);
	else
	{
		amberParameters->numberOfDihedralTerms = n;
		amberParameters->dihedralAngleTerms = terms;
	}
	/* printing for test*/
	/*	
	printf("number of dihedral torsion terms = %d \n",
			amberParameters->numberOfDihedralTerms);

	for(n=0;n<amberParameters->numberOfDihedralTerms;n++)
	{
		int j;
		printf("%d %d %d %d \t",
				amberParameters->dihedralAngleTerms[n].numbers[0],
				amberParameters->dihedralAngleTerms[n].numbers[1],
				amberParameters->dihedralAngleTerms[n].numbers[2],
				amberParameters->dihedralAngleTerms[n].numbers[3]
			);
		for(j=0;j<amberParameters->dihedralAngleTerms[n].nSomme;j++)
		{
			printf("%f %f %f %f\t",
				amberParameters->dihedralAngleTerms[n].divisor[j],
				amberParameters->dihedralAngleTerms[n].barrier[j],
				amberParameters->dihedralAngleTerms[n].phase[j],
				amberParameters->dihedralAngleTerms[n].n[j]
				);
		}
		printf("\n");
	}
	printf("\n");
	*/	

	return TRUE;
			

}
/**********************************************************************/
static boolean readAmberImproperTorsionTerms(AmberParameters* amberParameters,FILE* file)
{
	char t[BSIZE];
	int len = BSIZE;
	boolean Ok = FALSE;
	int n = 0;
	AmberImproperTorsionTerms* terms = NULL;

	/* Search Begin INPUT FOR  ATOM TYPES */ 

	rewind(file);
	while(!feof(file))
	{
		if(fgets(t,len,file))
		{
			if(strstr(t,improperTorsionTitle))
			{
				Ok = TRUE;
				break;
			}
		}
	}
	if(!Ok)
		return FALSE;

	terms = malloc(sizeof(AmberImproperTorsionTerms));
	n = 0;
	Ok = FALSE;
	while(!feof(file))
	{
		if(fgets(t,len,file))
		{
			if(strstr(t,"End") || strstr(t,"END"))
			{
				Ok = TRUE;
				break;
			}
		}
		else 
		{
			Ok = FALSE;
			break;
		}



		sscanf(t,"%d %d %d %d %lf %lf %lf",
			&terms[n].numbers[0],
			&terms[n].numbers[1],
			&terms[n].numbers[2],
			&terms[n].numbers[3],
			&terms[n].barrier,
			&terms[n].phase,
			&terms[n].n);

	    terms[n].numbers[0]--;
	    terms[n].numbers[1]--;
	    terms[n].numbers[2]--;
	    terms[n].numbers[3]--;
	    if(terms[n].numbers[0]>terms[n].numbers[3])
	    {
		int t = terms[n].numbers[0];
		terms[n].numbers[0] = terms[n].numbers[3];
		terms[n].numbers[3] = t;

		t =  terms[n].numbers[1];
		terms[n].numbers[1] = terms[n].numbers[2];
		terms[n].numbers[2] = t;
	    }

		n++;
		terms = realloc(terms,(n+1)*sizeof(AmberImproperTorsionTerms));
	}
	if(n==0 || !Ok )
		free(terms);
	else
	{
		amberParameters->numberOfImproperTorsionTerms = n;
		amberParameters->improperTorsionTerms = terms;
	}
	/* printing for test*/
	/*
	printf("number of improper torsion terms = %d \n",
			amberParameters->numberOfImproperTorsionTerms);

	for(n=0;n<amberParameters->numberOfImproperTorsionTerms;n++)
	{
		printf("%d %d %d %d %f %f %f\n",
				amberParameters->improperTorsionTerms[n].numbers[0],
				amberParameters->improperTorsionTerms[n].numbers[1],
				amberParameters->improperTorsionTerms[n].numbers[2],
				amberParameters->improperTorsionTerms[n].numbers[3],
				amberParameters->improperTorsionTerms[n].barrier,
				amberParameters->improperTorsionTerms[n].phase,
				amberParameters->improperTorsionTerms[n].n
				);
	}
	printf("\n");
	*/

	return TRUE;
			

}
/**********************************************************************/
static boolean readAmberOutOfPlaneTerms(AmberParameters* amberParameters,FILE* file)
{
	char t[BSIZE];
	int len = BSIZE;
	boolean Ok = FALSE;
	int n = 0;
	AmberOutOfPlaneTerms* terms = NULL;
	int nt = 0;

	/* Search Begin INPUT FOR OUT OF PLANE PARAMETERS */ 

	rewind(file);
	while(!feof(file))
	{
		if(fgets(t,len,file))
		{
			if(strstr(t,outOfPlaneTitle))
			{
				Ok = TRUE;
				break;
			}
		}
	}
	if(!Ok)
		return FALSE;

	terms = malloc(sizeof(AmberOutOfPlaneTerms));
	n = 0;
	Ok = FALSE;
	while(!feof(file))
	{
		if(fgets(t,len,file))
		{
			if(strstr(t,"End") || strstr(t,"END"))
			{
				Ok = TRUE;
				break;
			}
		}
		else 
		{
			Ok = FALSE;
			break;
		}



		terms[n].h3 = 0.0;
		terms[n].h4 = 0.0;
		terms[n].h5 = 0.0;
		terms[n].h6 = 0.0;
		nt = sscanf(t,"%d %d %d %d %lf %lf %lf %lf %lf",
			&terms[n].numbers[0],
			&terms[n].numbers[1],
			&terms[n].numbers[2],
			&terms[n].numbers[3],
			&terms[n].force,
			&terms[n].h3,
			&terms[n].h4,
			&terms[n].h5,
			&terms[n].h6);
		if(nt<9) terms[n].h6 = 0.0;
		if(nt<8) terms[n].h5 = 0.0;
		if(nt<7) terms[n].h4 = 0.0;
		if(nt<6) terms[n].h3 = 0.0;
		terms[n].type = 0;
		if(strstr(t,"W-D-C") || strstr(t,"Cross")) terms[n].type = 1;

	    terms[n].numbers[0]--;
	    terms[n].numbers[1]--;
	    terms[n].numbers[2]--;
	    terms[n].numbers[3]--;
	/*
	    if(terms[n].numbers[0]>terms[n].numbers[3])
	    {
		int t = terms[n].numbers[0];
		terms[n].numbers[0] = terms[n].numbers[3];
		terms[n].numbers[3] = t;

		t =  terms[n].numbers[1];
		terms[n].numbers[1] = terms[n].numbers[2];
		terms[n].numbers[2] = t;
	    }
	*/

		n++;
		terms = realloc(terms,(n+1)*sizeof(AmberOutOfPlaneTerms));
	}
	if(n==0 || !Ok ) free(terms);
	else
	{
		amberParameters->numberOfOutOfPlaneTerms = n;
		amberParameters->outOfPlaneTerms = terms;
	}
	/* printing for test*/
	/*
	printf("number of improper torsion terms = %d \n",
			amberParameters->numberOfOutOfPlaneTerms);

	for(n=0;n<amberParameters->numberOfOutOfPlaneTerms;n++)
	{
		printf("%d %d %d %d %f %f %f\n",
				amberParameters->outOfPlaneTerms[n].numbers[0],
				amberParameters->outOfPlaneTerms[n].numbers[1],
				amberParameters->outOfPlaneTerms[n].numbers[2],
				amberParameters->outOfPlaneTerms[n].numbers[3],
				amberParameters->outOfPlaneTerms[n].barrier,
				amberParameters->outOfPlaneTerms[n].phase,
				amberParameters->outOfPlaneTerms[n].n
				);
	}
	printf("\n");
	*/

	return TRUE;
			

}
/**********************************************************************/
static boolean readAmberHydrogenBonded1012Terms(AmberParameters* amberParameters,FILE* file)
{
	char t[BSIZE];
	int len = BSIZE;
	boolean Ok = FALSE;
	int n = 0;
	AmberHydrogenBonded1012Terms* terms = NULL;

	/* Search Begin INPUT FOR  ATOM TYPES */ 

	rewind(file);
	while(!feof(file))
	{
		if(fgets(t,len,file))
		{
			if(strstr(t,hydrogenBonded1012Title))
			{
				Ok = TRUE;
				break;
			}
		}
	}
	if(!Ok)
		return FALSE;

	terms = malloc(sizeof(AmberHydrogenBonded1012Terms));
	n = 0;
	Ok = FALSE;
	while(!feof(file))
	{
		if(fgets(t,len,file))
		{
			if(strstr(t,"End") || strstr(t,"END"))
			{
				Ok = TRUE;
				break;
			}
		}
		else 
		{
			Ok = FALSE;
			break;
		}

		sscanf(t,"%d %d %lf %lf",
				&terms[n].numbers[0],
				&terms[n].numbers[1],
				&terms[n].c,
				&terms[n].d);

		terms[n].numbers[0]--;
		terms[n].numbers[1]--;
		if(terms[n].numbers[0]>terms[n].numbers[1])
		{
			int t = terms[n].numbers[0];
			terms[n].numbers[0] = terms[n].numbers[1];
			terms[n].numbers[1] = t;
		}

		n++;
		terms = realloc(terms,(n+1)*sizeof(AmberHydrogenBonded1012Terms));
	}
	if(n==0 || !Ok )
		free(terms);
	else
	{
		amberParameters->numberOfHydrogenBonded1012 = n;
		amberParameters->hydrogenBonded1012Terms = terms;
	}
	/* printing for test*/
	/*
	printf("number of hydrogen bonds terms = %d \n",amberParameters->numberOfHydrogenBonded1012);
	for(n=0;n<amberParameters->numberOfHydrogenBonded1012;n++)
	{
		printf("%d %d %f %f\n",
				amberParameters->hydrogenBonded1012Terms[n].numbers[0],
				amberParameters->hydrogenBonded1012Terms[n].numbers[1],
				amberParameters->hydrogenBonded1012Terms[n].c,
				amberParameters->hydrogenBonded1012Terms[n].d
				);
	}
	printf("\n");
	*/

	return TRUE;
			

}
/**********************************************************************/
static boolean readAmberHydrogenBondedMorseTerms(AmberParameters* amberParameters,FILE* file)
{
	char t[BSIZE];
	int len = BSIZE;
	boolean Ok = FALSE;
	int n = 0;
	AmberHydrogenBondedMorseTerms* terms = NULL;

	/* Search Begin INPUT FOR  ATOM TYPES */ 

	rewind(file);
	while(!feof(file))
	{
		if(fgets(t,len,file))
		{
			if(strstr(t,hydrogenBondedMorseTitle))
			{
				Ok = TRUE;
				break;
			}
		}
	}
	if(!Ok)
		return FALSE;

	terms = malloc(sizeof(AmberHydrogenBondedMorseTerms));
	n = 0;
	Ok = FALSE;
	while(!feof(file))
	{
		if(fgets(t,len,file))
		{
			if(strstr(t,"End") || strstr(t,"END"))
			{
				Ok = TRUE;
				break;
			}
		}
		else 
		{
			Ok = FALSE;
			break;
		}

		sscanf(t,"%d %d %lf %lf %lf",
				&terms[n].numbers[0],
				&terms[n].numbers[1],
				&terms[n].force,
				&terms[n].Re,
				&terms[n].De
				);

		terms[n].numbers[0]--;
		terms[n].numbers[1]--;
		if(terms[n].numbers[0]>terms[n].numbers[1])
		{
			int t = terms[n].numbers[0];
			terms[n].numbers[0] = terms[n].numbers[1];
			terms[n].numbers[1] = t;
		}

		n++;
		terms = realloc(terms,(n+1)*sizeof(AmberHydrogenBondedMorseTerms));
	}
	if(n==0 || !Ok )
		free(terms);
	else
	{
		amberParameters->numberOfHydrogenBondedMorse = n;
		amberParameters->hydrogenBondedMorseTerms = terms;
	}
	/* printing for test*/
	/*
	printf("number of hydrogen bonds terms = %d \n",amberParameters->numberOfHydrogenBondedMorse);
	for(n=0;n<amberParameters->numberOfHydrogenBondedMorse;n++)
	{
		printf("%d %d %f %f %f\n",
				amberParameters->hydrogenBondedMorseTerms[n].numbers[0],
				amberParameters->hydrogenBondedMorseTerms[n].numbers[1],
				amberParameters->hydrogenBondedMorseTerms[n].force,
				amberParameters->hydrogenBondedMorseTerms[n].Re,
				amberParameters->hydrogenBondedMorseTerms[n].De,
				);
	}
	printf("\n");
	*/

	return TRUE;
			

}
/**********************************************************************/
static boolean readAmberSuttonChenTerms(AmberParameters* amberParameters,FILE* file)
{
	char t[BSIZE];
	int len = BSIZE;
	boolean Ok = FALSE;
	int n = 0;
	AmberSuttonChenTerms* terms = NULL;

	rewind(file);
	while(!feof(file))
	{
		if(fgets(t,len,file))
		{
			if(strstr(t,suttonChenTitle))
			{
				Ok = TRUE;
				break;
			}
		}
	}
	if(!Ok)
		return FALSE;

	terms = malloc(sizeof(AmberSuttonChenTerms));
	n = 0;
	Ok = FALSE;
	while(!feof(file))
	{
		if(fgets(t,len,file))
		{
			if(strstr(t,"End") || strstr(t,"END"))
			{
				Ok = TRUE;
				break;
			}
		}
		else 
		{
			Ok = FALSE;
			break;
		}

		sscanf(t,"%d %d %lf %lf %lf %lf %lf",
				&terms[n].numbers[0],
				&terms[n].numbers[1],
				&terms[n].epsilon,
				&terms[n].a,
				&terms[n].C,
				&terms[n].n,
				&terms[n].m
				);

		terms[n].numbers[0]--;
		terms[n].numbers[1]--;
		if(terms[n].numbers[0]>terms[n].numbers[1])
		{
			int t = terms[n].numbers[0];
			terms[n].numbers[0] = terms[n].numbers[1];
			terms[n].numbers[1] = t;
		}

		n++;
		terms = realloc(terms,(n+1)*sizeof(AmberSuttonChenTerms));
	}
	if(n==0 || !Ok )
		free(terms);
	else
	{
		amberParameters->numberOfSuttonChen = n;
		amberParameters->suttonChenTerms = terms;
	}
	/* printing for test*/
	/*
	printf("number of Sutton Chen terms = %d \n",amberParameters->numberOfSuttonChen);
	for(n=0;n<amberParameters->numberOfSuttonChen;n++)
	{
		printf("%d %d %f %f\n",
				amberParameters->suttonChenTerms[n].numbers[0],
				amberParameters->suttonChenTerms[n].numbers[1],
				amberParameters->suttonChenTerms[n].c,
				amberParameters->suttonChenTerms[n].d
				);
	}
	printf("\n");
	*/

	return TRUE;
			

}
/**********************************************************************/
static boolean readAmberVdw612Terms(AmberParameters* amberParameters,FILE* file)
{
	char t[BSIZE];
	int len = BSIZE;
	boolean Ok = FALSE;
	int n = 0;
	AmberVdw612Terms* terms = NULL;

	/* Search Begin INPUT FOR  NON-BONDED  */ 
	Ok = FALSE;
	rewind(file);
	while(!feof(file))
	{
		if(fgets(t,len,file))
		{
			if(strstr(t,vdw612Title))
			{
				Ok = TRUE;
				break;
			}
		}
	}
	if(!Ok)
		return FALSE;

	terms = malloc(sizeof(AmberVdw612Terms));
	n = 0;
	Ok = FALSE;
	while(!feof(file))
	{
		if(fgets(t,len,file))
		{
			if(strstr(t,"End") || strstr(t,"END"))
			{
				Ok = TRUE;
				break;
			}
		}
		else 
		{
			Ok = FALSE;
			break;
		}

		sscanf(t,"%d %lf %lf",
			&terms[n].number,
			&terms[n].r,
			&terms[n].epsilon);
		//printf("t=%s\n",t);
		
		terms[n].number--;
		n++;
		terms = realloc(terms,(n+1)*sizeof(AmberVdw612Terms));
	}

	if(n==0 || !Ok )
		free(terms);
	else
	{
		amberParameters->numberOfVdw612 = n;
		amberParameters->vdw612Terms = terms;
	}
	/* printing for test*/
	/*
	printf("number of non bended terms = %d \n",amberParameters->numberOfVdw612);
	for(n=0;n<amberParameters->numberOfVdw612;n++)
	{
		printf("%d %f %f\n",
				amberParameters->vdw612Terms[n].number,
				amberParameters->vdw612Terms[n].r,
				amberParameters->vdw612Terms[n].epsilon
				);
	}
	printf("\n");
	*/

	return TRUE;
			

}
/**********************************************************************/
static boolean readAmberVdw714Terms(AmberParameters* amberParameters,FILE* file)
{
	char t[BSIZE];
	int len = BSIZE;
	boolean Ok = FALSE;
	int n = 0;
	AmberVdw714Terms* terms = NULL;
	int nt = 0;

	/* Search Begin INPUT FOR  NON-BONDED 7-14  */ 
	Ok = FALSE;
	rewind(file);
	while(!feof(file))
	{
		if(fgets(t,len,file))
		{
			if(strstr(t,vdw714Title))
			{
				Ok = TRUE;
				break;
			}
		}
	}
	if(!Ok)
		return FALSE;

	terms = malloc(sizeof(AmberVdw714Terms));
	n = 0;
	Ok = FALSE;
	while(!feof(file))
	{
		if(fgets(t,len,file))
		{
			if(strstr(t,"End") || strstr(t,"END"))
			{
				Ok = TRUE;
				break;
			}
		}
		else 
		{
			Ok = FALSE;
			break;
		}

		nt = sscanf(t,"%d %lf %lf %lf %lf", &terms[n].number, &terms[n].r, &terms[n].epsilon, &terms[n].gamma, &terms[n].delta);
		if(nt<5) terms[n].delta = 0.07/2.0;
		if(nt<4) terms[n].gamma = 0.12/2.0;
		//printf("t=%s\n",t);
		
		terms[n].number--;
		n++;
		terms = realloc(terms,(n+1)*sizeof(AmberVdw714Terms));
	}

	if(n==0 || !Ok )
		free(terms);
	else
	{
		amberParameters->numberOfVdw714 = n;
		amberParameters->vdw714Terms = terms;
	}
	/* printing for test*/
	/*
	printf("number of non bended terms = %d \n",amberParameters->numberOfVdw714);
	for(n=0;n<amberParameters->numberOfVdw714;n++)
	{
		printf("%d %f %f\n",
				amberParameters->vdw714Terms[n].number,
				amberParameters->vdw714Terms[n].r,
				amberParameters->vdw714Terms[n].epsilon,
				amberParameters->vdw714Terms[n].gamma,
				amberParameters->vdw714Terms[n].delta
				);
	}
	printf("\n");
	*/

	return TRUE;
			

}
/**********************************************************************/
static boolean readAmberPairWiseTerms(AmberParameters* amberParameters,FILE* file)
{
	char t[BSIZE];
	int len = BSIZE;
	boolean Ok = FALSE;
	int n = 0;
	AmberPairWiseTerms* terms = NULL;

	/* Search Begin INPUT FOR PAIR WIZE  */ 
	Ok = FALSE;
	rewind(file);
	while(!feof(file))
	{
		if(fgets(t,len,file))
		{
			if(strstr(t,pairWiseTitle))
			{
				Ok = TRUE;
				break;
			}
		}
	}
	if(!Ok)
		return FALSE;

	terms = malloc(sizeof(AmberPairWiseTerms));
	n = 0;
	Ok = FALSE;
	while(!feof(file))
	{
		if(fgets(t,len,file))
		{
			if(strstr(t,"End") || strstr(t,"END"))
			{
				Ok = TRUE;
				break;
			}
		}
		else 
		{
			Ok = FALSE;
			break;
		}



		sscanf(t,"%d %d %lf %lf %lf %lf %lf %lf %lf",
			&terms[n].numbers[0],
			&terms[n].numbers[1],
			&terms[n].a,
			&terms[n].beta,
			&terms[n].c4,
			&terms[n].c6,
			&terms[n].c8,
			&terms[n].c10,
			&terms[n].b
			);
		
		terms[n].numbers[0]--;
		terms[n].numbers[1]--;
		n++;
		terms = realloc(terms,(n+1)*sizeof(AmberPairWiseTerms));
	}

	if(n==0 || !Ok )
		free(terms);
	else
	{
		amberParameters->numberOfPairWise = n;
		amberParameters->pairWiseTerms = terms;
	}
	/* printing for test*/
	/*
	printf("number of pair wise terms = %d \n",amberParameters->numberOfPairWise);
	for(n=0;n<amberParameters->numberOfPairWise;n++)
	{
		printf("%d %d %f %f %f %f %d\n",
				amberParameters->pairWiseTerms[n].numbers[0],
				amberParameters->pairWiseTerms[n].numbers[1],
				amberParameters->pairWiseTerms[n].a,
				amberParameters->pairWiseTerms[n].beta,
				amberParameters->pairWiseTerms[n].c6,
				amberParameters->pairWiseTerms[n].c8,
				amberParameters->pairWiseTerms[n].c10,
				amberParameters->pairWiseTerms[n].b,
				);
	}
	printf("\n");
	*/

	return TRUE;
			

}
/**********************************************************************/
static boolean readAmberBondHardnessTerms(AmberParameters* amberParameters,FILE* file)
{
	char t[BSIZE];
	int len = BSIZE;
	boolean Ok = FALSE;
	int n = 0;
	AmberBondHardnessTerms* terms = NULL;
	//int nt = 0;

	//printf("readAmberBondHardnessTerms\n");
	rewind(file);
	while(!feof(file))
	{
		if(fgets(t,len,file))
		{
			if(strstr(t,bondHardnessTitle))
			{
				Ok = TRUE;
				break;
			}
		}
	}
	if(!Ok)
		return FALSE;

	terms = malloc(sizeof(AmberBondHardnessTerms));
	n = 0;
	Ok = FALSE;
	while(!feof(file))
	{
		if(fgets(t,len,file))
		{
			if(strstr(t,"End") || strstr(t,"END"))
			{
				Ok = TRUE;
				break;
			}
		}
		else 
		{
			Ok = FALSE;
			break;
		}

		//nt = sscanf(t,"%d %d %lf", &terms[n].numbers[0], &terms[n].numbers[1], &terms[n].kappa);
		sscanf(t,"%d %d %lf", &terms[n].numbers[0], &terms[n].numbers[1], &terms[n].kappa);

	      	terms[n].numbers[0]--;
	      	terms[n].numbers[1]--;
		if(terms[n].numbers[0]>terms[n].numbers[1])
		{
			int t = terms[n].numbers[0];
			terms[n].numbers[0] = terms[n].numbers[1];
			terms[n].numbers[1] = t;
		}
		n++;
		terms = realloc(terms,(n+1)*sizeof(AmberBondHardnessTerms));
	}
	if(n==0 || !Ok )
		free(terms);
	else
	{
		amberParameters->numberOfHardnessTerms = n;
		amberParameters->bondHardnessTerms = terms;
	}
	/* printing for test*/
	
	/*
	printf("number of bonds = %d \n",amberParameters->numberOfHardnessTerms);
	for(n=0;n<amberParameters->numberOfHardnessTerms;n++)
	{
		printf("%d %d %f\n",
				amberParameters->bondHardnessTerms[n].numbers[0],
				amberParameters->bondHardnessTerms[n].numbers[1],
				amberParameters->bondHardnessTerms[n].kappa
				);
	}
	printf("\n");
	*/


	return TRUE;
			

}
/**********************************************************************/
boolean readAmberParameters(AmberParameters* amberParameters,char* filename)
{
	FILE* file;
	file = fopen(filename,"r");

	if(file == NULL)
		return FALSE;
	else
	{
		readAmberTypes(amberParameters,file);
		readAmberBondStretchTerms(amberParameters,file);
		readAmberAngleBendTerms(amberParameters,file);
		readAmberStrBendTerms(amberParameters,file);
		readAmberDihedralAngleTerms(amberParameters,file);
		readAmberImproperTorsionTerms(amberParameters,file);
		readAmberOutOfPlaneTerms(amberParameters,file);
		readAmberHydrogenBonded1012Terms(amberParameters,file);
		readAmberHydrogenBondedMorseTerms(amberParameters,file);
		readAmberSuttonChenTerms(amberParameters,file);
		readAmberVdw612Terms(amberParameters,file);
		readAmberVdw714Terms(amberParameters,file);
		readAmberPairWiseTerms(amberParameters,file);
		readAmberBondHardnessTerms(amberParameters,file);
		fclose(file);
	}
	return TRUE;
}
/**********************************************************************/
File: ./cchemilib/src/MolecularMechanics/ConjugateGradient.c

/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* ConjugateGradient.c */
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>

#include "../Utils/Utils.h"
#include "../Utils/AtomsProp.h"
#include "../Utils/Constants.h"
#include "../Utils/Types.h"
#include "../Molecule/Molecule.h"
#include "../MolecularMechanics/ConjugateGradient.h"


static double maxarg1,maxarg2;
#define FMAX(a,b) (maxarg1=(a),maxarg2=(b),(maxarg1) > (maxarg2) ?\
        (maxarg1) : (maxarg2))

static void hestenesStiefel(ConjugateGradient* conjugateGradient);
static void fletcherReeves(ConjugateGradient* conjugateGradient);
static void polakRibiere(ConjugateGradient* conjugateGradient);
static void wolfPowell(ConjugateGradient* conjugateGradient);
static double lineMinimize(ConjugateGradient* conjugateGradient);
static void bracketMinimum(ConjugateGradient* conjugateGradient, double pointA[], double pointB[], double pointC[] );
static double oneDimensionalEnergy(ConjugateGradient* conjugateGradient, double factor );
static double inverseParabolicInterpolation(ConjugateGradient* conjugateGradient,
		double pointa[], double mid[], double pointb[], 
		double minimum[] );
/**********************************************************************/
void	runConjugateGradient(ConjugateGradient* conjugateGradient, ForceField* forceField, 
		ConjugateGradientOptions conjugateGradientOptions)
{

	int i;
	int minimizerOptions = conjugateGradientOptions.method;
	conjugateGradient->forceField = forceField;
	conjugateGradient->numberOfAtoms = forceField->molecule.nAtoms;
	conjugateGradient->updateFrequency = conjugateGradientOptions.updateFrequency;
	conjugateGradient->maxIterations = conjugateGradientOptions.maxIterations;
	conjugateGradient->updateNumber = 0;
	conjugateGradient->maxLine = conjugateGradientOptions.maxLines;
	conjugateGradient->epsilon = conjugateGradientOptions.gradientNorm;
	conjugateGradient->initialStep = conjugateGradientOptions.initialStep;
	conjugateGradient->rmsDeplacment = 0;
	conjugateGradient->maxDeplacment = 0;
	conjugateGradient->gradientNorm = 0;
	conjugateGradient->initialBracket = conjugateGradientOptions.initialStep;
	conjugateGradient->lastInitialBracket = 0;
	conjugateGradient->term = 0;

	for(i=0;i<3;i++)
	{
		conjugateGradient->lastGradient[i] = 
			malloc(conjugateGradient->numberOfAtoms*sizeof(double));
		conjugateGradient->direction[i] = 
			malloc(conjugateGradient->numberOfAtoms*sizeof(double));
	}

	conjugateGradient->temporaryMolecule = malloc(sizeof(Molecule));
	conjugateGradient->temporaryMolecule->nAtoms = conjugateGradient->numberOfAtoms;
	conjugateGradient->temporaryMolecule->atoms = 
		malloc(conjugateGradient->numberOfAtoms*sizeof(Atom)); 
	for (  i = 0; i < conjugateGradient->numberOfAtoms; i++ )
	{
		conjugateGradient->temporaryMolecule->atoms[i].charge =  conjugateGradient->forceField->molecule.atoms[i].charge;
		conjugateGradient->temporaryMolecule->atoms[i].mass =  conjugateGradient->forceField->molecule.atoms[i].mass;
	}

	switch(minimizerOptions)
	{
		case 1 : hestenesStiefel(conjugateGradient);break;
		case 2 : fletcherReeves(conjugateGradient);break;
		case 3 : polakRibiere(conjugateGradient);break;
		case 4 : wolfPowell(conjugateGradient);break;
	}
}
/**********************************************************************/
void	freeConjugateGradient(ConjugateGradient* conjugateGradient)
{

	int i;
	conjugateGradient->forceField = NULL;
	conjugateGradient->numberOfAtoms = 0;
	conjugateGradient->updateFrequency = 0;
	conjugateGradient->maxIterations = 0;
	conjugateGradient->updateNumber = 0;
	conjugateGradient->maxLine = 0;
	conjugateGradient->epsilon = 0;
	conjugateGradient->initialStep = 0;
	conjugateGradient->rmsDeplacment = 0;
	conjugateGradient->maxDeplacment = 0;
	conjugateGradient->gradientNorm = 0;
	conjugateGradient->initialBracket = 0;
	conjugateGradient->lastInitialBracket = 0;
	conjugateGradient->term = 0;

	for(i=0;i<3;i++)
	{
		if(conjugateGradient->lastGradient[i] !=NULL)
		{
			free(conjugateGradient->lastGradient[i]);
			conjugateGradient->lastGradient[i]= NULL;
		}
		if(conjugateGradient->direction[i] != NULL)
		{
			free(conjugateGradient->direction[i]);
			conjugateGradient->direction[i] = NULL; 
		}
	}

	if(conjugateGradient->temporaryMolecule != NULL)
	{
		free(conjugateGradient->temporaryMolecule);
		conjugateGradient->temporaryMolecule = NULL;
	}

}
/**********************************************************************/
static void fletcherReeves(ConjugateGradient* conjugateGradient)
{
	double lastGradientDotGradient = 0, gradientDotGradient = 0, beta;
	int iterations = 0;
	int i;
	int j;
	double energy;
	char* str = strdup(" ");

	conjugateGradient->forceField->klass->calculateGradient(conjugateGradient->forceField);
	for ( i = 0; i < conjugateGradient->numberOfAtoms; i++ )
	{
		for(j=0;j<3;j++)
		{
		conjugateGradient->direction[j][ i ] = 
			-conjugateGradient->forceField->molecule.atoms[i].gradient[j];
		lastGradientDotGradient += conjugateGradient->forceField->molecule.atoms[i].gradient[j]
					* conjugateGradient->forceField->molecule.atoms[i].gradient[j]; 
		}
	}
	gradientDotGradient = lastGradientDotGradient;
	while ( 
			( lastGradientDotGradient > conjugateGradient->epsilon ) && 
			( iterations++ < conjugateGradient->maxIterations ) 
		)
	{

		lineMinimize(conjugateGradient);
		conjugateGradient->forceField->klass->calculateGradient(conjugateGradient->forceField);
		lastGradientDotGradient = gradientDotGradient;	
		gradientDotGradient = 0;	
		for (  i = 0; i < conjugateGradient->numberOfAtoms; i++ )
			for(j=0;j<3;j++)
			{
				gradientDotGradient += 
					conjugateGradient->forceField->molecule.atoms[i].gradient[j]
					* conjugateGradient->forceField->molecule.atoms[i].gradient[j]; 
			}
		beta = gradientDotGradient / lastGradientDotGradient;
		for (  i = 0; i < conjugateGradient->numberOfAtoms; i++ )
		{
			for(j=0;j<3;j++)
			{
				conjugateGradient->direction[j][i] = 
					beta *  conjugateGradient->direction[j][i] - 
					conjugateGradient->forceField->molecule.atoms[i].gradient[j];
			}
		}
		if ( conjugateGradient->updateNumber >= conjugateGradient->updateFrequency )
		{
			free(str);
			str = strdup_printf(("gradient = %f "),sqrt(gradientDotGradient)); 
			/* redrawMolecule(&conjugateGradient->forceField->molecule,str);*/
			fprintf(conjugateGradient->logfile, "%s\n",str);
			fflush(conjugateGradient->logfile);
			conjugateGradient->updateNumber = 0;
		}
		conjugateGradient->updateNumber++;
	}	

	conjugateGradient->forceField->klass->calculateGradient(conjugateGradient->forceField);
	conjugateGradient->gradientNorm = 0;
	for(  i = 0; i < conjugateGradient->numberOfAtoms; i++ )
	{
		for(j=0;j<3;j++)
		{
			conjugateGradient->gradientNorm += 
				conjugateGradient->forceField->molecule.atoms[i].gradient[j] *
				conjugateGradient->forceField->molecule.atoms[i].gradient[j]; 
		}
	}
	conjugateGradient->gradientNorm = sqrt(conjugateGradient->gradientNorm );
	updateGeometryCL(conjugateGradient->forceField,  &conjugateGradient->forceField->molecule);
	energy = conjugateGradient->forceField->klass->calculateEnergyTmp
		(conjugateGradient->forceField, &conjugateGradient->forceField->molecule );

	free(str);
	str = strdup_printf(("Gradient = %f  Energy = %f (Kcal/mol) "),
			(double)conjugateGradient->gradientNorm,(double)energy); 

	/* redrawMolecule(&conjugateGradient->forceField->molecule,str);*/
	fprintf(conjugateGradient->logfile, "%s\n",str);
	fflush(conjugateGradient->logfile);
	free(str);
}
/********************************************************************************/
static void polakRibiere(ConjugateGradient* conjugateGradient)
{
	double lastGradientDotGradient = 0, gradientDotGradient, beta;
	int iterations = 0;
	double energy;
	int i;
	int j;
	char* str = strdup(" ");

	conjugateGradient->forceField->klass->calculateGradient(conjugateGradient->forceField);

	for ( i = 0; i < conjugateGradient->numberOfAtoms; i++ )
	{
		for(j=0;j<3;j++)
		{
		conjugateGradient->direction[j][ i ] = 
		conjugateGradient->lastGradient[j][i] =
			-conjugateGradient->forceField->molecule.atoms[i].gradient[j];

		lastGradientDotGradient += conjugateGradient->forceField->molecule.atoms[i].gradient[j] 
					* conjugateGradient->forceField->molecule.atoms[i].gradient[j]; 
		}
	}
	gradientDotGradient = lastGradientDotGradient;
	while ( 
			( lastGradientDotGradient > conjugateGradient->epsilon ) && 
			( iterations++ < conjugateGradient->maxIterations ) 
		)
	{

		lineMinimize(conjugateGradient);
		conjugateGradient->forceField->klass->calculateGradient(conjugateGradient->forceField);
		lastGradientDotGradient = gradientDotGradient;
		gradientDotGradient = 0;	
		beta = 0;
		for (  i = 0; i < conjugateGradient->numberOfAtoms; i++ )
		{
			for (  j = 0; j < 3; j++ )
			{
				gradientDotGradient += 
					conjugateGradient->forceField->molecule.atoms[i].gradient[j] *
					conjugateGradient->forceField->molecule.atoms[i].gradient[j]; 
				
				beta += ( 
					conjugateGradient->forceField->molecule.atoms[i].gradient[j] - 
					conjugateGradient->lastGradient[j][i]
					)* conjugateGradient->forceField->molecule.atoms[i].gradient[j]; 
			}
		}
		beta /= lastGradientDotGradient;
		for (  i = 0; i < conjugateGradient->numberOfAtoms; i++ )
		{
			for (  j = 0; j < 3; j++ )
			{
				conjugateGradient->direction[j][i] = 
				beta * conjugateGradient->direction[j][i] - 
				conjugateGradient->forceField->molecule.atoms[i].gradient[j];
			}
		}
		for ( i = 0; i < conjugateGradient->numberOfAtoms; i++ )
		{
			for(j=0;j<3;j++)
			{
				conjugateGradient->lastGradient[j][i] = 
				conjugateGradient->forceField->molecule.atoms[i].gradient[j];
			}
		}
		if ( conjugateGradient->updateNumber >= conjugateGradient->updateFrequency )
		{
			free(str);
			str = strdup_printf("gradient = %f ",sqrt(gradientDotGradient)); 
			/* redrawMolecule(&conjugateGradient->forceField->molecule,str);*/
			fprintf(conjugateGradient->logfile, "%s\n",str);
			fflush(conjugateGradient->logfile);
			conjugateGradient->updateNumber = 0;
		}
		conjugateGradient->updateNumber++;
	}	
	conjugateGradient->forceField->klass->calculateGradient(conjugateGradient->forceField);
	conjugateGradient->gradientNorm = 0;
	for(  i = 0; i < conjugateGradient->numberOfAtoms; i++ )
	{
		for (  j = 0; j < 3; j++ )
		{
			conjugateGradient->gradientNorm += 
				conjugateGradient->forceField->molecule.atoms[i].gradient[j] *
				conjugateGradient->forceField->molecule.atoms[i].gradient[j]; 
		}
	}
	conjugateGradient->gradientNorm = sqrt(conjugateGradient->gradientNorm );
	updateGeometryCL(conjugateGradient->forceField,  &conjugateGradient->forceField->molecule);
	energy = conjugateGradient->forceField->klass->calculateEnergyTmp
		(conjugateGradient->forceField, &conjugateGradient->forceField->molecule );

	free(str);
	str = strdup_printf(("Gradient = %f  Energy = %f (Kcal/mol) "),
			(double)conjugateGradient->gradientNorm,(double)energy); 
	/* redrawMolecule(&conjugateGradient->forceField->molecule,str);*/
	fprintf(conjugateGradient->logfile, "%s\n",str);
	fflush(conjugateGradient->logfile);
	free(str);
}
/********************************************************************************/
static void hestenesStiefel(ConjugateGradient* conjugateGradient)
{
	double gradientDotGradient = 1, beta, gradientDiff, denom;
	int iterations = 0;
	double energy;
	int i;
	int j;
	char* str = strdup(" ");

	conjugateGradient->forceField->klass->calculateGradient(conjugateGradient->forceField);
	for ( i = 0; i < conjugateGradient->numberOfAtoms; i++ )
	{
		for(j=0;j<3;j++)
		{
		conjugateGradient->direction[j][ i ] = 
		conjugateGradient->lastGradient[j][i] = 
			-conjugateGradient->forceField->molecule.atoms[i].gradient[j];
		}
	}
	while ( 
			( gradientDotGradient > conjugateGradient->epsilon ) && 
			( iterations++ < conjugateGradient->maxIterations ) 
		)
	{

		lineMinimize(conjugateGradient);
		conjugateGradient->forceField->klass->calculateGradient(conjugateGradient->forceField);
		gradientDotGradient = 0;	
		for (  i = 0; i < conjugateGradient->numberOfAtoms; i++ )
		{
			for (  j = 0; j < 3; j++ )
			{
				gradientDotGradient += 
					conjugateGradient->forceField->molecule.atoms[i].gradient[j]*
					conjugateGradient->forceField->molecule.atoms[i].gradient[j];
			}
		}
		beta = 0;
		denom = 0;
		for (  i = 0; i < conjugateGradient->numberOfAtoms; i++ )
		{
			for (  j = 0; j < 3; j++ )
			{
				gradientDiff = 
					conjugateGradient->forceField->molecule.atoms[i].gradient[j]-
					conjugateGradient->lastGradient[j][i];

				beta += 
					conjugateGradient->forceField->molecule.atoms[i].gradient[j]*
				       	gradientDiff;
				denom += conjugateGradient->direction[j][i] * gradientDiff;
			}
		}
		if ( fabs( denom ) > 1.0e-10 )
			beta /= denom;
		else
			beta = 0;

		for (  i = 0; i < conjugateGradient->numberOfAtoms; i++ )
		{
			for (  j = 0; j < 3; j++ )
			{
				conjugateGradient->direction[j][ i ] = 
					beta * conjugateGradient->direction[j][ i ] - 
					conjugateGradient->forceField->molecule.atoms[i].gradient[j];
			}
		}
		for ( i = 0; i < conjugateGradient->numberOfAtoms; i++ )
		{
			for(j=0;j<3;j++)
			{
				conjugateGradient->lastGradient[j][i] = 
				conjugateGradient->forceField->molecule.atoms[i].gradient[j];
			}
		}
		if ( conjugateGradient->updateNumber >= conjugateGradient->updateFrequency )
		{
			free(str);
			str = strdup_printf(("gradient = %f "),sqrt(gradientDotGradient)); 
			/* redrawMolecule(&conjugateGradient->forceField->molecule,str);*/
			fprintf(conjugateGradient->logfile, "%s\n",str);
			fflush(conjugateGradient->logfile);
			conjugateGradient->updateNumber = 0;
		}
		conjugateGradient->updateNumber++;
	}	
	conjugateGradient->forceField->klass->calculateGradient(conjugateGradient->forceField);
	conjugateGradient->gradientNorm = 0;
	for(  i = 0; i < conjugateGradient->numberOfAtoms; i++ )
	{
		for(j=0;j<3;j++)
			conjugateGradient->gradientNorm += 
			conjugateGradient->direction[j][ i ] *
			conjugateGradient->direction[j][ i ];
	}
	conjugateGradient->gradientNorm = sqrt( conjugateGradient->gradientNorm );
	updateGeometryCL(conjugateGradient->forceField,  &conjugateGradient->forceField->molecule);
	energy = conjugateGradient->forceField->klass->calculateEnergyTmp
		(conjugateGradient->forceField, &conjugateGradient->forceField->molecule );

	free(str);
	str = strdup_printf(("Gradient = %f  Energy = %f (Kcal/mol) "),
			(double)conjugateGradient->gradientNorm,(double)energy); 
	/* redrawMolecule(&conjugateGradient->forceField->molecule,str);*/
	fprintf(conjugateGradient->logfile, "%s\n",str);
	fflush(conjugateGradient->logfile);
	free(str);
}
/********************************************************************************/
static void wolfPowell(ConjugateGradient* conjugateGradient)
{
	double lastGradientDotGradient = 0, gradientDotGradient, beta;
	int iterations = 0;
	double energy;
	int i;
	int j;
	char* str = strdup(" ");

	conjugateGradient->forceField->klass->calculateGradient(conjugateGradient->forceField);
	for ( i = 0; i < conjugateGradient->numberOfAtoms; i++ )
	{
		for(j=0;j<3;j++)
		{
		conjugateGradient->direction[j][ i ] = 
		conjugateGradient->lastGradient[j][i] =
			-conjugateGradient->forceField->molecule.atoms[i].gradient[j];

		lastGradientDotGradient += conjugateGradient->forceField->molecule.atoms[i].gradient[j]
					* conjugateGradient->forceField->molecule.atoms[i].gradient[j]; 
		}
	}
	while ( 
			( lastGradientDotGradient > conjugateGradient->epsilon ) && 
			( iterations++ < conjugateGradient->maxIterations ) 
		)
	{

		lineMinimize(conjugateGradient);
		conjugateGradient->forceField->klass->calculateGradient(conjugateGradient->forceField);
		gradientDotGradient = 0;	
		for ( i = 0; i < conjugateGradient->numberOfAtoms; i++ )
			for ( j = 0; j < 3; j++ )
			{
				gradientDotGradient += 
					conjugateGradient->forceField->molecule.atoms[i].gradient[j]*
					conjugateGradient->forceField->molecule.atoms[i].gradient[j];
			}

		beta = 0;
		for (  i = 0; i < conjugateGradient->numberOfAtoms; i++ )
		{
			for ( j = 0; j < 3; j++ )
				beta += ( 
					conjugateGradient->forceField->molecule.atoms[i].gradient[j] - 
					conjugateGradient->lastGradient[j][i]
					)* conjugateGradient->forceField->molecule.atoms[i].gradient[j]; 
		}
		beta /= lastGradientDotGradient;
		if ( beta < 0 )
			beta = 0;
		lastGradientDotGradient = gradientDotGradient;
		for (  i = 0; i < conjugateGradient->numberOfAtoms; i++ )
			for ( j = 0; j < 3; j++ )
				conjugateGradient->direction[j][ i ] = 
					beta * conjugateGradient->direction[j][ i ] - 
					conjugateGradient->forceField->molecule.atoms[i].gradient[j];
		
		for ( i = 0; i < conjugateGradient->numberOfAtoms; i++ )
		{
			for(j=0;j<3;j++)
			{
				conjugateGradient->lastGradient[j][i] = 
				conjugateGradient->forceField->molecule.atoms[i].gradient[j];
			}
		}
		if ( conjugateGradient->updateNumber >= conjugateGradient->updateFrequency )
		{
			free(str);
			str = strdup_printf(("gradient = %f "),sqrt(gradientDotGradient)); 
			/* redrawMolecule(&conjugateGradient->forceField->molecule,str);*/
			fprintf(conjugateGradient->logfile, "%s\n",str);
			fflush(conjugateGradient->logfile);
			conjugateGradient->updateNumber = 0;
		}
		conjugateGradient->updateNumber++;
	}	
	conjugateGradient->forceField->klass->calculateGradient(conjugateGradient->forceField);
	conjugateGradient->gradientNorm = 0;
	for(  i = 0; i < conjugateGradient->numberOfAtoms; i++ )
	{
		for(j=0;j<3;j++)
			conjugateGradient->gradientNorm += 
			conjugateGradient->direction[j][ i ] *
			conjugateGradient->direction[j][ i ];
	}
	conjugateGradient->gradientNorm = sqrt( conjugateGradient->gradientNorm );
	updateGeometryCL(conjugateGradient->forceField,  &conjugateGradient->forceField->molecule);
	energy = conjugateGradient->forceField->klass->calculateEnergyTmp
		(conjugateGradient->forceField, &conjugateGradient->forceField->molecule );

	free(str);
	str = strdup_printf(("Gradient = %f  Energy = %f (Kcal/mol) "),
			(double)conjugateGradient->gradientNorm,(double)energy); 
	/* redrawMolecule(&conjugateGradient->forceField->molecule,str);*/
	fprintf(conjugateGradient->logfile, "%s\n",str);
	fflush(conjugateGradient->logfile);
	free(str);
} 
/**********************************************************************/
static double lineMinimize(ConjugateGradient* conjugateGradient)
{
	double a;
	double b;
	double c;
	double minimum=0;
	double energy;
        double delta = 1.0e-7;
	int i;
	int j;
		
	a = 0; 
	b = conjugateGradient->initialBracket;
	bracketMinimum(conjugateGradient, &a, &b, &c );
	energy = inverseParabolicInterpolation(conjugateGradient, &a, &b, &c, &minimum );
	conjugateGradient->initialBracket = minimum;

	if ( 	( fabs( conjugateGradient->initialBracket ) < delta ) || 
		( conjugateGradient->initialBracket == conjugateGradient->lastInitialBracket ) )
	{
		conjugateGradient->initialBracket = 
			rand()/(double)RAND_MAX *conjugateGradient->initialStep;

		for (  i = 0; i < conjugateGradient->numberOfAtoms; i++ )
		{
			for(j=0;j<3;j++)
			conjugateGradient->direction[j][i] = 
				-conjugateGradient->forceField->molecule.atoms[i].gradient[j];
		}
	} 
	conjugateGradient->lastInitialBracket = conjugateGradient->initialBracket;
	for (  i = 0; i <  conjugateGradient->numberOfAtoms; i++ )
	{

			for(j=0;j<3;j++)
				conjugateGradient->forceField->molecule.atoms[i].coordinates[j] += 
				conjugateGradient->direction[j][i] * conjugateGradient->initialBracket;
	}
	updateGeometryCL( conjugateGradient->forceField,NULL);
	return( energy );
}
/********************************************************************************/
static void bracketMinimum(ConjugateGradient* conjugateGradient, double pointA[], double pointB[], double pointC[] )
{
	static double GOLDENRATIO = 1.618034;
	double energyA, energyB, energyC, temp;
      	double ulim, u, r, q, fu, denominator;
	int iter = 0;

       	energyA = oneDimensionalEnergy(conjugateGradient, pointA[ 0 ] );
        energyB = oneDimensionalEnergy(conjugateGradient, pointB[ 0 ] );

        if ( energyB > energyA ) 
	{  
		temp = pointA[ 0 ];
		pointA[ 0 ] = pointB[ 0 ];
		pointB[ 0 ] = temp;
		temp = energyB;
		energyB = energyA;
		energyA = temp;  
        }
        pointC[ 0 ] = pointB[ 0 ] + GOLDENRATIO * ( pointB[ 0 ] - pointA[ 0 ] );
        energyC = oneDimensionalEnergy(conjugateGradient, pointC[ 0 ] );
        while ( energyB > energyC )
	{
		iter++;
               	r = ( pointB[ 0 ] - pointA[ 0 ] ) * ( energyB - energyC );
               	q = ( pointB[ 0 ] - pointC[ 0 ] ) * ( energyB - energyA );
		denominator = FMAX( fabs( q - r ), 1.0e-20 );
		if ( ( q - r ) < 0 )
			denominator = -denominator;
               	u = ( pointB[ 0 ] ) - ( ( pointB[ 0 ]-pointC[ 0 ] ) * q - 
			( pointB[ 0 ] - pointA[ 0 ] ) * r ) /
                       	( 2.0 * denominator );
               	ulim = pointB[ 0 ] + 100 * ( pointC[ 0 ] - pointB[ 0 ] );
               	if ( ( pointB[ 0 ] - u ) * ( u - pointC[ 0 ] ) > 0.0 )
		{
                       	fu=oneDimensionalEnergy(conjugateGradient, u );
                       	if ( fu < energyC )
			{
                               	pointA[ 0 ] = pointB[ 0 ];
                               	pointB[ 0 ] = u;
                               	energyA = energyB;
                               	energyB = fu;
                               	return;
                       	}
			else if ( fu > energyB )
			{
                               	pointC[ 0 ] = u;
                               	energyC = fu;
                               	return;
			}
                       	u = pointC[ 0 ] + GOLDENRATIO * ( pointC[ 0 ] - pointB[ 0 ] );
                       	fu = oneDimensionalEnergy(conjugateGradient, u );
               	}
		else if ( ( pointC[ 0 ] - u ) * ( u - ulim ) > 0.0 )
		{
                       	fu = oneDimensionalEnergy(conjugateGradient, u );
                       	if ( fu < energyC )
			{
				pointB[ 0 ] = pointC[ 0 ];
				pointC[ 0 ] = u;
				u = pointC[ 0 ] + GOLDENRATIO * ( pointC[ 0 ] - pointB[ 0 ] );
				energyB = energyC;
				energyC = fu;
				fu = oneDimensionalEnergy(conjugateGradient, u );
                       	}
               	}
		else if ( ( u - ulim ) * ( ulim - pointC[ 0 ] ) >= 0.0 )
		{
                       	u = ulim;
                       	fu = oneDimensionalEnergy(conjugateGradient, u );
               	}
		else
		{
                       	u = pointC[ 0 ] + GOLDENRATIO * ( pointC[ 0 ] - pointB[ 0 ] );
                       	fu = oneDimensionalEnergy(conjugateGradient, u );
               	}
		pointA[ 0 ] = pointB[ 0 ];
		pointB[ 0 ] = pointC[ 0 ];
		pointC[ 0 ] = u;
		energyA = energyB;
		energyB = energyC;
		energyC = fu;
       	}
}
/********************************************************************************/
static double oneDimensionalEnergy(ConjugateGradient* conjugateGradient, double factor )
{

	int i;
	int j;
	for (  i = 0; i < conjugateGradient->numberOfAtoms; i++ )
	{
		for(j=0;j<3;j++)
		{
			conjugateGradient->temporaryMolecule->atoms[i].coordinates[j] = 
				conjugateGradient->forceField->molecule.atoms[i].coordinates[j] + 
				factor * conjugateGradient->direction[j][i];
		}
	}
	
	updateGeometryCL(conjugateGradient->forceField,  conjugateGradient->temporaryMolecule);
	return ( conjugateGradient->forceField->klass->calculateEnergyTmp(conjugateGradient->forceField,conjugateGradient->temporaryMolecule) );
}
/********************************************************************************/
static double inverseParabolicInterpolation(ConjugateGradient* conjugateGradient,
		double pointa[], double mid[], double pointb[], 
		double minimum[] )
{
        int iter;
	int maxIterations = conjugateGradient->maxLine;
	static double CGOLD = 0.3819660;
        double a,b,d=0,etemp,fu,fv,fw,fx,p,q,r,tol1,tol2,u,v,w,x,xm;
        double e=0.0, tol=2.0e-4;
	double pointA, pointB;
	double energy;
	
	pointA = pointa[ 0 ];
	pointB = pointb[ 0 ];

        a=(pointA < pointB ? pointA : pointB);
        b=(pointA > pointB ? pointA : pointB);
        x=w=v=mid[ 0 ];
        fw=fv=fx=fu=energy=oneDimensionalEnergy(conjugateGradient,x);
        for (iter=1;iter<=maxIterations;iter++)
	{

               	xm=0.5*(a+b);
		tol1 = tol* fabs( x ) + 1.0e-10;
               	tol2=2.0*tol1;
               	if (fabs(x-xm) <= (tol2-0.5*(b-a)))
		{
                       	minimum[0]=x;
                       	return fu;
               	}
               	if (fabs(e) > tol1)
		{
                       	r=(x-w)*(fx-fv);
                       	q=(x-v)*(fx-fw);
                       	p=(x-v)*q-(x-w)*r;
                       	q=2.0*(q-r);
                       	if (q > 0.0) p = -p;
                       	q=fabs(q);
                       	etemp=e;
                       	e=d;
                       	if (fabs(p) >= fabs(0.5*q*etemp) || 
				p <= q*(a-x) || p >= q*(b-x))
                               	d=CGOLD*(e=(x >= xm ? a-x : b-x));
                       	else
			{
                               	d=p/q;
                               	u=x+d;
                               	if (u-a < tol2 || b-u < tol2)
				{
					if ( ( xm - x ) < 0 )
						d = - tol1;
					else
						d = tol1;
				}
                       	}
               	}
		else
		{
                        	d=CGOLD*(e=(x >= xm ? a-x : b-x));
               	}
		if ( fabs( d ) >= tol1 )
		{
			u = x + d;
		}
		else
		{
			if ( d >= 0 )
				u = x + tol1;
			else
				u = x - tol1;
		}
               	fu=oneDimensionalEnergy(conjugateGradient,u);
               	if (fu <= fx)
		{
                       	if (u >= x) a=x; else b=x;
			v = w;
			w = x;
			x = u;
			fv = fw;
			fw = fx;
			fx = fu;
               	}
		else
		{
                       	if (u < x) a=u; else b=u;
                       	if (fu <= fw || w == x)
			{
                               	v=w;
                               	w=u;
                               	fv=fw;
                               	fw=fu;
                       	}
			else if (fu <= fv || v == x || v == w)
			{
                               	v=u;
                               	fv=fu;
                       	}
               	}
        }
	return( fu );
}
/*****************************************************************************************************************************************************/
void setCGOptions(FILE* file, ConjugateGradientOptions* conjugateGradientOptions)
{
/* Optimsation options */ 
	conjugateGradientOptions->gradientNorm = 1e-3;
	conjugateGradientOptions->maxIterations = 100;
	conjugateGradientOptions->updateFrequency = 1;
	conjugateGradientOptions->maxLines = 25;
	conjugateGradientOptions->initialStep = 0.001;
/* 1 : Hestenes Stiefel,  2 : Fletcher Reeves, 3 : Polak Ribiere, 4 : Wolf Powell*/
	conjugateGradientOptions->method = 1;

	readOneReal(file,"conjugateGradientGradientNorm",&conjugateGradientOptions->gradientNorm);
	readOneInt(file,"conjugateGradientMaxIterations",&conjugateGradientOptions->maxIterations);
	readOneInt(file,"conjugateGradientUpdateFrequency",&conjugateGradientOptions->updateFrequency);
	readOneInt(file,"conjugateGradientMaxLines",&conjugateGradientOptions->maxLines);
	readOneReal(file,"conjugateGradientInitialStep",&conjugateGradientOptions->initialStep);
	readOneInt(file,"conjugateGradientMethod",&conjugateGradientOptions->method);
	if(conjugateGradientOptions->method<1||conjugateGradientOptions->method>4) conjugateGradientOptions->method=1;
}
File: ./cchemilib/src/MolecularMechanics/MolecularMechanics.c

/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* MolecularMechanics.c */
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>

#include "../Utils/Utils.h"
#include "../Utils/Timer.h"
#ifdef ENABLE_CL
#include "../Utils/CLProp.h"
#endif
#include "../Utils/AtomsProp.h"
#include "../Utils/Constants.h"
#include "../Utils/Types.h"
#include "../Molecule/Molecule.h"
#include "../MolecularMechanics/MolecularMechanics.h"
#include "../MolecularMechanics/LoadMMParameters.h"
#include "../MolecularMechanics/CreateMolecularMechanicsFile.h"
#include "../EmpriricalCorrections/WallCorrection.h"
#ifdef ENABLE_CL
#include "../MolecularMechanics/MolecularMechanicsCL.h"
#endif


#define POSEPS 1e-10
static AmberParameters* staticAmberParameters = NULL;


/* static void calculateGradientNumericAmber(ForceField* forceField);*/
static void calculateGradientAmber(ForceField* forceField);
static void calculateEnergyAmber(ForceField* forceField);
static double calculateEnergyTmpAmber(ForceField* forceField,Molecule* m);
static void printEnergies(ForceField* forceField);
double calculateEnergyCoulombAmber(ForceField* forceField,Molecule* molecule);

void dessine();

/*****************************************************************************/
void setH4CorrectionMM(FILE* file, ForceField* forceField) 
{
	char* fileName = NULL;

	if(readOneString(file,"H4Correction",&fileName) && fileName) 
	{
		char tmp[BSIZE];
		sprintf(tmp,"%s",fileName);
		uppercase(tmp);
		if(!strstr(tmp,"NONE"))
		{
			HyhrogenBondCorrectionParameters parameters;
			if(!strstr(tmp,"DEFAULT")) setHydrogenBondCorrectionParameters(&parameters, fileName, NULL);
			else setHydrogenBondCorrectionParameters(&parameters, NULL, "MM");
			forceField->H4Parameters = malloc(sizeof(HyhrogenBondCorrectionParameters));
			*(forceField->H4Parameters) = parameters;
			return;
		}
	}
	forceField->H4Parameters= NULL;
}
/**********************************************************************/
static void addH4Correction(ForceField* forceField,boolean addGradient)
{
	if(forceField->H4Parameters)
		forceField->molecule.potentialEnergy += getH4Correction(&forceField->molecule, forceField->H4Parameters, addGradient);
}
/**********************************************************************/
static double getH4Energy(ForceField* forceField, Molecule* molecule)
{
	if(forceField->H4Parameters) return getH4Correction(molecule, forceField->H4Parameters, FALSE);
	else return 0;
}
/**********************************************************************/
static void addWallCorrection(ForceField* forceField, boolean addGradient)
{
	if(forceField->options.addWallCorrection)
	{
		//double eOld = forceField->molecule.potentialEnergy;
		forceField->molecule.potentialEnergy += getWallCorrection(&forceField->molecule, addGradient);
		//fprintf(stdout," Wall Correction = %f\n", forceField->molecule.potentialEnergy-eOld);
	}
}
/**********************************************************************/
AmberParameters newAmberParameters()
{
	AmberParameters amberParameters;

	amberParameters.numberOfTypes = 0;
	amberParameters.atomTypes = NULL;

	amberParameters.numberOfStretchTerms = 0;
	amberParameters.bondStretchTerms = NULL;

	amberParameters.numberOfBendTerms = 0;
	amberParameters.angleBendTerms = NULL;

	amberParameters.numberOfStrBendTerms = 0;
	amberParameters.strBendTerms = NULL;

	amberParameters.numberOfDihedralTerms = 0;
	amberParameters.dihedralAngleTerms = NULL;

	amberParameters.numberOfImproperTorsionTerms = 0;
	amberParameters.improperTorsionTerms = NULL;

	amberParameters.numberOfOutOfPlaneTerms = 0;
	amberParameters.outOfPlaneTerms = NULL;

	amberParameters.numberOfVdw612 = 0;
	amberParameters.vdw612Terms = NULL;

	amberParameters.numberOfVdw714 = 0;
	amberParameters.vdw714Terms = NULL;

	amberParameters.numberOfHydrogenBonded1012 = 0;
	amberParameters.hydrogenBonded1012Terms = NULL;

	amberParameters.numberOfHydrogenBondedMorse = 0;
	amberParameters.hydrogenBondedMorseTerms = NULL;

	amberParameters.numberOfSuttonChen = 0;
	amberParameters.suttonChenTerms = NULL;

	amberParameters.numberOfPairWise = 0;
	amberParameters.pairWiseTerms = NULL;

	amberParameters.numberOfHardnessTerms = 0;
	amberParameters.bondHardnessTerms = NULL;


	return amberParameters;
	
}
/**********************************************************************/
static void freeAmberParameters(AmberParameters* amberParameters)
{
	int i;

	for(i=0;i<amberParameters->numberOfTypes;i++)
		if(amberParameters->atomTypes[i].name)
			free(amberParameters->atomTypes[i].name);

	amberParameters->numberOfTypes = 0;
	if(amberParameters->atomTypes )
		free(amberParameters->atomTypes );

	amberParameters->atomTypes = NULL;

	amberParameters->numberOfStretchTerms = 0;
	if(amberParameters->bondStretchTerms)
		free(amberParameters->bondStretchTerms);
	amberParameters->bondStretchTerms = NULL;

	amberParameters->numberOfBendTerms = 0;
	if(amberParameters->angleBendTerms) free(amberParameters->angleBendTerms);
	amberParameters->angleBendTerms = NULL;

	amberParameters->numberOfStrBendTerms = 0;
	if(amberParameters->strBendTerms) free(amberParameters->strBendTerms);
	amberParameters->strBendTerms = NULL;

	for(i=0;i<amberParameters->numberOfDihedralTerms;i++)
	{
		if(amberParameters->dihedralAngleTerms[i].divisor)
			free(amberParameters->dihedralAngleTerms[i].divisor);
		if(amberParameters->dihedralAngleTerms[i].barrier)
			free(amberParameters->dihedralAngleTerms[i].barrier);
		if(amberParameters->dihedralAngleTerms[i].phase)
			free(amberParameters->dihedralAngleTerms[i].phase);
		if(amberParameters->dihedralAngleTerms[i].n)
			free(amberParameters->dihedralAngleTerms[i].n);

	}

	amberParameters->numberOfDihedralTerms = 0;
	if(amberParameters->dihedralAngleTerms)
		free(amberParameters->dihedralAngleTerms);
	amberParameters->dihedralAngleTerms = NULL;

	amberParameters->numberOfImproperTorsionTerms = 0;
	if(amberParameters->improperTorsionTerms) free(amberParameters->improperTorsionTerms);
	amberParameters->improperTorsionTerms = NULL;

	amberParameters->numberOfOutOfPlaneTerms = 0;
	if(amberParameters->outOfPlaneTerms) free(amberParameters->outOfPlaneTerms);
	amberParameters->outOfPlaneTerms = NULL;

	amberParameters->numberOfVdw612 = 0;
	if(amberParameters->vdw612Terms) free(amberParameters->vdw612Terms);
	amberParameters->vdw612Terms = NULL;

	amberParameters->numberOfVdw714 = 0;
	if(amberParameters->vdw714Terms) free(amberParameters->vdw714Terms);
	amberParameters->vdw714Terms = NULL;

	amberParameters->numberOfHydrogenBonded1012 = 0;
	if(amberParameters->hydrogenBonded1012Terms) free(amberParameters->hydrogenBonded1012Terms);
	amberParameters->hydrogenBonded1012Terms = NULL;

	amberParameters->numberOfHydrogenBondedMorse = 0;
	if(amberParameters->hydrogenBondedMorseTerms) free(amberParameters->hydrogenBondedMorseTerms);
	amberParameters->hydrogenBondedMorseTerms = NULL;

	amberParameters->numberOfSuttonChen = 0;
	if(amberParameters->suttonChenTerms)
		free(amberParameters->suttonChenTerms);
	amberParameters->suttonChenTerms = NULL;

}
/**********************************************************************/
static double getChargeFromMM(AmberParameters* amberParameters, char* type)
{
        int i;
        int nTypes = amberParameters->numberOfTypes;
        AmberAtomTypes* types = amberParameters->atomTypes;
        int len = strlen(type);

        if(strcmp(type,"X")==0) return 0.0;
        for(i=0;i<nTypes;i++)
        {
                if(len == (int)strlen(types[i].name) && strstr(types[i].name,type))
                        return types[i].charge;

        }
        return 0.0;
}
/**********************************************************************/
static void scalChargesToSetSumEqTotalCharge(ForceField* forceField)
{
	int i;
	double sp = 0;
	double sm = 0;
	int np = 0;
	int nm = 0;
	Molecule* m = &forceField->molecule;
	double totalCharge = m->totalCharge;
	double scalp = 1.0;
	double scalm = 1.0;

	for (  i = 0; i < m->nAtoms; i++ )
	{
		if(m->atoms[i].charge>0) {sp += m->atoms[i].charge; np++;}
		if(m->atoms[i].charge<0) {sm += m->atoms[i].charge; nm++;}
	}
	if(fabs(totalCharge)>0 && fabs(sp+sm)>0) scalp = scalm = totalCharge/(sp+sm);
	if(fabs(totalCharge)==0)
	{
		if(fabs(sm)>fabs(sp)) scalm = (totalCharge-sp)/sm;
		else if(fabs(sp)!=0) scalp  = (totalCharge-sm)/sp;
	}
	if(fabs(scalm-1)>1e-10 || fabs(scalp-1)>1e-10) 
	{
		printf("Warning : charges stacletd to set sum equal to total charge\n");
		for (  i = 0; i < m->nAtoms; i++ )
		{
			if(m->atoms[i].charge>0) m->atoms[i].charge *= scalp;
			if(m->atoms[i].charge<0) m->atoms[i].charge *= scalm;
		}
	}
	sp = 0.0;
	sm = 0.0;
	for (  i = 0; i < m->nAtoms; i++ )
	{
		if(m->atoms[i].charge>0) {sp += m->atoms[i].charge;}
		if(m->atoms[i].charge<0) {sm += m->atoms[i].charge;}
	}
	printf("\nSum of partial charges = %14.8f , total charge = %14.8f\n\n",sp+sm,totalCharge);

}
/**********************************************************************/
static void setChargesFromMMParameters(AmberParameters* amberParameters, ForceField* forceField)
{
	int i;
	Molecule* m = &forceField->molecule;

	if(strcmp(forceField->options.chargesType,"MM")) return;

	printf("forceField->options.chargesType = %s\n",forceField->options.chargesType);
	printf("Warning : I use the MM charge \n");

	
	for (  i = 0; i < m->nAtoms; i++ )
	{
		m->atoms[i].charge = getChargeFromMM(amberParameters, m->atoms[i].mmType);
	}
	scalChargesToSetSumEqTotalCharge(forceField);
}
/**********************************************************************/
static void setCharges(ForceField* forceField)
{
	if(strstr(forceField->options.chargesType,"SCALED")) scalChargesToSetSumEqTotalCharge(forceField);
	if(strstr(forceField->options.chargesType,"EEM")) forceField->molecule.klass->setChargesEEM(&forceField->molecule);
	if(strstr(forceField->options.chargesType,"ACKS2")) forceField->molecule.klass->setChargesACKS2(&forceField->molecule);
}
/**********************************************************************/
static int getNumberType(AmberParameters* amberParameters, char* type)
{
	int i;
	int nTypes = amberParameters->numberOfTypes;
	AmberAtomTypes* types = amberParameters->atomTypes;
	int len = strlen(type);

	if(strcmp(type,"X")==0)
		return -1;
	for(i=0;i<nTypes;i++)
	{
		if(len == (int)strlen(types[i].name) && strstr(types[i].name,type))
			return types[i].number;

	}
	return -2;
}
/**********************************************************************/
static ForceField newAmberModel()
{
	ForceField forceField = newForceField();

	forceField.klass->calculateGradient = calculateGradientAmber;
	/*forceField.klass->calculateGradient = calculateGradientNumericAmber;*/
	forceField.klass->calculateEnergy = calculateEnergyAmber;
	forceField.klass->calculateEnergyTmp = calculateEnergyTmpAmber;
	forceField.klass->printEnergies = printEnergies;

	forceField.options.type = AMBER;
	forceField.options.coulomb = TRUE;
	forceField.options.hydrogenBonded1012 = TRUE;
	forceField.options.hydrogenBonded612 = FALSE;
	forceField.options.hydrogenBondedMorse = TRUE;
	forceField.options.suttonChen = TRUE;
	forceField.options.improperTorsion = TRUE;
	forceField.options.outOfPlane = TRUE;

	return forceField;

}
/**********************************************************************/
static ForceField newPairWiseModel()
{
	ForceField forceField = newForceField();

	forceField.klass->calculateGradient = calculateGradientAmber;
	forceField.klass->calculateEnergy = calculateEnergyAmber;
	forceField.klass->calculateEnergyTmp = calculateEnergyTmpAmber;
	forceField.klass->printEnergies = printEnergies;

	forceField.options.type = PAIRWISE;

	forceField.options.coulomb = TRUE;
	forceField.options.vdw612 = TRUE;
	forceField.options.vdw714 = FALSE;

	forceField.options.bondStretch = FALSE;
	forceField.options.angleBend = FALSE;
	forceField.options.strBend = FALSE;
	forceField.options.dihedralAngle = FALSE;
	forceField.options.improperTorsion = FALSE;
	forceField.options.outOfPlane = FALSE;
	forceField.options.hydrogenBonded612 = FALSE;
	forceField.options.hydrogenBonded1012 = FALSE;
	forceField.options.hydrogenBondedMorse = FALSE;
	forceField.options.suttonChen = FALSE;


	return forceField;

}
/**********************************************************************/
/*
static boolean isIonic(char* mmType)
{
	if(!strcmp(mmType,"Li")) return TRUE;
	if(!strcmp(mmType,"Na")) return TRUE;
	if(!strcmp(mmType,"K")) return TRUE;
	if(!strcmp(mmType,"Rb")) return TRUE;
	if(!strcmp(mmType,"Cs")) return TRUE;
	if(!strcmp(mmType,"Ca")) return TRUE;
	if(!strcmp(mmType,"Sr")) return TRUE;
	if(!strcmp(mmType,"Ba")) return TRUE;
	if(!strcmp(mmType,"Zn")) return TRUE;
	if(!strcmp(mmType,"IB")) return TRUE;
	if(!strcmp(mmType,"Cl")) return TRUE;
	return FALSE;
}
*/
/**********************************************************************/
static boolean getStretchParameters(AmberParameters* amberParameters,
				int a1Type, int a2Type, 
				double* forceOrAlpha, double* equilibriumDistance,
				double* h3OrDe, double* h4, double* h5, double* h6,
				int* type
				)
{
	int i;
	forceOrAlpha[0] = 0.0;
	equilibriumDistance[0] = 0.0;
	h3OrDe[0] = 0.0;
	h4[0] = 0.0;
	h5[0] = 0.0;
	h6[0] = 0.0;
	*type = 0;

	if(a1Type>a2Type)
	{
		int t;
		t = a1Type;
		a1Type = a2Type;
		a2Type = t;
	}

	for(i=0;i<amberParameters->numberOfStretchTerms;i++)
	{
		if(
			a1Type == amberParameters->bondStretchTerms[i].numbers[0]  &&
			a2Type == amberParameters->bondStretchTerms[i].numbers[1] 
		)
		{
			*type = amberParameters->bondStretchTerms[i].type;
			if(*type==0)
			{
				forceOrAlpha[0]       = amberParameters->bondStretchTerms[i].forceConstant;// force for harmonic
			}
			else
			{
				double De =  amberParameters->bondStretchTerms[i].h3;
				if(fabs(De)>1e-13) forceOrAlpha[0] = sqrt(amberParameters->bondStretchTerms[i].forceConstant/2.0/De);// alpha
				else forceOrAlpha[0]       = 0.0;
			}
			equilibriumDistance[0] = amberParameters->bondStretchTerms[i].equilibriumDistance;
			h3OrDe[0] = amberParameters->bondStretchTerms[i].h3; // h3 for harmonic, De for Morse
			h4[0] = amberParameters->bondStretchTerms[i].h4;
			h5[0] = amberParameters->bondStretchTerms[i].h5;
			h6[0] = amberParameters->bondStretchTerms[i].h6;
			return TRUE;
		}
	}
	return FALSE;
}
/**********************************************************************/
static boolean getBendParameters(AmberParameters* amberParameters,int a1Type, int a2Type, int a3Type,
	       	double* forceConstant, double* equilibriumAngle,
		double* h3, double* h4, double* h5, double* h6
		)
{
	int i;
	forceConstant[0] = 0.0;
	equilibriumAngle[0] = 0.0;
	h3[0] = 0.0;
	h4[0] = 0.0;
	h5[0] = 0.0;
	h6[0] = 0.0;

	if(a1Type>a3Type)
	{
		int t;
		t = a1Type;
		a1Type = a3Type;
		a3Type = t;
	}

	for(i=0;i<amberParameters->numberOfBendTerms;i++)
	{
		if(
			a1Type == amberParameters->angleBendTerms[i].numbers[0]  &&
			a2Type == amberParameters->angleBendTerms[i].numbers[1]  &&
			a3Type == amberParameters->angleBendTerms[i].numbers[2] 
		)
		{
			forceConstant[0]       = amberParameters->angleBendTerms[i].forceConstant;
			equilibriumAngle[0]    = amberParameters->angleBendTerms[i].equilibriumAngle;
			h3[0]    = amberParameters->angleBendTerms[i].h3;
			h4[0]    = amberParameters->angleBendTerms[i].h4;
			h5[0]    = amberParameters->angleBendTerms[i].h5;
			h6[0]    = amberParameters->angleBendTerms[i].h6;
			return TRUE;
		}
	}
	return FALSE;
}
/**********************************************************************/
static boolean getStrBendParameters(AmberParameters* amberParameters,int a1Type, int a2Type, int a3Type,
	       	double* forceConstant12, double* forceConstant23
		)
{
	int i;
	forceConstant12[0] = 0.0;
	forceConstant23[0] = 0.0;

	if(a1Type>a3Type)
	{
		int t;
		t = a1Type;
		a1Type = a3Type;
		a3Type = t;
	}

	for(i=0;i<amberParameters->numberOfStrBendTerms;i++)
	{
		if(
			a1Type == amberParameters->strBendTerms[i].numbers[0]  &&
			a2Type == amberParameters->strBendTerms[i].numbers[1]  &&
			a3Type == amberParameters->strBendTerms[i].numbers[2] 
		)
		{
			forceConstant12[0]       = amberParameters->strBendTerms[i].forceConstant12;
			forceConstant23[0]       = amberParameters->strBendTerms[i].forceConstant23;
			return TRUE;
		}
	}
	return FALSE;
}
/**********************************************************************/
static boolean getHydrogenBonded1012Parameters(AmberParameters* amberParameters, int a1Type, int a2Type, double c[], double d[])
{
	int i;

	c[0] = 0.0;
	d[0] = 0.0;

	for(i=0;i<amberParameters->numberOfHydrogenBonded1012;i++)
	{
		if(
			(a1Type == amberParameters->hydrogenBonded1012Terms[i].numbers[0] &&
			a2Type == amberParameters->hydrogenBonded1012Terms[i].numbers[1])
			||
			(a2Type == amberParameters->hydrogenBonded1012Terms[i].numbers[0] &&
			a1Type == amberParameters->hydrogenBonded1012Terms[i].numbers[1])
		  )
		{
			c[0]    = amberParameters->hydrogenBonded1012Terms[i].c;
			d[0]    = amberParameters->hydrogenBonded1012Terms[i].d;
			return TRUE;
		}
	}
	return FALSE;
}
/**********************************************************************/
static boolean getHydrogenBondedMorseParameters(AmberParameters* amberParameters, int a1Type, int a2Type, double alpha[], double Re[], double De[])
{
	int i;

	alpha[0] = 0.0;
	Re[0] = 0.0;
	De[0] = 0.0;

	for(i=0;i<amberParameters->numberOfHydrogenBondedMorse;i++)
	{
		if(
			(a1Type == amberParameters->hydrogenBondedMorseTerms[i].numbers[0] &&
			a2Type == amberParameters->hydrogenBondedMorseTerms[i].numbers[1])
			||
			(a2Type == amberParameters->hydrogenBondedMorseTerms[i].numbers[0] &&
			a1Type == amberParameters->hydrogenBondedMorseTerms[i].numbers[1])
		  )
		{
			De[0]    = amberParameters->hydrogenBondedMorseTerms[i].De;
			if(fabs(De[0])>1e-13) alpha[0] = sqrt(fabs(amberParameters->hydrogenBondedMorseTerms[i].force/2.0/De[0]));
			Re[0]    = amberParameters->hydrogenBondedMorseTerms[i].Re;
			return TRUE;
		}
	}
	return FALSE;
}
/**********************************************************************/
static boolean getSuttonChenParameters(AmberParameters* amberParameters, int a1Type, int a2Type, double epsilon[], double a[], double C[], double n[], double m[] )
{
	int i;
	epsilon[0] = 0.0;
	a[0] = 0.0;
	C[0] = 0.0;
	n[0] = 0.0;
	m[0] = 0.0;

	for(i=0;i<amberParameters->numberOfSuttonChen;i++)
	{
		if(
			a1Type == amberParameters->suttonChenTerms[i].numbers[0] &&
			a2Type == amberParameters->suttonChenTerms[i].numbers[1]
		  )
		{
			epsilon[0]    = amberParameters->suttonChenTerms[i].epsilon;
			a[0]    = amberParameters->suttonChenTerms[i].a;
			C[0]    = amberParameters->suttonChenTerms[i].C;
			n[0]    = amberParameters->suttonChenTerms[i].n;
			m[0]    = amberParameters->suttonChenTerms[i].m;
			return TRUE;
		}
	}
	return FALSE;
}
/**********************************************************************/
static boolean getVdw612Parameters(AmberParameters* amberParameters, int atomType, double* r, double* epsilon )
{

	int i;
	r[0] = 1.0;
	epsilon[0] = 0.0;
	
	for(i=0;i<amberParameters->numberOfVdw612;i++)
	{
	//printf("r = %f eps = %f\n",amberParameters->vdw612Terms[i].r, amberParameters->vdw612Terms[i].epsilon);
		if(
			atomType == amberParameters->vdw612Terms[i].number
		  )
		{
			r[0]       = amberParameters->vdw612Terms[i].r;
			epsilon[0]    = amberParameters->vdw612Terms[i].epsilon;
			/*printf("r = %f eps = %f\n",r[0],epsilon[0]);*/
			return TRUE;
		}
	}

	return FALSE;
}
/********************************************************************************************************************************************************/
static boolean getHydrogenBonded612Parameters(AmberParameters* amberParameters, int a1Type, int a2Type, double c[], double d[] , FILE* logFile, char* type1, char* type2)
{
	double equilibriumDistance, epsilon, epsilonProduct, ri,rj;
	double Bij , Aij;

	c[0] = 0.0;
	d[0] = 0.0;
	if ( ! ( getVdw612Parameters(amberParameters, a1Type, &equilibriumDistance, &epsilon ) ) )
	{
		fprintf(logFile, ("**** couldn't find non bonded parameters for %s \n"),type1);
		fflush(logFile);
		return FALSE;
	}
		
	epsilonProduct = sqrt(fabs(epsilon));
	ri = equilibriumDistance;
	if(!getVdw612Parameters(amberParameters, a2Type, &equilibriumDistance, &epsilon )) 
	{
		fprintf(logFile, ("**** couldn't find non bonded parameters for %s \n"), type2);
		fflush(logFile);
		return FALSE;
	}
	epsilonProduct *= sqrt(fabs(epsilon));
	rj = equilibriumDistance;
	Bij = ( ri + rj ) * ( ri + rj );
	Bij = Bij * Bij * Bij;
	Aij = Bij * Bij * epsilonProduct;
	Bij *= epsilonProduct * 2.0;
	c[0] = Aij;
	d[0] = Bij;
	return TRUE;
}
/**********************************************************************/
static boolean getVdw714Parameters(AmberParameters* amberParameters, int atomType, double* r, double* epsilon , double* gamma, double* delta)
{

	int i;
	r[0] = 1.0;
	epsilon[0] = 0.0;
	gamma[0] = 0.07/2.0;
	delta[0] = 0.12/2.0;
	
	for(i=0;i<amberParameters->numberOfVdw714;i++)
	{
	//printf("r = %f eps = %f\n",amberParameters->vdw714Terms[i].r, amberParameters->vdw714Terms[i].epsilon);
		if( atomType == amberParameters->vdw714Terms[i].number)
		{
			r[0]       = amberParameters->vdw714Terms[i].r;
			epsilon[0]    = amberParameters->vdw714Terms[i].epsilon;
			gamma[0]    = amberParameters->vdw714Terms[i].gamma;
			delta[0]    = amberParameters->vdw714Terms[i].delta;
			/*printf("r = %f eps = %f\n",r[0],epsilon[0]);*/
			return TRUE;
		}
	}

	return FALSE;
}
/**********************************************************************/
static boolean getPairWiseParameters(AmberParameters* amberParameters,
	       	int a1Type, int a2Type,
		double* a, double* beta,
	       	 double* c4, double* c6, double* c8, double* c10, double* b)
{

	int i;

	a[0]    = 0.0;
	beta[0] = 1.0;
	c4[0]   = 0.0;
	c6[0]   = 0.0;
	c8[0]   = 0.0;
	c10[0]   = 0.0;
	b[0]    = 1.0;
	for(i=0;i<amberParameters->numberOfPairWise;i++)
	{
		if(
			(
			a1Type == amberParameters->pairWiseTerms[i].numbers[0] &&
			a2Type == amberParameters->pairWiseTerms[i].numbers[1] 
			) ||
			(
			a1Type == amberParameters->pairWiseTerms[i].numbers[1] &&
			a2Type == amberParameters->pairWiseTerms[i].numbers[0]
			)

		  )
		{
			a[0]    = amberParameters->pairWiseTerms[i].a;
			beta[0]    = amberParameters->pairWiseTerms[i].beta;
			c4[0]    = amberParameters->pairWiseTerms[i].c4;
			c6[0]    = amberParameters->pairWiseTerms[i].c6;
			c8[0]    = amberParameters->pairWiseTerms[i].c8;
			c10[0]    = amberParameters->pairWiseTerms[i].c10;
			b[0]    = amberParameters->pairWiseTerms[i].b;
			return TRUE;
		}
	}

	return FALSE;
}
/*********************************************************************************************************************************/
static int getNumberOutOfPlaneParameters( AmberParameters* amberParameters, int a1Type, int a2Type, int a3Type, int a4Type)
{
	int i;
	int a1Typet;
	int a2Typet;
	int a3Typet;
	int a4Typet;

	int a1Typet2;
	int a2Typet2;
	int a3Typet2;
	int a4Typet2;
	boolean btype;
	boolean Ok;
	int types[4];
	int k;

	a1Typet = a4Type;
	a2Typet = a2Type;
	a3Typet = a3Type;
	a4Typet = a1Type;

	a1Typet2 = a3Type;
	a2Typet2 = a2Type;
	a3Typet2 = a1Type;
	a4Typet2 = a4Type;

	/*
	for(i=0;i<amberParameters->numberOfOutOfPlaneTerms;i++)
	{
		for(k=0;k<4;k++) printf("%d ", amberParameters->outOfPlaneTerms[i].numbers[k]);
		printf("\n");
	}
	*/
	/* Je cherche d'abord sans les -1 */
	for(i=0;i<amberParameters->numberOfOutOfPlaneTerms;i++)
	{

		types[0] = a1Type;
		types[1] = a2Type;
		types[2] = a3Type;
		types[3] = a4Type;

		Ok = TRUE;
		for(k=0;k<4;k++)
		{
			btype = (types[k] == amberParameters->outOfPlaneTerms[i].numbers[k]);
			if(!btype)
			{
				Ok = FALSE;
				break;
			}
		}
		if(!Ok)
		{
			types[0] = a1Typet;
			types[1] = a2Typet;
			types[2] = a3Typet;
			types[3] = a4Typet;
			Ok = TRUE;
			for(k=0;k<4;k++)
			{
				btype = (types[k] == amberParameters->outOfPlaneTerms[i].numbers[k]);
				if(!btype)
				{
					Ok = FALSE;
					break;
				}
			}
		}
		if(!Ok)
		{
			types[0] = a1Typet2;
			types[1] = a2Typet2;
			types[2] = a3Typet2;
			types[3] = a4Typet2;
			Ok = TRUE;
			for(k=0;k<4;k++)
			{
				btype = (types[k] == amberParameters->outOfPlaneTerms[i].numbers[k]);
				if(!btype)
				{
					Ok = FALSE;
					break;
				}
			}
		}

			 
		if(Ok)
		{
			return i;
		}
	}
	/* Je cherche d'abord avec les -1 */
	for(i=0;i<amberParameters->numberOfOutOfPlaneTerms;i++)
	{

		types[0] = a1Type;
		types[1] = a2Type;
		types[2] = a3Type;
		types[3] = a4Type;

		Ok = TRUE;
		for(k=0;k<4;k++)
		{
			btype = 
			(amberParameters->outOfPlaneTerms[i].numbers[k] == -1) || 
			(types[k] == amberParameters->outOfPlaneTerms[i].numbers[k]);
			if(!btype)
			{
				Ok = FALSE;
				break;
			}
		}
		if(!Ok)
		{
			types[0] = a1Typet;
			types[1] = a2Typet;
			types[2] = a3Typet;
			types[3] = a4Typet;
			Ok = TRUE;
			for(k=0;k<4;k++)
			{
				btype = 
				(amberParameters->outOfPlaneTerms[i].numbers[k] == -1) || 
				(types[k] == amberParameters->outOfPlaneTerms[i].numbers[k]);
				if(!btype)
				{
					Ok = FALSE;
					break;
				}
			}
		}
		if(!Ok)
		{
			types[0] = a1Typet2;
			types[1] = a2Typet2;
			types[2] = a3Typet2;
			types[3] = a4Typet2;
			Ok = TRUE;
			for(k=0;k<4;k++)
			{
				btype = 
				(amberParameters->outOfPlaneTerms[i].numbers[k] == -1) || 
				(types[k] == amberParameters->outOfPlaneTerms[i].numbers[k]);
				if(!btype)
				{
					Ok = FALSE;
					break;
				}
			}
		}


			 
		if(Ok)
		{
			return i;
		}
	}

	return -1;
}
/**********************************************************************/
static boolean addOutOfPlaneParameters(AmberParameters* amberParameters, int a1, int a2, int a3, int a4, int* atomTypes, double** outOfPlaneTerms, int *pNumberOfOutOfPlaneTerms)
{
	int numberOfOutOfPlaneTerms = *pNumberOfOutOfPlaneTerms;
	
	int a1Type, a2Type, a3Type,a4Type;
	int k;
	a1Type = atomTypes[a1];
	a2Type = atomTypes[a2];
	a3Type = atomTypes[a3];
	a4Type = atomTypes[a4];
	//printf("type a1 a2 a3 a4 = %d %d %d %d\n",a1Type, a2Type, a3Type, a4Type);
	k = getNumberOutOfPlaneParameters(amberParameters, a1Type, a2Type, a3Type, a4Type);
	//printf("k =%d\n",k);
	if(k>-1)
	{
		outOfPlaneTerms[0][numberOfOutOfPlaneTerms] = a1;
		outOfPlaneTerms[1][numberOfOutOfPlaneTerms] = a2;
		outOfPlaneTerms[2][numberOfOutOfPlaneTerms] = a3;
		outOfPlaneTerms[3][numberOfOutOfPlaneTerms] = a4;
		outOfPlaneTerms[4][numberOfOutOfPlaneTerms] = amberParameters->outOfPlaneTerms[k].type;// 0 = ALLINGER, 1 = WDC
		outOfPlaneTerms[5][numberOfOutOfPlaneTerms] = amberParameters->outOfPlaneTerms[k].force;
		outOfPlaneTerms[6][numberOfOutOfPlaneTerms] = amberParameters->outOfPlaneTerms[k].h3;
		outOfPlaneTerms[7][numberOfOutOfPlaneTerms] = amberParameters->outOfPlaneTerms[k].h4;
		outOfPlaneTerms[8][numberOfOutOfPlaneTerms] = amberParameters->outOfPlaneTerms[k].h5;
		outOfPlaneTerms[9][numberOfOutOfPlaneTerms] = amberParameters->outOfPlaneTerms[k].h6;
		numberOfOutOfPlaneTerms++;
		*pNumberOfOutOfPlaneTerms = numberOfOutOfPlaneTerms;
		return TRUE;
	}
	return FALSE;
}
/**********************************************************************/
static void setOutOfPlaneParameters(AmberParameters* amberParameters, ForceField* forceField, int* atomTypes)
{
	int i;
	int j;
	int a1,a2,a3,a4;
	Molecule* m = &forceField->molecule;
	double* outOfPlaneTerms[OUTOFPLANEDIM];
	int numberOfOutOfPlaneTerms = 0;
	int a4j;
	int nc = 0;

	forceField->numberOfOutOfPlaneTerms = 0;
	for( i=0; i<OUTOFPLANEDIM;i++) forceField->outOfPlaneTerms[i] = NULL;
	if(!forceField->options.outOfPlane) return;

	/*  6 terms 1=a1, 2=a2, 3=a3, 4=a4, 5=force  6=h3 7=h4 8=h5 9=h6*/
	/*  OUTOFPLANEDIM 9 */

	for( i=0; i<OUTOFPLANEDIM;i++) outOfPlaneTerms[i] =  malloc(3*m->numberOf3Connections*sizeof(double)); 

	numberOfOutOfPlaneTerms = 0;

	for (  i = 0; i < m->numberOf3Connections; i++ )
	{
		a1 = m->connected3[0][i];
		a2 = m->connected3[1][i];
		a3 = m->connected3[2][i];
		a4 = -1;
		nc = 0;
		for (  j = 0; j < m->numberOf2Connections; j++ ) if(m->connected2[0][j] == a2 || m->connected2[1][j] == a2) nc++;
		//printf("a2 = %d nc = %d\n",a2,nc);
		if(nc!=3) continue;

		for (  j = 0; j < m->numberOf2Connections; j++ )
		{
			if(m->connected2[0][j] != a2 && m->connected2[1][j] != a2) continue;
			a4j = m->connected2[0][j]; 
			if(m->connected2[0][j] == a2) a4j = m->connected2[1][j];
			if(a4j == a1) continue;
			if(a4j == a3) continue;
			a4 = a4j;
			break;
		}
		//printf("a1 a2 a3 a4 = %d %d %d %d\n",a1, a2, a3, a4);
		if(a4<0) continue;

		addOutOfPlaneParameters(amberParameters, a1, a2, a3, a4, atomTypes, outOfPlaneTerms, &numberOfOutOfPlaneTerms);
		addOutOfPlaneParameters(amberParameters, a3, a2, a1, a4, atomTypes, outOfPlaneTerms, &numberOfOutOfPlaneTerms);
		addOutOfPlaneParameters(amberParameters, a4, a2, a3, a1, atomTypes, outOfPlaneTerms, &numberOfOutOfPlaneTerms);
	}

	forceField->numberOfOutOfPlaneTerms = numberOfOutOfPlaneTerms;
	for( i=0; i<OUTOFPLANEDIM;i++) forceField->outOfPlaneTerms[i] = outOfPlaneTerms[i]; 
	//printf("numberOfOutOfPlaneTerms=%d\n",numberOfOutOfPlaneTerms);
	//printf("numberOfOutOfPlaneParams=%d\n",amberParameters->numberOfOutOfPlaneTerms);
}
/**********************************************************************/
static int getNumberDihedralParameters( AmberParameters* amberParameters,
		int a1Type, int a2Type, int a3Type, int a4Type,
		int *n)
{
	int i;
	int a1Typet;
	int a2Typet;
	int a3Typet;
	int a4Typet;
	boolean btype;
	boolean Ok;
	int types[4];
	int k;

	*n = 0;

	a1Typet = a4Type;
	a2Typet = a3Type;
	a3Typet = a2Type;
	a4Typet = a1Type;

	/* Je cherche d'abord sans les -1 */
	for(i=0;i<amberParameters->numberOfDihedralTerms;i++)
	{

		types[0] = a1Type;
		types[1] = a2Type;
		types[2] = a3Type;
		types[3] = a4Type;

		Ok = TRUE;
		for(k=0;k<4;k++)
		{
			btype = (types[k] == amberParameters->dihedralAngleTerms[i].numbers[k]);
			if(!btype)
			{
				Ok = FALSE;
				break;
			}
		}
		if(!Ok)
		{
			types[0] = a1Typet;
			types[1] = a2Typet;
			types[2] = a3Typet;
			types[3] = a4Typet;
			Ok = TRUE;
			for(k=0;k<4;k++)
			{
				btype = (types[k] == amberParameters->dihedralAngleTerms[i].numbers[k]);
				if(!btype)
				{
					Ok = FALSE;
					break;
				}
			}
		}

			 
		if(Ok)
		{
			*n =i;
			return amberParameters->dihedralAngleTerms[i].nSomme;
		}
	}
	/* Je cherche d'abord avec les -1 */
	for(i=0;i<amberParameters->numberOfDihedralTerms;i++)
	{

		types[0] = a1Type;
		types[1] = a2Type;
		types[2] = a3Type;
		types[3] = a4Type;

		Ok = TRUE;
		for(k=0;k<4;k++)
		{
			btype = 
			(amberParameters->dihedralAngleTerms[i].numbers[k] == -1) || 
			(types[k] == amberParameters->dihedralAngleTerms[i].numbers[k]);
			if(!btype)
			{
				Ok = FALSE;
				break;
			}
		}
		if(!Ok)
		{
			types[0] = a1Typet;
			types[1] = a2Typet;
			types[2] = a3Typet;
			types[3] = a4Typet;
			Ok = TRUE;
			for(k=0;k<4;k++)
			{
				btype = 
				(amberParameters->dihedralAngleTerms[i].numbers[k] == -1) || 
				(types[k] == amberParameters->dihedralAngleTerms[i].numbers[k]);
				if(!btype)
				{
					Ok = FALSE;
					break;
				}
			}
		}

			 
		if(Ok)
		{
			*n =i;
			return amberParameters->dihedralAngleTerms[i].nSomme;
		}
	}

	return 0;
}

/**********************************************************************/
static boolean canHydrogenBond(AmberParameters* amberParameters, int a1Type, int a2Type )
{
	AmberAtomTypes* types = amberParameters->atomTypes;
	int nTypes = amberParameters->numberOfTypes;
	int a1=-1,a2=-1;
	int i;

	if( a1Type<0 || a2Type<0) return FALSE;
	for(i=0;i<nTypes;i++)
	{
		if(types[i].number==a1Type) a1 = i;
		if(types[i].number==a2Type) a2 = i;
	}
	if( a1<0 || a2<0) return FALSE;
	if( types[a1].name[0] == 'H' || types[a2].name[0] == 'H') return TRUE;

	return FALSE;
}
/**********************************************************************/
static boolean canSuttonChen(ForceField* forceField, int a)
{

	int i;
	for (  i = 0; i < forceField->numberOfSuttonChen; i++ )
	{
		int b1,b2;
		b1 = (int)forceField->suttonChenTerms[0][i];
		b2 = (int)forceField->suttonChenTerms[1][i];
		if(a==b1 || a==b2) return TRUE;
	}

	return FALSE;
}
/**********************************************************************/
static void setRattleConstraintsParameters(ForceField* forceField)
{
	Molecule* m = &forceField->molecule;
	m->klass->resetConstraints(m,forceField->options.rattleConstraints);
}
/**********************************************************************/
static void setStretchParameters(AmberParameters* amberParameters,ForceField* forceField,int* atomTypes)
{
	int i;
	int a1,a2;
	int type;
	int a1Type, a2Type;
	double forceOrAlpha, equilibriumDistance;
	double h3OrDe,h4,h5,h6;
	Molecule* m = &forceField->molecule;
	int numberOfStretchTerms = 0;
	double* bondStretchTerms[STRETCHDIM];

	if(!forceField->options.bondStretch) return;

	numberOfStretchTerms = m->numberOf2Connections;
	for( i=0; i<STRETCHDIM;i++)
       		bondStretchTerms[i] = malloc(numberOfStretchTerms*sizeof(double));

	/* 1=a1, 2=a2, 3=Force, 4=Re  h3 h4 h5 h6*/
	/* STRETCHDIM 	8 */
	for ( i = 0; i < numberOfStretchTerms; i++ )
	{
		a1 = m->connected2[0][i];
		a2 = m->connected2[1][i];
		a1Type = atomTypes[a1];
		a2Type = atomTypes[a2];
		
		if ( ! (getStretchParameters(amberParameters, a1Type, a2Type,&forceOrAlpha,&equilibriumDistance,&h3OrDe,&h4,&h5,&h6,&type) ) )
		{
			/*
			char l1 = m->atoms[a1].mmType[0];
			char l2 = m->atoms[a2].mmType[0];
			*/
			fprintf(forceField->logfile,  ("**** couldn't find stretch parameters for %s-%s(%d-%d) "), 
				m->atoms[a1].mmType,m->atoms[a2].mmType,a1Type, a2Type);
			fprintf(forceField->logfile, "\n");
			fflush(forceField->logfile);
			bondStretchTerms[0][i] = type;
			bondStretchTerms[1][i] = a1;
			bondStretchTerms[2][i] = a2;
			bondStretchTerms[3][i] = forceOrAlpha;
			bondStretchTerms[4][i] = equilibriumDistance;
			bondStretchTerms[5][i] = h3OrDe;
			bondStretchTerms[6][i] = h4;
			bondStretchTerms[7][i] = h5;
			bondStretchTerms[8][i] = h6;
		}
		else
		{
			bondStretchTerms[0][i] = type;
			bondStretchTerms[1][i] = a1;
			bondStretchTerms[2][i] = a2;
			bondStretchTerms[3][i] = forceOrAlpha;
			bondStretchTerms[4][i] = equilibriumDistance;
			bondStretchTerms[5][i] = h3OrDe;
			bondStretchTerms[6][i] = h4;
			bondStretchTerms[7][i] = h5;
			bondStretchTerms[8][i] = h6;
		}
	}

	forceField->numberOfStretchTerms = numberOfStretchTerms;
	for( i=0; i<STRETCHDIM;i++)
       		forceField->bondStretchTerms[i] = bondStretchTerms[i]; 
}
/**********************************************************************/
static void setBendParameters(AmberParameters* amberParameters,ForceField* forceField,int* atomTypes)
{
	int i;
	int a1,a2,a3;
	int a1Type, a2Type, a3Type;
	Molecule* m = &forceField->molecule;
	int numberOfBendTerms = 0;
	double* angleBendTerms[BENDDIM];
	double forceConstant, equilibriumAngle;
	double h3,h4,h5,h6;

	forceField-> numberOfBendTerms = 0;
	for( i=0; i<BENDDIM;i++) forceField->angleBendTerms[i] = NULL;
	if(!forceField->options.angleBend) return;

	numberOfBendTerms =  m->numberOf3Connections;
	for( i=0; i<BENDDIM;i++)
		angleBendTerms[i] =  malloc(numberOfBendTerms*sizeof(double)); 

	/* 5 terms 1=a1, 2=a2, 3=a3, 4=Force, 5=angle  h3 h4 h5 h6*/
	/* BENDDIM 9 */
	for ( i = 0; i < numberOfBendTerms; i++ )
	{
		a1 = m->connected3[0][i];
		a2 = m->connected3[1][i];
		a3 = m->connected3[2][i];
		a1Type = atomTypes[a1];
		a2Type = atomTypes[a2];
		a3Type = atomTypes[a3];

		if ( ! ( getBendParameters(amberParameters, a1Type, a2Type, a3Type,&forceConstant,&equilibriumAngle, &h3, &h4, &h5, &h6) ) )
		{
			/*
			char l1 = m->atoms[a1].mmType[0];
			char l2 = m->atoms[a2].mmType[0];
			char l3 = m->atoms[a3].mmType[0];
			*/
			fprintf(forceField->logfile, ("**** couldn't find bend parameters for %s-%s-%s "),
			m->atoms[a1].mmType,m->atoms[a2].mmType,m->atoms[a3].mmType);
			fprintf(forceField->logfile, "\n");
			fflush(forceField->logfile);
			/*
			forceConstant = 60.0;
			equilibriumAngle = 115.0;
			if(!strcmp(m->atoms[a2].mmType,"CT"))
			{
				forceConstant = 50.0;
				equilibriumAngle = 109.0;
			}
			else
			if(l1=='H' || l2=='H' || l3=='H')
			{
				forceConstant = 50.0;
				equilibriumAngle = 120.0;
			}
			if(isIonic( m->atoms[a1].mmType) || isIonic( m->atoms[a2].mmType) ||  isIonic( m->atoms[a3].mmType))
			{
				forceConstant = 0;
			}
			fprintf(forceField->logfile, ("-> I set force to %f and equilibrium angle to %f\n"), forceConstant, equilibriumAngle);
			fflush(forceField->logfile);
			*/
			angleBendTerms[0][i] = a1;
			angleBendTerms[1][i] = a2;
			angleBendTerms[2][i] = a3;
			angleBendTerms[3][i] = forceConstant;
			angleBendTerms[4][i] = equilibriumAngle;
			angleBendTerms[5][i] = h3;
			angleBendTerms[6][i] = h4;
			angleBendTerms[7][i] = h5;
			angleBendTerms[8][i] = h6;
		}
		else
		{
			angleBendTerms[0][i] = a1;
			angleBendTerms[1][i] = a2;
			angleBendTerms[2][i] = a3;
			angleBendTerms[3][i] = forceConstant;
			angleBendTerms[4][i] = equilibriumAngle;
			angleBendTerms[5][i] = h3;
			angleBendTerms[6][i] = h4;
			angleBendTerms[7][i] = h5;
			angleBendTerms[8][i] = h6;
		}
	}

	forceField-> numberOfBendTerms = numberOfBendTerms;
	for( i=0; i<BENDDIM;i++)
       		forceField->angleBendTerms[i] = angleBendTerms[i]; 

}
/**********************************************************************/
static void setStrBendParameters(AmberParameters* amberParameters,ForceField* forceField,int* atomTypes)
{
	int i;
	int a1,a2,a3;
	int a1Type, a2Type, a3Type;
	int type1, type2;
	Molecule* m = &forceField->molecule;
	int numberOfBendTerms = 0;
	int numberOfStrBendTerms = 0;
	double* strBendTerms[STRBENDDIM];
	double forceConstant, equilibriumAngle;
	double forceConstant12, forceConstant23;
	double alpha12, alpha23;
	double Re12, Re23;
	int nTerms = 0;
	double h3,h4,h5,h6;
	double h3OrDe1, h3OrDe2;

	if(!forceField->options.strBend) return;

	numberOfBendTerms =  m->numberOf3Connections;
	numberOfStrBendTerms =  m->numberOf3Connections;
	for( i=0; i<STRBENDDIM;i++) strBendTerms[i] =  malloc(numberOfStrBendTerms*sizeof(double)); 

	/* 8 terms 1=a1, 2=a2, 3=a3, 4=Force12, 5=Force23, 6=Re12 7=Re23 8=Angle0*/
	/* STRBENDDIM 8 */
	for ( i = 0; i < numberOfBendTerms; i++ )
	{
		a1 = m->connected3[0][i];
		a2 = m->connected3[1][i];
		a3 = m->connected3[2][i];
		a1Type = atomTypes[a1];
		a2Type = atomTypes[a2];
		a3Type = atomTypes[a3];

		if ( ( getBendParameters(amberParameters, a1Type, a2Type, a3Type,&forceConstant,&equilibriumAngle, &h3, &h4, &h5, &h6) ) )
		{
			if ( getStrBendParameters(amberParameters, a1Type, a2Type, a3Type,&forceConstant12,&forceConstant23)
			     &&
			     getStretchParameters(amberParameters, a1Type, a2Type,&alpha12,&Re12,&h3OrDe1,&h4,&h5,&h6,&type1)
			     && 
			     getStretchParameters(amberParameters, a2Type, a3Type,&alpha23,&Re23,&h3OrDe2,&h4,&h5,&h6,&type2) 
			)
			{
				strBendTerms[0][nTerms] = type1;
				strBendTerms[1][nTerms] = type2;
				strBendTerms[2][nTerms] = a1;
				strBendTerms[3][nTerms] = a2;
				strBendTerms[4][nTerms] = a3;
				strBendTerms[5][nTerms] = forceConstant12;
				strBendTerms[6][nTerms] = forceConstant23;
				strBendTerms[10][nTerms] = 0.0;
				strBendTerms[11][nTerms] = 0.0;
				/*
				if(type1==0) strBendTerms[5][nTerms] = forceConstant12;
				else{
					double De=h3OrDe1;
					strBendTerms[5][nTerms] = 0;
					if(fabs(De)>1e-13) strBendTerms[5][nTerms] = sqrt(forceConstant12/2.0/De);
					strBendTerms[10][nTerms] = De;
				}
				if(type2==0) strBendTerms[6][nTerms] = forceConstant23;
				else {
					double De=h3OrDe2;
					strBendTerms[6][nTerms] = 0;
					if(fabs(De)>1e-13) strBendTerms[6][nTerms] = sqrt(forceConstant23/2.0/De);
					strBendTerms[11][nTerms] = De;
				}
				*/
				strBendTerms[7][nTerms] = Re12;
				strBendTerms[8][nTerms] = Re23;
				strBendTerms[9][nTerms] = equilibriumAngle;
				nTerms++;
			}
		}
	}

	forceField->numberOfStrBendTerms = nTerms;
	for( i=0; i<STRBENDDIM;i++)
       		forceField->strBendTerms[i] = strBendTerms[i]; 
	//printf("numberOfStrBendTerms =%d\n",numberOfStrBendTerms);
}
/**********************************************************************/
static void setDihedralParameters(AmberParameters* amberParameters,ForceField* forceField,int* atomTypes)
{
	int i;
	int j;
	int k;
	int l;
	int a1,a2,a3,a4;
	int a1Type, a2Type, a3Type,a4Type;
	Molecule* m = &forceField->molecule;
	double* dihedralAngleTerms[DIHEDRALDIM];
	int numberOfDihedralTerms = 0;
	int dim;

	if(!forceField->options.dihedralAngle) return;
	/*  8 terms 1=a1, 2=a2, 3=a3, 4=a4, 5=Idiv, 6=Pk, 7=Phase, 8=Pn */
	/*  DIHEDRALDIM	8 */

	for( i=0; i<DIHEDRALDIM;i++)
		dihedralAngleTerms[i] =  malloc(4*m->numberOf4Connections*sizeof(double)); 

	numberOfDihedralTerms = 0;

	for (  i = 0; i < m->numberOf4Connections; i++ )
	{
		a1 = m->connected4[0][i];
		a2 = m->connected4[1][i];
		a3 = m->connected4[2][i];
		a4 = m->connected4[3][i];

		a1Type = atomTypes[a1];
		a2Type = atomTypes[a2];
		a3Type = atomTypes[a3];
		a4Type = atomTypes[a4];

		dim = getNumberDihedralParameters(amberParameters, a1Type, a2Type, a3Type, a4Type,&k);
		if(dim>0)
		{
			for(j=0;j<dim;j++)
			{
				dihedralAngleTerms[0][numberOfDihedralTerms] = a1;
				dihedralAngleTerms[1][numberOfDihedralTerms] = a2;
				dihedralAngleTerms[2][numberOfDihedralTerms] = a3;
				dihedralAngleTerms[3][numberOfDihedralTerms] = a4;
				dihedralAngleTerms[4][numberOfDihedralTerms] = 
					amberParameters->dihedralAngleTerms[k].divisor[j];
				dihedralAngleTerms[5][numberOfDihedralTerms] = 
					amberParameters->dihedralAngleTerms[k].barrier[j];
				dihedralAngleTerms[6][numberOfDihedralTerms] = 
					amberParameters->dihedralAngleTerms[k].phase[j];
				dihedralAngleTerms[7][numberOfDihedralTerms] = 
					amberParameters->dihedralAngleTerms[k].n[j];

				numberOfDihedralTerms++;
				if(numberOfDihedralTerms>4*m->numberOf4Connections)
				{
					for( l=0; l<DIHEDRALDIM;l++)
					{
						dihedralAngleTerms[l] =  
						realloc(dihedralAngleTerms[l],numberOfDihedralTerms*sizeof(double)); 
					}

				}
			}
		}		
	}

	forceField-> numberOfDihedralTerms = numberOfDihedralTerms;
	for( i=0; i<DIHEDRALDIM;i++)
       		forceField->dihedralAngleTerms[i] = dihedralAngleTerms[i]; 
}

/**********************************************************************/
static int getNumberImproperTorsionParameters( AmberParameters* amberParameters, int a1Type, int a2Type, int a3Type, int a4Type)
{
	int i;
	int a1Typet;
	int a2Typet;
	int a3Typet;
	int a4Typet;
	boolean btype;
	boolean Ok;
	int types[4];
	int k;

	a1Typet = a4Type;
	a2Typet = a3Type;
	a3Typet = a2Type;
	a4Typet = a1Type;

	/* Je cherche d'abord sans les -1 */
	for(i=0;i<amberParameters->numberOfImproperTorsionTerms;i++)
	{

		types[0] = a1Type;
		types[1] = a2Type;
		types[2] = a3Type;
		types[3] = a4Type;

		Ok = TRUE;
		for(k=0;k<4;k++)
		{
			btype = (types[k] == amberParameters->improperTorsionTerms[i].numbers[k]);
			if(!btype)
			{
				Ok = FALSE;
				break;
			}
		}
		if(!Ok)
		{
			types[0] = a1Typet;
			types[1] = a2Typet;
			types[2] = a3Typet;
			types[3] = a4Typet;
			Ok = TRUE;
			for(k=0;k<4;k++)
			{
				btype = (types[k] == amberParameters->improperTorsionTerms[i].numbers[k]);
				if(!btype)
				{
					Ok = FALSE;
					break;
				}
			}
		}

			 
		if(Ok)
		{
			return i;
		}
	}
	/* Je cherche d'abord avec les -1 */
	for(i=0;i<amberParameters->numberOfImproperTorsionTerms;i++)
	{

		types[0] = a1Type;
		types[1] = a2Type;
		types[2] = a3Type;
		types[3] = a4Type;

		Ok = TRUE;
		for(k=0;k<4;k++)
		{
			btype = 
			(amberParameters->improperTorsionTerms[i].numbers[k] == -1) || 
			(types[k] == amberParameters->improperTorsionTerms[i].numbers[k]);
			if(!btype)
			{
				Ok = FALSE;
				break;
			}
		}
		if(!Ok)
		{
			types[0] = a1Typet;
			types[1] = a2Typet;
			types[2] = a3Typet;
			types[3] = a4Typet;
			Ok = TRUE;
			for(k=0;k<4;k++)
			{
				btype = 
				(amberParameters->improperTorsionTerms[i].numbers[k] == -1) || 
				(types[k] == amberParameters->improperTorsionTerms[i].numbers[k]);
				if(!btype)
				{
					Ok = FALSE;
					break;
				}
			}
		}

			 
		if(Ok)
		{
			return i;
		}
	}

	return -1;
}
/**********************************************************************/
static boolean addImproperTorsionParameters(AmberParameters* amberParameters, int a1, int a2, int a3, int a4, int* atomTypes, double** improperTorsionTerms, int *pNumberOfImproperTorsionTerms)
{
	int i = *pNumberOfImproperTorsionTerms;
	
	int a1Type, a2Type, a3Type,a4Type;
	int n;
	a1Type = atomTypes[a1];
	a2Type = atomTypes[a2];
	a3Type = atomTypes[a3];
	a4Type = atomTypes[a4];
	printf("type a1 a2 a3 a4 = %d %d %d %d\n",a1Type, a2Type, a3Type, a4Type);
	n = getNumberImproperTorsionParameters(amberParameters, a1Type, a2Type, a3Type, a4Type);
	printf("n =%d\n",n);
	if(n>-1)
	{
		improperTorsionTerms[0][i] = a1;
		improperTorsionTerms[1][i] = a2;
		improperTorsionTerms[2][i] = a3;
		improperTorsionTerms[3][i] = a4;
		improperTorsionTerms[4][i] = amberParameters->improperTorsionTerms[n].barrier;
		improperTorsionTerms[5][i] = amberParameters->improperTorsionTerms[n].phase;
		improperTorsionTerms[6][i] = amberParameters->improperTorsionTerms[n].n;
		i++;
		*pNumberOfImproperTorsionTerms = i;
		return TRUE;
	}
	return FALSE;
}
/**********************************************************************/
static void setImproperTorionParameters(AmberParameters* amberParameters, ForceField* forceField,int* atomTypes)
{
	int i;
	int a1,a2,a3,a4;
	Molecule* m = &forceField->molecule;
	int numberOfImproperTorsionTerms = 0;
	double* improperTorsionTerms[IMPROPERDIHEDRALDIM];

	if(!forceField->options.improperTorsion) return;
	/*  8 terms 1=a1, 2=a2, 3=a3, 4=a4, 5=Idiv, 6=Pk, 7=Phase, 8=Pn */
	/*  IMPROPERDIHEDRALDIM	8 */

	for( i=0; i<IMPROPERDIHEDRALDIM;i++) improperTorsionTerms[i] =  malloc(6*m->numberOf3Connections*sizeof(double)); 

	numberOfImproperTorsionTerms = 0;

	for (  i = 0; i < m->numberOf3Connections; i++ )
	{
		int nc = 0;
		int j;
		int a4j;
		a1 = m->connected3[0][i];
		a2 = m->connected3[1][i];
		a3 = m->connected3[2][i];
		a4 = -1;
		
		for (  j = 0; j < m->numberOf2Connections; j++ ) if(m->connected2[0][j] == a2 || m->connected2[1][j] == a2) nc++;
		printf("a2 = %d nc = %d\n",a2,nc);
		if(nc!=3) continue;

		for (  j = 0; j < m->numberOf2Connections; j++ )
		{
			if(m->connected2[0][j] != a2 && m->connected2[1][j] != a2) continue;
			a4j = m->connected2[0][j]; 
			if(m->connected2[0][j] == a2) a4j = m->connected2[1][j];
			if(a4j == a1) continue;
			if(a4j == a3) continue;
			a4 = a4j;
			break;
		}
		printf("a1 a2 a3 a4 = %d %d %d %d\n",a1, a2, a3, a4);
		if(a4<0) continue;
		addImproperTorsionParameters(amberParameters, a1, a3, a2, a4, atomTypes, improperTorsionTerms, &numberOfImproperTorsionTerms);
		addImproperTorsionParameters(amberParameters, a3, a1, a2, a4, atomTypes, improperTorsionTerms, &numberOfImproperTorsionTerms);
		addImproperTorsionParameters(amberParameters, a1, a4, a2, a3, atomTypes, improperTorsionTerms, &numberOfImproperTorsionTerms);
		addImproperTorsionParameters(amberParameters, a4, a1, a2, a3, atomTypes, improperTorsionTerms, &numberOfImproperTorsionTerms);
		addImproperTorsionParameters(amberParameters, a3, a4, a2, a1, atomTypes, improperTorsionTerms, &numberOfImproperTorsionTerms);
		addImproperTorsionParameters(amberParameters, a4, a3, a2, a1, atomTypes, improperTorsionTerms, &numberOfImproperTorsionTerms);

	}

	forceField-> numberOfImproperTorsionTerms = numberOfImproperTorsionTerms;
	for( i=0; i<IMPROPERDIHEDRALDIM;i++) forceField->improperTorsionTerms[i] = improperTorsionTerms[i]; 

}
/**********************************************************************/
static void setHydrogenBondedParameters(AmberParameters* amberParameters,ForceField* forceField,int* atomTypes)
{
	int numberOfHydrogenBonded = 0;
	int i,j;
	int a1,a2,a4,ax;
	int a1Type,a2Type,a4Type;
	Molecule* m = &forceField->molecule;
	double C, D; // C = alpha, D = Re for Morse, C = A12 and D = A6 for 6-12 , C = A12 and D = A10 for 10-12
	double De;
	double* hydrogenBondedTerms[HYDROGENBONDEDDIM];
	if(!forceField->options.hydrogenBonded612 && !forceField->options.hydrogenBonded1012 && !forceField->options.hydrogenBondedMorse) return;


	for( i=0; i<HYDROGENBONDEDDIM;i++)
		hydrogenBondedTerms[i] =  malloc((m->numberOfNonBonded+m->numberOf4Connections)*sizeof(double));

	for ( i = 0; i < m->numberOfNonBonded; i++ )
	{
		boolean suttonChena1 = FALSE;
		boolean suttonChena2 = FALSE;
		a1 = m->nonBonded[0][i];
		a2 = m->nonBonded[1][i];
		ax = -1;

		a1Type = atomTypes[a1];
		a2Type = atomTypes[a2];
		suttonChena1 = canSuttonChen(forceField, a1);
		suttonChena2 = canSuttonChen(forceField, a2);
		if ( suttonChena1 || suttonChena2 ) continue;

		if ( canHydrogenBond( amberParameters, a1Type, a2Type ) )
		{ 
			De = 0.0;
			if(forceField->options.hydrogenBonded612) getHydrogenBonded612Parameters(amberParameters, a1Type, a2Type, &C, &D, forceField->logfile, m->atoms[a1].mmType, m->atoms[a2].mmType);
			else if(forceField->options.hydrogenBonded1012)  getHydrogenBonded1012Parameters(amberParameters, a1Type, a2Type, &C, &D );
			else getHydrogenBondedMorseParameters(amberParameters, a1Type, a2Type, &C, &D, &De );

			if(fabs(C)<1e-13 && fabs(D)<1e-13) continue;
			if(forceField->options.hbDirectional) 
			{
				int aH = a1;
				ax = -1;
				if(m->atoms[a2].mmType[0]=='H') aH = a2;
				for (  j = 0; j < m->numberOf2Connections; j++ ) 
				{
					if(m->connected2[0][j] == aH) { ax = m->connected2[1][j]; break;};
					if(m->connected2[1][j] == aH) { ax = m->connected2[0][j]; break;};
				}
			}
			hydrogenBondedTerms[0][numberOfHydrogenBonded] = a1;
			hydrogenBondedTerms[1][numberOfHydrogenBonded] = a2;
			hydrogenBondedTerms[2][numberOfHydrogenBonded] = ax;
			hydrogenBondedTerms[3][numberOfHydrogenBonded] = C;
			hydrogenBondedTerms[4][numberOfHydrogenBonded] = D;
			hydrogenBondedTerms[5][numberOfHydrogenBonded] = De;
			numberOfHydrogenBonded++;
		}
	}
	/* now 1/2 non bonded */
	for (  i = 0; i < m->numberOf4Connections; i++ )
	{
		boolean suttonChena1 = FALSE;
		boolean suttonChena4 = FALSE;

		a1 = m->connected4[0][i];
		a4 = m->connected4[3][i];
		ax = -1;
		if(forceField->options.hbDirectional) 
		{
			if(m->atoms[a1].mmType[0] =='H') ax =  m->connected4[1][i];
			else ax =  m->connected4[2][i];
		}

		a1Type = atomTypes[a1];
		a4Type = atomTypes[a4];
		suttonChena1 = canSuttonChen(forceField, a1);
		suttonChena4 = canSuttonChen(forceField, a4);
		if ( suttonChena1 || suttonChena4 ) continue;
		if ( canHydrogenBond( amberParameters, a1Type, a4Type ) )
		{ 
			De = 0;
			if(forceField->options.hydrogenBonded612) 
			{
				getHydrogenBonded612Parameters(amberParameters, a1Type, a4Type, &C, &D, forceField->logfile, m->atoms[a1].mmType, m->atoms[a4].mmType);
				C /= 2.0;
				D /= 2.0;
			}
			else if(forceField->options.hydrogenBonded1012)  
			{
				getHydrogenBonded1012Parameters(amberParameters, a1Type, a4Type, &C, &D );
				C /= 2.0;
				D /= 2.0;
			}
			else 
			{
				getHydrogenBondedMorseParameters(amberParameters, a1Type, a4Type, &C, &D, &De );
				De /= 2;
			}
			if(fabs(C)<1e-13 && fabs(D)<1e-13) continue;
			hydrogenBondedTerms[0][numberOfHydrogenBonded] = a1;
			hydrogenBondedTerms[1][numberOfHydrogenBonded] = a4;
			hydrogenBondedTerms[2][numberOfHydrogenBonded] = ax;
			hydrogenBondedTerms[3][numberOfHydrogenBonded] = C;
			hydrogenBondedTerms[4][numberOfHydrogenBonded] = D;
			hydrogenBondedTerms[5][numberOfHydrogenBonded] = De;
			numberOfHydrogenBonded++;
		}
	}

	if(numberOfHydrogenBonded==0)
		for( i=0; i<HYDROGENBONDEDDIM;i++)
		{
			free(hydrogenBondedTerms[i]);
			hydrogenBondedTerms[i] = NULL;
		}
	else
		for( i=0; i<HYDROGENBONDEDDIM;i++)
		{
			hydrogenBondedTerms[i] = 
				realloc(hydrogenBondedTerms[i],numberOfHydrogenBonded*sizeof(double));
		}

	forceField-> numberOfHydrogenBonded = numberOfHydrogenBonded;
	for( i=0; i<HYDROGENBONDEDDIM;i++)
       		forceField->hydrogenBondedTerms[i] = hydrogenBondedTerms[i]; 
	printf("numberOfHydrogenBonded=%d\n",numberOfHydrogenBonded);

}
/**********************************************************************/
static void setVdw612Parameters(AmberParameters* amberParameters, ForceField* forceField,int* atomTypes)
{
	int numberOfVdw612 = 0;
	int i;
	int a1,a2,a4;
	int a1Type,a2Type,a4Type;
	Molecule* m = &forceField->molecule;
	double equilibriumDistance, epsilon;
	double epsilonProduct;
	double ri, rj;
	double Aij, Bij;
	double* vdw612Terms[VDW612DIM];
	boolean useHydrogenBonded = forceField->options.hydrogenBonded612 || forceField->options.hydrogenBonded1012 || forceField->options.hydrogenBondedMorse;

	if(!forceField->options.vdw612) return;

	/* 5 terms 1=a1, 2=a2, 3=Aij, 4=Bij*/
	/* VDW612DIM 4 */
	for( i=0; i<VDW612DIM;i++) vdw612Terms[i] =  malloc((m->numberOfNonBonded+m->numberOf4Connections)*sizeof(double)); 

	for ( i = 0; i < m->numberOfNonBonded; i++ )
	{
		boolean suttonChena1 = FALSE;
		boolean suttonChena2 = FALSE;

		a1 = m->nonBonded[0][i];
		a2 = m->nonBonded[1][i];
		a1Type = atomTypes[a1];
		a2Type = atomTypes[a2];

		suttonChena1 = canSuttonChen(forceField, a1);
		suttonChena2 = canSuttonChen(forceField, a2);
		if ( suttonChena1 || suttonChena2 ) continue;

		if ( !useHydrogenBonded || !canHydrogenBond(amberParameters, a1Type, a2Type ) )
		{ 
			if ( ! ( getVdw612Parameters(amberParameters, a1Type, &equilibriumDistance, &epsilon ) ) )
			{
				fprintf(forceField->logfile, ("**** couldn't find non bonded parameters for %s \n"),m->atoms[a1].mmType);
				fflush(forceField->logfile);
			}
		
			epsilonProduct = sqrt(fabs(epsilon));
			ri = equilibriumDistance;
			/*printf("r1 = %f eps1 = %f\n",equilibriumDistance,epsilon);*/

			getVdw612Parameters(amberParameters, a2Type, &equilibriumDistance, &epsilon );
			/*printf("r2 = %f eps2 = %f\n",equilibriumDistance,epsilon);*/
			epsilonProduct *= sqrt(fabs(epsilon));
			rj = equilibriumDistance;
			Bij = ( ri + rj ) * ( ri + rj );
			Bij = Bij * Bij * Bij;
			Aij = Bij * Bij * epsilonProduct;
			Bij *= epsilonProduct * 2.0;
			if(fabs(Aij)<1e-13 && fabs(Bij)<1e-13) continue;
			/*
			if(a1Type==64 || a2Type==64)
			{
				printf("Aij = %f\n",Aij);
				printf("Bij = %f\n",Bij);
			}
			*/

			vdw612Terms[0][numberOfVdw612] = a1;
			vdw612Terms[1][numberOfVdw612] = a2;
			vdw612Terms[2][numberOfVdw612] = Aij;
			vdw612Terms[3][numberOfVdw612] = Bij;
			numberOfVdw612++;
		}
	}

	/* now 1/2 non bonded */
	for (  i = 0; i < m->numberOf4Connections; i++ )
	{
		boolean suttonChena1 = FALSE;
		boolean suttonChena4 = FALSE;

		a1 = m->connected4[0][i];
		a4 = m->connected4[3][i];
		a1Type = atomTypes[a1];
		a4Type = atomTypes[a4];
		suttonChena1 = canSuttonChen(forceField, a1);
		suttonChena4 = canSuttonChen(forceField, a4);
		if ( suttonChena1 || suttonChena4 ) continue;
		epsilonProduct = 0;
		ri = 0;
		rj = 0;
	        if ( getVdw612Parameters(amberParameters, a1Type, &equilibriumDistance, &epsilon ) )
		{
	        	epsilonProduct = sqrt(fabs(epsilon));
	        	ri = equilibriumDistance;
			/*printf("r1 = %f eps1 = %f\n",equilibriumDistance,epsilon);*/
		}
		else
		{
			epsilonProduct = 0;
		}

	        if ( getVdw612Parameters( amberParameters, a4Type, &equilibriumDistance, &epsilon ) )
		{
	        	epsilonProduct *= sqrt(fabs(epsilon));
	        	rj = equilibriumDistance;
			/*printf("r2 = %f eps2 = %f\n",equilibriumDistance,epsilon);*/
		}
		else
		{
			epsilonProduct = 0;
		}

	       	Bij = ( ri + rj ) * ( ri + rj );
	       	Bij = Bij * Bij * Bij;
	       	Aij = Bij * Bij * epsilonProduct / 2.0;
	       	Bij *= epsilonProduct;
		if(fabs(Aij)<1e-13 && fabs(Bij)<1e-13) continue;

		/*
			Aij = 0;
			Bij = 0;
		*/

		vdw612Terms[0][numberOfVdw612] = a1;
		vdw612Terms[1][numberOfVdw612] = a4;
		vdw612Terms[2][numberOfVdw612] = Aij;
		vdw612Terms[3][numberOfVdw612] = Bij;
		numberOfVdw612++;
	}
	if(numberOfVdw612==0)
		for( i=0; i<VDW612DIM;i++)
		{
			free(vdw612Terms[i]);
			vdw612Terms[i] = NULL;
		}
	else
		for( i=0; i<VDW612DIM;i++)
			vdw612Terms[i] = 
				realloc(vdw612Terms[i],numberOfVdw612*sizeof(double));

	forceField-> numberOfVdw612 = numberOfVdw612;
	for( i=0; i<VDW612DIM;i++) forceField->vdw612Terms[i] = vdw612Terms[i]; 
	//printf("numberOfVdw612=%d\n",numberOfVdw612);
}
/**********************************************************************/
static void setVdw714Parameters(AmberParameters* amberParameters, ForceField* forceField,int* atomTypes)
{
	int numberOfVdw714 = 0;
	int i;
	int a1,a2,a4;
	int a1Type,a2Type,a4Type;
	Molecule* m = &forceField->molecule;
	double R01, epsilon1;
	double R02, epsilon2;
	double gamma1, delta1;
	double gamma2, delta2;
	double gamma, delta;
	double epsilonij;
	double Rij0;
	double* vdw714Terms[VDW714DIM];
	boolean useHydrogenBonded = forceField->options.hydrogenBonded612 || forceField->options.hydrogenBonded1012 || forceField->options.hydrogenBondedMorse;
	double term;

	if(!forceField->options.vdw714) return;
	/* 5 terms 1=a1, 2=a2, 3=Aij, 4=Bij*/
	/* VDW714DIM 4 */
	for( i=0; i<VDW714DIM;i++) vdw714Terms[i] =  malloc((m->numberOfNonBonded+m->numberOf4Connections)*sizeof(double)); 

	for ( i = 0; i < m->numberOfNonBonded; i++ )
	{
		boolean suttonChena1 = FALSE;
		boolean suttonChena2 = FALSE;

		a1 = m->nonBonded[0][i];
		a2 = m->nonBonded[1][i];
		a1Type = atomTypes[a1];
		a2Type = atomTypes[a2];

		suttonChena1 = canSuttonChen(forceField, a1);
		suttonChena2 = canSuttonChen(forceField, a2);
		if ( suttonChena1 || suttonChena2 ) continue;

		if ( !useHydrogenBonded || !canHydrogenBond(amberParameters, a1Type, a2Type ) )
		{ 
			if ( ! ( getVdw714Parameters(amberParameters, a1Type, &R01, &epsilon1, &gamma1, &delta1 ) ) ) 
			{
				fprintf(forceField->logfile, ("**** couldn't find non bonded parameters for %s \n"),m->atoms[a1].mmType);
				fflush(forceField->logfile);
				continue;
			}
			if(!getVdw714Parameters(amberParameters, a2Type, &R02, &epsilon2, &gamma2, &delta2 ))
			{
				fprintf(forceField->logfile, ("**** couldn't find non bonded parameters for %s \n"),m->atoms[a2].mmType);
				fflush(forceField->logfile);
				continue;
			}

			term = sqrt(fabs(epsilon1))+sqrt(fabs(epsilon2));
			epsilonij = 4*( epsilon1*epsilon2)/(term*term);
			if(fabs(epsilonij)<1e-13) continue;
			Rij0 = (R01*R01*R01+R02*R02*R02)/(R01*R01+R02*R02);
			if(fabs(Rij0)<1e-13) continue;
			gamma = gamma1 + gamma2;
			delta = delta1 + delta2;

			vdw714Terms[0][numberOfVdw714] = a1;
			vdw714Terms[1][numberOfVdw714] = a2;
			vdw714Terms[2][numberOfVdw714] = epsilonij;
			vdw714Terms[3][numberOfVdw714] = Rij0;
			vdw714Terms[4][numberOfVdw714] = gamma;
			vdw714Terms[5][numberOfVdw714] = delta;
			numberOfVdw714++;
		}
	}

	/* now 1/2 non bonded */
	for (  i = 0; i < m->numberOf4Connections; i++ )
	{
		boolean suttonChena1 = FALSE;
		boolean suttonChena4 = FALSE;

		a1 = m->connected4[0][i];
		a4 = m->connected4[3][i];
		a1Type = atomTypes[a1];
		a4Type = atomTypes[a4];
		suttonChena1 = canSuttonChen(forceField, a1);
		suttonChena4 = canSuttonChen(forceField, a4);
		if ( suttonChena1 || suttonChena4 ) continue;
	        if (! getVdw714Parameters(amberParameters, a1Type, &R01, &epsilon1, &gamma1, &delta1 ) )
		{
			fprintf(forceField->logfile, ("**** couldn't find non bonded parameters for %s \n"),m->atoms[a1].mmType);
			fflush(forceField->logfile);
			continue;
		}
	        if (! getVdw714Parameters(amberParameters, a4Type, &R02, &epsilon2, &gamma2, &delta2 ) )
		{
			fprintf(forceField->logfile, ("**** couldn't find non bonded parameters for %s \n"),m->atoms[a4].mmType);
			fflush(forceField->logfile);
			continue;
		}

		term = sqrt(fabs(epsilon1))+sqrt(fabs(epsilon2));
		epsilonij = 4*( epsilon1*epsilon2)/(term*term);
		if(fabs(epsilonij)<1e-13) continue;
		Rij0 = (R01*R01*R01+R02*R02*R02)/(R01*R01+R02*R02);
		if(fabs(Rij0)<1e-13) continue;
		gamma = gamma1 + gamma2;
		delta = delta1 + delta2;

		vdw714Terms[0][numberOfVdw714] = a1;
		vdw714Terms[1][numberOfVdw714] = a4;
		vdw714Terms[2][numberOfVdw714] = epsilonij;
		vdw714Terms[3][numberOfVdw714] = Rij0;
		vdw714Terms[4][numberOfVdw714] = gamma;
		vdw714Terms[5][numberOfVdw714] = delta;
		numberOfVdw714++;
	}
	if(numberOfVdw714==0)
	for( i=0; i<VDW714DIM;i++)
	{
		free(vdw714Terms[i]);
		vdw714Terms[i] = NULL;
	}
	else
	for( i=0; i<VDW714DIM;i++) vdw714Terms[i] = realloc(vdw714Terms[i],numberOfVdw714*sizeof(double));

	forceField-> numberOfVdw714 = numberOfVdw714;
	for( i=0; i<VDW714DIM;i++) forceField->vdw714Terms[i] = vdw714Terms[i]; 
	printf("numberOfVdw714=%d\n",numberOfVdw714);
}
/**********************************************************************/
static void setCoulombParameters(AmberParameters* amberParameters, ForceField* forceField,int* atomTypes)
{
	int numberOfCoulomb = 0;
	int i;
	int a1,a2,a4;
	Molecule* m = &forceField->molecule;
	double* coulombTerms[COULOMBDIM];
	double permittivityScale = 1, permittivity = 1;
	double coulombFactor = 332.05382 / ( permittivity * permittivityScale );
	boolean useCoulomb = forceField->options.coulomb;

	if(!forceField->options.coulomb) return;

	/* 5 terms 1=a1, 2=a2, 3=Aij, 4=Bij*/
	/* COULOMBDIM 4 */
	for( i=0; i<COULOMBDIM;i++) coulombTerms[i] =  malloc((m->numberOfNonBonded+m->numberOf4Connections)*sizeof(double)); 

	if(useCoulomb)
	for ( i = 0; i < m->numberOfNonBonded; i++ )
	{
		boolean suttonChena1 = FALSE;
		boolean suttonChena2 = FALSE;

		a1 = m->nonBonded[0][i];
		a2 = m->nonBonded[1][i];

		suttonChena1 = canSuttonChen(forceField, a1);
		suttonChena2 = canSuttonChen(forceField, a2);
		if ( suttonChena1 || suttonChena2 ) continue;
		if(fabs(m->atoms[a1].charge*m->atoms[a2].charge)<1e-13) continue;

		coulombTerms[0][numberOfCoulomb] = a1;
		coulombTerms[1][numberOfCoulomb] = a2;
		//coulombTerms[2][numberOfCoulomb] = 1.0*m->atoms[a1].charge*m->atoms[a2].charge*coulombFactor;
		coulombTerms[2][numberOfCoulomb] = 1.0*coulombFactor;
		//coulombTerms[2][numberOfCoulomb] = 0.57*coulombFactor;
		numberOfCoulomb++;
	}

	/* now 1/2 non bonded */
	if(useCoulomb)
	for (  i = 0; i < m->numberOf4Connections; i++ )
	{
		boolean suttonChena1 = FALSE;
		boolean suttonChena4 = FALSE;

		a1 = m->connected4[0][i];
		a4 = m->connected4[3][i];
		suttonChena1 = canSuttonChen(forceField, a1);
		suttonChena4 = canSuttonChen(forceField, a4);
		if ( suttonChena1 || suttonChena4 ) continue;
		if(fabs(m->atoms[a1].charge*m->atoms[a4].charge)<1e-13) continue;
		coulombTerms[0][numberOfCoulomb] = a1;
		coulombTerms[1][numberOfCoulomb] = a4;
		//coulombTerms[2][numberOfCoulomb] = 1.0/(double)1.2*m->atoms[a1].charge*m->atoms[a4].charge*coulombFactor;
		//coulombTerms[2][numberOfCoulomb] = 1.0/(double)1.2*coulombFactor;
		coulombTerms[2][numberOfCoulomb] = 0.57*coulombFactor;
		numberOfCoulomb++;
	}
	if(numberOfCoulomb==0)
		for( i=0; i<COULOMBDIM;i++)
		{
			free(coulombTerms[i]);
			coulombTerms[i] = NULL;
		}
	else
		for( i=0; i<COULOMBDIM;i++) coulombTerms[i] = realloc(coulombTerms[i],numberOfCoulomb*sizeof(double));

	forceField-> numberOfCoulomb = numberOfCoulomb;
	for( i=0; i<COULOMBDIM;i++) forceField->coulombTerms[i] = coulombTerms[i]; 
	//printf("numberOfCoulomb=%d\n",numberOfCoulomb);
}
/**********************************************************************/
static void setSuttonChenParameters(AmberParameters* amberParameters, ForceField* forceField,int* atomTypes)
{
	int numberOfSuttonChen = 0;
	int i,j;
	int a1,a2;
	int a1Type,a2Type;
	Molecule* mol = &forceField->molecule;
	double epsilon, a, C, n, m;
	double* suttonChenTerms[SUTTONCHENDIM];
	int nA;
	if(!forceField->options.suttonChen) return;

	/* 7 terms 1=a1, 2=a2, 3=epsilon, 4=a, 5=C , 6=n, 7=m */
	/* SUTTONCHENDIM 7 */
	nA = mol->nAtoms*( mol->nAtoms-1)/2;
	for( i=0; i<SUTTONCHENDIM;i++) suttonChenTerms[i] =  malloc(nA*sizeof(double)); 

	for ( i = 0; i < mol->nAtoms; i++ )
	{
		a1 = i;
		for ( j = i+1; j < mol->nAtoms; j++ )
		{
			a2 = j;

			a1Type = atomTypes[a1];
			a2Type = atomTypes[a2];

			if (  ( getSuttonChenParameters(amberParameters, a1Type, a2Type, &epsilon, &a,&C,&n,&m ) ) )
			{
				suttonChenTerms[0][numberOfSuttonChen] = a1;
				suttonChenTerms[1][numberOfSuttonChen] = a2;
				suttonChenTerms[2][numberOfSuttonChen] = epsilon;
				suttonChenTerms[3][numberOfSuttonChen] = a;
				suttonChenTerms[4][numberOfSuttonChen] = C;
				suttonChenTerms[5][numberOfSuttonChen] = n;
				suttonChenTerms[6][numberOfSuttonChen] = m;
				numberOfSuttonChen++;
			}
                }
	}

	if(numberOfSuttonChen==0)
		for( i=0; i<SUTTONCHENDIM;i++)
		{
			free(suttonChenTerms[i]);
			suttonChenTerms[i] = NULL;
		}
	else
		for( i=0; i<SUTTONCHENDIM;i++)
			suttonChenTerms[i] = 
				realloc(suttonChenTerms[i],numberOfSuttonChen*sizeof(double));

	forceField-> numberOfSuttonChen = numberOfSuttonChen;
	for( i=0; i<SUTTONCHENDIM;i++)
       		forceField->suttonChenTerms[i] = suttonChenTerms[i]; 
}
/**********************************************************************/
static void setPairWiseParameters(AmberParameters* amberParameters, ForceField* forceField,int* atomTypes)
{
	int numberOfPairWise = 0;
	int i;
	int j;
	int a1,a2;
	int a1Type,a2Type;
	Molecule* m = &forceField->molecule;
	double a, beta, c4, c6, c8, c10, b;
	double* pairWiseTerms[PAIRWISEDIM];

	numberOfPairWise = m->nAtoms*(m->nAtoms-1)/2;

	/* PAIRWISEDIM 8 */
	for( i=0; i<PAIRWISEDIM;i++)
		pairWiseTerms[i] =  
			malloc((numberOfPairWise)*sizeof(double)); 

	numberOfPairWise = 0;
	for ( i = 0; i < m->nAtoms; i++ )
	for ( j = i+1; j < m->nAtoms; j++ )
	{
		a1 = i;
		a2 = j;

		a1Type = atomTypes[a1];
		a2Type = atomTypes[a2];

		if ( ! ( getPairWiseParameters(amberParameters, a1Type,a2Type,&a, &beta,&c4, &c6,&c8, &c10,&b) ) )
		{
			fprintf(forceField->logfile,  ("**** couldn't find pair wise parameters for %s-%s\n"),
					m->atoms[a1].mmType, m->atoms[a2].mmType);
			fflush(forceField->logfile);
		}
		
			pairWiseTerms[0][numberOfPairWise] = a1;
			pairWiseTerms[1][numberOfPairWise] = a2;
			pairWiseTerms[2][numberOfPairWise] = a;
			pairWiseTerms[3][numberOfPairWise] = beta;
			pairWiseTerms[4][numberOfPairWise] = c4;
			pairWiseTerms[5][numberOfPairWise] = c6;
			pairWiseTerms[6][numberOfPairWise] = c8;
			pairWiseTerms[7][numberOfPairWise] = c10;
			pairWiseTerms[8][numberOfPairWise] = b;
			numberOfPairWise++;
	}

	if(numberOfPairWise==0)
		for( i=0; i<PAIRWISEDIM;i++)
		{
			free(pairWiseTerms[i]);
			pairWiseTerms[i] = NULL;
		}
	else
		for( i=0; i<PAIRWISEDIM;i++)
			pairWiseTerms[i] = 
				realloc(pairWiseTerms[i],numberOfPairWise*sizeof(double));

	forceField-> numberOfPairWise = numberOfPairWise;
	for( i=0; i<PAIRWISEDIM;i++)
       		forceField->pairWiseTerms[i] = pairWiseTerms[i]; 
}
/**********************************************************************/
static void setACKS2Parameters(AmberParameters* amberParameters, ForceField* forceField)
{

	/*
	 if(
	strcmp(forceField->options.chargesType,"ACKS2")
	&& strcmp(forceField->options.chargesType,"EEM")
	) return;
	*/
        int nTypes = amberParameters->numberOfTypes;
        AmberAtomTypes* types = amberParameters->atomTypes;
	char** mmTypes1 = NULL;
	char** mmTypes2 = NULL;
	double* dum = NULL;
	Molecule* molecule = &forceField->molecule;
	int nBonds = 0;
	int i,j;

	if(nTypes<1) return;

	mmTypes1 = malloc(nTypes*sizeof(char*));
	dum = malloc(nTypes*sizeof(double));

        for(i=0;i<nTypes;i++) mmTypes1[i] = strdup(types[i].name);
        for(i=0;i<nTypes;i++) dum[i] = types[i].electronegativity;
        molecule->klass->setElectronegativity(molecule, nTypes, mmTypes1, dum);
        for(i=0;i<nTypes;i++) dum[i] = types[i].hardness;
        molecule->klass->setHardness(molecule, nTypes, mmTypes1, dum);
        for(i=0;i<nTypes;i++) dum[i] = types[i].width;
        molecule->klass->setWidth(molecule, nTypes, mmTypes1, dum);
        for(i=0;i<nTypes;i++) dum[i] = types[i].charge;
        molecule->klass->setCharge0(molecule, nTypes, mmTypes1, dum);

        for(i=0;i<nTypes;i++) if( mmTypes1 && mmTypes1[i]) free(mmTypes1[i]);
        if( mmTypes1) free(mmTypes1);
	if(dum) free(dum);
	
	nBonds = amberParameters->numberOfHardnessTerms;
	if(nBonds<1) return;
	dum = malloc(nBonds*sizeof(double));
	mmTypes1 = malloc(nBonds*sizeof(char*));
	mmTypes2 = malloc(nBonds*sizeof(char*));
        for(i=0;i<nBonds;i++) mmTypes1[i] = NULL;
        for(i=0;i<nBonds;i++) mmTypes2[i] = NULL;
        for(i=0;i<nBonds;i++) 
	{
		dum[i] = amberParameters->bondHardnessTerms[i].kappa;
		for(j=0;j<nTypes;j++)
        	{
                        if(amberParameters->bondHardnessTerms[i].numbers[0]==types[j].number)  mmTypes1[i] = strdup(types[j].name);
			if(amberParameters->bondHardnessTerms[i].numbers[1]==types[j].number)  mmTypes2[i] = strdup(types[j].name);
        	}
		if(mmTypes1[i] == NULL) mmTypes1[i] = strdup("X");
		if(mmTypes2[i] == NULL) mmTypes2[i] = strdup("X");
	}
        molecule->klass->setBondHardness(molecule, nBonds, mmTypes1, mmTypes2, dum);
        for(i=0;i<nBonds;i++) if( mmTypes1 && mmTypes1[i]) free(mmTypes1[i]);
        if( mmTypes1) free(mmTypes1);
        for(i=0;i<nBonds;i++) if( mmTypes2 && mmTypes2[i]) free(mmTypes2[i]);
        if( mmTypes2) free(mmTypes2);
	if(dum) free(dum);
}
/**********************************************************************/
/**********************************************************************/
static void setAtomTypes(AmberParameters* amberParameters,ForceField* forceField,int* atomTypes)
{
	Molecule* m = &forceField->molecule;
	int nAtoms = m->nAtoms;
	int i;
	for(i=0;i<nAtoms;i++)
	{ 
		/* printf("Atom %s=",m->atoms[i].mmType); */
		atomTypes[i] = getNumberType(amberParameters, m->atoms[i].mmType);
		/*
		{
			int j;
			int nTypes = amberParameters->numberOfTypes;
			AmberAtomTypes* types = amberParameters->atomTypes;
			char* type = m->atoms[i].mmType;
			int len = strlen(type);

			if(strcmp(type,"X")==0)
				printf("-1\n");
			for(j=0;j<nTypes;j++)
			{
					if(len == (int)strlen(types[j].name) && 
						strstr(types[j].name,type))
						printf(" %d \n",types[j].number);
			}
		}
		*/
	}
	
}
/**********************************************************************/
static char* getFileNameParameters()
{
	FILE* file;
	/* check if I can read parameters from a file in Default folder */
	char* fileName = strdup_printf("MolecularMechanics.prm");
	file = fopen(fileName,"r");
	if(file)
	{
		fclose(file);
		return fileName;
	}
	free(fileName);
	return strdup_printf("%s%sMolecularMechanics.prm",cchemiDirectory(), DIR_SEPARATOR_S);
}
/**********************************************************************/
static void setAmberParameters(ForceField* forceField)
{
	Molecule* m = &forceField->molecule;
	int* atomTypes = malloc(m->nAtoms*sizeof(int));
	AmberParameters amberParameters;

	if(staticAmberParameters && staticAmberParameters->numberOfTypes >0 )
		amberParameters = *staticAmberParameters;
	else
	{
		char* defaultFileName = getFileNameParameters();

		amberParameters =  newAmberParameters();
		if(!readAmberParameters(&amberParameters,defaultFileName))
		{
			free(defaultFileName);
			return;
		}

		staticAmberParameters = malloc(sizeof(AmberParameters));
		*staticAmberParameters = amberParameters;

		free(defaultFileName);

	}

	setAtomTypes(&amberParameters,forceField,atomTypes);
	setACKS2Parameters(&amberParameters, forceField);
	setChargesFromMMParameters(&amberParameters,forceField);
	setCharges(forceField);
	setStretchParameters(&amberParameters,forceField,atomTypes);
	setBendParameters(&amberParameters,forceField,atomTypes);
	setStrBendParameters(&amberParameters,forceField,atomTypes);
	setDihedralParameters(&amberParameters, forceField,atomTypes);
	setImproperTorionParameters(&amberParameters,forceField,atomTypes);
	//printf("options.outOfPlane=%d\n",forceField->options.outOfPlane);
	setOutOfPlaneParameters(&amberParameters,forceField,atomTypes);
	//printf("forceField->options.hydrogenBonded=%d\n",forceField->options.hydrogenBonded);
	setHydrogenBondedParameters(&amberParameters,forceField,atomTypes);
	setSuttonChenParameters(&amberParameters,forceField,atomTypes);
	setVdw612Parameters(&amberParameters,forceField,atomTypes);
	setVdw714Parameters(&amberParameters,forceField,atomTypes);
	//printf("forceField->options.coulomb=%d\n",forceField->options.coulomb);
	setCoulombParameters(&amberParameters,forceField,atomTypes);
	setRattleConstraintsParameters(forceField);
	/*
	freeAmberParameters(&amberParameters);
	*/
}
/**********************************************************************/
static void setAllPairWiseParameters(ForceField* forceField)
{
	Molecule* m = &forceField->molecule;
	int* atomTypes = malloc(m->nAtoms*sizeof(int));
	AmberParameters amberParameters;



	if(staticAmberParameters && staticAmberParameters->numberOfTypes >0 )
		amberParameters = *staticAmberParameters;
	else
	{
		char* defaultFileName = getFileNameParameters();

		amberParameters =  newAmberParameters();
		if(!readAmberParameters(&amberParameters,defaultFileName))
		{
			free(defaultFileName);
			return;
		}

		staticAmberParameters = malloc(sizeof(AmberParameters));
		*staticAmberParameters = amberParameters;

		free(defaultFileName);

	}
	

	setAtomTypes(&amberParameters,forceField,atomTypes);
	
	setPairWiseParameters(&amberParameters,forceField,atomTypes);

	setRattleConstraintsParameters(forceField);

	/*
	freeAmberParameters(&amberParameters);
	*/
}
#ifndef ENABLE_CL
/**********************************************************************/
static void calculateGradientBondAmber(ForceField* forceField)
{
	int i;
	Molecule* m = &forceField->molecule;
	double* bondStretchTerms[STRETCHDIM];
	int numberOfStretchTerms = forceField->numberOfStretchTerms;
	double energy = 0;

	for( i=0; i<STRETCHDIM;i++)
       		bondStretchTerms[i] = forceField->bondStretchTerms[i];

#ifdef ENABLE_OMP
#pragma omp parallel for private(i) 
#endif
	for ( i = 0; i < numberOfStretchTerms; i++ )
	{
		int ai, aj;
		double rijx, rijy, rijz, forceOrAlpha, equilibriumDistance, term;
		double h3OrDe,h4,h5,h6;
		double gradix, gradiy, gradiz;
		double bondLength;
		double diff = 0;
		double diff2 = 0;
		double diff3 = 0;
		double diff4 = 0;
		double diff5 = 0;
		double diff6 = 0;
		double der = 0;
		int type;

		type = bondStretchTerms[0][i];
		ai = (int)bondStretchTerms[1][i];
		aj = (int)bondStretchTerms[2][i];
		forceOrAlpha = bondStretchTerms[3][i];
		equilibriumDistance = bondStretchTerms[4][i];
		h3OrDe = bondStretchTerms[5][i];
		h4 = bondStretchTerms[6][i];
		h5 = bondStretchTerms[7][i];
		h6 = bondStretchTerms[8][i];

		rijx = m->atoms[ai].coordinates[0] - m->atoms[aj].coordinates[0];
		rijy = m->atoms[ai].coordinates[1] - m->atoms[aj].coordinates[1];
		rijz = m->atoms[ai].coordinates[2] - m->atoms[aj].coordinates[2];

		bondLength = sqrt( rijx * rijx + rijy * rijy + rijz * rijz );

		if ( bondLength < POSEPS ) bondLength = POSEPS;

		if(type==0)
		{
			diff = bondLength - equilibriumDistance;
			diff2 = diff*diff;
			diff3 = diff2*diff;
			diff4 = diff3*diff;
			diff5 = diff4*diff;
			diff6 = diff5*diff;
			der = forceOrAlpha/ bondLength;

			term = 2*der*diff;
			term += 3*h3OrDe*der*diff2;
			term += 4*h4*der*diff3;
			term += 5*h5*der*diff4;
			term += 6*h6*der*diff5;
		}
		else
		{
			double alpha = forceOrAlpha;
			double De = h3OrDe;
			double X = exp(-alpha*(bondLength-equilibriumDistance));
			double t = 1-X;
			term = 2*De*t*X*alpha/bondLength;
		}
		gradix = term * rijx;
		gradiy = term * rijy;
		gradiz = term * rijz;
#ifdef ENABLE_OMP
#pragma omp critical
#endif
		{
			m->atoms[ai].gradient[0] += gradix;
			m->atoms[ai].gradient[1] += gradiy;
			m->atoms[ai].gradient[2] += gradiz;
		
			m->atoms[aj].gradient[0] -= gradix;
			m->atoms[aj].gradient[1] -= gradiy;
			m->atoms[aj].gradient[2] -= gradiz;
		}
		if(type==0)
		{
			energy += forceOrAlpha * diff2;
			energy += h3OrDe * forceOrAlpha * diff3;
			energy += h4 * forceOrAlpha * diff4;
			energy += h5 * forceOrAlpha * diff5;
			energy += h6 * forceOrAlpha * diff6;
		}
		else
		{
			double alpha = forceOrAlpha;
			double De = h3OrDe;
			double X = exp(-alpha*(bondLength-equilibriumDistance));
			double t = 1-X;
			energy += De*t*t;
		}
	} 
	m->potentialEnergy += energy;
}
/**********************************************************************/
static void calculateGradientBendAmber(ForceField* forceField)
{
	int i;

	Molecule* m = &forceField->molecule;
	double* angleBendTerms[BENDDIM];
	static double D2R = 1/(RADTODEG);
	int numberOfBendTerms = forceField->numberOfBendTerms;
	double energy = 0;

	for( i=0; i<BENDDIM;i++)
		angleBendTerms[i] = forceField->angleBendTerms[i]; 

#ifdef ENABLE_OMP
#pragma omp parallel for private(i)
#endif
	for ( i = 0; i < numberOfBendTerms; i++ )
	{
		int ai, aj, ak;
		double term, term1, term2;
		double thetaRad;
		double delta = 1e-10;
		double cosine;
		double diff = 0;
		double diff2 = 0;
		double diff3 = 0;
		double diff4 = 0;

		double rijx, rijy, rijz;
		double rkjx, rkjy, rkjz;
		double rij2, rkj2;

		double gradix, gradiy, gradiz;
		double gradjx, gradjy, gradjz;
		double gradkx, gradky, gradkz;

		double rijDotrkj;
		double xp,yp,zp,rp;

		ai = (int)angleBendTerms[0][i];
		aj = (int)angleBendTerms[1][i];
		ak = (int)angleBendTerms[2][i];

		rijx = m->atoms[ai].coordinates[0] - m->atoms[aj].coordinates[0];
		rijy = m->atoms[ai].coordinates[1] - m->atoms[aj].coordinates[1];
		rijz = m->atoms[ai].coordinates[2] - m->atoms[aj].coordinates[2];
		rij2 = rijx * rijx + rijy * rijy + rijz * rijz;

		rkjx = m->atoms[ak].coordinates[0] - m->atoms[aj].coordinates[0];
		rkjy = m->atoms[ak].coordinates[1] - m->atoms[aj].coordinates[1];
		rkjz = m->atoms[ak].coordinates[2] - m->atoms[aj].coordinates[2];
		rkj2 = rkjx * rkjx + rkjy * rkjy + rkjz * rkjz;

		if (rij2==0 || rkj2==0) continue;

		rijDotrkj = rijx * rkjx + rijy * rkjy + rijz * rkjz;

		// corss rij^rkj
		xp = rkjy*rijz - rkjz*rijy;
		yp = rkjz*rijx - rkjx*rijz;
		zp = rkjx*rijy - rkjy*rijx;
		rp = sqrt(xp*xp + yp*yp + zp*zp);
		if ( rp < delta )
		{
			fprintf(forceField->logfile, "cut rp\n");
			fflush(forceField->logfile);
			rp = delta;
		printf("rp==0\n");
		}
	
	        cosine = rijDotrkj / sqrt(rij2*rkj2);
		if(cosine>1) cosine = 1;
		if(cosine<-1) cosine = -1;
                thetaRad = acos(cosine);
		diff =  thetaRad - D2R*angleBendTerms[4][i];
		diff2 = diff*diff;
		diff3 = diff2*diff;
		diff4 = diff3*diff;
		term =  angleBendTerms[3][i]*diff*
		(2.0+3.0*angleBendTerms[5][i]*diff+4.0*angleBendTerms[6][i]*diff2+5.0*angleBendTerms[7][i]*diff3+6.0*angleBendTerms[8][i]*diff4);

		term1 = -term/(rij2*rp);
		term2 = +term/(rkj2*rp);

		gradix = term1 * (rijy*zp-rijz*yp);
		gradiy = term1 * (rijz*xp-rijx*zp);
		gradiz = term1 * (rijx*yp-rijy*xp);

		gradkx = term2 * (rkjy*zp-rkjz*yp);
		gradky = term2 * (rkjz*xp-rkjx*zp);
		gradkz = term2 * (rkjx*yp-rkjy*xp);
			
		gradjx = -gradix -gradkx;
		gradjy = -gradiy -gradky;
		gradjz = -gradiz -gradkz;
			
#ifdef ENABLE_OMP
#pragma omp critical
#endif
		{
			m->atoms[ai].gradient[0] += gradix;
			m->atoms[ai].gradient[1] += gradiy;
			m->atoms[ai].gradient[2] += gradiz;
			
			m->atoms[aj].gradient[0] += gradjx;
			m->atoms[aj].gradient[1] += gradjy;
			m->atoms[aj].gradient[2] += gradjz;
			
			m->atoms[ak].gradient[0] += gradkx;
			m->atoms[ak].gradient[1] += gradky;
			m->atoms[ak].gradient[2] += gradkz;

/* energy */
			energy += angleBendTerms[3][i]*diff2*
			(1.0+angleBendTerms[5][i]*diff+angleBendTerms[6][i]*diff2+angleBendTerms[7][i]*diff3+angleBendTerms[8][i]*diff4);
		}
		//printf("Theta Equ diff = %f %f %f\n", thetaRad, D2R*angleBendTerms[4][i], diff);
		//printf("h = %f %f %f %f\n",angleBendTerms[5][i],angleBendTerms[6][i],angleBendTerms[7][i],angleBendTerms[8][i]);

	} 
	//printf("energy bend = %f\n",energy);
	m->potentialEnergy += energy;
}
/**********************************************************************/
static void calculateGradientStrBendAmber(ForceField* forceField)
{
	int i;

	Molecule* m = &forceField->molecule;
	double* strBendTerms[STRBENDDIM];
	static double D2R = 1/(RADTODEG);
	int numberOfStrBendTerms = forceField->numberOfStrBendTerms;
	double energy = 0;

	for( i=0; i<STRBENDDIM;i++) strBendTerms[i] = forceField->strBendTerms[i]; 

	//printf("numberOfStrBendTerms=%d\n",numberOfStrBendTerms);
#ifdef ENABLE_OMP
#pragma omp parallel for private(i)
#endif
	for ( i = 0; i < numberOfStrBendTerms; i++ )
	{
		int ai, aj, ak;
		//double thetaDeg, thetaRad, cosTheta;
		double thetaDeg;
		double absTheta;
		double delta = 1e-10;

		double rijx, rijy, rijz;
		double rkjx, rkjy, rkjz;
		double rij, rkj;
		double rij2, rkj2;
		double xp,yp,zp,rp;

		double gradix, gradiy, gradiz;
		double gradjx, gradjy, gradjz;
		double gradkx, gradky, gradkz;

		double diffAngle, diffR12, diffR23;
		double term1, term2;
		double termR, term1Angle, term2Angle;
		double termAngleix, termAngleiy, termAngleiz;
		double termAnglekx, termAngleky, termAnglekz;
		double termBondix, termBondiy,termBondiz;
		double termBondkx, termBondky,termBondkz;

		ai = (int)strBendTerms[2][i];
		aj = (int)strBendTerms[3][i];
		ak = (int)strBendTerms[4][i];

		thetaDeg = getAngle(&m->atoms[ai], &m->atoms[aj], &m->atoms[ak]);
		//thetaRad = thetaDeg * D2R;
		absTheta = fabs( thetaDeg );
		//cosTheta = cos( thetaRad );

		if ( ( absTheta > delta ) && ( absTheta < 180.0 - delta ) )
		{

			rijx = m->atoms[ai].coordinates[0] - m->atoms[aj].coordinates[0];
			rijy = m->atoms[ai].coordinates[1] - m->atoms[aj].coordinates[1];
			rijz = m->atoms[ai].coordinates[2] - m->atoms[aj].coordinates[2];

			rkjx = m->atoms[ak].coordinates[0] - m->atoms[aj].coordinates[0];
			rkjy = m->atoms[ak].coordinates[1] - m->atoms[aj].coordinates[1];
			rkjz = m->atoms[ak].coordinates[2] - m->atoms[aj].coordinates[2];

			rij2 = rijx * rijx + rijy * rijy + rijz * rijz;
			rij = sqrt(rij2);

			rkj2 = rkjx * rkjx + rkjy * rkjy + rkjz * rkjz;
			rkj = sqrt(rkj2);

			xp = rkjy*rijz - rkjz*rijy;
			yp = rkjz*rijx - rkjx*rijz;
			zp = rkjx*rijy - rkjy*rijx;
			rp = sqrt(xp*xp + yp*yp + zp*zp);
			if ( rp < delta )
			{
				fprintf(forceField->logfile, "cut rp\n");
				fflush(forceField->logfile);
				rp = delta;
			}
		//printf("Const = %f %f %f %f %f\n",strBendTerms[5][i],strBendTerms[6][i],strBendTerms[7][i],strBendTerms[8][i],strBendTerms[9][i]);
			// Terms for the bond angle derivative
          		diffAngle = D2R*(thetaDeg - strBendTerms[9][i]);
               		term1 = -1.0 / (rij2*rp);
               		term2 =  1.0 / (rkj2*rp);
               		termAngleix = term1 * (rijy*zp-rijz*yp);
               		termAngleiy = term1 * (rijz*xp-rijx*zp);
               		termAngleiz = term1 * (rijx*yp-rijy*xp);

               		termAnglekx = term2 * (rkjy*zp-rkjz*yp);
               		termAngleky = term2 * (rkjz*xp-rkjx*zp);
               		termAnglekz = term2 * (rkjx*yp-rkjy*xp);
			//  Terms for the bond length derivatives
          		diffR12 = rij - strBendTerms[7][i];
          		diffR23 = rkj - strBendTerms[8][i];
               		term1 = 1.0 / rij;
               		term2 = 1.0 / rkj;
               		termBondix = term1 * rijx;
               		termBondiy = term1 * rijy;
               		termBondiz = term1 * rijz;

               		termBondkx = term2 * rkjx;
               		termBondky = term2 * rkjy;
               		termBondkz = term2 * rkjz;

               		termR = strBendTerms[5][i]*diffR12 + strBendTerms[6][i]*diffR23;
               		term1Angle = strBendTerms[5][i] * diffAngle;
               		term2Angle = strBendTerms[6][i] * diffAngle;

			gradix = term1Angle * termBondix + termR*termAngleix;
			gradiy = term1Angle * termBondiy + termR*termAngleiy;
			gradiz = term1Angle * termBondiz + termR*termAngleiz;
			
			gradkx = term2Angle * termBondkx + termR*termAnglekx;
			gradky = term2Angle * termBondky + termR*termAngleky;
			gradkz = term2Angle * termBondkz + termR*termAnglekz;

			gradjx = -gradix-gradkx;
			gradjy = -gradiy-gradky;
			gradjz = -gradiz-gradkz;
			
#ifdef ENABLE_OMP
#pragma omp critical
#endif
			{
			m->atoms[ai].gradient[0] += gradix;
			m->atoms[ai].gradient[1] += gradiy;
			m->atoms[ai].gradient[2] += gradiz;
			
			m->atoms[aj].gradient[0] += gradjx;
			m->atoms[aj].gradient[1] += gradjy;
			m->atoms[aj].gradient[2] += gradjz;
			
			m->atoms[ak].gradient[0] += gradkx;
			m->atoms[ak].gradient[1] += gradky;
			m->atoms[ak].gradient[2] += gradkz;
			}
/* energy */
			//printf("ener str-bend  in grad= %f\n",termR*diffAngle);
			energy += termR*diffAngle;
		}
	} 
	m->potentialEnergy += energy;
}
/**********************************************************************/
void calculateGradientDihedralAmber(ForceField* forceField)
{

	int i;

	Molecule* m = &forceField->molecule;
	double* dihedralAngleTerms[DIHEDRALDIM];
	static double D2R = 1/(RADTODEG);
	int numberOfDihedralTerms = forceField->numberOfDihedralTerms;
	double phiDeg;
	double energy = 0;

	for(i=0;i<DIHEDRALDIM;i++)
		dihedralAngleTerms[i] = forceField->dihedralAngleTerms[i];

#ifdef ENABLE_OMP
#pragma omp parallel for private(i) 
#endif
	for (  i = 0; i < numberOfDihedralTerms; i++ )
	{
		int ai, aj, ak, al;
		int j;

		double rjix, rjiy, rjiz;
		double rkjx, rkjy, rkjz;
		double rkix, rkiy, rkiz;
		double rljx, rljy, rljz;
		double rlkx, rlky, rlkz;

		double gradix, gradiy, gradiz;
		double gradjx, gradjy, gradjz;
		double gradkx, gradky, gradkz;
		double gradlx, gradly, gradlz;

		double rkj;
		double xt, yt, zt;
		double xu, yu, zu;
		double xtu, ytu, ztu;
		double rt2, ru2, rtru;
		double cosine1, sine1, cosineN, sineN, cosold, sinold;
		double cosPhase, sinPhase;
		double dedxt, dedyt, dedzt;
		double dedxu, dedyu, dedzu;
		double dedphi;
		int n;
		double vn;

		ai = (int)dihedralAngleTerms[0][i];
		aj = (int)dihedralAngleTerms[1][i];
		ak = (int)dihedralAngleTerms[2][i];
		al = (int)dihedralAngleTerms[3][i];

		rjix = m->atoms[aj].coordinates[0] - m->atoms[ai].coordinates[0];
		rjiy = m->atoms[aj].coordinates[1] - m->atoms[ai].coordinates[1];
		rjiz = m->atoms[aj].coordinates[2] - m->atoms[ai].coordinates[2];

		rkjx = m->atoms[ak].coordinates[0] - m->atoms[aj].coordinates[0];
		rkjy = m->atoms[ak].coordinates[1] - m->atoms[aj].coordinates[1];
		rkjz = m->atoms[ak].coordinates[2] - m->atoms[aj].coordinates[2];

		rlkx = m->atoms[al].coordinates[0] - m->atoms[ak].coordinates[0];
		rlky = m->atoms[al].coordinates[1] - m->atoms[ak].coordinates[1];
		rlkz = m->atoms[al].coordinates[2] - m->atoms[ak].coordinates[2];


		xt = rjiy*rkjz - rkjy*rjiz;
		yt = rjiz*rkjx - rkjz*rjix;
		zt = rjix*rkjy - rkjx*rjiy;

		xu = rkjy*rlkz - rlky*rkjz;
		yu = rkjz*rlkx - rlkz*rkjx;
		zu = rkjx*rlky - rlkx*rkjy;

		xtu = yt*zu - yu*zt;
		ytu = zt*xu - zu*xt;
		ztu = xt*yu - xu*yt;

		rt2 = xt*xt + yt*yt + zt*zt;
		ru2 = xu*xu + yu*yu + zu*zu;

		rtru = sqrt(rt2 * ru2);

		rkj = sqrt(rkjx*rkjx + rkjy*rkjy + rkjz*rkjz);
		cosine1 = 1.0;
		sine1   = 0.0;

		if (rtru <1e-10) rtru = 1e-10;
		if (rt2 <1e-10) rt2 = 1e-10;
		if (ru2 <1e-10) ru2 = 1e-10;

		cosine1 = (xt*xu + yt*yu + zt*zu) / rtru;
		sine1 = (rkjx*xtu + rkjy*ytu + rkjz*ztu) / (rkj*rtru);

		n = (int)dihedralAngleTerms[7][i];
		cosPhase = cos(D2R*dihedralAngleTerms[6][i]);
		sinPhase = sin(D2R*dihedralAngleTerms[6][i]);
		vn = dihedralAngleTerms[5][i]/dihedralAngleTerms[4][i];

/*
     compute the multiple angle trigonometry and the phase terms
*/
		
		cosineN = cosine1;
		sineN   = sine1;

		for(j=2;j<=n;j++)
		{
		   cosold = cosineN;
		   sinold = sineN;
		   cosineN = cosine1*cosold - sine1*sinold;
		   sineN   = cosine1*sinold + sine1*cosold;
		}

		dedphi = vn*n*(cosineN*sinPhase-sineN*cosPhase);

/*
     chain rule terms for first derivative components
*/

		rkix = m->atoms[ak].coordinates[0] - m->atoms[ai].coordinates[0];
		rkiy = m->atoms[ak].coordinates[1] - m->atoms[ai].coordinates[1];
		rkiz = m->atoms[ak].coordinates[2] - m->atoms[ai].coordinates[2];

		rljx = m->atoms[al].coordinates[0] - m->atoms[aj].coordinates[0];
		rljy = m->atoms[al].coordinates[1] - m->atoms[aj].coordinates[1];
		rljz = m->atoms[al].coordinates[2] - m->atoms[aj].coordinates[2];

		dedxt = dedphi * (yt*rkjz - rkjy*zt) / (rt2*rkj);
		dedyt = dedphi * (zt*rkjx - rkjz*xt) / (rt2*rkj);
		dedzt = dedphi * (xt*rkjy - rkjx*yt) / (rt2*rkj);

		dedxu = -dedphi * (yu*rkjz - rkjy*zu) / (ru2*rkj);
		dedyu = -dedphi * (zu*rkjx - rkjz*xu) / (ru2*rkj);
		dedzu = -dedphi * (xu*rkjy - rkjx*yu) / (ru2*rkj);
/*

     compute first derivative components for this angle
*/

		gradix = rkjz*dedyt - rkjy*dedzt;
		gradiy = rkjx*dedzt - rkjz*dedxt;
		gradiz = rkjy*dedxt - rkjx*dedyt;

		gradjx = rkiy*dedzt - rkiz*dedyt + rlkz*dedyu - rlky*dedzu;
		gradjy = rkiz*dedxt - rkix*dedzt + rlkx*dedzu - rlkz*dedxu;
		gradjz = rkix*dedyt - rkiy*dedxt + rlky*dedxu - rlkx*dedyu;

		gradkx = rjiz*dedyt - rjiy*dedzt + rljy*dedzu - rljz*dedyu;
		gradky = rjix*dedzt - rjiz*dedxt + rljz*dedxu - rljx*dedzu;
		gradkz = rjiy*dedxt - rjix*dedyt + rljx*dedyu - rljy*dedxu;

		gradlx = rkjz*dedyu - rkjy*dedzu;
		gradly = rkjx*dedzu - rkjz*dedxu;
		gradlz = rkjy*dedxu - rkjx*dedyu;

#ifdef ENABLE_OMP
#pragma omp critical
#endif
		{
		m->atoms[ai].gradient[0] += gradix;
		m->atoms[ai].gradient[1] += gradiy;
		m->atoms[ai].gradient[2] += gradiz;

		m->atoms[aj].gradient[0] += gradjx;
		m->atoms[aj].gradient[1] += gradjy;
		m->atoms[aj].gradient[2] += gradjz;

		m->atoms[ak].gradient[0] += gradkx;
		m->atoms[ak].gradient[1] += gradky;
		m->atoms[ak].gradient[2] += gradkz;

		m->atoms[al].gradient[0] += gradlx;
		m->atoms[al].gradient[1] += gradly;
		m->atoms[al].gradient[2] += gradlz;
		}
		phiDeg = getTorsion(  &m->atoms[ai] ,&m->atoms[aj], &m->atoms[ak], &m->atoms[al]);
		//phiDeg = acos(cosine1)*RADTODEG;
		energy += dihedralAngleTerms[5][i]/dihedralAngleTerms[4][i] * 
		( 1.0 + cos( D2R*(dihedralAngleTerms[7][i] * phiDeg - dihedralAngleTerms[6][i] )) );
	}
	m->potentialEnergy += energy;
}
/**********************************************************************/
static void calculateGradientImproperTorsion(ForceField* forceField)
{
	int i;
	Molecule* m = &forceField->molecule;
	double forceConstant, equilibriumAngle;
	double* improperTorsionTerms[IMPROPERDIHEDRALDIM];
	static double D2R = 1/(RADTODEG);
	double energy = 0;
	double phiDeg;
	int numberOfImproperTorsionTerms = forceField->numberOfImproperTorsionTerms;

	for(i=0;i<IMPROPERDIHEDRALDIM;i++) improperTorsionTerms[i] = forceField->improperTorsionTerms[i];

#ifdef ENABLE_OMP
#pragma omp parallel for private(i) 
#endif
	for (  i = 0; i < numberOfImproperTorsionTerms; i++ )
	{
		int ai, aj, ak, al;
		int j;

		double rjix, rjiy, rjiz;
		double rkjx, rkjy, rkjz;
		double rkix, rkiy, rkiz;
		double rljx, rljy, rljz;
		double rlkx, rlky, rlkz;

		double gradix, gradiy, gradiz;
		double gradjx, gradjy, gradjz;
		double gradkx, gradky, gradkz;
		double gradlx, gradly, gradlz;

		double rkj;
		double xt, yt, zt;
		double xu, yu, zu;
		double xtu, ytu, ztu;
		double rt2, ru2, rtru;
		double cosine1, sine1, cosineN, sineN, cosold, sinold;
		double cosPhase, sinPhase;
		double dedxt, dedyt, dedzt;
		double dedxu, dedyu, dedzu;
		double dedphi;
		int n;

		ai = (int)improperTorsionTerms[0][i];
		aj = (int)improperTorsionTerms[1][i];
		ak = (int)improperTorsionTerms[2][i];
		al = (int)improperTorsionTerms[3][i];

		forceConstant = improperTorsionTerms[4][i];
		n = (int)improperTorsionTerms[6][i];
                equilibriumAngle = improperTorsionTerms[5][i];

		rjix = m->atoms[aj].coordinates[0] - m->atoms[ai].coordinates[0];
		rjiy = m->atoms[aj].coordinates[1] - m->atoms[ai].coordinates[1];
		rjiz = m->atoms[aj].coordinates[2] - m->atoms[ai].coordinates[2];

		rkjx = m->atoms[ak].coordinates[0] - m->atoms[aj].coordinates[0];
		rkjy = m->atoms[ak].coordinates[1] - m->atoms[aj].coordinates[1];
		rkjz = m->atoms[ak].coordinates[2] - m->atoms[aj].coordinates[2];

		rlkx = m->atoms[al].coordinates[0] - m->atoms[ak].coordinates[0];
		rlky = m->atoms[al].coordinates[1] - m->atoms[ak].coordinates[1];
		rlkz = m->atoms[al].coordinates[2] - m->atoms[ak].coordinates[2];


		xt = rjiy*rkjz - rkjy*rjiz;
		yt = rjiz*rkjx - rkjz*rjix;
		zt = rjix*rkjy - rkjx*rjiy;

		xu = rkjy*rlkz - rlky*rkjz;
		yu = rkjz*rlkx - rlkz*rkjx;
		zu = rkjx*rlky - rlkx*rkjy;

		xtu = yt*zu - yu*zt;
		ytu = zt*xu - zu*xt;
		ztu = xt*yu - xu*yt;

		rt2 = xt*xt + yt*yt + zt*zt;
		ru2 = xu*xu + yu*yu + zu*zu;

		rtru = sqrt(rt2 * ru2);

		rkj = sqrt(rkjx*rkjx + rkjy*rkjy + rkjz*rkjz);
		cosine1 = 1.0;
		sine1   = 0.0;

		if (rtru <1e-10) rtru = 1e-10;
		if (rt2 <1e-10) rt2 = 1e-10;
		if (ru2 <1e-10) ru2 = 1e-10;

		cosine1 = (xt*xu + yt*yu + zt*zu) / rtru;
		sine1 = (rkjx*xtu + rkjy*ytu + rkjz*ztu) / (rkj*rtru);

		cosPhase = cos(D2R*equilibriumAngle);
		sinPhase = sin(D2R*equilibriumAngle);

/*
     compute the multiple angle trigonometry and the phase terms
*/
		
		cosineN = cosine1;
		sineN   = sine1;

		for(j=2;j<=n;j++)
		{
		   cosold = cosineN;
		   sinold = sineN;
		   cosineN = cosine1*cosold - sine1*sinold;
		   sineN   = cosine1*sinold + sine1*cosold;
		}

		dedphi = forceConstant*n*(cosineN*sinPhase-sineN*cosPhase);

/*
     chain rule terms for first derivative components
*/

		rkix = m->atoms[ak].coordinates[0] - m->atoms[ai].coordinates[0];
		rkiy = m->atoms[ak].coordinates[1] - m->atoms[ai].coordinates[1];
		rkiz = m->atoms[ak].coordinates[2] - m->atoms[ai].coordinates[2];

		rljx = m->atoms[al].coordinates[0] - m->atoms[aj].coordinates[0];
		rljy = m->atoms[al].coordinates[1] - m->atoms[aj].coordinates[1];
		rljz = m->atoms[al].coordinates[2] - m->atoms[aj].coordinates[2];

		dedxt = dedphi * (yt*rkjz - rkjy*zt) / (rt2*rkj);
		dedyt = dedphi * (zt*rkjx - rkjz*xt) / (rt2*rkj);
		dedzt = dedphi * (xt*rkjy - rkjx*yt) / (rt2*rkj);

		dedxu = -dedphi * (yu*rkjz - rkjy*zu) / (ru2*rkj);
		dedyu = -dedphi * (zu*rkjx - rkjz*xu) / (ru2*rkj);
		dedzu = -dedphi * (xu*rkjy - rkjx*yu) / (ru2*rkj);
/*

     compute first derivative components for this angle
*/

		gradix = rkjz*dedyt - rkjy*dedzt;
		gradiy = rkjx*dedzt - rkjz*dedxt;
		gradiz = rkjy*dedxt - rkjx*dedyt;

		gradjx = rkiy*dedzt - rkiz*dedyt + rlkz*dedyu - rlky*dedzu;
		gradjy = rkiz*dedxt - rkix*dedzt + rlkx*dedzu - rlkz*dedxu;
		gradjz = rkix*dedyt - rkiy*dedxt + rlky*dedxu - rlkx*dedyu;

		gradkx = rjiz*dedyt - rjiy*dedzt + rljy*dedzu - rljz*dedyu;
		gradky = rjix*dedzt - rjiz*dedxt + rljz*dedxu - rljx*dedzu;
		gradkz = rjiy*dedxt - rjix*dedyt + rljx*dedyu - rljy*dedxu;

		gradlx = rkjz*dedyu - rkjy*dedzu;
		gradly = rkjx*dedzu - rkjz*dedxu;
		gradlz = rkjy*dedxu - rkjx*dedyu;

#ifdef ENABLE_OMP
#pragma omp critical
#endif
		{
		m->atoms[ai].gradient[0] += gradix;
		m->atoms[ai].gradient[1] += gradiy;
		m->atoms[ai].gradient[2] += gradiz;

		m->atoms[aj].gradient[0] += gradjx;
		m->atoms[aj].gradient[1] += gradjy;
		m->atoms[aj].gradient[2] += gradjz;

		m->atoms[ak].gradient[0] += gradkx;
		m->atoms[ak].gradient[1] += gradky;
		m->atoms[ak].gradient[2] += gradkz;

		m->atoms[al].gradient[0] += gradlx;
		m->atoms[al].gradient[1] += gradly;
		m->atoms[al].gradient[2] += gradlz;
		}
		phiDeg = getTorsion(  &m->atoms[ai] ,&m->atoms[aj], &m->atoms[ak], &m->atoms[al]);
		//phiDeg = acos(cosine1)*RADTODEG;
		energy += forceConstant * ( 1.0 + cos( D2R*(n * phiDeg - equilibriumAngle )) );
	}
	//printf("ImproperTorsion energy =%f\n",energy);
	m->potentialEnergy += energy;
}
/*****************************************************************************************/
void calculateGradientOutOfPlaneAmber(ForceField* forceField)
{

	int i;

	Molecule* m = &forceField->molecule;
	double* outOfPlaneTerms[OUTOFPLANEDIM];
	int numberOfOutOfPlaneTerms = forceField->numberOfOutOfPlaneTerms;
	double energy = 0;

	for(i=0;i<OUTOFPLANEDIM;i++) outOfPlaneTerms[i] = forceField->outOfPlaneTerms[i];

#ifdef ENABLE_OMP
#pragma omp parallel for private(i) 
#endif
	for (  i = 0; i < numberOfOutOfPlaneTerms; i++ )
	{
		int ai, aj, ak, al;

		double rijx, rijy, rijz;
		double rkjx, rkjy, rkjz;
		double rljx, rljy, rljz;

		double gradix, gradiy, gradiz;
		double gradjx, gradjy, gradjz;
		double gradkx, gradky, gradkz;
		double gradlx, gradly, gradlz;

		//double angle, e, e2, c2;
		double angle,  e2, c2;
		double dot;
		double rilx, rily, rilz;
		double rklx, rkly, rklz;
		double rij2 =0.0, rkj2 = 0.0, ril2 = 0.0, rkl2 = 0.0, rlj2 = 0.0;
		double bkk2, cosine;
		double dt, dt2, dt3, dt4;
		double deddt, dEdCos;
		double term;
		double dc2dix, dc2diy, dc2diz;
		double dc2dkx, dc2dky, dc2dkz;
		double dc2dlx, dc2dly, dc2dlz;
		double de2dix, de2diy, de2diz;
		double de2dkx, de2dky, de2dkz;
		double de2dlx, de2dly, de2dlz;

		boolean wdc = (outOfPlaneTerms[4][i]==1);
		double force = outOfPlaneTerms[5][i];
		double h3 = outOfPlaneTerms[6][i];
		double h4 = outOfPlaneTerms[7][i];
		double h5 = outOfPlaneTerms[8][i];
		double h6 = outOfPlaneTerms[9][i];

		ai = (int)outOfPlaneTerms[0][i];
		aj = (int)outOfPlaneTerms[1][i];
		ak = (int)outOfPlaneTerms[2][i];
		al = (int)outOfPlaneTerms[3][i];

		rijx = m->atoms[ai].coordinates[0] - m->atoms[aj].coordinates[0];
		rijy = m->atoms[ai].coordinates[1] - m->atoms[aj].coordinates[1];
		rijz = m->atoms[ai].coordinates[2] - m->atoms[aj].coordinates[2];

		rkjx = m->atoms[ak].coordinates[0] - m->atoms[aj].coordinates[0];
		rkjy = m->atoms[ak].coordinates[1] - m->atoms[aj].coordinates[1];
		rkjz = m->atoms[ak].coordinates[2] - m->atoms[aj].coordinates[2];

		rljx = m->atoms[al].coordinates[0] - m->atoms[aj].coordinates[0];
		rljy = m->atoms[al].coordinates[1] - m->atoms[aj].coordinates[1];
		rljz = m->atoms[al].coordinates[2] - m->atoms[aj].coordinates[2];

		rilx = m->atoms[ai].coordinates[0] - m->atoms[al].coordinates[0];
		rily = m->atoms[ai].coordinates[1] - m->atoms[al].coordinates[1];
		rilz = m->atoms[ai].coordinates[2] - m->atoms[al].coordinates[2];

		rklx = m->atoms[ak].coordinates[0] - m->atoms[al].coordinates[0];
		rkly = m->atoms[ak].coordinates[1] - m->atoms[al].coordinates[1];
		rklz = m->atoms[ak].coordinates[2] - m->atoms[al].coordinates[2];

		if(wdc) //  'W-D-C'
		{
		     	rij2 = rijx*rijx + rijy*rijy + rijz*rijz;
               		rkj2 = rkjx*rkjx + rkjy*rkjy + rkjz*rkjz;
               		dot = rijx*rkjx+rijy*rkjy+rijz*rkjz;
               		c2 = rij2*rkj2 - dot*dot;
		}
		else // ALLINGER
		{
			ril2 = rilx*rilx + rily*rily + rilz*rilz;
               		rkl2 = rklx*rklx + rkly*rkly + rklz*rklz;
               		dot = rilx*rklx + rily*rkly + rilz*rklz;
               		c2 = ril2*rkl2 - dot*dot;
		}
		// energy
		e2 = rljx*(rijy*rkjz-rijz*rkjy) + rljy*(rijz*rkjx-rijx*rkjz)+ rljz*(rijx*rkjy-rijy*rkjx);
            	rlj2 = rljx*rljx + rljy*rljy + rljz*rljz;
            	if (rlj2==0.0 || c2 == 0.0) continue;
               	bkk2 = rlj2 - e2*e2/c2;
               	cosine = sqrt(bkk2/rlj2);
		if(cosine>1) cosine = 1;
		if(cosine<-1) cosine = -1;
               	angle = acos(cosine);
               	dt = angle;
               	dt2 = dt * dt;
               	dt3 = dt2 * dt;
               	dt4 = dt2 * dt2;
               	//e = force * dt2*(1.0+h3*dt+h4*dt2+h5*dt3+h6*dt4);
               	deddt = force * dt * (2.0 + 3.0*h3*dt + 4.0*h4*dt2 +5.0*h5*dt3 + 6.0*h6*dt4);
               	dEdCos = -deddt / sqrt(c2*bkk2);
		if(e2<0) dEdCos = deddt / sqrt(c2*bkk2);
		//  first derivative components
		if(wdc)
		{
			term = e2 / c2;
                  	dc2dix = (rijx*rkj2-rkjx*dot) * term;
                  	dc2diy = (rijy*rkj2-rkjy*dot) * term;
                  	dc2diz = (rijz*rkj2-rkjz*dot) * term;
                  	dc2dkx = (rkjx*rij2-rijx*dot) * term;
                  	dc2dky = (rkjy*rij2-rijy*dot) * term;
                  	dc2dkz = (rkjz*rij2-rijz*dot) * term;
                  	dc2dlx = 0.0;
                  	dc2dly = 0.0;
                  	dc2dlz = 0.0;

		}
		else
		{
			term = e2 / c2;
                  	dc2dix = (rilx*rkl2-rklx*dot) * term;
                  	dc2diy = (rily*rkl2-rkly*dot) * term;
                  	dc2diz = (rilz*rkl2-rklz*dot) * term;
                  	dc2dkx = (rklx*ril2-rilx*dot) * term;
                  	dc2dky = (rkly*ril2-rily*dot) * term;
                  	dc2dkz = (rklz*ril2-rilz*dot) * term;
                  	dc2dlx = -dc2dix - dc2dkx;
                  	dc2dly = -dc2diy - dc2dky;
                  	dc2dlz = -dc2diz - dc2dkz;
		}
		term = e2 / rlj2;
               	de2dix = rljy*rkjz - rljz*rkjy;
               	de2diy = rljz*rkjx - rljx*rkjz;
               	de2diz = rljx*rkjy - rljy*rkjx;
               	de2dkx = rijy*rljz - rijz*rljy;
               	de2dky = rijz*rljx - rijx*rljz;
               	de2dkz = rijx*rljy - rijy*rljx;
               	de2dlx = rkjy*rijz - rkjz*rijy + rljx*term;
               	de2dly = rkjz*rijx - rkjx*rijz + rljy*term;
               	de2dlz = rkjx*rijy - rkjy*rijx + rljz*term;


	       	gradix = dEdCos * (dc2dix+de2dix);
               	gradiy = dEdCos * (dc2diy+de2diy);
               	gradiz = dEdCos * (dc2diz+de2diz);
               	gradkx = dEdCos * (dc2dkx+de2dkx);
               	gradky = dEdCos * (dc2dky+de2dky);
               	gradkz = dEdCos * (dc2dkz+de2dkz);
               	gradlx = dEdCos * (dc2dlx+de2dlx);
               	gradly = dEdCos * (dc2dly+de2dly);
               	gradlz = dEdCos * (dc2dlz+de2dlz);
               	gradjx = -gradix - gradkx - gradlx;
               	gradjy = -gradiy - gradky - gradly;
               	gradjz = -gradiz - gradkz - gradlz;
#ifdef ENABLE_OMP
#pragma omp critical
#endif
		{
			m->atoms[ai].gradient[0] += gradix;
			m->atoms[ai].gradient[1] += gradiy;
			m->atoms[ai].gradient[2] += gradiz;

			m->atoms[aj].gradient[0] += gradjx;
			m->atoms[aj].gradient[1] += gradjy;
			m->atoms[aj].gradient[2] += gradjz;

			m->atoms[ak].gradient[0] += gradkx;
			m->atoms[ak].gradient[1] += gradky;
			m->atoms[ak].gradient[2] += gradkz;

			m->atoms[al].gradient[0] += gradlx;
			m->atoms[al].gradient[1] += gradly;
			m->atoms[al].gradient[2] += gradlz;
		}
		energy += e2;
	}
	m->potentialEnergy += energy;
}
/**********************************************************************/
void calculateGradientVdw612Amber(ForceField* forceField)
{
	int i;
	double energy = 0;

	Molecule* m = &forceField->molecule;
	double* vdw612Terms[VDW612DIM];
	int numberOfVdw612 = forceField->numberOfVdw612;


	//printf("calculateGradientVdw612Amber : useCoulomb=%d\n",useCoulomb);
	for(i=0;i<VDW612DIM;i++)
		vdw612Terms[i] = forceField->vdw612Terms[i];

	/* non-bonded part */
#ifdef ENABLE_OMP
#pragma omp parallel for private(i) 
#endif
	for (  i = 0; i < numberOfVdw612; i++ )
	{
		int ai, aj;
		double rijx, rijy, rijz;
		double gradix, gradiy, gradiz;
		double rij2, rij;
		double rijm3;
		double rijm6, rijm8;
		double  term3;
		double A,B;

		ai       = (int)vdw612Terms[0][i];
		aj       = (int)vdw612Terms[1][i];
		A = vdw612Terms[2][i];
		B = vdw612Terms[3][i];

		rijx =  m->atoms[ai].coordinates[0] - m->atoms[aj].coordinates[0];
		rijy =  m->atoms[ai].coordinates[1] - m->atoms[aj].coordinates[1];
		rijz =  m->atoms[ai].coordinates[2] - m->atoms[aj].coordinates[2];

		rij2 = rijx * rijx + rijy * rijy + rijz * rijz;
		if ( rij2 < POSEPS*POSEPS ) rij2 = POSEPS*POSEPS;	

		rij = sqrt( rij2 );
		rijm3 = 1.0/(rij2 * rij);
		rijm6 = rijm3 * rijm3;
		rijm8 = rijm6 / rij2;
		
		term3 = -6*(2 * A * rijm6 - B)*rijm8;
		gradix = term3 * rijx;
		gradiy = term3 * rijy;
		gradiz = term3 * rijz;
#ifdef ENABLE_OMP
#pragma omp critical
#endif
		{
			m->atoms[ai].gradient[0] += gradix;
			m->atoms[ai].gradient[1] += gradiy;
			m->atoms[ai].gradient[2] += gradiz;

			m->atoms[aj].gradient[0] -= gradix;
			m->atoms[aj].gradient[1] -= gradiy;
			m->atoms[aj].gradient[2] -= gradiz;
		}
		energy += (A*rijm6 - B) * rijm6;
		if(rij<1) printf("Warning : rij2 = %f atom# = %d atom# = %d\n",rij,ai+1,aj+1);
	//	printf("rij2 = %f ai = %d aj = %d\n",rij2,ai+1,aj+1);
	}  
	m->potentialEnergy += energy;
}
/**********************************************************************/
void calculateGradientVdw714Amber(ForceField* forceField)
{
	int i;
	double energy = 0;

	Molecule* m = &forceField->molecule;
	double* vdw714Terms[VDW714DIM];
	int numberOfVdw714 = forceField->numberOfVdw714;


	//printf("calculateGradientVdw714Amber : useCoulomb=%d\n",useCoulomb);
	for(i=0;i<VDW714DIM;i++) vdw714Terms[i] = forceField->vdw714Terms[i];

	/* non-bonded part */
#ifdef ENABLE_OMP
#pragma omp parallel for private(i) 
#endif
	for (  i = 0; i < numberOfVdw714; i++ )
	{
		double rijx, rijy, rijz;
		double gradix, gradiy, gradiz;
		double gradjx, gradjy, gradjz;
		double rij2, rij;
		int ai, aj;
		double epsilon, gamma, delta, R0;
		double rho;
		double e,de;
		//double R02,R04,R07;
		double R02,R07;
		double rij6,rij7;
		double tau, dtau, tau7, gtau;

		ai       = (int)vdw714Terms[0][i];
		aj       = (int)vdw714Terms[1][i];

		epsilon  = vdw714Terms[2][i];
		R0       = vdw714Terms[3][i];
		gamma    = vdw714Terms[4][i];
		delta    = vdw714Terms[5][i];

		rijx =  m->atoms[ai].coordinates[0] - m->atoms[aj].coordinates[0];
		rijy =  m->atoms[ai].coordinates[1] - m->atoms[aj].coordinates[1];
		rijz =  m->atoms[ai].coordinates[2] - m->atoms[aj].coordinates[2];

		rij2 = rijx * rijx + rijy * rijy + rijz * rijz;
		if ( rij2 < POSEPS*POSEPS ) rij2 = POSEPS*POSEPS;	

		rij = sqrt( rij2 );
	printf("rij = %f R0 = %f epsilon = %f gamma = %f delta = %f\n",rij,R0,epsilon,gamma,delta);
		R02 = R0*R0;
		//R04 = R02*R02;
		R07 = R02*R02*R02*R0;
		rij6 = rij2*rij2*rij2;
		rij7 = rij6*rij;
		rho = rij7+gamma*R07;

                tau = (delta+1.0) / (rij + delta*R0);
                tau7 = pow(tau,7);
                dtau = tau / (delta+1.0);
                gtau = epsilon*tau7*rij6*(gamma+1.0)*(R07/rho)*(R07/rho);
                e = epsilon*tau7*R07*((gamma+1.0)*R07/rho-2.0);
                de = 7.0 * (dtau*e+gtau);
		de = de/rij;

		gradix = de * rijx;
		gradiy = de * rijy;
		gradiz = de * rijz;

		gradjx = -gradix;
		gradjy = -gradiy;
		gradjz = -gradiz;
#ifdef ENABLE_OMP
#pragma omp critical
#endif
		{
		m->atoms[ai].gradient[0] += gradix;
		m->atoms[ai].gradient[1] += gradiy;
		m->atoms[ai].gradient[2] += gradiz;

		m->atoms[aj].gradient[0] += gradjx;
		m->atoms[aj].gradient[1] += gradjy;
		m->atoms[aj].gradient[2] += gradjz;

		energy += e;
		}
		if(rij<1) printf("Warning : rij2 = %f atom# = %d atom# = %d\n",rij,ai+1,aj+1);
	//	printf("rij2 = %f ai = %d aj = %d\n",rij2,ai+1,aj+1);
	}  
	//printf("E in grad 7-14 %f\n",energy);
	m->potentialEnergy += energy;
}
/**********************************************************************/
void calculateGradientVdw714AmberOld(ForceField* forceField)
{
	int i;
	double energy = 0;

	Molecule* m = &forceField->molecule;
	double* vdw714Terms[VDW714DIM];
	int numberOfVdw714 = forceField->numberOfVdw714;


	//printf("calculateGradientVdw714Amber : useCoulomb=%d\n",useCoulomb);
	for(i=0;i<VDW714DIM;i++) vdw714Terms[i] = forceField->vdw714Terms[i];

	/* non-bonded part */
#ifdef ENABLE_OMP
#pragma omp parallel for private(i) 
#endif
	for (  i = 0; i < numberOfVdw714; i++ )
	{
		double rijx, rijy, rijz;
		double gradix, gradiy, gradiz;
		double gradjx, gradjy, gradjz;
		double rij2, rij;
		int ai, aj;
		double epsilon, gamma, delta, R0;
		double R02;
		double d,d2,d4,d7;
		double sr,sr2,sr4,sr7,sr8;
		double rho,rho2,rho4,rho5, rho7;
		double srijg7;
		double e7,e14;
		double term, term7, term14, term14_1, term14_2;

		ai       = (int)vdw714Terms[0][i];
		aj       = (int)vdw714Terms[1][i];

		epsilon  = vdw714Terms[2][i];
		R0       = vdw714Terms[3][i];
		gamma    = vdw714Terms[4][i];
		delta    = vdw714Terms[5][i];

		rijx =  m->atoms[ai].coordinates[0] - m->atoms[aj].coordinates[0];
		rijy =  m->atoms[ai].coordinates[1] - m->atoms[aj].coordinates[1];
		rijz =  m->atoms[ai].coordinates[2] - m->atoms[aj].coordinates[2];

		rij2 = rijx * rijx + rijy * rijy + rijz * rijz;
		if ( rij2 < POSEPS*POSEPS ) rij2 = POSEPS*POSEPS;	

		rij = sqrt( rij2 );
		R02 = R0*R0;

		rho = rij/R0;
		rho2 = rho*rho;
		rho4 = rho2*rho2;
		rho5 = rho4*rho;
		rho7 = rho5*rho2;

		d = (1+delta);
		d2 = d*d;
		d4 = d2*d2;
		d7 = d4*d2*d;

		sr = 1.0/(rho+delta);
		sr2 = sr*sr;
		sr4 = sr2*sr2;
		sr7 = sr4*sr2*sr;
		sr8 = sr4*sr4;
		srijg7=1.0/(rho7+gamma);
		
		e7  = epsilon*d7*sr7;
		e14 = e7*(1+gamma)*srijg7;
		e7  = 2*e7;

		term7 = -14*epsilon*d7*sr8/(rij*R0);
		term14  = 7*epsilon*d7*(1+gamma)*sr7*srijg7;
		term14_1 = term14*sr/(rij*R0);
		term14_2 = term14*srijg7*rho5/R02;
		term = term7 + term14_1 + term14_2;
		term = - term;

		gradix = term * rijx;
		gradiy = term * rijy;
		gradiz = term * rijz;

		gradjx = -gradix;
		gradjy = -gradiy;
		gradjz = -gradiz;
#ifdef ENABLE_OMP
#pragma omp critical
#endif
		{
		m->atoms[ai].gradient[0] += gradix;
		m->atoms[ai].gradient[1] += gradiy;
		m->atoms[ai].gradient[2] += gradiz;

		m->atoms[aj].gradient[0] += gradjx;
		m->atoms[aj].gradient[1] += gradjy;
		m->atoms[aj].gradient[2] += gradjz;

		energy += e14-e7;
		}
		if(rij<1) printf("Warning : rij2 = %f atom# = %d atom# = %d\n",rij,ai+1,aj+1);
	//	printf("rij2 = %f ai = %d aj = %d\n",rij2,ai+1,aj+1);
	}  
	//printf("E in grad 7-14 %f\n",energy);
	m->potentialEnergy += energy;
}
/**********************************************************************/
void calculateGradientCoulombAmberEEMACKS2(ForceField* forceField)
{
	double dx = forceField->options.dx;
	Molecule* m = &forceField->molecule;
	int nAtoms = m->nAtoms;
	int i,k;
	double Ep=0, Em=0;

	for(i=0;i<nAtoms;i++)
	for(k=0;k<3;k++)
	{
		m->atoms[i].coordinates[k] += dx;
		setCharges(forceField);
		Ep = calculateEnergyCoulombAmber(forceField,m);

		m->atoms[i].coordinates[k] -= 2*dx;
		setCharges(forceField);
		Em = calculateEnergyCoulombAmber(forceField,m);

		m->atoms[i].gradient[k] += (Ep-Em)/dx/2;
		m->atoms[i].coordinates[k] += dx;
	}
	setCharges(forceField);
	m->potentialEnergy += calculateEnergyCoulombAmber(forceField,m);
}
/**********************************************************************/
void calculateGradientCoulombAmber(ForceField* forceField)
{
	int i;
	double energy = 0;

	Molecule* m = &forceField->molecule;
	double* coulombTerms[COULOMBDIM];
	int numberOfCoulomb = forceField->numberOfCoulomb;

	if(!strcmp(forceField->options.chargesType,"EEM") || 
	!strcmp(forceField->options.chargesType,"ACKS2"))
	{
		calculateGradientCoulombAmberEEMACKS2(forceField);
		return;
	}

	for(i=0;i<COULOMBDIM;i++) coulombTerms[i] = forceField->coulombTerms[i];

	/* non-bonded part */
#ifdef ENABLE_OMP
#pragma omp parallel for private(i,ai,aj) 
#endif
	for (  i = 0; i < numberOfCoulomb; i++ )
	{
		double rijx, rijy, rijz;
		double gradix, gradiy, gradiz;
		double rij2, rij;
		double rij3;
		double  term3;
		int ai, aj;
		double C;

		ai       = (int)coulombTerms[0][i];
		aj       = (int)coulombTerms[1][i];
		C = coulombTerms[2][i]*m->atoms[ai].charge*m->atoms[aj].charge;

		rijx =  m->atoms[ai].coordinates[0] - m->atoms[aj].coordinates[0];
		rijy =  m->atoms[ai].coordinates[1] - m->atoms[aj].coordinates[1];
		rijz =  m->atoms[ai].coordinates[2] - m->atoms[aj].coordinates[2];

		rij2 = rijx * rijx + rijy * rijy + rijz * rijz;
		if ( rij2 < POSEPS*POSEPS ) rij2 = POSEPS*POSEPS;	

		rij = sqrt( rij2 );
		rij3 = 1.0/(rij2 * rij);
		
		term3 = -C * rij3;
		gradix = term3 * rijx;
		gradiy = term3 * rijy;
		gradiz = term3 * rijz;
#ifdef ENABLE_OMP
#pragma omp critical
#endif
		{
			m->atoms[ai].gradient[0] += gradix;
			m->atoms[ai].gradient[1] += gradiy;
			m->atoms[ai].gradient[2] += gradiz;

			m->atoms[aj].gradient[0] -= gradix;
			m->atoms[aj].gradient[1] -= gradiy;
			m->atoms[aj].gradient[2] -= gradiz;
		}
		energy += C / rij;
		if(rij<1) printf("Warning : rij2 = %f atom# = %d atom# = %d\n",rij,ai+1,aj+1);
	//	printf("rij2 = %f ai = %d aj = %d\n",rij2,ai+1,aj+1);
	}  
	m->potentialEnergy += energy;
}
/**********************************************************************/
static double calculateRhoSuttonChenAmber(ForceField* forceField,Molecule* molecule)
{
	int i;
	double rijx, rijy, rijz;
	double rij2, rijm,rijn;
	int ai, aj;
	double term = 0;
	double energyAtt = 0;
	double energyRep = 0;

	Molecule* m = molecule;
	double* suttonChenTerms[SUTTONCHENDIM];
	int numberOfSuttonChen = forceField->numberOfSuttonChen;

	for(i=0;i<SUTTONCHENDIM;i++)
		suttonChenTerms[i] = forceField->suttonChenTerms[i];

	for (  i = 0; i < m->nAtoms; i++ ) m->atoms[i].rho = 0;

#ifdef ENABLE_OMP
#pragma omp parallel for private(i,ai,aj) 
#endif
	for (  i = 0; i < numberOfSuttonChen; i++ )
	{
		ai       = (int)suttonChenTerms[0][i];
		aj       = (int)suttonChenTerms[1][i];

		rijx =  m->atoms[ai].coordinates[0] - m->atoms[aj].coordinates[0];
		rijy =  m->atoms[ai].coordinates[1] - m->atoms[aj].coordinates[1];
		rijz =  m->atoms[ai].coordinates[2] - m->atoms[aj].coordinates[2];

		rij2 = rijx * rijx + rijy * rijy + rijz * rijz;
		if ( rij2 < POSEPS*POSEPS ) rij2 = POSEPS*POSEPS;	

		rijn = pow( suttonChenTerms[3][i]*suttonChenTerms[3][i]/rij2, suttonChenTerms[5][i]/2);
		rijm = pow( suttonChenTerms[3][i]*suttonChenTerms[3][i]/rij2, suttonChenTerms[6][i]/2);
		//printf("ai=%d aj=%d rijm = %f\n",ai,aj,rijm);
		
		term =  suttonChenTerms[4][i]* suttonChenTerms[4][i]*suttonChenTerms[2][i]*suttonChenTerms[2][i]*rijm;
		m->atoms[ai].rho += term;
		m->atoms[aj].rho += term;
		energyRep += suttonChenTerms[2][i]* rijn;
	}  
	for (  i = 0; i < m->nAtoms; i++ ) 
	{
		if(m->atoms[i].rho>0)   
		{
			m->atoms[i].rho = sqrt(m->atoms[i].rho);
			energyAtt +=  m->atoms[i].rho; 
			m->atoms[i].rho = 1/m->atoms[i].rho;
		}
		else  
		{
			m->atoms[i].rho  = 0;
		}
		//printf("i = %d rho = %f\n",i,m->atoms[i].rho);
	}
	/*
	printf("eneryRep = %f\n",energyRep);
	printf("eneryAtt = %f\n",-energyAtt);
	printf("eneryAll = %f\n",energyRep-energyAtt);
	*/
	//printf("enery ev par atom = %f\n",(energyRep-energyAtt)/ m->nAtoms*0.04336410);
	return energyRep - energyAtt;
}
/**********************************************************************/
void calculateGradientSuttonChenAmber(ForceField* forceField)
{
	int i;
	double rijx, rijy, rijz;
	double gradix, gradiy, gradiz;
	double rij2, rijn, rijm;
	double  term;
	int ai, aj;
	double energy = 0;

	Molecule* m = &forceField->molecule;
	double* suttonChenTerms[SUTTONCHENDIM];
	int numberOfSuttonChen = forceField->numberOfSuttonChen;

	for(i=0;i<SUTTONCHENDIM;i++)
		suttonChenTerms[i] = forceField->suttonChenTerms[i];

	energy = calculateRhoSuttonChenAmber(forceField,m);
#ifdef ENABLE_OMP
#pragma omp parallel for private(i,ai,aj) 
#endif
	for (  i = 0; i < numberOfSuttonChen; i++ )
	{
		ai       = (int)suttonChenTerms[0][i];
		aj       = (int)suttonChenTerms[1][i];

		rijx =  m->atoms[ai].coordinates[0] - m->atoms[aj].coordinates[0];
		rijy =  m->atoms[ai].coordinates[1] - m->atoms[aj].coordinates[1];
		rijz =  m->atoms[ai].coordinates[2] - m->atoms[aj].coordinates[2];

		rij2 = rijx * rijx + rijy * rijy + rijz * rijz;
		if ( rij2 < POSEPS*POSEPS ) rij2 = POSEPS*POSEPS;	

		rijn = pow( suttonChenTerms[3][i]*suttonChenTerms[3][i]/rij2, suttonChenTerms[5][i]/2);
		rijm = pow( suttonChenTerms[3][i]*suttonChenTerms[3][i]/rij2, suttonChenTerms[6][i]/2);
		
		//printf("rijn = %f rijm = %f\n", rijn,rijm);
		term =  suttonChenTerms[2][i]/rij2*
			(suttonChenTerms[5][i]*rijn-suttonChenTerms[4][i]*suttonChenTerms[4][i]*suttonChenTerms[2][i]*suttonChenTerms[6][i]/2*rijm*(m->atoms[ai].rho+m->atoms[aj].rho));
		//	(suttonChenTerms[5][i]*rijn);
		term = - term;
		gradix = term * rijx;
		gradiy = term * rijy;
		gradiz = term * rijz;
		//printf("ai = %d force=%f %f %f\n", ai, gradix, gradiy, gradiz);
#ifdef ENABLE_OMP
#pragma omp critical
#endif
		{
			m->atoms[ai].gradient[0] += gradix;
			m->atoms[ai].gradient[1] += gradiy;
			m->atoms[ai].gradient[2] += gradiz;

			m->atoms[aj].gradient[0] -= gradix;
			m->atoms[aj].gradient[1] -= gradiy;
			m->atoms[aj].gradient[2] -= gradiz;
		}
	}  
	//printf("Energy Dans grad = %f\n",energy);
	m->potentialEnergy += energy;
}
/**********************************************************************/
static void addDerivCosBeta(ForceField* forceField, int ai, int aj, int ak, double factor)
{
	Molecule* m = &forceField->molecule;

	double cosBeta, sinBeta;
	double delta = 1e-13;

	double rijx, rijy, rijz;
	double rkjx, rkjy, rkjz;
	//double rij, rkj;
	//double rij;
	double rij2, rkj2;
	double xp,yp,zp,rp;

	double term1, term2;
	double termAngleix, termAngleiy, termAngleiz;
	double termAnglekx, termAngleky, termAnglekz;
	double dot;


	rijx = m->atoms[ai].coordinates[0] - m->atoms[aj].coordinates[0];
	rijy = m->atoms[ai].coordinates[1] - m->atoms[aj].coordinates[1];
	rijz = m->atoms[ai].coordinates[2] - m->atoms[aj].coordinates[2];

	rkjx = m->atoms[ak].coordinates[0] - m->atoms[aj].coordinates[0];
	rkjy = m->atoms[ak].coordinates[1] - m->atoms[aj].coordinates[1];
	rkjz = m->atoms[ak].coordinates[2] - m->atoms[aj].coordinates[2];

	rij2 = rijx * rijx + rijy * rijy + rijz * rijz;
	//rij = sqrt(rij2);

	rkj2 = rkjx * rkjx + rkjy * rkjy + rkjz * rkjz;
	//rkj = sqrt(rkj2);

	dot = rijx*rkjx + rijy*rkjy + rijz*rkjz;
	cosBeta = dot / sqrt(rij2*rkj2);
	sinBeta = sqrt(fabs(1.0-cosBeta*cosBeta));


	xp = rkjy*rijz - rkjz*rijy;
	yp = rkjz*rijx - rkjx*rijz;
	zp = rkjx*rijy - rkjy*rijx;
	rp = sqrt(xp*xp + yp*yp + zp*zp);
	if ( rp < delta )
	{
		fprintf(forceField->logfile, "cut rp\n");
		fflush(forceField->logfile);
		rp = delta;
	}
       	term1 = sinBeta/rij2/rp*factor;
       	term2 =-sinBeta/rkj2/rp*factor;

        termAngleix = term1 * (rijy*zp-rijz*yp);
        termAngleiy = term1 * (rijz*xp-rijx*zp);
        termAngleiz = term1 * (rijx*yp-rijy*xp);

      	termAnglekx = term2 * (rkjy*zp-rkjz*yp);
      	termAngleky = term2 * (rkjz*xp-rkjx*zp);
      	termAnglekz = term2 * (rkjx*yp-rkjy*xp);

	m->atoms[ai].gradient[0] += termAngleix;
	m->atoms[ai].gradient[1] += termAngleiy;
	m->atoms[ai].gradient[2] += termAngleiz;

	m->atoms[ak].gradient[0] += termAnglekx;
	m->atoms[ak].gradient[1] += termAngleky;
	m->atoms[ak].gradient[2] += termAnglekz;

	m->atoms[aj].gradient[0] -= termAngleix + termAnglekx;
	m->atoms[aj].gradient[1] -= termAngleiy + termAngleky;
	m->atoms[aj].gradient[2] -= termAngleiz + termAnglekz;
}
/**********************************************************************/
static double getCosBeta(Molecule* m, int ai, int ax, int aj)
{
	double cosBeta = 1.0;
	if(ai>=0 && ax>=0 && aj>=0)
	{
		double rix =  m->atoms[ai].coordinates[0] - m->atoms[ax].coordinates[0];
		double riy =  m->atoms[ai].coordinates[1] - m->atoms[ax].coordinates[1];
		double riz =  m->atoms[ai].coordinates[2] - m->atoms[ax].coordinates[2];
		double ri2 = rix*rix+riy*riy+riz*riz;
		double rjx =  m->atoms[aj].coordinates[0] - m->atoms[ax].coordinates[0];
		double rjy =  m->atoms[aj].coordinates[1] - m->atoms[ax].coordinates[1];
		double rjz =  m->atoms[aj].coordinates[2] - m->atoms[ax].coordinates[2];
		double rj2 = rjx*rjx+rjy*rjy+rjz*rjz;
		cosBeta = (rix*rjx + riy*rjy + riz*rjz) / sqrt(ri2*rj2);
		if(cosBeta<-1) cosBeta = -1.0;
		if(cosBeta>1) cosBeta = 1.0;
	}
	return cosBeta;
}
/*********************************************************************/
static void calculateGradientHydrogenBonded612Amber(ForceField* forceField)
{
	int i;
	double energy = 0;

	Molecule* m = &forceField->molecule;
	double* hydrogenBondedTerms[HYDROGENBONDEDDIM];
	int numberOfHydrogenBonded =  forceField->numberOfHydrogenBonded;

	for(i=0;i<HYDROGENBONDEDDIM;i++)
		hydrogenBondedTerms[i] = forceField->hydrogenBondedTerms[i];

	/* Hydrogen-bonded part */
#ifdef ENABLE_OMP
#pragma omp parallel for private(i) 
#endif
	for (  i = 0; i < numberOfHydrogenBonded; i++ )
	{
		int ai, aj,ax;
		double e12, e6;

		double rijx, rijy, rijz;

		double gradix, gradiy, gradiz;
		double gradjx, gradjy, gradjz;
		double cosBeta = 1.0;

		double Cij, Dij, rij2,  rij4, rij6, rij8, rij12, rij14;
		double  term1, term2, term3;

		ai = (int)hydrogenBondedTerms[0][i];
		aj = (int)hydrogenBondedTerms[1][i];
		ax = (int)hydrogenBondedTerms[2][i];
		Cij = hydrogenBondedTerms[3][i];
		Dij = hydrogenBondedTerms[4][i];

		cosBeta = getCosBeta(m, ai, ax, aj);

		rijx =  m->atoms[ai].coordinates[0] - m->atoms[aj].coordinates[0];
		rijy =  m->atoms[ai].coordinates[1] - m->atoms[aj].coordinates[1];
		rijz =  m->atoms[ai].coordinates[2] - m->atoms[aj].coordinates[2];

		rij2 = rijx * rijx + rijy * rijy + rijz * rijz;

		if ( rij2 < POSEPS*POSEPS ) rij2 = POSEPS*POSEPS;	

		rij4 = rij2 * rij2;
		rij6 = rij4 * rij2;
		rij8 = rij4 * rij4;
		rij12 = rij8 * rij4;
		rij14 = rij12 * rij2;
		term1 = -12.0*Cij / rij14;
		term2 = +6*Dij / rij8*cosBeta;

		term3 = term1 + term2;
		gradix = term3 * rijx;
		gradiy = term3 * rijy;
		gradiz = term3 * rijz;
		gradjx = -gradix;
		gradjy = -gradiy;
		gradjz = -gradiz;
#ifdef ENABLE_OMP
#pragma omp critical
#endif
		{
			m->atoms[ai].gradient[0] += gradix;
			m->atoms[ai].gradient[1] += gradiy;
			m->atoms[ai].gradient[2] += gradiz;

			m->atoms[aj].gradient[0] += gradjx;
			m->atoms[aj].gradient[1] += gradjy;
			m->atoms[aj].gradient[2] += gradjz;
		}
		e12 =  Cij / rij12;
		e6 =  -Dij / (rij6);
		energy += e12 + cosBeta*e6;
		if(ax>-1) addDerivCosBeta(forceField, ai, ax, aj, e6);
	}
	m->potentialEnergy += energy;
}
/*********************************************************************/
static void calculateGradientHydrogenBonded1012Amber(ForceField* forceField)
{
	int i;
	double energy = 0;

	Molecule* m = &forceField->molecule;
	double* hydrogenBondedTerms[HYDROGENBONDEDDIM];
	int numberOfHydrogenBonded =  forceField->numberOfHydrogenBonded;

	for(i=0;i<HYDROGENBONDEDDIM;i++)
		hydrogenBondedTerms[i] = forceField->hydrogenBondedTerms[i];

	/* Hydrogen-bonded part */
#ifdef ENABLE_OMP
#pragma omp parallel for private(i) 
#endif
	for (  i = 0; i < numberOfHydrogenBonded; i++ )
	{
		int ai, aj,ax;
		double e12, e10;

		double rijx, rijy, rijz;

		double gradix, gradiy, gradiz;
		double gradjx, gradjy, gradjz;
		double cosBeta = 1.0;

		//double Cij, Dij, rij2,  rij4, rij6, rij8, rij12, rij14;
		double Cij, Dij, rij2,  rij4, rij8, rij12, rij14;
		double  term1, term2, term3;

		ai = (int)hydrogenBondedTerms[0][i];
		aj = (int)hydrogenBondedTerms[1][i];
		ax = (int)hydrogenBondedTerms[2][i];
		Cij = hydrogenBondedTerms[3][i];
		Dij = hydrogenBondedTerms[4][i];
		cosBeta = getCosBeta(m, ai, ax, aj);

		rijx =  m->atoms[ai].coordinates[0] - m->atoms[aj].coordinates[0];
		rijy =  m->atoms[ai].coordinates[1] - m->atoms[aj].coordinates[1];
		rijz =  m->atoms[ai].coordinates[2] - m->atoms[aj].coordinates[2];

		rij2 = rijx * rijx + rijy * rijy + rijz * rijz;

		if ( rij2 < POSEPS*POSEPS ) rij2 = POSEPS*POSEPS;	

		rij4 = rij2 * rij2;
		//rij6 = rij4 * rij2;
		rij8 = rij4 * rij4;
		rij12 = rij8 * rij4;
		rij14 = rij12 * rij2;
		term1 = -12.0*Cij / rij14;
		term2 = +10.0*Dij / rij12*cosBeta;

		term3 = term1 + term2;
		gradix = term3 * rijx;
		gradiy = term3 * rijy;
		gradiz = term3 * rijz;
		gradjx = -gradix;
		gradjy = -gradiy;
		gradjz = -gradiz;
#ifdef ENABLE_OMP
#pragma omp critical
#endif
		{
			m->atoms[ai].gradient[0] += gradix;
			m->atoms[ai].gradient[1] += gradiy;
			m->atoms[ai].gradient[2] += gradiz;

			m->atoms[aj].gradient[0] += gradjx;
			m->atoms[aj].gradient[1] += gradjy;
			m->atoms[aj].gradient[2] += gradjz;
		}
		e12 =  Cij / rij12;
		e10 =  -Dij / (rij8*rij2);
		energy += e12 + cosBeta*e10;
		if(ax>-1) addDerivCosBeta(forceField, ai, ax, aj, e10);
	}
	m->potentialEnergy += energy;
}
/*********************************************************************/
static void calculateGradientHydrogenBondedMorseAmber(ForceField* forceField)
{
	int i;
	double energy = 0;

	Molecule* m = &forceField->molecule;
	double* hydrogenBondedTerms[HYDROGENBONDEDDIM];
	int numberOfHydrogenBonded =  forceField->numberOfHydrogenBonded;

	for(i=0;i<HYDROGENBONDEDDIM;i++) hydrogenBondedTerms[i] = forceField->hydrogenBondedTerms[i];

	/* Hydrogen-bonded part */
#ifdef ENABLE_OMP
#pragma omp parallel for private(i) 
#endif
	for (  i = 0; i < numberOfHydrogenBonded; i++ )
	{
		int ai, aj,ax;
		double e;

		double rijx, rijy, rijz;

		double gradix, gradiy, gradiz;
		double gradjx, gradjy, gradjz;
		double cosBeta = 1.0;

		double alpha, Re, De, rij,  rij2;
		double  X, term2, term3;

		ai = (int)hydrogenBondedTerms[0][i];
		aj = (int)hydrogenBondedTerms[1][i];
		ax = (int)hydrogenBondedTerms[2][i];
		alpha = hydrogenBondedTerms[3][i];
		Re = hydrogenBondedTerms[4][i];
		De = hydrogenBondedTerms[5][i];
		cosBeta = getCosBeta(m, ai, ax, aj);

		rijx =  m->atoms[ai].coordinates[0] - m->atoms[aj].coordinates[0];
		rijy =  m->atoms[ai].coordinates[1] - m->atoms[aj].coordinates[1];
		rijz =  m->atoms[ai].coordinates[2] - m->atoms[aj].coordinates[2];

		rij2 = rijx * rijx + rijy * rijy + rijz * rijz;

		if ( rij2 < POSEPS*POSEPS ) rij2 = POSEPS*POSEPS;	

		rij = sqrt(rij2);
		X = exp(-alpha*(rij-Re));
		term2 = 1-X;
		term3 = 2*De*term2*X*alpha/rij*cosBeta;

		gradix = term3 * rijx;
		gradiy = term3 * rijy;
		gradiz = term3 * rijz;
		gradjx = -gradix;
		gradjy = -gradiy;
		gradjz = -gradiz;
#ifdef ENABLE_OMP
#pragma omp critical
#endif
		{
			m->atoms[ai].gradient[0] += gradix;
			m->atoms[ai].gradient[1] += gradiy;
			m->atoms[ai].gradient[2] += gradiz;

			m->atoms[aj].gradient[0] += gradjx;
			m->atoms[aj].gradient[1] += gradjy;
			m->atoms[aj].gradient[2] += gradjz;
		}
		e = De*(X*X-2*X);
		energy += cosBeta*e;
		if(ax>-1) addDerivCosBeta(forceField, ai, ax, aj, e);
	}
	m->potentialEnergy += energy;
}
/*********************************************************************/
static void calculateGradientHydrogenBondedAmber(ForceField* forceField)
{
	if(forceField->options.hydrogenBonded612) calculateGradientHydrogenBonded612Amber(forceField);
	else if(forceField->options.hydrogenBonded1012) calculateGradientHydrogenBonded1012Amber(forceField);
	else if(forceField->options.hydrogenBondedMorse) calculateGradientHydrogenBondedMorseAmber(forceField);
}
/**********************************************************************/
static void calculateGradientPairWise(ForceField* forceField)
{
	int i;
	int ai, aj;
	double energy = 0;

	double rijx, rijy, rijz;

	double gradix, gradiy, gradiz;
	double gradjx, gradjy, gradjz;

	double permittivityScale = 1, permittivity = 1;
	double coulombFactor;
	double rij2, rij;
	double rij3,rij5;
	double coulombTerm;
	double rij6, rij7, rij8, rij9, rij10, rij11, rij12;
	double  term1, term4, term6, term8, term10, termAll;
	double A, Beta, C4, C6, C8, C10,b;
	double s, sp, fact, br, brk, ebr;
	int n, k;
	double  B6, B8, B10;

	boolean useCoulomb = forceField->options.coulomb;
	boolean useVanderWals = forceField->options.vdw612;
	Molecule* m = &forceField->molecule;
	double* pairWiseTerms[PAIRWISEDIM];
	int numberOfPairWise = forceField->numberOfPairWise;

	for(i=0;i<PAIRWISEDIM;i++)
		pairWiseTerms[i] = forceField->pairWiseTerms[i];

	/* non-bonded part */
	coulombFactor = 332.05382 / ( permittivity * permittivityScale );
	B6 = 0;
	B8 = 0;
	B10 = 0;
	for (  i = 0; i < numberOfPairWise; i++ )
	{
		ai       = (int)pairWiseTerms[0][i];
		aj       = (int)pairWiseTerms[1][i];
		A        = pairWiseTerms[2][i];
		Beta     = pairWiseTerms[3][i];
		C4       = pairWiseTerms[4][i];
		C6       = pairWiseTerms[5][i];
		C8       = pairWiseTerms[6][i];
		C10      = pairWiseTerms[7][i];
		b        = pairWiseTerms[8][i];

		rijx =  m->atoms[ai].coordinates[0] - m->atoms[aj].coordinates[0];
		rijy =  m->atoms[ai].coordinates[1] - m->atoms[aj].coordinates[1];
		rijz =  m->atoms[ai].coordinates[2] - m->atoms[aj].coordinates[2];

		rij2 = rijx * rijx + rijy * rijy + rijz * rijz;
		if ( rij2 < POSEPS*POSEPS ) rij2 = POSEPS*POSEPS;	

		rij = sqrt( rij2 );
		rij3 = rij2 * rij;
		rij5 = rij3 * rij2;
		rij6 = rij3 * rij3;
		rij7 = rij6 * rij;
		rij8 = rij7 * rij;
		rij9 = rij8 * rij;
		rij10 = rij9 * rij;
		rij11 = rij10 * rij;
		rij12 = rij11 * rij;
		if(useCoulomb)
			coulombTerm = ( m->atoms[ai].charge*m->atoms[aj].charge * coulombFactor ) / rij3;
		else
			coulombTerm = 0.0;
		
		/*term1 = -A*Beta/rij*exp(-Beta*rij);*/
		term1 = A*Beta/rij*exp(-Beta*rij);

		br = b*rij;
		ebr = exp(-b*rij);

		term4 =   0.0;
		if(useVanderWals && fabs(C4)>1e-12)
		{
			fact = 1.0;
			s = 1.0;
			n = 2;
			brk = 1.0;
			for(k=1;k<2*n;k++)
			{
				fact *= k;
				brk *= br;
				s += brk/fact;
			}
			sp = s*b;
			fact *=2*n;
			brk *= br;
			s += brk/fact;
			term4 =   b*C4*ebr*s/rij5
				-(2*n)*C4*(1-ebr*s)/rij6
				-C4*ebr/rij5*sp;
		}

		term6 =   0.0;
		if(useVanderWals && fabs(C6)>1e-12)
		{
			fact = 1.0;
			s = 1.0;
			n = 3;
			brk = 1.0;
			for(k=1;k<2*n;k++)
			{
				fact *= k;
				brk *= br;
				s += brk/fact;
			}
			sp = s*b;
			fact *=2*n;
			brk *= br;
			s += brk/fact;
			term6 =   b*C6*ebr*s/rij7
				-(2*n)*C6*(1-ebr*s)/rij8
				-C6*ebr/rij7*sp;
		}
		term8 =   0.0;
		if(useVanderWals && fabs(C8)>1e-12)
		{
			fact = 1.0;
			s = 1.0;
			n = 4;
			brk = 1.0;
			for(k=1;k<2*n;k++)
			{
				fact *= k;
				brk *= br;
				s += brk/fact;
			}
			sp = s*b;
			fact *=2*n;
			brk *= br;
			s += brk/fact;
			term8 =   b*C8*ebr*s/rij9
				-(2*n)*C8*(1-ebr*s)/rij10
				-C8*ebr/rij9*sp;
		}

		term10 =   0.0;
		if(useVanderWals && fabs(C10)>1e-12)
		{
			fact = 1.0;
			s = 1.0;
			n = 5;
			brk = 1.0;
			for(k=1;k<2*n;k++)
			{
				fact *= k;
				brk *= br;
				s += brk/fact;
			}
			sp = s*b;

			fact *=2*n;
			brk *= br;
			s += brk/fact;
			term10 =   b*C10*ebr*s/rij11
				-(2*n)*C10*(1-ebr*s)/rij12
				-C10*ebr/rij11*sp;
		}

		//termAll = term1 - term6 - term8 - term10 + coulombTerm;
		termAll = term1 + term4 + term6 + term8 + term10 + coulombTerm;
		termAll = - termAll;


		gradix = termAll * rijx;
		gradiy = termAll * rijy;
		gradiz = termAll * rijz;
		gradjx = - gradix;
		gradjy = - gradiy;
		gradjz = - gradiz;
#ifdef ENABLE_OMP
#pragma omp critical
#endif
		{
			m->atoms[ai].gradient[0] += gradix;
			m->atoms[ai].gradient[1] += gradiy;
			m->atoms[ai].gradient[2] += gradiz;

			m->atoms[aj].gradient[0] += gradjx;
			m->atoms[aj].gradient[1] += gradjy;
			m->atoms[aj].gradient[2] += gradjz;
		}
		if(useCoulomb) coulombTerm = ( m->atoms[ai].charge*m->atoms[aj].charge * coulombFactor ) / rij;
		else coulombTerm = 0.0;

		B6  = 0;
		B8  = 0;
		B10 = 0;
		/* printf("A = %f Beta = %f qi = %f qj = %f rij = %f\n",A,Beta,chargei,chargej,rij);*/
		if(useVanderWals)
		{
			double fact = 1.0;
			double s = 1.0;
			double br = b*rij;
			double brk = 1.0;
			int k;

			if(fabs(C6)>1e-12)
			{
				for(k=1;k<=2*3;k++)
				{
					fact *= k;
					brk *= br;
					s += brk/fact;
				}
				B6 = C6*(1-exp(-br)*s);
			}

			if(fabs(C8)>1e-12)
			{
				fact = 1.0;
				s = 1.0;
				br = b*rij;
				brk = 1.0;
				for(k=1;k<=2*4;k++)
				{
					fact *= k;
					brk *= br;
					s += brk/fact;
				}
				B8 = C8*(1-exp(-br)*s);
			}

			if(fabs(C10)>1e-12)
			{
				fact = 1.0;
				s = 1.0;
				br = b*rij;
				brk = 1.0;
				for(k=1;k<=2*5;k++)
				{
					fact *= k;
					brk *= br;
					s += brk/fact;
				}
				B10 = C10*(1-exp(-br)*s);
			}
		}

		energy += A*exp(-Beta*rij)
			- B6 / rij6 
			- B8 / rij8 
			- B10 / rij10 
			+ coulombTerm;
	}  
	m->potentialEnergy += energy;
}
#endif /* ENABLE_CL */
/**********************************************************************/
static void calculateGradientAmberAnalytic(ForceField* forceField)
{
#ifdef DEBUG
        TimerType timer;
        TimerType timer2;
#endif
#ifdef ENABLE_CL
	CLProp clProp = getCLProp();
	//size_t local = 64;
	size_t global;
	int i;
	int j;
	cl_int err;

#ifdef DEBUG
        timer_init(timer);
       	timer_start( timer );
#endif
	forceField->molecule.potentialEnergy = 0;
#ifdef DEBUG
	fprintf(forceField->logfile, "Begin calculateGradientAmber\n");
#endif
/*
	global = forceField->nMaxTerms;
	clEnqueueNDRangeKernel(clProp.command_queue, forceField->initVelocitiesKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	clFinish(clProp.command_queue);
*/
//	if(forceField->numberOfVdw612<forceField->nMaxTerms)
	{
#ifdef DEBUG
        timer_init(timer2);
       	timer_start( timer2 );
#endif
	global = forceField->nMaxTerms;
	err = clEnqueueNDRangeKernel(clProp.command_queue, forceField->initEnergyKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	if(err != CL_SUCCESS)
	{
		printErrorCLRun(err);
        	fprintf(forceField->logfile, "I cannot execute initEnergyKernel\n");
		fflush(forceField->logfile);
		exit(1);
	}
	clFinish(clProp.command_queue);
#ifdef DEBUG
       	timer_stop(timer2);
        fprintf(forceField->logfile, "time initEnergy (s) = %f\n", timer_get(timer2)*1e-6);
	fflush(forceField->logfile);

        timer_init(timer2);
       	timer_start( timer2 );
#endif
	//global = forceField->nBlockGradientBuffer*forceField->molecule.nAtoms;
	global = forceField->molecule.nAtoms;
	global = forceField->nBlockGradientBuffer;
	//global = forceField->nMaxTerms;
	global = forceField->nBlockGradientBuffer*forceField->molecule.nAtoms;
	//global = 512;
	err = clEnqueueNDRangeKernel(clProp.command_queue, forceField->initGradientsKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	if(err != CL_SUCCESS)
	{
		printErrorCLRun(err);
        	fprintf(forceField->logfile, "I cannot execute initGradientsKernel\n");
		fflush(forceField->logfile);
		exit(1);
	}
	clFinish(clProp.command_queue);
#ifdef DEBUG
       	timer_stop(timer2);
        fprintf(forceField->logfile, "time initGrad (s) = %f\n", timer_get(timer2)*1e-6);
	fflush(forceField->logfile);
#endif
	}
	if(forceField->numberOfVdw612>0)
	{
#ifdef DEBUG
        timer_init(timer2);
       	timer_start( timer2 );
#endif
	//size_t local = 128;
	//global = ((forceField->numberOfVdw612+local-1)/local)*local;
	//clEnqueueNDRangeKernel(clProp.command_queue, forceField->addGradientVdw612AmberKernel, 1, NULL, &global, &local, 0, NULL, NULL);
	global = forceField->numberOfVdw612;
	global = forceField->molecule.nAtoms;
	global = 64;
	global = forceField->numberOfVdw612;
	clEnqueueNDRangeKernel(clProp.command_queue, forceField->addGradientVdw612AmberKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	clFinish(clProp.command_queue);
#ifdef DEBUG
       	timer_stop(timer2);
        fprintf(forceField->logfile, "time Vdw612 (s) = %f\n", timer_get(timer2)*1e-6);
	fflush(forceField->logfile);
#endif
	}
	if(forceField->numberOfVdw714>0)
	{
#ifdef DEBUG
        timer_init(timer2);
       	timer_start( timer2 );
#endif
	//size_t local = 128;
	//global = ((forceField->numberOfVdw714+local-1)/local)*local;
	//clEnqueueNDRangeKernel(clProp.command_queue, forceField->addGradientVdw714AmberKernel, 1, NULL, &global, &local, 0, NULL, NULL);
	global = forceField->numberOfVdw714;
	global = forceField->molecule.nAtoms;
	global = 64;
	global = forceField->numberOfVdw714;
	clEnqueueNDRangeKernel(clProp.command_queue, forceField->addGradientVdw714AmberKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	clFinish(clProp.command_queue);
#ifdef DEBUG
       	timer_stop(timer2);
        fprintf(forceField->logfile, "time Vdw714 (s) = %f\n", timer_get(timer2)*1e-6);
	fflush(forceField->logfile);
#endif
	}
	if(forceField->numberOfSuttonChen>0)
	{
	global = forceField->numberOfSuttonChen;
	clEnqueueNDRangeKernel(clProp.command_queue, forceField->initRhoKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	clEnqueueNDRangeKernel(clProp.command_queue, forceField->computeRhoKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	global = forceField->molecule.nAtoms;
	clEnqueueNDRangeKernel(clProp.command_queue, forceField->reduceRhoKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	global = forceField->numberOfSuttonChen;
#ifdef DEBUG
        timer_init(timer2);
       	timer_start( timer2 );
#endif
	//size_t local = 128;
	//global = ((forceField->numberOfVdw612+local-1)/local)*local;
	//clEnqueueNDRangeKernel(clProp.command_queue, forceField->addGradientSuttonChenAmberKernel, 1, NULL, &global, &local, 0, NULL, NULL);
	global = forceField->numberOfSuttonChen;
	global = forceField->molecule.nAtoms;
	global = 64;
	global = forceField->numberOfSuttonChen;
	clEnqueueNDRangeKernel(clProp.command_queue, forceField->addGradientSuttonChenKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	clFinish(clProp.command_queue);
#ifdef DEBUG
       	timer_stop(timer2);
        fprintf(forceField->logfile, "time Vdw612 (s) = %f\n", timer_get(timer2)*1e-6);
	fflush(forceField->logfile);
#endif
	}


/*
	global = forceField->molecule.nAtoms;
	//global = forceField->nMaxTerms;
	err = clEnqueueNDRangeKernel(clProp.command_queue, forceField->initVelocitiesKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	if(err != CL_SUCCESS)
	{
		printErrorCLRun(err);
        	fprintf(forceField->logfile, "I cannot execute initVelocitiesKernel\n");
		fflush(forceField->logfile);
		exit(1);
	}
	clFinish(clProp.command_queue);
*/

	if(forceField->numberOfStretchTerms>0)
	{
#ifdef DEBUG
        timer_init(timer2);
       	timer_start( timer2 );
#endif
	//size_t local = 16;
	//global = ((forceField->numberOfStretchTerms+local-1)/local)*local;
	global = forceField->numberOfStretchTerms;
	//global = forceField->nMaxTerms;
	//fprintf(forceField->logfile, "Call addGradientBondAmberKernel \n");
	//fflush(forceField->logfile);
	err = clEnqueueNDRangeKernel(clProp.command_queue, forceField->addGradientBondAmberKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	if(err != CL_SUCCESS)
	{
		printErrorCLRun(err);
        	fprintf(forceField->logfile, "I cannot execute addGradientBondAmberKernel\n");
		fflush(forceField->logfile);
		exit(1);
	}
	clFinish(clProp.command_queue);
#ifdef DEBUG
       	timer_stop(timer2);
        fprintf(forceField->logfile, "time Bond (s) = %f\n", timer_get(timer2)*1e-6);
	fflush(forceField->logfile);
#endif
	}

	if(forceField->numberOfBendTerms>0)
	{
#ifdef DEBUG
        timer_init(timer2);
       	timer_start( timer2 );
#endif
	global = forceField->numberOfBendTerms;
	//global = forceField->nMaxTerms;
	clEnqueueNDRangeKernel(clProp.command_queue, forceField->addGradientBendAmberKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	clFinish(clProp.command_queue);
#ifdef DEBUG
       	timer_stop(timer2);
        fprintf(forceField->logfile, "time Bend (s) = %f\n", timer_get(timer2)*1e-6);
	fflush(forceField->logfile);
#endif
	}

	if(forceField->numberOfDihedralTerms>0)
	{
#ifdef DEBUG
        timer_init(timer2);
       	timer_start( timer2 );
#endif
	global = forceField->numberOfDihedralTerms;
	//global = forceField->nMaxTerms;
	clEnqueueNDRangeKernel(clProp.command_queue, forceField->addGradientDihedralAmberKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	clFinish(clProp.command_queue);
#ifdef DEBUG
       	timer_stop(timer2);
        fprintf(forceField->logfile, "time Dihedral (s) = %f\n", timer_get(timer2)*1e-6);
	fflush(forceField->logfile);
#endif
	}


	if(forceField->numberOfHydrogenBonded>0)
	{
#ifdef DEBUG
        timer_init(timer2);
       	timer_start( timer2 );
#endif
	global = forceField->numberOfHydrogenBonded;
	//global = forceField->nMaxTerms;
	clEnqueueNDRangeKernel(clProp.command_queue, forceField->addGradientHydrogenBondedAmberKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	clFinish(clProp.command_queue);
#ifdef DEBUG
       	timer_stop(timer2);
        fprintf(forceField->logfile, "time HydrogenBonded (s) = %f\n", timer_get(timer2)*1e-6);
	fflush(forceField->logfile);
#endif
	}

	if(forceField->numberOfPairWise>0)
	{
	global = forceField->numberOfPairWise;
	//global = forceField->nMaxTerms;
	clEnqueueNDRangeKernel(clProp.command_queue, forceField->addGradientPairWiseKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	clFinish(clProp.command_queue);
	}

#ifdef DEBUG
        timer_init(timer2);
       	timer_start( timer2 );
#endif
	global = forceField->molecule.nAtoms;
	global = 512;
	clEnqueueNDRangeKernel(clProp.command_queue, forceField->reduceGradientsKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	clFinish(clProp.command_queue);
#ifdef DEBUG
       	timer_stop(timer2);
        fprintf(forceField->logfile, "time reduceGrad (s) = %f\n", timer_get(timer2)*1e-6);
	fflush(forceField->logfile);

        timer_init(timer2);
       	timer_start( timer2 );
#endif
	clEnqueueReadBuffer(clProp.command_queue, forceField->gradientBufferCL, CL_TRUE, 0, sizeof(cl_float4)*forceField->molecule.nAtoms, forceField->gradientBufferCPU, 0, NULL, NULL);
	for( i=0; i<forceField->molecule.nAtoms;i++)
	{
		if(!forceField->molecule.atoms[i].variable)
			for(j=0;j<3;j++)
				forceField->molecule.atoms[i].gradient[j] = 0.0;
		else
			for(j=0;j<3;j++)
				forceField->molecule.atoms[i].gradient[j] = forceField->gradientBufferCPU[i].s[j];
	}
	clEnqueueReadBuffer(clProp.command_queue, forceField->energyBufferCL, CL_TRUE, 0, sizeof(cl_float)*forceField->nMaxTerms, forceField->energyBufferCPU, 0, NULL, NULL);
	forceField->molecule.potentialEnergy = 0;
	for(i=0;i<forceField->nMaxTerms;i++) forceField->molecule.potentialEnergy+=forceField->energyBufferCPU[i];
#ifdef DEBUG
       	timer_stop(timer2);
        fprintf(forceField->logfile, "time read buffer (s) = %f\n", timer_get(timer2)*1e-6);
	fflush(forceField->logfile);
       	timer_stop(timer);
        fprintf(forceField->logfile, "time (s) = %f\n", timer_get(timer)*1e-6);
	fflush(forceField->logfile);
#endif
#else // ENABLE_CL
	int i;
	int j;
	Molecule* m = &forceField->molecule;

	forceField->molecule.potentialEnergy = 0;

#ifdef DEBUG
        timer_init(timer);
       	timer_start( timer );
#endif

	for(j=0;j<3;j++)
		for( i=0; i<m->nAtoms;i++)
			m->atoms[i].gradient[j] = 0.0;

	if(!strstr(forceField->options.chargesType,"BEGIN")) setCharges(forceField);
	calculateGradientBondAmber(forceField);
	calculateGradientBendAmber(forceField);
	calculateGradientStrBendAmber(forceField);
#ifdef DEBUG
        timer_init(timer2);
       	timer_start( timer2 );
#endif
	calculateGradientDihedralAmber(forceField);
#ifdef DEBUG
       	timer_stop(timer2);
        fprintf(forceField->logfile, "time Dihedral (s) = %f\n", timer_get(timer2)*1e-6);
	fflush(forceField->logfile);
#endif
	calculateGradientImproperTorsion(forceField);
#ifdef DEBUG
        timer_init(timer2);
       	timer_start( timer2 );
#endif
	calculateGradientVdw612Amber(forceField);
#ifdef DEBUG
       	timer_stop(timer2);
        fprintf(forceField->logfile, "time Vdw612 (s) = %f\n", timer_get(timer2)*1e-6);
	fflush(forceField->logfile);
#endif

#ifdef DEBUG
        timer_init(timer2);
       	timer_start( timer2 );
#endif
	calculateGradientVdw714Amber(forceField);
#ifdef DEBUG
       	timer_stop(timer2);
        fprintf(forceField->logfile, "time Vdw714 (s) = %f\n", timer_get(timer2)*1e-6);
	fflush(forceField->logfile);
#endif

#ifdef DEBUG
        timer_init(timer2);
       	timer_start( timer2 );
#endif
	calculateGradientSuttonChenAmber(forceField);
#ifdef DEBUG
       	timer_stop(timer2);
        fprintf(forceField->logfile, "time SuttonChen (s) = %f\n", timer_get(timer2)*1e-6);
	fflush(forceField->logfile);
#endif

	calculateGradientCoulombAmber(forceField);
	calculateGradientHydrogenBondedAmber(forceField);
	calculateGradientPairWise(forceField);
	addH4Correction(forceField, TRUE);
	addWallCorrection(forceField,TRUE);

	for( i=0; i<m->nAtoms;i++)
	{
		if(!m->atoms[i].variable)
			for(j=0;j<3;j++)
				m->atoms[i].gradient[j] = 0.0;
	}
#ifdef DEBUG
       	timer_stop(timer);
        fprintf(forceField->logfile, "time (s) = %f\n", timer_get(timer)*1e-6);
	fflush(forceField->logfile);
#endif
#endif // ENABLE_CL
}
/**********************************************************************/
static void calculateGradientAmber(ForceField* forceField)
{
	if(!forceField->options.numeric) calculateGradientAmberAnalytic(forceField);
	else forceField->klass->calculateGradientNumeric(forceField);
}
/**********************************************************************/
/*
static void calculateGradientNumericAmber(ForceField* forceField)
{
	int i;
	int j;
	Molecule* m = &forceField->molecule;
	double h=0.0001;
	double E1;
	double E2;

	for(j=0;j<3;j++)
		for( i=0; i<m->nAtoms;i++)
		{
			m->atoms[i].coordinates[j] += h;
			E1 = calculateEnergyTmpAmber(forceField,&m);
			m->atoms[i].coordinates[j] -= h+h;
			E2 = calculateEnergyTmpAmber(forceField,&m);
			m->atoms[i].coordinates[j] += h;
			m->atoms[i].gradient[j] = (E1-E2)/2/h;
		}


}
*/
#ifndef ENABLE_CL
/**********************************************************************/
static double calculateEnergyBondAmber(ForceField* forceField,Molecule* molecule)
{
	int i;

	Molecule* m = molecule;
	double* bondStretchTerms[STRETCHDIM];
	int numberOfStretchTerms = forceField->numberOfStretchTerms;
	double energy = 0.0;

	for( i=0; i<STRETCHDIM;i++) bondStretchTerms[i] = forceField->bondStretchTerms[i];


#ifdef ENABLE_OMP
#pragma omp parallel for private(i) reduction(+:energy)
#endif
	for (  i = 0; i < numberOfStretchTerms; i++ )
	{
		int ai, aj;
		double rijx, rijy, rijz, forceOrAlpha, equilibriumDistance;
		double h3OrDe, h4, h5, h6;
		double bondLength;
		double diff, diff2, diff3, diff4, diff5, diff6;
		int type = 0;

		type = (int)bondStretchTerms[0][i];
		ai = (int)bondStretchTerms[1][i];
		aj = (int)bondStretchTerms[2][i];
		forceOrAlpha = bondStretchTerms[3][i];
		equilibriumDistance = bondStretchTerms[4][i];
		h3OrDe = bondStretchTerms[5][i];
		h4 = bondStretchTerms[6][i];
		h5 = bondStretchTerms[7][i];
		h6 = bondStretchTerms[8][i];
		
		rijx =  m->atoms[ai].coordinates[0] - m->atoms[aj].coordinates[0];
		rijy =  m->atoms[ai].coordinates[1] - m->atoms[aj].coordinates[1];
		rijz =  m->atoms[ai].coordinates[2] - m->atoms[aj].coordinates[2];

		bondLength = sqrt( rijx * rijx + rijy * rijy + rijz * rijz );
		diff = bondLength - equilibriumDistance;

		if(type==0)
		{
			diff2 = diff*diff;
			diff3 = diff2*diff;
			diff4 = diff3*diff;
			diff5 = diff4*diff;
			diff6 = diff5*diff;
			energy += forceOrAlpha * diff2;
			energy += h3OrDe * forceOrAlpha * diff3;
			energy += h4 * forceOrAlpha * diff4;
			energy += h5 * forceOrAlpha * diff5;
			energy += h6 * forceOrAlpha * diff6;
		}
		else
		{
			double alpha = forceOrAlpha;
			double De = h3OrDe;
			double X = exp(-alpha*(bondLength-equilibriumDistance));
			double t = 1-X;
			energy += De*t*t;
		}
	} 
	return energy;
}
/**********************************************************************/
static double calculateEnergyBendAmber(ForceField* forceField,Molecule* molecule)
{
	int i;
	double energy = 0.0;
	static double D2R = 1/(RADTODEG);

	Molecule* m = molecule;
	double* angleBendTerms[BENDDIM];
	int numberOfBendTerms = forceField->numberOfBendTerms;

	for( i=0; i<BENDDIM;i++)
		angleBendTerms[i] = forceField->angleBendTerms[i]; 

#ifdef ENABLE_OMP
#pragma omp parallel for private(i) reduction(+:energy)
#endif
	for (  i = 0; i < numberOfBendTerms; i++ )
	{
//HERE
		int ai, aj, ak;
		double thetaRad;
		double cosine;
		double diff = 0;
		double diff2 = 0;
		double diff3 = 0;
		double diff4 = 0;

		double rijx, rijy, rijz;
		double rkjx, rkjy, rkjz;
		double rij2, rkj2;

		double rijDotrkj;

		ai = (int)angleBendTerms[0][i];
		aj = (int)angleBendTerms[1][i];
		ak = (int)angleBendTerms[2][i];

		rijx = m->atoms[ai].coordinates[0] - m->atoms[aj].coordinates[0];
		rijy = m->atoms[ai].coordinates[1] - m->atoms[aj].coordinates[1];
		rijz = m->atoms[ai].coordinates[2] - m->atoms[aj].coordinates[2];
		rij2 = rijx * rijx + rijy * rijy + rijz * rijz;

		rkjx = m->atoms[ak].coordinates[0] - m->atoms[aj].coordinates[0];
		rkjy = m->atoms[ak].coordinates[1] - m->atoms[aj].coordinates[1];
		rkjz = m->atoms[ak].coordinates[2] - m->atoms[aj].coordinates[2];
		rkj2 = rkjx * rkjx + rkjy * rkjy + rkjz * rkjz;

		if (rij2==0 || rkj2==0) continue;

		rijDotrkj = rijx * rkjx + rijy * rkjy + rijz * rkjz;

	        cosine = rijDotrkj / sqrt(rij2*rkj2);
		if(cosine>1) cosine = 1;
		if(cosine<-1) cosine = -1;
                thetaRad = acos(cosine);
		diff =  thetaRad - D2R*angleBendTerms[4][i];
		diff2 = diff*diff;
		diff3 = diff2*diff;
		diff4 = diff3*diff;

		energy += angleBendTerms[3][i]*diff2*
		(1.0+angleBendTerms[5][i]*diff+angleBendTerms[6][i]*diff2+angleBendTerms[7][i]*diff3+angleBendTerms[8][i]*diff4);
	} 
	//printf("Energy bend = %f\n",energy);
	return energy;
}
/**********************************************************************/
static double calculateEnergyStrBendAmber(ForceField* forceField,Molecule* molecule)
{
	int i;
	int ai, aj, ak;
	double thetaDeg;
	double term;
	double energy = 0.0;
	static double D2R = 1/(RADTODEG);
	double forceConstant12;
	double forceConstant23;
	double Re12;
	double Re23;
	double angle123;
	double R12;
	double R23;
	double rx, ry, rz;


	Molecule* m = molecule;
	double* strBendTerms[STRBENDDIM];
	int numberOfStrBendTerms = forceField->numberOfStrBendTerms;

	for( i=0; i<STRBENDDIM;i++)
		strBendTerms[i] = forceField->strBendTerms[i]; 

#ifdef ENABLE_OMP
#pragma omp parallel for private(i,ai,aj,ak,thetaDeg,term) reduction(+:energy)
#endif
	for (  i = 0; i < numberOfStrBendTerms; i++ )
	{
		ai = (int)strBendTerms[2][i];
		aj = (int)strBendTerms[3][i];
		ak = (int)strBendTerms[4][i];
		forceConstant12 = strBendTerms[5][i];
		forceConstant23 = strBendTerms[6][i];
		Re12 = strBendTerms[7][i];
		Re23 = strBendTerms[8][i];
		angle123 = strBendTerms[9][i];
		thetaDeg = getAngle(  &m->atoms[ai] ,&m->atoms[aj], &m->atoms[ak]);
	        rx = m->atoms[ai].coordinates[0] - m->atoms[aj].coordinates[0];
                ry = m->atoms[ai].coordinates[1] - m->atoms[aj].coordinates[1];
                rz = m->atoms[ai].coordinates[2] - m->atoms[aj].coordinates[2];
                R12 = sqrt( rx * rx + ry * ry + rz * rz );

	        rx = m->atoms[ak].coordinates[0] - m->atoms[aj].coordinates[0];
                ry = m->atoms[ak].coordinates[1] - m->atoms[aj].coordinates[1];
                rz = m->atoms[ak].coordinates[2] - m->atoms[aj].coordinates[2];
                R23 = sqrt( rx * rx + ry * ry + rz * rz );
		term = D2R*(thetaDeg - angle123)*(forceConstant12*(R12 - Re12)+forceConstant23*(R23 - Re23));
		energy += term;
	
		/*
		fprintf(forceField->logfile, "f =%f t0 = %f  t= %f e= %f\n",
			strBendTerms[5][i],
			strBendTerms[6][i],
			thetaDeg,
			energy);
		fflush(forceField->logfile);
		*/
	

	} 
	return energy;
}
/**********************************************************************/
double calculateEnergyDihedralAmber(ForceField* forceField,Molecule* molecule)
{
	int i;
	int ai, aj, ak, al;
	double phiDeg;
	Molecule* m = molecule;
	double* dihedralAngleTerms[DIHEDRALDIM];
	int numberOfDihedralTerms = forceField->numberOfDihedralTerms;
	double energy = 0.0;
	static double D2R = 1/(RADTODEG);

	for(i=0;i<DIHEDRALDIM;i++)
		dihedralAngleTerms[i] = forceField->dihedralAngleTerms[i];

#ifdef ENABLE_OMP
#pragma omp parallel for private(i,ai,aj,ak,al,phiDeg) reduction(+:energy)
#endif
	for (  i = 0; i < numberOfDihedralTerms; i++ )
	{
		ai = (int)dihedralAngleTerms[0][i];
		aj = (int)dihedralAngleTerms[1][i];
		ak = (int)dihedralAngleTerms[2][i];
		al = (int)dihedralAngleTerms[3][i];

		phiDeg = getTorsion(  &m->atoms[ai] ,&m->atoms[aj], &m->atoms[ak], &m->atoms[al]);

		energy += dihedralAngleTerms[5][i]/dihedralAngleTerms[4][i] * 
		( 1.0 + cos( D2R*(dihedralAngleTerms[7][i] * phiDeg - dihedralAngleTerms[6][i] )) );
	}
	return energy;
}
/**********************************************************************/
static double calculateEnergyImproperTorsionAmber(ForceField* forceField,Molecule* molecule)
{
//HERE
	int i;
	Molecule* m = &forceField->molecule;
	double forceConstant, equilibriumAngle;
	int numberOfImproperTorsionTerms = forceField->numberOfImproperTorsionTerms;
	double* improperTorsionTerms[IMPROPERDIHEDRALDIM];
	static double D2R = 1/(RADTODEG);
	double energy = 0;
	double phiDeg;

	for(i=0;i<IMPROPERDIHEDRALDIM;i++) improperTorsionTerms[i] = forceField->improperTorsionTerms[i];

#ifdef ENABLE_OMP
#pragma omp parallel for private(i) 
#endif
	for (  i = 0; i < numberOfImproperTorsionTerms; i++ )
	{
		int ai, aj, ak, al;
		int n;

		ai = (int)improperTorsionTerms[0][i];
		aj = (int)improperTorsionTerms[1][i];
		ak = (int)improperTorsionTerms[2][i];
		al = (int)improperTorsionTerms[3][i];

		forceConstant = improperTorsionTerms[4][i];
		n = (int)improperTorsionTerms[6][i];
                equilibriumAngle = improperTorsionTerms[5][i];

		phiDeg = getTorsion(  &m->atoms[ai] ,&m->atoms[aj], &m->atoms[ak], &m->atoms[al]);
		//printf("PhiDeg force equi =%f %f %f\n",phiDeg,forceConstant,equilibriumAngle);
		energy += forceConstant * ( 1.0 + cos( D2R*(n * phiDeg - equilibriumAngle )) );
	}
	//printf("ImproperTorsion energy =%f\n",energy);
	//printf("numberOfImproperTorsionTerms  =%d\n",numberOfImproperTorsionTerms);
	m->potentialEnergy += energy;
	return energy;
}
/**********************************************************************/
double calculateEnergyVdw612Amber(ForceField* forceField,Molecule* molecule)
{
	int i;
	int ai, aj;
	double rij2, rij6;
	double rijx, rijy, rijz;
	Molecule* m = molecule;
	double* vdw612Terms[VDW612DIM];
	int numberOfVdw612 = forceField->numberOfVdw612;
	double energy = 0.0;

	//printf("calculateEnergyVdw612Amber : useCoulomb=%d\n",useCoulomb);
	for(i=0;i<VDW612DIM;i++)
		vdw612Terms[i] = forceField->vdw612Terms[i];

	/* now for non-bonded term */
	/*fprintf(forceField->logfile, "number of Non Bonded terms = %d\n",numberOfVdw612);*/
	//fflush(forceField->logfile);
#ifdef ENABLE_OMP
#pragma omp parallel for private(i,ai,aj,rijx,rijy,rijz,rij2,rij6,coulombTerm) reduction(+:energy)
#endif
	for (  i = 0; i < numberOfVdw612; i++ )
	{
		ai     = (int)vdw612Terms[0][i];
		aj     = (int)vdw612Terms[1][i];

		rijx =  m->atoms[ai].coordinates[0] -  m->atoms[aj].coordinates[0];
		rijy =  m->atoms[ai].coordinates[1] -  m->atoms[aj].coordinates[1];
		rijz =  m->atoms[ai].coordinates[2] -  m->atoms[aj].coordinates[2];

		rij2 = (rijx * rijx + rijy * rijy + rijz * rijz);
		if ( rij2 < POSEPS*POSEPS ) rij2 = POSEPS*POSEPS;	
		rij2 = 1.0/rij2;
		rij6 = rij2 * rij2 * rij2;

		energy += (vdw612Terms[2][i]* rij6 - vdw612Terms[3][i]) * rij6;

		//if(1/rij2<2) printf("rij2 = %f ai = %d aj = %d\n",1/rij2,ai+1,aj+1);
		//printf("rij2 = %f ai = %d aj = %d\n",1/rij2,ai+1,aj+1);
		//printf("Coulomterm = %f\n",coulombTerm);
		/*
		fprintf(forceField->logfile, "A =%f B = %f  r= %f e= %f\n",
			Aij,Bij ,rij,energy);
		fflush(forceField->logfile);
		*/
	}  
	/* fprintf(forceField->logfile, "Non Bonded energy = %f\n",energy);*/
	//fflush(forceField->logfile);
	return energy;
}
/**********************************************************************/
double calculateEnergyVdw714Amber(ForceField* forceField,Molecule* molecule)
{
	int i;
	double energy = 0;

	Molecule* m = &forceField->molecule;
	double* vdw714Terms[VDW714DIM];
	int numberOfVdw714 = forceField->numberOfVdw714;


	for(i=0;i<VDW714DIM;i++) vdw714Terms[i] = forceField->vdw714Terms[i];

#ifdef ENABLE_OMP
#pragma omp parallel for private(i,ai,aj) 
#endif
	for (  i = 0; i < numberOfVdw714; i++ )
	{
		double rijx, rijy, rijz;
		double rij2, rij;
		int ai, aj;
		double epsilon, gamma, delta, R0;
		//double R02;
		double d,d2,d4,d7;
		//double sr,sr2,sr4,sr7,sr8;
		double sr,sr2,sr4,sr7;
		//double rho,rho2,rho4,rho5, rho7;
		double rho,rho2,rho4, rho7;
		double srijg7;
		double e7,e14;

		ai       = (int)vdw714Terms[0][i];
		aj       = (int)vdw714Terms[1][i];

		epsilon  = vdw714Terms[2][i];
		R0       = vdw714Terms[3][i];
		gamma    = vdw714Terms[4][i];
		delta    = vdw714Terms[5][i];

		rijx =  m->atoms[ai].coordinates[0] - m->atoms[aj].coordinates[0];
		rijy =  m->atoms[ai].coordinates[1] - m->atoms[aj].coordinates[1];
		rijz =  m->atoms[ai].coordinates[2] - m->atoms[aj].coordinates[2];

		rij2 = rijx * rijx + rijy * rijy + rijz * rijz;
		if ( rij2 < POSEPS*POSEPS ) rij2 = POSEPS*POSEPS;	

		rij = sqrt( rij2 );
		//R02 = R0*R0;

		rho = rij/R0;
		rho2 = rho*rho;
		rho4 = rho2*rho2;
		//rho5 = rho4*rho;
		rho7 = rho4*rho2*rho;

		d = (1+delta);
		d2 = d*d;
		d4 = d2*d2;
		d7 = d4*d2*d;

		sr = 1.0/(rho+delta);
		sr2 = sr*sr;
		sr4 = sr2*sr2;
		sr7 = sr4*sr2*sr;
		//sr8 = sr4*sr4;
		srijg7=1.0/(rho7+gamma);
		
		e7 = epsilon*d7*sr7;
		e14=e7*(1+gamma)*srijg7;
		e7 = 2*e7;

#ifdef ENABLE_OMP
#pragma omp critical
#endif
		{
		energy += e14-e7;
		}
		if(rij<1) printf("Warning : rij2 = %f atom# = %d atom# = %d\n",rij,ai+1,aj+1);
	//	printf("rij2 = %f ai = %d aj = %d\n",rij2,ai+1,aj+1);
	}  
	//printf("E in ener 7-14 %f\n",energy);

	return energy;
}
/**********************************************************************/
double calculateEnergyCoulombAmber(ForceField* forceField,Molecule* molecule)
{
	int i;
	Molecule* m = molecule;
	double* coulombTerms[COULOMBDIM];
	int numberOfCoulomb = forceField->numberOfCoulomb;
	double energy = 0.0;

/*
	if(!strcmp(forceField->options.chargesType,"EEM")) return forceField->molecule.klass->getEnergyEEM(&forceField->molecule);
	if(!strcmp(forceField->options.chargesType,"ACKS2")) return forceField->molecule.klass->getEnergyACKS2(&forceField->molecule);
*/

	for(i=0;i<COULOMBDIM;i++) coulombTerms[i] = forceField->coulombTerms[i];

#ifdef ENABLE_OMP
#pragma omp parallel for private(i,ai,aj,rijx,rijy,rijz,rij2,rij6,coulombTerm) reduction(+:energy)
#endif
	for (  i = 0; i < numberOfCoulomb; i++ )
	{
		int ai, aj;
		double rij2;
		double rijx, rijy, rijz;
		double C;
	
		ai     = (int)coulombTerms[0][i];
		aj     = (int)coulombTerms[1][i];
		C = coulombTerms[2][i]*m->atoms[ai].charge*m->atoms[aj].charge;

		rijx =  m->atoms[ai].coordinates[0] -  m->atoms[aj].coordinates[0];
		rijy =  m->atoms[ai].coordinates[1] -  m->atoms[aj].coordinates[1];
		rijz =  m->atoms[ai].coordinates[2] -  m->atoms[aj].coordinates[2];

		rij2 = (rijx * rijx + rijy * rijy + rijz * rijz);
		if ( rij2 < POSEPS*POSEPS ) rij2 = POSEPS*POSEPS;	
		rij2 = 1.0/rij2;

		//printf("ai aj c=%d %d %f\n",ai,aj,coulombTerms[2][i]);
		energy += C  * sqrt( rij2 );
	}  
	//printf("numberOfCoulomb=%d\n",numberOfCoulomb);
	//printf("EC=%f\n",energy);
	return energy;
}
/**********************************************************************/
double calculateEnergySuttonChenAmber(ForceField* forceField,Molecule* molecule)
{
	double energy = 0;
	Molecule* m = molecule;

	energy = calculateRhoSuttonChenAmber(forceField,m);
	return energy;
}
/**********************************************************************/
static double calculateEnergyHydrogenBonded612Amber(ForceField* forceField,Molecule* molecule)
{
	int i;
	Molecule* m = molecule;
	double* hydrogenBondedTerms[HYDROGENBONDEDDIM];
	int numberOfHydrogenBonded =  forceField->numberOfHydrogenBonded;
	double energy = 0.0;

	//printf("Begin energ Hydrogen-bonded\n");
	for(i=0;i<HYDROGENBONDEDDIM;i++) hydrogenBondedTerms[i] = forceField->hydrogenBondedTerms[i];

	/* Hydrogen-bonded term */
#ifdef ENABLE_OMP
#pragma omp parallel for private(i) reduction(+:energy)
#endif
	for (  i = 0; i < numberOfHydrogenBonded; i++ )
	{
		int ai, aj,ax;
		double rij2, rij4, rij8, rij12;
		double rijx, rijy, rijz;
		double Cij, Dij;
		double cosBeta = 1.0;
		ai = (int)hydrogenBondedTerms[0][i];
		aj = (int)hydrogenBondedTerms[1][i];
		ax = (int)hydrogenBondedTerms[2][i];
		Cij = hydrogenBondedTerms[3][i];
		Dij = hydrogenBondedTerms[4][i];

		cosBeta = getCosBeta(m, ai, ax, aj);

		rijx =  m->atoms[ai].coordinates[0] - m->atoms[aj].coordinates[0];
		rijy =  m->atoms[ai].coordinates[1] - m->atoms[aj].coordinates[1];
		rijz =  m->atoms[ai].coordinates[2] - m->atoms[aj].coordinates[2];

		rij2 = rijx * rijx + rijy * rijy + rijz * rijz;
		if ( rij2 < POSEPS*POSEPS )
		{
			fprintf(forceField->logfile, "i = %d j = %d\n",ai,aj);
			fflush(forceField->logfile);
			rij2 = POSEPS*POSEPS;	
		}
		rij4 = rij2 * rij2;
                rij8 = rij4 * rij4;
                rij12 = rij8 * rij4;

		energy += Cij / rij12 - cosBeta*Dij / (rij4*rij2);

		/*
		fprintf(forceField->logfile, "C =%f D = %f  r= %f e= %f\n", Cij,Dij ,sqrt(rij2),energy);
		fflush(forceField->logfile);
		*/

	}  
	//printf("End energ Hydrogen-bonded\n");

	return energy;		
}
/**********************************************************************/
static double calculateEnergyHydrogenBonded1012Amber(ForceField* forceField,Molecule* molecule)
{
	int i;
	Molecule* m = molecule;
	double* hydrogenBondedTerms[HYDROGENBONDEDDIM];
	int numberOfHydrogenBonded =  forceField->numberOfHydrogenBonded;
	double energy = 0.0;

	//printf("Begin energ Hydrogen-bonded\n");
	for(i=0;i<HYDROGENBONDEDDIM;i++) hydrogenBondedTerms[i] = forceField->hydrogenBondedTerms[i];

	/* Hydrogen-bonded term */
#ifdef ENABLE_OMP
#pragma omp parallel for private(i,ai,aj,Cij,Dij,rijx,rijy,rijz,rij2,rij4,rij6,rij10,rij12) reduction(+:energy)
#endif
	for (  i = 0; i < numberOfHydrogenBonded; i++ )
	{
		int ai, aj,ax;
		double rij2, rij4, rij8, rij12;
		double rijx, rijy, rijz;
		double Cij, Dij;
		double cosBeta = 1.0;
		ai = (int)hydrogenBondedTerms[0][i];
		aj = (int)hydrogenBondedTerms[1][i];
		ax = (int)hydrogenBondedTerms[2][i];
		Cij = hydrogenBondedTerms[3][i];
		Dij = hydrogenBondedTerms[4][i];

		cosBeta = getCosBeta(m, ai, ax, aj);

		rijx =  m->atoms[ai].coordinates[0] - m->atoms[aj].coordinates[0];
		rijy =  m->atoms[ai].coordinates[1] - m->atoms[aj].coordinates[1];
		rijz =  m->atoms[ai].coordinates[2] - m->atoms[aj].coordinates[2];

		rij2 = rijx * rijx + rijy * rijy + rijz * rijz;
		if ( rij2 < POSEPS*POSEPS )
		{
			fprintf(forceField->logfile, "i = %d j = %d\n",ai,aj);
			fflush(forceField->logfile);
			rij2 = POSEPS*POSEPS;	
		}
		rij4 = rij2 * rij2;
                rij8 = rij4 * rij4;
                rij12 = rij8 * rij4;

		energy += Cij / rij12 - cosBeta*Dij / (rij8*rij2);

		/*
		fprintf(forceField->logfile, "C =%f D = %f  r= %f e= %f\n", Cij,Dij ,sqrt(rij2),energy);
		fflush(forceField->logfile);
		*/

	}  
	//printf("End energ Hydrogen-bonded\n");

	return energy;		
}
/**********************************************************************/
static double calculateEnergyHydrogenBondedMorseAmber(ForceField* forceField,Molecule* molecule)
{
	// Ref : J. Phys. Chem. B 1997, 101, 4851-4859
	int i;
	Molecule* m = molecule;
	double* hydrogenBondedTerms[HYDROGENBONDEDDIM];
	int numberOfHydrogenBonded =  forceField->numberOfHydrogenBonded;
	double energy = 0.0;

	//printf("Begin energ Hydrogen-bonded\n");
	for(i=0;i<HYDROGENBONDEDDIM;i++) hydrogenBondedTerms[i] = forceField->hydrogenBondedTerms[i];

	/* Hydrogen-bonded term */
#ifdef ENABLE_OMP
#pragma omp parallel for private(i,ai,aj,Cij,Dij,rijx,rijy,rijz,rij2,rij4,rij6,rij10,rij12) reduction(+:energy)
#endif
	for (  i = 0; i < numberOfHydrogenBonded; i++ )
	{
		int ai, aj,ax;
		double rij, rij2;
		double rijx, rijy, rijz;
		double alpha, Re,De;
		double cosBeta = 1.0;
		double X = 0.0;
		ai = (int)hydrogenBondedTerms[0][i];
		aj = (int)hydrogenBondedTerms[1][i];
		ax = (int)hydrogenBondedTerms[2][i];
		alpha = hydrogenBondedTerms[3][i];
		Re = hydrogenBondedTerms[4][i];
		De = hydrogenBondedTerms[5][i];

		cosBeta = getCosBeta(m, ai, ax, aj);

		rijx =  m->atoms[ai].coordinates[0] - m->atoms[aj].coordinates[0];
		rijy =  m->atoms[ai].coordinates[1] - m->atoms[aj].coordinates[1];
		rijz =  m->atoms[ai].coordinates[2] - m->atoms[aj].coordinates[2];

		rij2 = rijx * rijx + rijy * rijy + rijz * rijz;
		if ( rij2 < POSEPS*POSEPS )
		{
			fprintf(forceField->logfile, "i = %d j = %d\n",ai,aj);
			fflush(forceField->logfile);
			rij2 = POSEPS*POSEPS;	
		}
		rij = sqrt(rij2);
		X = exp(-alpha*(rij-Re));
		energy += De*(X*X-2*X)*cosBeta;
		/*
		fprintf(forceField->logfile, "alpha =%f Re = %f  De= %f r = %f  cosBeta = %f energy= %f\n", alpha,Re,De, rij,cosBeta, energy);
		fflush(forceField->logfile);
		*/

	}  
	//printf("End energ Hydrogen-bonded\n");
	return energy;		
}
/**********************************************************************/
static double calculateEnergyHydrogenBondedAmber(ForceField* forceField,Molecule* molecule)
{
	if(forceField->options.hydrogenBonded612) return calculateEnergyHydrogenBonded612Amber(forceField,molecule);
	else if(forceField->options.hydrogenBonded1012) return calculateEnergyHydrogenBonded1012Amber(forceField,molecule);
	else if(forceField->options.hydrogenBondedMorse) return calculateEnergyHydrogenBondedMorseAmber(forceField,molecule);
	return 0;
}
/**********************************************************************/
double calculateEnergyOutOfPlaneAmber(ForceField* forceField,Molecule* molecule)
{
	int i;
	Molecule* m = molecule;
	double energy = 0.0;
	double* outOfPlaneTerms[OUTOFPLANEDIM];
	int numberOfOutOfPlaneTerms = forceField->numberOfOutOfPlaneTerms;

	for(i=0;i<OUTOFPLANEDIM;i++) outOfPlaneTerms[i] = forceField->outOfPlaneTerms[i];

#ifdef ENABLE_OMP
#pragma omp parallel for private(i) 
#endif
	for (  i = 0; i < numberOfOutOfPlaneTerms; i++ )
	{
		int ai, aj, ak, al;

		double rijx, rijy, rijz;
		double rkjx, rkjy, rkjz;
		double rljx, rljy, rljz;

		double angle, e2, c2;
		double dot;
		double rilx, rily, rilz;
		double rklx, rkly, rklz;
		double rij2, rkj2, ril2, rkl2, rlj2;
		double bkk2, cosine;
		double dt, dt2, dt3, dt4;

		boolean wdc = (outOfPlaneTerms[4][i]==1);
		double force = outOfPlaneTerms[5][i];
		double h3 = outOfPlaneTerms[6][i];
		double h4 = outOfPlaneTerms[7][i];
		double h5 = outOfPlaneTerms[8][i];
		double h6 = outOfPlaneTerms[9][i];

		ai = (int)outOfPlaneTerms[0][i];
		aj = (int)outOfPlaneTerms[1][i];
		ak = (int)outOfPlaneTerms[2][i];
		al = (int)outOfPlaneTerms[3][i];

		rijx = m->atoms[ai].coordinates[0] - m->atoms[aj].coordinates[0];
		rijy = m->atoms[ai].coordinates[1] - m->atoms[aj].coordinates[1];
		rijz = m->atoms[ai].coordinates[2] - m->atoms[aj].coordinates[2];

		rkjx = m->atoms[ak].coordinates[0] - m->atoms[aj].coordinates[0];
		rkjy = m->atoms[ak].coordinates[1] - m->atoms[aj].coordinates[1];
		rkjz = m->atoms[ak].coordinates[2] - m->atoms[aj].coordinates[2];

		rljx = m->atoms[al].coordinates[0] - m->atoms[aj].coordinates[0];
		rljy = m->atoms[al].coordinates[1] - m->atoms[aj].coordinates[1];
		rljz = m->atoms[al].coordinates[2] - m->atoms[aj].coordinates[2];

		rilx = m->atoms[ai].coordinates[0] - m->atoms[al].coordinates[0];
		rily = m->atoms[ai].coordinates[1] - m->atoms[al].coordinates[1];
		rilz = m->atoms[ai].coordinates[2] - m->atoms[al].coordinates[2];

		rklx = m->atoms[ak].coordinates[0] - m->atoms[al].coordinates[0];
		rkly = m->atoms[ak].coordinates[1] - m->atoms[al].coordinates[1];
		rklz = m->atoms[ak].coordinates[2] - m->atoms[al].coordinates[2];

		if(wdc) //  'W-D-C'
		{
		     	rij2 = rijx*rijx + rijy*rijy + rijz*rijz;
               		rkj2 = rkjx*rkjx + rkjy*rkjy + rkjz*rkjz;
               		dot = rijx*rkjx+rijy*rkjy+rijz*rkjz;
               		c2 = rij2*rkj2 - dot*dot;
		}
		else // ALLINGER
		{
			ril2 = rilx*rilx + rily*rily + rilz*rilz;
               		rkl2 = rklx*rklx + rkly*rkly + rklz*rklz;
               		dot = rilx*rklx + rily*rkly + rilz*rklz;
               		c2 = ril2*rkl2 - dot*dot;
		}
		// energy
		e2 = rljx*(rijy*rkjz-rijz*rkjy) + rljy*(rijz*rkjx-rijx*rkjz)+ rljz*(rijx*rkjy-rijy*rkjx);
            	rlj2 = rljx*rljx + rljy*rljy + rljz*rljz;
            	if (rlj2==0.0 || c2 == 0.0) continue;
               	bkk2 = rlj2 - e2*e2/c2;
               	cosine = sqrt(bkk2/rlj2);
		if(cosine>1) cosine = 1;
		if(cosine<-1) cosine = -1;
               	angle = acos(cosine);
               	dt = angle;
               	dt2 = dt * dt;
               	dt3 = dt2 * dt;
               	dt4 = dt2 * dt2;
               	energy += force * dt2*(1.0+h3*dt+h4*dt2+h5*dt3+h6*dt4);
	}
	return energy;
}
/**********************************************************************/
static double calculateEnergyPairWise(ForceField* forceField,Molecule* molecule)
{
	int i;
	int ai, aj;
	double rij2, rij4, rij6, rij8, rij10;
	double coulombTerm;
	double rijx, rijy, rijz;
	double rij;
	double permittivityScale = 1, permittivity = 1;
	double coulombFactor;
	Molecule* m = molecule;
	double* pairWiseTerms[PAIRWISEDIM];
	int numberOfPairWise = forceField->numberOfPairWise;
	boolean useCoulomb = forceField->options.coulomb;
	boolean useVanderWals = forceField->options.vdw612;
	double energy = 0.0;
	double A, Beta;
	double  B4, B6, B8, B10;
	double c4, c6, c8, c10, b;

	for(i=0;i<PAIRWISEDIM;i++)
		pairWiseTerms[i] = forceField->pairWiseTerms[i];

	/* now for non-bonded term */
	coulombFactor = 332.05382/ ( permittivity * permittivityScale );
	/* fprintf(forceField->logfile, "number of Non Bonded terms = %d\n",numberOfPairWise);*/
	// fflush(forceField->logfile);
#ifdef ENABLE_OMP
#pragma omp parallel for private(i,A,Beta,c4,c6,c8,c10,b,rijx,rijy,rijz,rij2,rij,rij6,rij8,rij10,coulombTerm,B6,B8,B10) reduction(+:energy)
#endif
	for (  i = 0; i < numberOfPairWise; i++ )
	{
		ai     = (int)pairWiseTerms[0][i];
		aj     = (int)pairWiseTerms[1][i];
		A      = pairWiseTerms[2][i];
		Beta   = pairWiseTerms[3][i];
		c4     = pairWiseTerms[4][i];
		c6     = pairWiseTerms[5][i];
		c8     = pairWiseTerms[6][i];
		c10    = pairWiseTerms[7][i];
		b      = pairWiseTerms[8][i];

		rijx =  m->atoms[ai].coordinates[0] - m->atoms[aj].coordinates[0];
		rijy =  m->atoms[ai].coordinates[1] - m->atoms[aj].coordinates[1];
		rijz =  m->atoms[ai].coordinates[2] - m->atoms[aj].coordinates[2];

		rij2 = rijx * rijx + rijy * rijy + rijz * rijz;

		rij = sqrt( rij2 );
		rij4 = rij2 * rij2;
		rij6 = rij2 * rij2 * rij2;
		rij8 = rij6* rij2;
		rij10 = rij8 * rij2;

		if(useCoulomb)
			coulombTerm = ( m->atoms[ai].charge*m->atoms[aj].charge * coulombFactor ) / rij;
		else
			coulombTerm = 0.0;

		B4  = 0;
		B6  = 0;
		B8  = 0;
		B10 = 0;
		/* printf("A = %f Beta = %f qi = %f qj = %f rij = %f\n",A,Beta,chargei,chargej,rij);*/
		if(useVanderWals)
		{
			double fact = 1.0;
			double s = 1.0;
			double br = b*rij;
			double brk = 1.0;
			int k;

			if(fabs(c6)>1e-12)
			{
				for(k=1;k<=2*3;k++)
				{
					fact *= k;
					brk *= br;
					s += brk/fact;
				}
				B6 = c6*(1-exp(-br)*s);
			}
			if(fabs(c4)>1e-12)
			{
				fact = 1.0;
				s = 1.0;
				br = b*rij;
				brk = 1.0;
				for(k=1;k<=2*2;k++)
				{
					fact *= k;
					brk *= br;
					s += brk/fact;
				}
				B4 = c4*(1-exp(-br)*s);
			}

			if(fabs(c8)>1e-12)
			{
				fact = 1.0;
				s = 1.0;
				br = b*rij;
				brk = 1.0;
				for(k=1;k<=2*4;k++)
				{
					fact *= k;
					brk *= br;
					s += brk/fact;
				}
				B8 = c8*(1-exp(-br)*s);
			}

			if(fabs(c10)>1e-12)
			{
				fact = 1.0;
				s = 1.0;
				br = b*rij;
				brk = 1.0;
				for(k=1;k<=2*5;k++)
				{
					fact *= k;
					brk *= br;
					s += brk/fact;
				}
				B10 = c10*(1-exp(-br)*s);
			}
		}
					


		energy += A*exp(-Beta*rij)
			- B4 / rij4 
			- B6 / rij6 
			- B8 / rij8 
			- B10 / rij10 
			+ coulombTerm;
	}  
	return energy;
}
#endif /* ENABLE_CL*/

/**********************************************************************/
static void calculateEnergyAmber(ForceField* forceField)
{
	Molecule* m = &forceField->molecule;

	forceField->molecule.potentialEnergy =  calculateEnergyTmpAmber(forceField,m);
}
/**********************************************************************/
static double calculateEnergyTmpAmber(ForceField* forceField,Molecule* molecule)
{
	double energy = 0.0;
#ifdef DEBUG
        TimerType timer;
#endif

#ifdef ENABLE_CL
	CLProp clProp = getCLProp();
	size_t local = 64;
	size_t global;
	int i;

	fprintf(forceField->logfile, "Begin calculateEnergyTmpAmber\n");
	fflush(forceField->logfile);
	global = forceField->nMaxTerms;
	clEnqueueNDRangeKernel(clProp.command_queue, forceField->initEnergyKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	clFinish(clProp.command_queue);

#ifdef DEBUG
        timer_init(timer);
       	timer_start( timer );
#endif
	if(forceField->numberOfStretchTerms>0)
	{
	global = forceField->numberOfStretchTerms;
	clEnqueueNDRangeKernel(clProp.command_queue, forceField->addEnergyBondAmberKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	clFinish(clProp.command_queue);
	}

	if(forceField->numberOfBendTerms>0)
	{
	global = forceField->numberOfBendTerms;
	clEnqueueNDRangeKernel(clProp.command_queue, forceField->addEnergyBendAmberKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	clFinish(clProp.command_queue);
	}

	if(forceField->numberOfDihedralTerms>0)
	{
	global = forceField->numberOfDihedralTerms;
	clEnqueueNDRangeKernel(clProp.command_queue, forceField->addEnergyDihedralAmberKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	clFinish(clProp.command_queue);
	}

	if(forceField->numberOfVdw612>0)
	{
	global = forceField->numberOfVdw612;
	clEnqueueNDRangeKernel(clProp.command_queue, forceField->addEnergyVdw612AmberKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	clFinish(clProp.command_queue);
	}

	if(forceField->numberOfSuttonChen>0)
	{
	global = forceField->numberOfSuttonChen;
	clEnqueueNDRangeKernel(clProp.command_queue, forceField->initRhoKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	clEnqueueNDRangeKernel(clProp.command_queue, forceField->computeRhoKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	global = forceField->molecule.nAtoms;
	clEnqueueNDRangeKernel(clProp.command_queue, forceField->reduceRhoKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	global = forceField->numberOfSuttonChen;
	clEnqueueNDRangeKernel(clProp.command_queue, forceField->addEnergySuttoChenAmberKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	clFinish(clProp.command_queue);
	}

	if(forceField->numberOfHydrogenBonded>0)
	{
	global = forceField->numberOfHydrogenBonded;
	clEnqueueNDRangeKernel(clProp.command_queue, forceField->addEnergyHydrogenBondedAmberKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	clFinish(clProp.command_queue);
	}

	if(forceField->numberOfPairWise>0)
	{
	global = forceField->numberOfPairWise;
	clEnqueueNDRangeKernel(clProp.command_queue, forceField->addEnergyPairWiseKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	clFinish(clProp.command_queue);
	}


	clEnqueueReadBuffer(clProp.command_queue, forceField->energyBufferCL, CL_TRUE, 0, sizeof(cl_float)*forceField->nMaxTerms, forceField->energyBufferCPU, 0, NULL, NULL);
	energy = 0;
	for(i=0;i<forceField->nMaxTerms;i++) energy+=forceField->energyBufferCPU[i];
#ifdef DEBUG
       	timer_stop(timer);
        fprintf(forceField->logfile, "time (s) = %f\n", timer_get(timer)*1e-6);
	fflush(forceField->logfile);
#endif
#else // ENABLE_CL
#ifdef DEBUG
        timer_init(timer);
       	timer_start( timer );
#endif
	if(!strstr(forceField->options.chargesType,"BEGIN")) setCharges(forceField);
	energy +=calculateEnergyBondAmber(forceField,molecule);
	energy +=calculateEnergyBendAmber(forceField,molecule);
	energy +=calculateEnergyStrBendAmber(forceField,molecule);
	energy +=calculateEnergyDihedralAmber(forceField,molecule);
	energy +=calculateEnergyImproperTorsionAmber(forceField,molecule);
	energy +=calculateEnergyOutOfPlaneAmber(forceField,molecule);
	energy +=calculateEnergyVdw612Amber(forceField,molecule);
	energy +=calculateEnergySuttonChenAmber(forceField,molecule);
	energy +=calculateEnergyCoulombAmber(forceField,molecule);
	energy +=calculateEnergyHydrogenBondedAmber(forceField,molecule);
	energy +=calculateEnergyPairWise(forceField,molecule);
	energy +=getH4Energy(forceField, molecule);
#ifdef DEBUG
       	timer_stop(timer);
        fprintf(forceField->logfile, "time (s) = %f\n", timer_get(timer)*1e-6);
	fflush(forceField->logfile);
#endif
#endif // ENABLE_CL

	return energy;		
}
/**********************************************************************/
#ifdef ENABLE_CL
void initCLForceField (ForceField* forceField)
{
	CLProp clProp = getCLProp();
	cl_int err;
	int i;
	//cl_int2* clint2 = NULL;
	cl_int4* clint4 = NULL;
	cl_int8* clint8 = NULL;
	cl_float* clfloat = NULL;
	cl_float2* clfloat2 = NULL;
	cl_float4* clfloat4 = NULL;
	cl_float8* clfloat8 = NULL;
	int numberOfStretchTerms = forceField->numberOfStretchTerms;
	double* bondStretchTerms[STRETCHDIM];
	int numberOfBendTerms = forceField->numberOfBendTerms;
	double* angleBendTerms[BENDDIM];
	int numberOfDihedralTerms = forceField->numberOfDihedralTerms;
	double* dihedralAngleTerms[DIHEDRALDIM];
	double* vdw612Terms[VDW612DIM];
	int numberOfVdw612 = forceField->numberOfVdw612;
	double* hydrogenBondedTerms[HYDROGENBONDEDDIM];
	int numberOfHydrogenBonded =  forceField->numberOfHydrogenBonded;
	double* pairWiseTerms[PAIRWISEDIM];
	int numberOfPairWise = forceField->numberOfPairWise;
	size_t local = 64;
	size_t global;
	int nMaxTerms = 0;
	int useCoulomb = forceField->options.coulomb;
	int* gradCounters = malloc(forceField->molecule.nAtoms*sizeof(int));
	int* suttonChenCounters = malloc(forceField->molecule.nAtoms*sizeof(int));
	int ea,eb,ec;
	int maxCounters=0;
	int maxSuttonChenCounters=0;
	int maxRattleCounters=0;
	int numberOfRattleConstraintsTerms = 0;
	double* rattleConstraintsTerms[RATTLEDIM];

	numberOfRattleConstraintsTerms = forceField->numberOfRattleConstraintsTerms;
	for( i=0; i<RATTLEDIM;i++) rattleConstraintsTerms[i] = forceField->rattleConstraintsTerms[i];

        for( i=0; i<forceField->molecule.nAtoms;i++) gradCounters[i] = 0;

        for( i=0; i<STRETCHDIM;i++) bondStretchTerms[i] = forceField->bondStretchTerms[i];
	for( i=0; i<BENDDIM;i++) angleBendTerms[i] = forceField->angleBendTerms[i]; 
	for(i=0;i<DIHEDRALDIM;i++) dihedralAngleTerms[i] = forceField->dihedralAngleTerms[i];
	for(i=0;i<VDW612DIM;i++) vdw612Terms[i] = forceField->vdw612Terms[i];
	for(i=0;i<HYDROGENBONDEDDIM;i++) hydrogenBondedTerms[i] = forceField->hydrogenBondedTerms[i];
	for(i=0;i<PAIRWISEDIM;i++) pairWiseTerms[i] = forceField->pairWiseTerms[i];
	if(numberOfStretchTerms>nMaxTerms) nMaxTerms = numberOfStretchTerms;
	if(numberOfBendTerms>nMaxTerms) nMaxTerms = numberOfBendTerms ;
	if(numberOfDihedralTerms>nMaxTerms) nMaxTerms = numberOfDihedralTerms;
	if(numberOfVdw612>nMaxTerms) nMaxTerms = numberOfVdw612;
	if(numberOfHydrogenBonded>nMaxTerms) nMaxTerms =numberOfHydrogenBonded ;
	if(numberOfPairWise>nMaxTerms) nMaxTerms =numberOfPairWise ;
	forceField->nMaxTerms = nMaxTerms;

	// create a program from the kernel source code
	forceField->programMM = clCreateProgramWithSource(clProp.context,1,(const char **) &mmCLSource, NULL, &err);
#ifdef DEBUG
	fprintf(forceField->logfile, "err = %d\n",err);
	fflush(forceField->logfile);
#endif
	// compile the program
	if (clBuildProgram(forceField->programMM, 0, NULL, NULL, NULL, NULL) != CL_SUCCESS)
	{
		char build[2048];
		fprintf(forceField->logfile, "Error building MM CL program\n");
		fflush(forceField->logfile);
		clGetProgramBuildInfo(forceField->programMM, clProp.device_id, CL_PROGRAM_BUILD_LOG, 2048, build, NULL);
		fprintf(forceField->logfile, "Build Log:\n%s\n",build);
		fflush(forceField->logfile);
		exit(1);
	}

	forceField->atomsCPU = malloc(forceField->molecule.nAtoms*sizeof(cl_float8));
#ifdef DEBUG
	fprintf(forceField->logfile, "End malloc\n");
	fflush(forceField->logfile);
#endif
	for(i=0;i<forceField->molecule.nAtoms;i++)
	{
		forceField->atomsCPU[i].s[0] = forceField->molecule.atoms[i].coordinates[0];
		forceField->atomsCPU[i].s[1] = forceField->molecule.atoms[i].coordinates[1];
		forceField->atomsCPU[i].s[2] = forceField->molecule.atoms[i].coordinates[2];
		forceField->atomsCPU[i].s[3] = forceField->molecule.atoms[i].charge;
		forceField->atomsCPU[i].s[4] = forceField->molecule.atoms[i].mass;
		// velocity
		forceField->atomsCPU[i].s[5] = 0;
		forceField->atomsCPU[i].s[6] = 0;
		forceField->atomsCPU[i].s[7] = 0;
	}
	printf("create buffers for the input and ouput\n");
	forceField->atomsCL = clCreateBuffer(clProp.context, CL_MEM_READ_WRITE, sizeof(cl_float8) * forceField->molecule.nAtoms, NULL, &ea);
	if(ea!=CL_SUCCESS)
	{
		fprintf(forceField->logfile, "I cannot create atoms Buffer\n");
		fflush(forceField->logfile);
		exit(1);
	}
	clEnqueueWriteBuffer(clProp.command_queue, forceField->atomsCL, CL_TRUE, 0, sizeof(cl_float8) * forceField->molecule.nAtoms, forceField->atomsCPU, 0, NULL, NULL);
#ifdef DEBUG
	fprintf(forceField->logfile, "End atomsCL\n");
	fflush(forceField->logfile);

	fprintf(forceField->logfile, "nMaxTerms=%d\n",nMaxTerms);
	fflush(forceField->logfile);
#endif

	forceField->energyBufferCPU = malloc(nMaxTerms*sizeof(cl_float));
	forceField->energyBufferCL = clCreateBuffer(clProp.context, CL_MEM_READ_WRITE, sizeof(cl_float)*nMaxTerms, NULL, &ea);
	if(ea!=CL_SUCCESS)
	{
		fprintf(forceField->logfile, "I cannot create energies Buffer\n");
		fflush(forceField->logfile);
		exit(1);
	}

	if(numberOfStretchTerms>0)
	{
	clint4 = malloc(numberOfStretchTerms*sizeof(cl_int4));
	clfloat2 = malloc(numberOfStretchTerms*sizeof(cl_float2));
        for( i=0; i<forceField->molecule.nAtoms;i++) gradCounters[i] = 0;
	for(i=0;i<numberOfStretchTerms;i++)
	{
		clint4[i].s[0] = (int) bondStretchTerms[0][i];
		clint4[i].s[1] = (int) bondStretchTerms[1][i];
		clint4[i].s[2] = gradCounters[clint4[i].s[0]]++;
		clint4[i].s[3] = gradCounters[clint4[i].s[1]]++;
		
		clfloat2[i].s[0] = bondStretchTerms[2][i];
		clfloat2[i].s[1] = bondStretchTerms[3][i];
	}
	forceField->bondIndexCL = clCreateBuffer(clProp.context, CL_MEM_READ_ONLY, sizeof(cl_int4)*numberOfStretchTerms, NULL, &ea);
	forceField->bondTermsCL = clCreateBuffer(clProp.context, CL_MEM_READ_ONLY, sizeof(cl_float2)*numberOfStretchTerms, NULL, &eb);
	if(ea!=CL_SUCCESS||eb!=CL_SUCCESS)
	{
		fprintf(forceField->logfile, "I cannot bonds Buffer\n");
		fflush(forceField->logfile);
		exit(1);
	}
	ea = clEnqueueWriteBuffer(clProp.command_queue, forceField->bondIndexCL, CL_TRUE, 0, sizeof(cl_int4) * numberOfStretchTerms, clint4, 0, NULL, NULL);
	eb = clEnqueueWriteBuffer(clProp.command_queue, forceField->bondTermsCL, CL_TRUE, 0, sizeof(cl_float2) * numberOfStretchTerms, clfloat2, 0, NULL, NULL);
	if(ea!=CL_SUCCESS||eb!=CL_SUCCESS)
	{
		fprintf(forceField->logfile, "I cannot write bonds data in GPU Buffer\n");
		fflush(forceField->logfile);
		exit(1);
	}
	free(clint4);
	free(clfloat2);
#ifdef DEBUG
	fprintf(forceField->logfile, "End numberOfStretchTerms\n");
	fflush(forceField->logfile);
#endif
        for( i=0; i<forceField->molecule.nAtoms;i++) if(maxCounters<gradCounters[i]) maxCounters = gradCounters[i];
	}

	if(numberOfBendTerms>0)
	{
	clint8 = malloc(numberOfBendTerms*sizeof(cl_int8));
	clfloat2 = malloc(numberOfBendTerms*sizeof(cl_float2));
        for( i=0; i<forceField->molecule.nAtoms;i++) gradCounters[i] = 0;
	for(i=0;i<numberOfBendTerms;i++)
	{
		clint8[i].s[0] = (int) angleBendTerms[0][i];
		clint8[i].s[1] = (int) angleBendTerms[1][i];
		clint8[i].s[2] = (int) angleBendTerms[2][i];
		clint8[i].s[3] =  gradCounters[clint8[i].s[0]]++;
		clint8[i].s[4] =  gradCounters[clint8[i].s[1]]++;
		clint8[i].s[5] =  gradCounters[clint8[i].s[2]]++;
		clint8[i].s[6] =  -1;
		clint8[i].s[7] =  -1;

		clfloat2[i].s[0] = angleBendTerms[3][i];
		clfloat2[i].s[1] = angleBendTerms[4][i];
	}
	forceField->bendIndexCL = clCreateBuffer(clProp.context, CL_MEM_READ_ONLY, sizeof(cl_int8)*numberOfBendTerms, NULL, NULL);
	forceField->bendTermsCL = clCreateBuffer(clProp.context, CL_MEM_READ_ONLY, sizeof(cl_float2)*numberOfBendTerms, NULL, NULL);
	clEnqueueWriteBuffer(clProp.command_queue, forceField->bendIndexCL, CL_TRUE, 0, sizeof(cl_int8) * numberOfBendTerms, clint8, 0, NULL, NULL);
	clEnqueueWriteBuffer(clProp.command_queue, forceField->bendTermsCL, CL_TRUE, 0, sizeof(cl_float2) * numberOfBendTerms, clfloat2, 0, NULL, NULL);
	free(clint8);
	free(clfloat2);
        for( i=0; i<forceField->molecule.nAtoms;i++) if(maxCounters<gradCounters[i]) maxCounters = gradCounters[i];
#ifdef DEBUG
	fprintf(forceField->logfile, "End Bend\n");
	fflush(forceField->logfile);
#endif
	}

	if(numberOfDihedralTerms>0)
	{
	clint8 = malloc(numberOfDihedralTerms*sizeof(cl_int8));
	clfloat4 = malloc(numberOfDihedralTerms*sizeof(cl_float4));
        for( i=0; i<forceField->molecule.nAtoms;i++) gradCounters[i] = 0;
	for(i=0;i<numberOfDihedralTerms;i++)
	{
		clint8[i].s[0] = (int) dihedralAngleTerms[0][i];
		clint8[i].s[1] = (int) dihedralAngleTerms[1][i];
		clint8[i].s[2] = (int) dihedralAngleTerms[2][i];
		clint8[i].s[3] = (int) dihedralAngleTerms[3][i];
		clint8[i].s[4] =  gradCounters[clint8[i].s[0]]++;
		clint8[i].s[5] =  gradCounters[clint8[i].s[1]]++;
		clint8[i].s[6] =  gradCounters[clint8[i].s[2]]++;
		clint8[i].s[7] =  gradCounters[clint8[i].s[3]]++;

		clfloat4[i].s[0] = dihedralAngleTerms[4][i];
		clfloat4[i].s[1] = dihedralAngleTerms[5][i];
		clfloat4[i].s[2] = dihedralAngleTerms[6][i];
		clfloat4[i].s[3] = dihedralAngleTerms[7][i];
	}
	forceField->dihedralIndexCL = clCreateBuffer(clProp.context, CL_MEM_READ_ONLY, sizeof(cl_int8)*numberOfDihedralTerms, NULL, NULL);
	forceField->dihedralTermsCL = clCreateBuffer(clProp.context, CL_MEM_READ_ONLY, sizeof(cl_float4)*numberOfDihedralTerms, NULL, NULL);
	clEnqueueWriteBuffer(clProp.command_queue, forceField->dihedralIndexCL, CL_TRUE, 0, sizeof(cl_int8) * numberOfDihedralTerms, clint8, 0, NULL, NULL);
	clEnqueueWriteBuffer(clProp.command_queue, forceField->dihedralTermsCL, CL_TRUE, 0, sizeof(cl_float4) * numberOfDihedralTerms, clfloat4, 0, NULL, NULL);
	free(clint8);
	free(clfloat4);
        for( i=0; i<forceField->molecule.nAtoms;i++) if(maxCounters<gradCounters[i]) maxCounters = gradCounters[i];
#ifdef DEBUG
	fprintf(forceField->logfile, "End dihed\n");
	fflush(forceField->logfile);
#endif
	}


	forceField->improperTorsionIndexCL = 0;


	if(numberOfVdw612>0)
	{
	clint4 = malloc(numberOfVdw612*sizeof(cl_int4));
	clfloat4 = malloc(numberOfVdw612*sizeof(cl_float4));
        for( i=0; i<forceField->molecule.nAtoms;i++) gradCounters[i] = 0;
	for(i=0;i<numberOfVdw612;i++)
	{
		clint4[i].s[0] = (int) vdw612Terms[0][i];
		clint4[i].s[1] = (int) vdw612Terms[1][i];
		clint4[i].s[2] =  gradCounters[clint4[i].s[0]]++;
		clint4[i].s[3] =  gradCounters[clint4[i].s[1]]++;

		clfloat4[i].s[0] = vdw612Terms[2][i];
		clfloat4[i].s[1] = vdw612Terms[3][i];
		clfloat4[i].s[2] = vdw612Terms[4][i];
		clfloat4[i].s[3] = 0;
	}
	forceField->vdw612IndexCL = clCreateBuffer(clProp.context, CL_MEM_READ_ONLY, sizeof(cl_int4)*numberOfVdw612, NULL, &ea);
	forceField->vdw612TermsCL = clCreateBuffer(clProp.context, CL_MEM_READ_ONLY, sizeof(cl_float4)*numberOfVdw612, NULL, &eb);
	if(ea!=CL_SUCCESS ||eb!=CL_SUCCESS)
	{
		fprintf(forceField->logfile, "I cannot create Buffers for non-bonded terms\n");
		fflush(forceField->logfile);
		exit(1);
	}
	clEnqueueWriteBuffer(clProp.command_queue, forceField->vdw612IndexCL, CL_TRUE, 0, sizeof(cl_int4) * numberOfVdw612, clint4, 0, NULL, NULL);
	clEnqueueWriteBuffer(clProp.command_queue, forceField->vdw612TermsCL, CL_TRUE, 0, sizeof(cl_float4) * numberOfVdw612, clfloat4, 0, NULL, NULL);
	free(clint4);
	free(clfloat4);
        for( i=0; i<forceField->molecule.nAtoms;i++) if(maxCounters<gradCounters[i]) maxCounters = gradCounters[i];
#ifdef DEBUG
	fprintf(forceField->logfile, "End NonBond\n");
	fflush(forceField->logfile);
#endif
	}
	if(numberOfSuttonChen>0)
	{
	clint4 = malloc(numberOfSuttonChen*sizeof(cl_int4));
	clfloat8 = malloc(numberOfSuttonChen*sizeof(cl_float8));
        for( i=0; i<forceField->molecule.nAtoms;i++) suttonChenCounters[i] = 0;
	for(i=0;i<numberOfSuttonChen;i++)
	{
		clint4[i].s[0] = (int) suttonChenTerms[0][i];
		clint4[i].s[1] = (int) suttonChenTerms[1][i];
		clint4[i].s[2] =  suttonChenCounters[clint4[i].s[0]]++;
		clint4[i].s[3] =  suttonChenCounters[clint4[i].s[1]]++;

		clfloat8[i].s[0] = suttonChenTerms[2][i];
		clfloat8[i].s[1] = suttonChenTerms[3][i];
		clfloat8[i].s[2] = suttonChenTerms[4][i];
		clfloat8[i].s[3] = suttonChenTerms[5][i];
		clfloat8[i].s[4] = suttonChenTerms[6][i];
		clfloat8[i].s[5] = 0;
		clfloat8[i].s[6] = 0;
		clfloat8[i].s[7] = 0;
	}
	forceField->suttonChenIndexCL = clCreateBuffer(clProp.context, CL_MEM_READ_ONLY, sizeof(cl_int4)*numberOfSuttonChen, NULL, &ea);
	forceField->suttonChenTermsCL = clCreateBuffer(clProp.context, CL_MEM_READ_ONLY, sizeof(cl_float8)*numberOfSuttonChen, NULL, &eb);
	if(ea!=CL_SUCCESS ||eb!=CL_SUCCESS)
	{
		fprintf(forceField->logfile, "I cannot create Buffers for non-bonded terms\n");
		fflush(forceField->logfile);
		exit(1);
	}
	clEnqueueWriteBuffer(clProp.command_queue, forceField->suttonChenIndexCL, CL_TRUE, 0, sizeof(cl_int4) * numberOfSuttonChen, clint4, 0, NULL, NULL);
	clEnqueueWriteBuffer(clProp.command_queue, forceField->suttonChenTermsCL, CL_TRUE, 0, sizeof(cl_float8) * numberOfSuttonChen, clfloat8, 0, NULL, NULL);
	free(clint4);
	free(clfloat8);
	
        for( i=0; i<forceField->molecule.nAtoms;i++) if(maxSuttonChenCounters<suttonChenCounters[i]) maxSuttonChenCounters = suttonChenCounters[i];
#ifdef DEBUG
	fprintf(forceField->logfile, "End NonBond\n");
	fflush(forceField->logfile);
#endif
	free(suttonChenCounters);
	forceField->nBlockRhoBuffer = maxSuttonChenCounters;
	forceField->rhoBufferCL = clCreateBuffer(clProp.context,  CL_MEM_READ_WRITE, sizeof(cl_float)*forceField->molecule.nAtoms*forceField->nBlockRhoBuffer, NULL, &ea);
	}

	if(numberOfHydrogenBonded>0)
	{
	clint4 = malloc(numberOfHydrogenBonded*sizeof(cl_int4));
	clfloat2 = malloc(numberOfHydrogenBonded*sizeof(cl_float2));
        for( i=0; i<forceField->molecule.nAtoms;i++) gradCounters[i] = 0;
	for(i=0;i<numberOfHydrogenBonded;i++)
	{
		clint4[i].s[0] = (int) hydrogenBondedTerms[0][i];
		clint4[i].s[1] = (int) hydrogenBondedTerms[1][i];
		clint4[i].s[2] =  gradCounters[clint4[i].s[0]]++;
		clint4[i].s[3] =  gradCounters[clint4[i].s[1]]++;

		clfloat2[i].s[0] = hydrogenBondedTerms[2][i];
		clfloat2[i].s[1] = hydrogenBondedTerms[3][i];
	}
	forceField->hydrogenBondedIndexCL = clCreateBuffer(clProp.context, CL_MEM_READ_ONLY, sizeof(cl_int4)*numberOfHydrogenBonded, NULL, NULL);
	forceField->hydrogenBondedTermsCL = clCreateBuffer(clProp.context, CL_MEM_READ_ONLY, sizeof(cl_float2)*numberOfHydrogenBonded, NULL, NULL);
	clEnqueueWriteBuffer(clProp.command_queue, forceField->hydrogenBondedIndexCL, CL_TRUE, 0, sizeof(cl_int4) * numberOfHydrogenBonded, clint4, 0, NULL, NULL);
	clEnqueueWriteBuffer(clProp.command_queue, forceField->hydrogenBondedTermsCL, CL_TRUE, 0, sizeof(cl_float2) * numberOfHydrogenBonded, clfloat2, 0, NULL, NULL);
	free(clint4);
	free(clfloat2);
        for( i=0; i<forceField->molecule.nAtoms;i++) if(maxCounters<gradCounters[i]) maxCounters = gradCounters[i];
#ifdef DEBUG
	fprintf(forceField->logfile, "End numberOfHydrogenBonded\n");
	fflush(forceField->logfile);
#endif
	}

	if(numberOfPairWise>0)
	{
	clint4 = malloc(numberOfPairWise*sizeof(cl_int4));
	clfloat8 = malloc(numberOfPairWise*sizeof(cl_float8));
        for( i=0; i<forceField->molecule.nAtoms;i++) gradCounters[i] = 0;
	for(i=0;i<numberOfPairWise;i++)
	{
		clint4[i].s[0] = (int) pairWiseTerms[0][i];
		clint4[i].s[1] = (int) pairWiseTerms[1][i];
		clint4[i].s[2] =  gradCounters[clint4[i].s[0]]++;
		clint4[i].s[3] =  gradCounters[clint4[i].s[1]]++;

		clfloat8[i].s[0] = pairWiseTerms[2][i];
		clfloat8[i].s[1] = pairWiseTerms[3][i];
		clfloat8[i].s[2] = pairWiseTerms[4][i];
		clfloat8[i].s[3] = pairWiseTerms[5][i];
		clfloat8[i].s[4] = pairWiseTerms[6][i];
		clfloat8[i].s[5] = pairWiseTerms[7][i];
		clfloat8[i].s[6] = 0;
		clfloat8[i].s[7] = 0;
	}
	forceField->pairWiseIndexCL = clCreateBuffer(clProp.context, CL_MEM_READ_ONLY, sizeof(cl_int4)*numberOfPairWise, NULL, NULL);
	forceField->pairWiseTermsCL = clCreateBuffer(clProp.context, CL_MEM_READ_ONLY, sizeof(cl_float8)*numberOfPairWise, NULL, NULL);
	clEnqueueWriteBuffer(clProp.command_queue, forceField->pairWiseIndexCL, CL_TRUE, 0, sizeof(cl_int4) * numberOfPairWise, clint4, 0, NULL, NULL);
	clEnqueueWriteBuffer(clProp.command_queue, forceField->pairWiseTermsCL, CL_TRUE, 0, sizeof(cl_float8) * numberOfPairWise, clfloat8, 0, NULL, NULL);
	free(clint4);
	free(clfloat8);
        for( i=0; i<forceField->molecule.nAtoms;i++) if(maxCounters<gradCounters[i]) maxCounters = gradCounters[i];
#ifdef DEBUG
	fprintf(forceField->logfile, "End numberOfPairWise\n");
	fflush(forceField->logfile);
#endif
	}
	if(numberOfRattleConstraintsTerms>0)
	{
	cl_int* rattleCounters = malloc(forceField->molecule.nAtoms*sizeof(cl_int));
	clint4 = malloc(numberOfRattleConstraintsTerms*sizeof(cl_int4));
	clfloat = malloc(numberOfRattleConstraintsTerms*sizeof(cl_float));
        for( i=0; i<forceField->molecule.nAtoms;i++) rattleCounters[i] = 0;
	for(i=0;i<numberOfRattleConstraintsTerms;i++)
	{
		clint4[i].s[0] = (int) rattleConstraintsTerms[0][i];
		clint4[i].s[1] = (int) rattleConstraintsTerms[1][i];
		clint4[i].s[2] = rattleCounters[clint4[i].s[0]]++;
		clint4[i].s[3] = rattleCounters[clint4[i].s[1]]++;
		
		clfloat[i] = rattleConstraintsTerms[2][i];
	}
	forceField->rattleConstraintsIndexCL = clCreateBuffer(clProp.context, CL_MEM_READ_ONLY, sizeof(cl_int4)*numberOfRattleConstraintsTerms, NULL, &ea);
	forceField->rattleConstraintsTermsCL = clCreateBuffer(clProp.context, CL_MEM_READ_ONLY, sizeof(cl_float)*numberOfRattleConstraintsTerms, NULL, &eb);
	if(ea!=CL_SUCCESS||eb!=CL_SUCCESS)
	{
		fprintf(forceField->logfile, "I cannot bonds Buffer\n");
		fflush(forceField->logfile);
		exit(1);
	}
	ea = clEnqueueWriteBuffer(clProp.command_queue, forceField->rattleConstraintsIndexCL, CL_TRUE, 0, sizeof(cl_int4) * numberOfRattleConstraintsTerms, clint4, 0, NULL, NULL);
	eb = clEnqueueWriteBuffer(clProp.command_queue, forceField->rattleConstraintsTermsCL, CL_TRUE, 0, sizeof(cl_float) * numberOfRattleConstraintsTerms, clfloat, 0, NULL, NULL);
	if(ea!=CL_SUCCESS||eb!=CL_SUCCESS)
	{
		fprintf(forceField->logfile, "I cannot write bonds data in GPU Buffer\n");
		fflush(forceField->logfile);
		exit(1);
	}
	free(clint4);
	free(clfloat);
#ifdef DEBUG
	fprintf(forceField->logfile, "End numberOfRattleConstraintsTerms0\n");
	fflush(forceField->logfile);
#endif
	maxRattleCounters  = 1;
        for( i=0; i<forceField->molecule.nAtoms;i++) if(maxRattleCounters<rattleCounters[i]) maxRattleCounters = rattleCounters[i];
	free(rattleCounters);
	forceField->nBlockRattleBuffer = maxRattleCounters;
#ifdef DEBUG
	fprintf(forceField->logfile, "nBlockRattleBuffer=%d\n",maxRattleCounters);
	fflush(forceField->logfile);
#endif
	forceField->rattledeltaPositionBufferCL = clCreateBuffer(clProp.context, CL_MEM_READ_WRITE, sizeof(cl_float4)*forceField->nBlockRattleBuffer*forceField->molecule.nAtoms, NULL, &ec);
	forceField->rattledeltaVelocityBufferCL = clCreateBuffer(clProp.context, CL_MEM_READ_WRITE, sizeof(cl_float4)*forceField->nBlockRattleBuffer*forceField->molecule.nAtoms, NULL, &ec);
	forceField->rattleMovedBufferCL = clCreateBuffer(clProp.context, CL_MEM_READ_WRITE, sizeof(cl_int)*forceField->molecule.nAtoms, NULL, &ec);
	forceField->rattleUpdateBufferCL = clCreateBuffer(clProp.context, CL_MEM_READ_WRITE, sizeof(cl_int)*forceField->nBlockRattleBuffer*forceField->molecule.nAtoms, NULL, &ec);
	forceField->rattleDoneBufferCL = clCreateBuffer(clProp.context, CL_MEM_READ_WRITE, sizeof(cl_int), NULL, &ec);
#ifdef DEBUG
	fprintf(forceField->logfile, "End numberOfRattleConstraintsTerms\n");
	fflush(forceField->logfile);
#endif
	}

	free(gradCounters);
	forceField->nBlockGradientBuffer = maxCounters;
	//forceField->nBlockGradientBuffer = forceField->molecule.nAtoms;
	forceField->gradientBufferCL = clCreateBuffer(clProp.context,  CL_MEM_READ_WRITE, sizeof(cl_float4)*forceField->molecule.nAtoms*forceField->nBlockGradientBuffer, NULL, &ea);
	//maxCounters *= forceField->molecule.nAtoms;
#ifdef DEBUG
	fprintf(forceField->logfile, "nBlockGradientBuffer=%d\n",forceField->nBlockGradientBuffer);
	fprintf(forceField->logfile, "nAtoms=%d\n",forceField->molecule.nAtoms);
	fflush(forceField->logfile);
#endif
	//maxCounters = forceField->molecule.nAtoms*forceField->molecule.nAtoms;
	//forceField->gradientBufferCL = clCreateBuffer(clProp.context,  CL_MEM_READ_WRITE, sizeof(cl_float4)*maxCounters, NULL, &ea);
	if(ea!=CL_SUCCESS)
	{
		fprintf(forceField->logfile, "I cannot create the gradient Buffer\n");
		fflush(forceField->logfile);
		exit(1);
	}
	forceField->gradientBufferCPU = malloc(forceField->molecule.nAtoms*sizeof(cl_float4));

	// create kernels
	forceField->initEnergyKernel =  clCreateKernel(forceField->programMM, "initEnergy", &err);
	clSetKernelArg(forceField->initEnergyKernel, 0, sizeof(cl_mem),  &forceField->energyBufferCL);
	clSetKernelArg(forceField->initEnergyKernel, 1, sizeof(cl_float),  &forceField->nMaxTerms);
#ifdef DEBUG
	fprintf(forceField->logfile, "err = %d\n",err);
	fflush(forceField->logfile);
#endif


	if(forceField->numberOfStretchTerms>0)
	{
	forceField->addEnergyBondAmberKernel = clCreateKernel(forceField->programMM, "addEnergyBondAmber", &err);
	clSetKernelArg(forceField->addEnergyBondAmberKernel, 0, sizeof(cl_mem),  &forceField->energyBufferCL);
	clSetKernelArg(forceField->addEnergyBondAmberKernel, 1, sizeof(cl_mem),  &forceField->atomsCL);
	clSetKernelArg(forceField->addEnergyBondAmberKernel, 2, sizeof(cl_mem),  &forceField->bondIndexCL);
	clSetKernelArg(forceField->addEnergyBondAmberKernel, 3, sizeof(cl_mem),  &forceField->bondTermsCL);
	clSetKernelArg(forceField->addEnergyBondAmberKernel, 4, sizeof(cl_int),  &forceField->molecule.nAtoms);
	clSetKernelArg(forceField->addEnergyBondAmberKernel, 5, sizeof(cl_int),  &forceField->numberOfStretchTerms);
#ifdef DEBUG
	fprintf(forceField->logfile, "addEnergyBondAmber err = %d\n",err);
	fflush(forceField->logfile);
#endif
	size_t global = forceField->numberOfStretchTerms;
#ifdef DEBUG
	fprintf(forceField->logfile, "Call addEnergyBondAmber =====>0\n");
	fflush(forceField->logfile);
#endif
	err = clEnqueueNDRangeKernel(clProp.command_queue, forceField->addEnergyBondAmberKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	if(err != CL_SUCCESS)
	{
		printErrorCLRun(err);
        	fprintf(forceField->logfile, "I cannot execute addEnergyBondAmberKernel\n");
		fflush(forceField->logfile);
		exit(1);
	}
	}

	if(forceField->numberOfBendTerms>0)
	{
	forceField->addEnergyBendAmberKernel = clCreateKernel(forceField->programMM, "addEnergyBendAmber", &err);
	clSetKernelArg(forceField->addEnergyBendAmberKernel, 0, sizeof(cl_mem),  &forceField->energyBufferCL);
	clSetKernelArg(forceField->addEnergyBendAmberKernel, 1, sizeof(cl_mem),  &forceField->atomsCL);
	clSetKernelArg(forceField->addEnergyBendAmberKernel, 2, sizeof(cl_mem),  &forceField->bendIndexCL);
	clSetKernelArg(forceField->addEnergyBendAmberKernel, 3, sizeof(cl_mem),  &forceField->bendTermsCL);
	clSetKernelArg(forceField->addEnergyBendAmberKernel, 4, sizeof(cl_int),  &forceField->molecule.nAtoms);
	clSetKernelArg(forceField->addEnergyBendAmberKernel, 5, sizeof(cl_int),  &forceField->numberOfBendTerms);
#ifdef DEBUG
	fprintf(forceField->logfile, "addEnergyBendAmber err = %d\n",err);
	fflush(forceField->logfile);
#endif
	}

	if(forceField->numberOfDihedralTerms>0)
	{
	forceField->addEnergyDihedralAmberKernel =  clCreateKernel(forceField->programMM, "addEnergyDihedralAmber", &err);
	clSetKernelArg(forceField->addEnergyDihedralAmberKernel, 0, sizeof(cl_mem),  &forceField->energyBufferCL);
	clSetKernelArg(forceField->addEnergyDihedralAmberKernel, 1, sizeof(cl_mem),  &forceField->atomsCL);
	clSetKernelArg(forceField->addEnergyDihedralAmberKernel, 2, sizeof(cl_mem),  &forceField->dihedralIndexCL);
	clSetKernelArg(forceField->addEnergyDihedralAmberKernel, 3, sizeof(cl_mem),  &forceField->dihedralTermsCL);
	clSetKernelArg(forceField->addEnergyDihedralAmberKernel, 4, sizeof(cl_int),  &forceField->molecule.nAtoms);
	clSetKernelArg(forceField->addEnergyDihedralAmberKernel, 5, sizeof(cl_int),  &forceField->numberOfDihedralTerms);
#ifdef DEBUG
	fprintf(forceField->logfile, "addEnergyDihedralAmber err = %d\n",err);
	fflush(forceField->logfile);
#endif
	}

	if(numberOfVdw612>0)
	{
#ifdef DEBUG
	fprintf(forceField->logfile, "Use Coulomb = %d\n",forceField->options.coulomb);
	fflush(forceField->logfile);
#endif
	forceField->addEnergyVdw612AmberKernel =  clCreateKernel(forceField->programMM, "addEnergyVdw612Amber", &err);
	clSetKernelArg(forceField->addEnergyVdw612AmberKernel, 0, sizeof(cl_mem),  &forceField->energyBufferCL);
	clSetKernelArg(forceField->addEnergyVdw612AmberKernel, 1, sizeof(cl_mem),  &forceField->atomsCL);
	clSetKernelArg(forceField->addEnergyVdw612AmberKernel, 2, sizeof(cl_mem),  &forceField->vdw612IndexCL);
	clSetKernelArg(forceField->addEnergyVdw612AmberKernel, 3, sizeof(cl_mem),  &forceField->vdw612TermsCL);
	clSetKernelArg(forceField->addEnergyVdw612AmberKernel, 4, sizeof(cl_int),  &forceField->molecule.nAtoms);
	clSetKernelArg(forceField->addEnergyVdw612AmberKernel, 5, sizeof(cl_int),  &forceField->numberOfVdw612);
	clSetKernelArg(forceField->addEnergyVdw612AmberKernel, 6, sizeof(cl_int),  &useCoulomb);
#ifdef DEBUG
	fprintf(forceField->logfile, "addEnergyVdw612Amber err = %d\n",err);
	fflush(forceField->logfile);
#endif
	}
	if(numberOfSuttonChen>0)
	{
	forceField->addEnergySuttonChenAmberKernel =  clCreateKernel(forceField->programMM, "addEnergySuttonChenAmber", &err);
	clSetKernelArg(forceField->addEnergySuttonChenAmberKernel, 0, sizeof(cl_mem),  &forceField->energyBufferCL);
	clSetKernelArg(forceField->addEnergySuttonChenAmberKernel, 1, sizeof(cl_mem),  &forceField->atomsCL);
	clSetKernelArg(forceField->addEnergySuttonChenAmberKernel, 2, sizeof(cl_mem),  &forceField->suttonChenIndexCL);
	clSetKernelArg(forceField->addEnergySuttonChenAmberKernel, 3, sizeof(cl_mem),  &forceField->suttonChenTermsCL);
	clSetKernelArg(forceField->addEnergySuttonChenAmberKernel, 4, sizeof(cl_mem),  &forceField->rhoSuttonChenCL);
	clSetKernelArg(forceField->addEnergySuttonChenAmberKernel, 5, sizeof(cl_int),  &forceField->molecule.nAtoms);
	clSetKernelArg(forceField->addEnergySuttonChenAmberKernel, 6, sizeof(cl_int),  &forceField->numberOfSuttonChen);
#ifdef DEBUG
	fprintf(forceField->logfile, "addEnergyVdw612Amber err = %d\n",err);
	fflush(forceField->logfile);
#endif
	}

	if(forceField->numberOfHydrogenBonded>0)
	{
	forceField->addEnergyHydrogenBondedAmberKernel =  clCreateKernel(forceField->programMM, "addEnergyHydrogenBondedAmber", &err);
	clSetKernelArg(forceField->addEnergyHydrogenBondedAmberKernel, 0, sizeof(cl_mem),  &forceField->energyBufferCL);
	clSetKernelArg(forceField->addEnergyHydrogenBondedAmberKernel, 1, sizeof(cl_mem),  &forceField->atomsCL);
	clSetKernelArg(forceField->addEnergyHydrogenBondedAmberKernel, 2, sizeof(cl_mem),  &forceField->hydrogenBondedIndexCL);
	clSetKernelArg(forceField->addEnergyHydrogenBondedAmberKernel, 3, sizeof(cl_mem),  &forceField->hydrogenBondedTermsCL);
	clSetKernelArg(forceField->addEnergyHydrogenBondedAmberKernel, 4, sizeof(cl_int),  &forceField->molecule.nAtoms);
	clSetKernelArg(forceField->addEnergyHydrogenBondedAmberKernel, 5, sizeof(cl_int),  &forceField->numberOfHydrogenBonded);
#ifdef DEBUG
	fprintf(forceField->logfile, "addEnergyHydrogenBondedAmber err = %d\n",err);
	fflush(forceField->logfile);
#endif
	}

	if(numberOfPairWise>0)
	{
	forceField->addEnergyPairWiseKernel =  clCreateKernel(forceField->programMM, "addEnergyPairWise", &err);
	clSetKernelArg(forceField->addEnergyPairWiseKernel, 0, sizeof(cl_mem),  &forceField->energyBufferCL);
	clSetKernelArg(forceField->addEnergyPairWiseKernel, 1, sizeof(cl_mem),  &forceField->atomsCL);
	clSetKernelArg(forceField->addEnergyPairWiseKernel, 2, sizeof(cl_mem),  &forceField->pairWiseIndexCL);
	clSetKernelArg(forceField->addEnergyPairWiseKernel, 3, sizeof(cl_mem),  &forceField->pairWiseTermsCL);
	clSetKernelArg(forceField->addEnergyPairWiseKernel, 4, sizeof(cl_int),  &forceField->molecule.nAtoms);
	clSetKernelArg(forceField->addEnergyPairWiseKernel, 5, sizeof(cl_int),  &forceField->numberOfPairWise);
	clSetKernelArg(forceField->addEnergyPairWiseKernel, 6, sizeof(cl_int),  &forceField->options.coulomb);
	clSetKernelArg(forceField->addEnergyPairWiseKernel, 7, sizeof(cl_int),  &forceField->options.vanderWals);
#ifdef DEBUG
	fprintf(forceField->logfile, "addEnergyPairWise err = %d\n",err);
	fflush(forceField->logfile);
#endif
	}
	if(numberOfSuttonChen>0)
	{
	forceField->reduceRhoKernel =  clCreateKernel(forceField->programMM, "reduceRho", &err);
	clSetKernelArg(forceField->reduceRhoKernel, 0, sizeof(cl_mem),  &forceField->rhoBufferCL);
	clSetKernelArg(forceField->reduceRhoKernel, 1, sizeof(cl_int),  &forceField->molecule.nAtoms);
	clSetKernelArg(forceField->reduceRhoKernel, 2, sizeof(cl_int),  &forceField->nBlockRhoBuffer);
#ifdef DEBUG
	fprintf(forceField->logfile, "reduceRhoKernel err = %d\n",err);
	fflush(forceField->logfile);
#endif
	forceField->initRhoKernel =  clCreateKernel(forceField->programMM, "initRho", &err);
	clSetKernelArg(forceField->initRhoKernel, 0, sizeof(cl_mem),  &forceField->rhoBufferCL);
	clSetKernelArg(forceField->initRhoKernel, 1, sizeof(cl_int),  &forceField->molecule.nAtoms);
	clSetKernelArg(forceField->initRhoKernel, 2, sizeof(cl_int),  &forceField->nBlockRhoBuffer);
#ifdef DEBUG
	fprintf(forceField->logfile, "initRhoKernel err = %d\n",err);
	fflush(forceField->logfile);
#endif
	forceField->computeRhoKernel =  clCreateKernel(forceField->programMM, "computeRhoKernel", &err);
	clSetKernelArg(forceField->computeRhoKernel, 0, sizeof(cl_mem),  &forceField->rhoBufferCL);
	clSetKernelArg(forceField->computeRhoKernel, 1, sizeof(cl_int),  &forceField->molecule.nAtoms);
	clSetKernelArg(forceField->computeRhoKernel, 2, sizeof(cl_int),  &forceField->nBlockRhoBuffer);
#ifdef DEBUG
	fprintf(forceField->logfile, "computeRhoKernel err = %d\n",err);
	fflush(forceField->logfile);
#endif
	}

	forceField->reduceGradientsKernel =  clCreateKernel(forceField->programMM, "reduceGradients", &err);
	clSetKernelArg(forceField->reduceGradientsKernel, 0, sizeof(cl_mem),  &forceField->gradientBufferCL);
	clSetKernelArg(forceField->reduceGradientsKernel, 1, sizeof(cl_int),  &forceField->molecule.nAtoms);
	clSetKernelArg(forceField->reduceGradientsKernel, 2, sizeof(cl_int),  &forceField->nBlockGradientBuffer);
#ifdef DEBUG
	fprintf(forceField->logfile, "reduceGradients err = %d\n",err);
	fflush(forceField->logfile);
#endif

	forceField->initGradientsKernel =  clCreateKernel(forceField->programMM, "initGradients", &err);
	clSetKernelArg(forceField->initGradientsKernel, 0, sizeof(cl_mem),  &forceField->gradientBufferCL);
	clSetKernelArg(forceField->initGradientsKernel, 1, sizeof(cl_int),  &forceField->molecule.nAtoms);
	clSetKernelArg(forceField->initGradientsKernel, 2, sizeof(cl_int),  &forceField->nBlockGradientBuffer);
#ifdef DEBUG
	fprintf(forceField->logfile, "initGradients err = %d\n",err);
	fflush(forceField->logfile);
#endif

	forceField->initVelocitiesKernel =  clCreateKernel(forceField->programMM, "initVelocities", &err);
	clSetKernelArg(forceField->initVelocitiesKernel, 0, sizeof(cl_mem),  &forceField->atomsCL);
	clSetKernelArg(forceField->initVelocitiesKernel, 1, sizeof(cl_int),  &forceField->molecule.nAtoms);
#ifdef DEBUG
	fprintf(forceField->logfile, "initVelocities err = %d\n",err);
	fflush(forceField->logfile);
#endif
	//global = forceField->molecule.nAtoms;
	//clEnqueueNDRangeKernel(clProp.command_queue, forceField->initVelocitiesKernel, 1, NULL, &global, &local, 0, NULL, NULL);
	//clFinish(clProp.command_queue);

	if(forceField->numberOfStretchTerms>0)
	{
	forceField->addGradientBondAmberKernel =  clCreateKernel(forceField->programMM, "addGradientBondAmber", &err);
	if(err!=CL_SUCCESS)
	{
		fprintf(forceField->logfile, "I cannot create the addGradientBondAmberKernel kernel\n");
		fflush(forceField->logfile);
		exit(1);
	}
	err |= clSetKernelArg(forceField->addGradientBondAmberKernel, 0, sizeof(cl_mem),  &forceField->energyBufferCL);
	err |= clSetKernelArg(forceField->addGradientBondAmberKernel, 1, sizeof(cl_mem),  &forceField->gradientBufferCL);
	err |= clSetKernelArg(forceField->addGradientBondAmberKernel, 2, sizeof(cl_mem),  &forceField->atomsCL);
	err |= clSetKernelArg(forceField->addGradientBondAmberKernel, 3, sizeof(cl_mem),  &forceField->bondIndexCL);
	err |= clSetKernelArg(forceField->addGradientBondAmberKernel, 4, sizeof(cl_mem),  &forceField->bondTermsCL);
	err |= clSetKernelArg(forceField->addGradientBondAmberKernel, 5, sizeof(cl_int),  &forceField->molecule.nAtoms);
	err |= clSetKernelArg(forceField->addGradientBondAmberKernel, 6, sizeof(cl_int),  &forceField->numberOfStretchTerms);
#ifdef DEBUG
	fprintf(forceField->logfile, "addGradientBondAmber err = %d\n",err);
	fprintf(forceField->logfile, "Call addGradientBondAmberKernel =====>0\n");
	fflush(forceField->logfile);
#endif
	size_t global = forceField->numberOfStretchTerms;
	err = clEnqueueNDRangeKernel(clProp.command_queue, forceField->addGradientBondAmberKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	if(err != CL_SUCCESS)
	{
		printErrorCLRun(err);
        	fprintf(forceField->logfile, "I cannot execute addGradientBondAmberKernel\n");
		fflush(forceField->logfile);
		exit(1);
	}
	}

	if(forceField->numberOfBendTerms>0)
	{
	forceField->addGradientBendAmberKernel =  clCreateKernel(forceField->programMM, "addGradientBendAmber", &err);
	clSetKernelArg(forceField->addGradientBendAmberKernel, 0, sizeof(cl_mem),  &forceField->energyBufferCL);
	clSetKernelArg(forceField->addGradientBendAmberKernel, 1, sizeof(cl_mem),  &forceField->gradientBufferCL);
	clSetKernelArg(forceField->addGradientBendAmberKernel, 2, sizeof(cl_mem),  &forceField->atomsCL);
	clSetKernelArg(forceField->addGradientBendAmberKernel, 3, sizeof(cl_mem),  &forceField->bendIndexCL);
	clSetKernelArg(forceField->addGradientBendAmberKernel, 4, sizeof(cl_mem),  &forceField->bendTermsCL);
	clSetKernelArg(forceField->addGradientBendAmberKernel, 5, sizeof(cl_int),  &forceField->molecule.nAtoms);
	clSetKernelArg(forceField->addGradientBendAmberKernel, 6, sizeof(cl_int),  &forceField->numberOfBendTerms);
#ifdef DEBUG
	fprintf(forceField->logfile, "addGradientBendAmber err = %d\n",err);
	fflush(forceField->logfile);
#endif
	}

	if(forceField->numberOfDihedralTerms>0)
	{
	forceField->addGradientDihedralAmberKernel =  clCreateKernel(forceField->programMM, "addGradientDihedralAmber", &err);
	clSetKernelArg(forceField->addGradientDihedralAmberKernel, 0, sizeof(cl_mem),  &forceField->energyBufferCL);
	clSetKernelArg(forceField->addGradientDihedralAmberKernel, 1, sizeof(cl_mem),  &forceField->gradientBufferCL);
	clSetKernelArg(forceField->addGradientDihedralAmberKernel, 2, sizeof(cl_mem),  &forceField->atomsCL);
	clSetKernelArg(forceField->addGradientDihedralAmberKernel, 3, sizeof(cl_mem),  &forceField->dihedralIndexCL);
	clSetKernelArg(forceField->addGradientDihedralAmberKernel, 4, sizeof(cl_mem),  &forceField->dihedralTermsCL);
	clSetKernelArg(forceField->addGradientDihedralAmberKernel, 5, sizeof(cl_int),  &forceField->molecule.nAtoms);
	clSetKernelArg(forceField->addGradientDihedralAmberKernel, 6, sizeof(cl_int),  &forceField->numberOfDihedralTerms);
#ifdef DEBUG
	fprintf(forceField->logfile, "addGradientDihedralAmber err = %d\n",err);
	fflush(forceField->logfile);
#endif
	}

	if(forceField->numberOfImproperTorsionTerms>0)
	{
	forceField->addGradientImproperTorsionKernel =  clCreateKernel(forceField->programMM, "addGradientImproperTorsion", &err);
#ifdef DEBUG
	fprintf(forceField->logfile, "addGradientImproperTorsion err = %d\n",err);
	fflush(forceField->logfile);
#endif
	}

	if(numberOfVdw612>0)
	{
	forceField->addGradientVdw612AmberKernel =  clCreateKernel(forceField->programMM, "addGradientVdw612Amber", &err);
	clSetKernelArg(forceField->addGradientVdw612AmberKernel, 0, sizeof(cl_mem),  &forceField->energyBufferCL);
	clSetKernelArg(forceField->addGradientVdw612AmberKernel, 1, sizeof(cl_mem),  &forceField->gradientBufferCL);
	clSetKernelArg(forceField->addGradientVdw612AmberKernel, 2, sizeof(cl_mem),  &forceField->atomsCL);
	clSetKernelArg(forceField->addGradientVdw612AmberKernel, 3, sizeof(cl_mem),  &forceField->vdw612IndexCL);
	clSetKernelArg(forceField->addGradientVdw612AmberKernel, 4, sizeof(cl_mem),  &forceField->vdw612TermsCL);
	clSetKernelArg(forceField->addGradientVdw612AmberKernel, 5, sizeof(cl_int),  &forceField->molecule.nAtoms);
	clSetKernelArg(forceField->addGradientVdw612AmberKernel, 6, sizeof(cl_int),  &forceField->numberOfVdw612);
	clSetKernelArg(forceField->addGradientVdw612AmberKernel, 7, sizeof(cl_int),  &forceField->options.coulomb);
#ifdef DEBUG
	fprintf(forceField->logfile, "addGradientVdw612Amber err = %d\n",err);
	fflush(forceField->logfile);
#endif
	}
	if(numberOfVdw714>0)
	{
	forceField->addGradientVdw714AmberKernel =  clCreateKernel(forceField->programMM, "addGradientVdw714Amber", &err);
	clSetKernelArg(forceField->addGradientVdw714AmberKernel, 0, sizeof(cl_mem),  &forceField->energyBufferCL);
	clSetKernelArg(forceField->addGradientVdw714AmberKernel, 1, sizeof(cl_mem),  &forceField->gradientBufferCL);
	clSetKernelArg(forceField->addGradientVdw714AmberKernel, 2, sizeof(cl_mem),  &forceField->atomsCL);
	clSetKernelArg(forceField->addGradientVdw714AmberKernel, 3, sizeof(cl_mem),  &forceField->vdw714IndexCL);
	clSetKernelArg(forceField->addGradientVdw714AmberKernel, 4, sizeof(cl_mem),  &forceField->vdw714TermsCL);
	clSetKernelArg(forceField->addGradientVdw714AmberKernel, 5, sizeof(cl_int),  &forceField->molecule.nAtoms);
	clSetKernelArg(forceField->addGradientVdw714AmberKernel, 6, sizeof(cl_int),  &forceField->numberOfVdw714);
	clSetKernelArg(forceField->addGradientVdw714AmberKernel, 7, sizeof(cl_int),  &forceField->options.coulomb);
#ifdef DEBUG
	fprintf(forceField->logfile, "addGradientVdw714Amber err = %d\n",err);
	fflush(forceField->logfile);
#endif
	}
	if(numberOfSuttonChen>0)
	{
	forceField->addGradientSuttonChenAmberKernel =  clCreateKernel(forceField->programMM, "addGradientSuttonChenAmber", &err);
	clSetKernelArg(forceField->addGradientSuttonChenAmberKernel, 0, sizeof(cl_mem),  &forceField->energyBufferCL);
	clSetKernelArg(forceField->addGradientSuttonChenAmberKernel, 1, sizeof(cl_mem),  &forceField->gradientBufferCL);
	clSetKernelArg(forceField->addGradientSuttonChenAmberKernel, 2, sizeof(cl_mem),  &forceField->atomsCL);
	clSetKernelArg(forceField->addGradientSuttonChenAmberKernel, 3, sizeof(cl_mem),  &forceField->suttonChenIndexCL);
	clSetKernelArg(forceField->addGradientSuttonChenAmberKernel, 4, sizeof(cl_mem),  &forceField->suttonChenTermsCL);
	clSetKernelArg(forceField->addGradientSuttonChenAmberKernel, 6, sizeof(cl_mem),  &forceField->suttonChenRhoCL);
	clSetKernelArg(forceField->addGradientSuttonChenAmberKernel, 6, sizeof(cl_int),  &forceField->molecule.nAtoms);
	clSetKernelArg(forceField->addGradientSuttonChenAmberKernel, 7, sizeof(cl_int),  &forceField->numberOfVdw612);
#ifdef DEBUG
	fprintf(forceField->logfile, "addGradientSuttonChenAmberKernel err = %d\n",err);
	fflush(forceField->logfile);
#endif
	}

	if(forceField->numberOfHydrogenBonded>0)
	{
	forceField->addGradientHydrogenBondedAmberKernel =  clCreateKernel(forceField->programMM, "addGradientHydrogenBondedAmber", &err);
	clSetKernelArg(forceField->addGradientHydrogenBondedAmberKernel, 0, sizeof(cl_mem),  &forceField->energyBufferCL);
	clSetKernelArg(forceField->addGradientHydrogenBondedAmberKernel, 1, sizeof(cl_mem),  &forceField->gradientBufferCL);
	clSetKernelArg(forceField->addGradientHydrogenBondedAmberKernel, 2, sizeof(cl_mem),  &forceField->atomsCL);
	clSetKernelArg(forceField->addGradientHydrogenBondedAmberKernel, 3, sizeof(cl_mem),  &forceField->hydrogenBondedIndexCL);
	clSetKernelArg(forceField->addGradientHydrogenBondedAmberKernel, 4, sizeof(cl_mem),  &forceField->hydrogenBondedTermsCL);
	clSetKernelArg(forceField->addGradientHydrogenBondedAmberKernel, 5, sizeof(cl_int),  &forceField->molecule.nAtoms);
	clSetKernelArg(forceField->addGradientHydrogenBondedAmberKernel, 6, sizeof(cl_int),  &forceField->numberOfHydrogenBonded);
#ifdef DEBUG
	fprintf(forceField->logfile, "addGradientHydrogenBondedAmber err = %d\n",err);
	fflush(forceField->logfile);
#endif
	}

	if(numberOfPairWise>0)
	{
	forceField->addGradientPairWiseKernel =  clCreateKernel(forceField->programMM, "addGradientPairWise", &err);
	clSetKernelArg(forceField->addGradientPairWiseKernel, 0, sizeof(cl_mem),  &forceField->energyBufferCL);
	clSetKernelArg(forceField->addGradientPairWiseKernel, 1, sizeof(cl_mem),  &forceField->gradientBufferCL);
	clSetKernelArg(forceField->addGradientPairWiseKernel, 2, sizeof(cl_mem),  &forceField->atomsCL);
	clSetKernelArg(forceField->addGradientPairWiseKernel, 3, sizeof(cl_mem),  &forceField->pairWiseIndexCL);
	clSetKernelArg(forceField->addGradientPairWiseKernel, 4, sizeof(cl_mem),  &forceField->pairWiseTermsCL);
	clSetKernelArg(forceField->addGradientPairWiseKernel, 5, sizeof(cl_int),  &forceField->molecule.nAtoms);
	clSetKernelArg(forceField->addGradientPairWiseKernel, 6, sizeof(cl_int),  &forceField->numberOfPairWise);
	clSetKernelArg(forceField->addGradientPairWiseKernel, 7, sizeof(cl_int),  &forceField->options.coulomb);
	clSetKernelArg(forceField->addGradientPairWiseKernel, 8, sizeof(cl_int),  &forceField->options.vanderWals);
#ifdef DEBUG
	fprintf(forceField->logfile, " addGradientPairWise err = %d\n",err);
	fflush(forceField->logfile);
#endif
	}



	// set the argument list for the kernel command
	// cl_float4 pos => pos.s[0], pos.s[1], ... 
};
#endif
/**********************************************************************/
ForceField createAmberModel (Molecule* mol, ForceFieldOptions forceFieldOptions,FILE* logfile)
{
	ForceField forceField = newAmberModel();

	forceField.molecule = *(mol->klass->copy(mol));
	
	forceField.options = forceFieldOptions;
	forceField.logfile = logfile;
	setRattleConstraintsParameters(&forceField);

	fprintf(forceField.logfile, ("Setting of Parameters ...\n"));
	fflush(forceField.logfile);

	setAmberParameters(&forceField);
#ifdef ENABLE_CL
	initCLForceField (&forceField);
#endif

	return forceField;
}
/**********************************************************************/
ForceField createPairWiseModel(Molecule* mol, ForceFieldOptions forceFieldOptions, FILE* logfile)
{
	ForceField forceField = newPairWiseModel();
	

	forceField.molecule = *(mol->klass->copy(mol));
	
	forceField.options = forceFieldOptions;
	forceField.logfile = logfile;
	setRattleConstraintsParameters(&forceField);

	forceField.options.bondStretch = FALSE;
	forceField.options.angleBend = FALSE;
	forceField.options.dihedralAngle = FALSE;
	forceField.options.improperTorsion = FALSE;
	forceField.options.vdw612 = FALSE;
	forceField.options.hydrogenBonded612 = FALSE;
	forceField.options.hydrogenBonded1012 = FALSE;
	forceField.options.hydrogenBondedMorse = FALSE;


	fprintf(forceField.logfile, ("Setting of Parameters ...\n"));
	fflush(forceField.logfile);

	setAllPairWiseParameters(&forceField);

	return forceField;
}
/**********************************************************************/
void saveAmberParameters()
{
	createMMFile();
}
/**********************************************************************/
void loadAmberParameters()
{
	AmberParameters amberParameters;

	char* defaultFileName = getFileNameParameters();

	if(staticAmberParameters != NULL) freeAmberParameters(staticAmberParameters);

	amberParameters =  newAmberParameters();

	if(!readAmberParameters(&amberParameters,defaultFileName))
	{
		createMMFile();
		if(!readAmberParameters(&amberParameters,defaultFileName))
		{
			free(defaultFileName);
			return;
		}
	}

	staticAmberParameters = malloc(sizeof(AmberParameters));
	*staticAmberParameters = amberParameters;

	free(defaultFileName);
}
/**********************************************************************/
AmberParameters* getPointerAmberParameters()
{
	return staticAmberParameters;
}
/**********************************************************************/
void setPointerAmberParameters(AmberParameters* ptr)
{
	staticAmberParameters = ptr;
}
/********************************************************************************/
char** getListMMTypes(int* nlist)
{

	char** t = NULL;
	
	int i;

	*nlist = 0;

	if(!staticAmberParameters || staticAmberParameters->numberOfTypes<=0)
		return NULL;
	
	t = malloc(staticAmberParameters->numberOfTypes*sizeof(char*));
	*nlist = staticAmberParameters->numberOfTypes;

	for(i=0;i<staticAmberParameters->numberOfTypes;i++)
		t[i] = strdup(staticAmberParameters->atomTypes[i].name);

	return t;
}
/**********************************************************************/
static void printEnergies(ForceField* forceField)
{
	double totalEnergy = 0.0;
	double energy = 0.0;
	Molecule* molecule = &forceField->molecule;
	int j;

#ifdef DEBUG
        TimerType timer;
#endif

#ifdef ENABLE_CL
	CLProp clProp = getCLProp();
	size_t local = 64;
	size_t global;
	int i;

	fprintf(forceField->logfile, "Begin calculateEnergyTmpAmber\n");
	fflush(forceField->logfile);
	global = forceField->nMaxTerms;
	clEnqueueNDRangeKernel(clProp.command_queue, forceField->initEnergyKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	clFinish(clProp.command_queue);

#ifdef DEBUG
        timer_init(timer);
       	timer_start( timer );
#endif
	if(forceField->numberOfStretchTerms>0)
	{
	global = forceField->numberOfStretchTerms;
	clEnqueueNDRangeKernel(clProp.command_queue, forceField->addEnergyBondAmberKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	clFinish(clProp.command_queue);
	}

	if(forceField->numberOfBendTerms>0)
	{
	global = forceField->numberOfBendTerms;
	clEnqueueNDRangeKernel(clProp.command_queue, forceField->addEnergyBendAmberKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	clFinish(clProp.command_queue);
	}

	if(forceField->numberOfDihedralTerms>0)
	{
	global = forceField->numberOfDihedralTerms;
	clEnqueueNDRangeKernel(clProp.command_queue, forceField->addEnergyDihedralAmberKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	clFinish(clProp.command_queue);
	}

	if(forceField->numberOfVdw612>0)
	{
	global = forceField->numberOfVdw612;
	clEnqueueNDRangeKernel(clProp.command_queue, forceField->addEnergyVdw612AmberKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	clFinish(clProp.command_queue);
	}

	if(forceField->numberOfSuttonChen>0)
	{
	global = forceField->numberOfSuttonChen;
	clEnqueueNDRangeKernel(clProp.command_queue, forceField->initRhoKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	clEnqueueNDRangeKernel(clProp.command_queue, forceField->computeRhoKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	global = forceField->molecule.nAtoms;
	clEnqueueNDRangeKernel(clProp.command_queue, forceField->reduceRhoKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	global = forceField->numberOfSuttonChen;
	clEnqueueNDRangeKernel(clProp.command_queue, forceField->addEnergySuttoChenAmberKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	clFinish(clProp.command_queue);
	}

	if(forceField->numberOfHydrogenBonded>0)
	{
	global = forceField->numberOfHydrogenBonded;
	clEnqueueNDRangeKernel(clProp.command_queue, forceField->addEnergyHydrogenBondedAmberKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	clFinish(clProp.command_queue);
	}

	if(forceField->numberOfPairWise>0)
	{
	global = forceField->numberOfPairWise;
	clEnqueueNDRangeKernel(clProp.command_queue, forceField->addEnergyPairWiseKernel, 1, NULL, &global, NULL, 0, NULL, NULL);
	clFinish(clProp.command_queue);
	}


	clEnqueueReadBuffer(clProp.command_queue, forceField->energyBufferCL, CL_TRUE, 0, sizeof(cl_float)*forceField->nMaxTerms, forceField->energyBufferCPU, 0, NULL, NULL);
	energy = 0;
	for(i=0;i<forceField->nMaxTerms;i++) energy+=forceField->energyBufferCPU[i];
#ifdef DEBUG
       	timer_stop(timer);
        fprintf(forceField->logfile, "time (s) = %f\n", timer_get(timer)*1e-6);
	fflush(forceField->logfile);
#endif
#else // ENABLE_CL
#ifdef DEBUG
        timer_init(timer);
       	timer_start( timer );
#endif
#endif

	for(j=0;j<80;j++) printf("-"); printf("\n");
	energy =calculateEnergyBondAmber(forceField,molecule);
	totalEnergy += energy;
	printf("%-30s %s %20.14f\n","Bond energy","=",energy);
	energy =calculateEnergyBendAmber(forceField,molecule);
	totalEnergy += energy;
	printf("%-30s %s %20.14f\n","Bend energy","=",energy);
	energy =calculateEnergyStrBendAmber(forceField,molecule);
	totalEnergy += energy;
	printf("%-30s %s %20.14f\n","Str-Bend energy","=",energy);
	energy =calculateEnergyDihedralAmber(forceField,molecule);
	totalEnergy += energy;
	printf("%-30s %s %20.14f\n","Dihedral energy","=",energy);
	energy =calculateEnergyImproperTorsionAmber(forceField,molecule);
	totalEnergy += energy;
	printf("%-30s %s %20.14f\n","Improper Torsion energy","=",energy);
	energy =calculateEnergyOutOfPlaneAmber(forceField,molecule);
	totalEnergy += energy;
	printf("%-30s %s %20.14f\n","Out Of Plane energy","=",energy);
	energy =calculateEnergyVdw612Amber(forceField,molecule);
	totalEnergy += energy;
	printf("%-30s %s %20.14f\n","VDW 6-12 energy","=",energy);
	energy =calculateEnergyVdw714Amber(forceField,molecule);
	totalEnergy += energy;
	printf("%-30s %s %20.14f\n","VDW 7-14 energy","=",energy);
	energy =calculateEnergyCoulombAmber(forceField,molecule);
	totalEnergy += energy;
	printf("%-30s %s %20.14f\n","Coulomb energy","=",energy);
	energy =calculateEnergySuttonChenAmber(forceField,molecule);
	totalEnergy += energy;
	printf("%-30s %s %20.14f\n","Sutton-Chen energy","=",energy);
	energy =calculateEnergyHydrogenBondedAmber(forceField,molecule);
	totalEnergy += energy;
	printf("%-30s %s %20.14f\n","Hydrogen Bonded energy","=",energy);
	energy =calculateEnergyPairWise(forceField,molecule);
	totalEnergy += energy;
	printf("%-30s %s %20.14f\n","Pair wise energy","=",energy);
	energy =getH4Energy(forceField, molecule);
	totalEnergy += energy;
	printf("%-30s %s %20.14f\n","Hydrogen Bonded-H4 energy","=",energy);

	printf("%-30s %s %20.14f\n","Total energy","=", totalEnergy);
	for(j=0;j<80;j++) printf("-"); printf("\n");
}
File: ./cchemilib/src/MolecularMechanics/QuasiNewton.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* QuasiNewton.c */
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>

#include "../Utils/Utils.h"
#include "../Utils/AtomsProp.h"
#include "../Utils/Constants.h"
#include "../Utils/Types.h"
#include "../Molecule/Molecule.h"
#include "../MolecularMechanics/QuasiNewton.h"

double maxarg1,maxarg2;
#define FMIN(a,b) (maxarg1=(a),maxarg2=(b),(maxarg1) > (maxarg2) ?(maxarg2) : (maxarg1))
#define FMAX(a,b) (maxarg1=(a),maxarg2=(b),(maxarg1) > (maxarg2) ?(maxarg1) : (maxarg2))


static int lbfgs( 
		int n , int m , double x[] , double f , double g[] ,
		int diagco , double diag[] , double eps ,
		double xtol , int maxLines,int iflag[]
	);
/**********************************************************************/
void runQuasiNewton(QuasiNewton* quasiNewton)
{

	int j;
	int i,i3;
	int iter;
	int nAtomsX3;
	int diagco = FALSE;
	double* x = NULL;
	double* g = NULL;
	double* diag = NULL;
	int iflag = 0;
	double energy = 0;
	int nAtoms;
	int updateNumber = 0;
	char str[BSIZE];
	double gradientNorm;

	ForceField* forceField = quasiNewton->forceField;

	if(forceField->molecule.nAtoms<1) return;

	nAtoms = forceField->molecule.nAtoms;
	nAtomsX3 = 3*nAtoms;

	diag = malloc(nAtomsX3*sizeof(double));
	x = malloc(nAtomsX3*sizeof(double));
	g = malloc(nAtomsX3*sizeof(double));

	forceField->klass->calculateEnergy(forceField);
	forceField->klass->calculateGradient(forceField);
	energy = forceField->molecule.potentialEnergy;

	gradientNorm = 0;
	for (  i = 0; i < nAtoms; i++ )
	for(j=0;j<3;j++) gradientNorm += forceField->molecule.atoms[i].gradient[j]*forceField->molecule.atoms[i].gradient[j]; 
	sprintf(str,("Gradient = %0.14f energy = %0.14f "),sqrt(gradientNorm),energy); 
	fprintf(quasiNewton->logfile,"%s\n",str);
	fflush(quasiNewton->logfile);

	for(iter=0;iter<quasiNewton->maxIterations;iter++)
	{
		forceField->klass->calculateGradient(forceField);
		energy = forceField->klass->calculateEnergyTmp(forceField, &forceField->molecule );
		//printf("energy = %f energyC = %f\n",energy,forceField->molecule.potentialEnergy);
		/* set x  and g table from coordinates and gradient */
		for(i=0,i3=0;i<nAtoms;i++)
		{
			if(!forceField->molecule.atoms[i].variable) continue;
			x[i3  ] = forceField->molecule.atoms[i].coordinates[0];
			x[i3+1] = forceField->molecule.atoms[i].coordinates[1];
			x[i3+2] = forceField->molecule.atoms[i].coordinates[2];

			g[i3  ] = forceField->molecule.atoms[i].gradient[0];
			g[i3+1] = forceField->molecule.atoms[i].gradient[1];
			g[i3+2] = forceField->molecule.atoms[i].gradient[2];
			i3 += 3;
		}
		lbfgs(i3, i3,x, energy,g,diagco,diag,
				quasiNewton->epsilon,quasiNewton->tolerence,
				quasiNewton->maxLines,
				&iflag);
		/*
		lbfgs(nAtomsX3, nAtomsX3,x, energy,g,diagco,diag,
				quasiNewton->epsilon,quasiNewton->tolerence,
				quasiNewton->maxLines,
				&iflag);
				*/
		/* set coordinates from x */
		for(i=0,i3=0;i<nAtoms;i++)
		{
			if(forceField->molecule.atoms[i].variable) 
			{
				forceField->molecule.atoms[i].coordinates[0] = x[i3];
				forceField->molecule.atoms[i].coordinates[1] = x[i3+1];
				forceField->molecule.atoms[i].coordinates[2] = x[i3+2];
				i3+=3;
			}
		}
		updateGeometryCL(forceField,NULL);

		if ( updateNumber >= quasiNewton->updateFrequency )
		{
			gradientNorm = 0;
			for (  i = 0; i < nAtoms; i++ )
				for(j=0;j<3;j++)
					gradientNorm += 
					forceField->molecule.atoms[i].gradient[j]
					*forceField->molecule.atoms[i].gradient[j]; 

			sprintf(str,("Gradient = %0.14f energy = %0.14f "),sqrt(gradientNorm),energy); 
			fprintf(quasiNewton->logfile,"%s\n",str);
			fflush(quasiNewton->logfile);
			/* redrawMolecule(&forceField->molecule,str);*/
			updateNumber = 0;
		}
		updateNumber++;
		if(iflag<=0)
			break;
	}
	gradientNorm = 0;
	for (  i = 0; i < nAtoms; i++ )
		for(j=0;j<3;j++)
			gradientNorm += 
			forceField->molecule.atoms[i].gradient[j]
			*forceField->molecule.atoms[i].gradient[j]; 

	sprintf(str,("Gradient = %0.14f energy = %0.14f "),sqrt(gradientNorm),energy); 
	/* redrawMolecule(&forceField->molecule,str);*/
	fprintf(quasiNewton->logfile,"%s\n",str);
	fflush(quasiNewton->logfile);
	/* forceField->klass->printEnergies(forceField);*/
	free(diag);
	free(x);
	free(g);
}
/**********************************************************************/
void	freeQuasiNewton(QuasiNewton* quasiNewton)
{
	quasiNewton->forceField = NULL;
	quasiNewton->updateFrequency = 0;
	quasiNewton->maxIterations = 0;
	quasiNewton->maxLines = 0;
	quasiNewton->epsilon = 0;
	quasiNewton->tolerence = 0;
}
/**********************************************************************/
static double sqr( double x )
{ 
	return x*x;
}
/******************************************************************************/
static double max3( double x, double y, double z )
{
	return x < y ? ( y < z ? z : y ) : ( x < z ? z : x );
}
/** The purpose of this function is to compute a safeguarded step for
  * a linesearch and to update an interval of uncertainty for
  * a minimizer of the function.<p>
*/ 
static void mcstep (   double stx[] , double fx[] , double dx[] ,
		double sty[] , double fy[] , double dy[] ,
		double stp[] , double fp , double dp ,
		int brackt[] , double stpmin , double stpmax , int info[]
   	    )
{
	int bound;
	double gamma, p, q, r, s, sgnd, stpc, stpf, stpq, theta;

	info[0] = 0;

	if ( (
		brackt[0] && 
		( stp[0] <= FMIN ( stx[0] , sty[0] ) || stp[0] >= FMAX ( stx[0] , sty[0] ))
	     ) 
	     || dx[0] * ( stp[0] - stx[0] ) >= 0.0 
	     || stpmax < stpmin
	    )
		return;

	/* Determine if the derivatives have opposite sign.*/

	sgnd = dp * ( dx[0] / fabs ( dx[0] ) );

	if ( fp > fx[0] )
	{
		/* 
		 First case. A higher function value.
		 The minimum is bracketed. If the cubic step is closer
		 to stx than the quadratic step, the cubic step is taken,
		 else the average of the cubic and quadratic steps is taken.
		*/

		info[0] = 1;
		bound = TRUE;
		theta = 3 * ( fx[0] - fp ) / ( stp[0] - stx[0] ) + dx[0] + dp;
		s = max3 ( fabs ( theta ) , fabs ( dx[0] ) , fabs ( dp ) );
		gamma = s * sqrt ( sqr( theta / s ) - ( dx[0] / s ) * ( dp / s ) );
		if ( stp[0] < stx[0] ) gamma = - gamma;
		p = ( gamma - dx[0] ) + theta;
		q = ( ( gamma - dx[0] ) + gamma ) + dp;
		r = p/q;
		stpc = stx[0] + r * ( stp[0] - stx[0] );
		stpq = stx[0] 
			+ ( ( dx[0] / ( ( fx[0] - fp ) / ( stp[0] - stx[0] ) + dx[0] ) ) / 2 )
			*( stp[0] - stx[0] );

		if ( fabs ( stpc - stx[0] ) < fabs ( stpq - stx[0] ) )
			stpf = stpc;
		else
			stpf = stpc + ( stpq - stpc ) / 2;

		brackt[0] = TRUE;
	}
	else if ( sgnd < 0.0 )
	{
		/* Second case. A lower function value and derivatives of
		   opposite sign. The minimum is bracketed. If the cubic
		   step is closer to stx than the quadratic (secant) step,
		   the cubic step is taken, else the quadratic step is taken.
		 */

		info[0] = 2;
		bound = FALSE;
		theta = 3 * ( fx[0] - fp ) / ( stp[0] - stx[0] ) + dx[0] + dp;
		s = max3 ( fabs ( theta ) , fabs ( dx[0] ) , fabs ( dp ) );
		gamma = s * sqrt ( sqr( theta / s ) - ( dx[0] / s ) * ( dp / s ) );
		if ( stp[0] > stx[0] ) gamma = - gamma;
		p = ( gamma - dp ) + theta;
		q = ( ( gamma - dp ) + gamma ) + dx[0];
		r = p/q;
		stpc = stp[0] + r * ( stx[0] - stp[0] );
		stpq = stp[0] + ( dp / ( dp - dx[0] ) ) * ( stx[0] - stp[0] );
		if ( fabs ( stpc - stp[0] ) > fabs ( stpq - stp[0] ) )
			stpf = stpc;
		else
			stpf = stpq;

		brackt[0] = TRUE;
	}
	else if ( fabs ( dp ) < fabs ( dx[0] ) )
	{
		/* Third case. A lower function value, derivatives of the
		   same sign, and the magnitude of the derivative decreases.
		   The cubic step is only used if the cubic tends to infinity
		   in the direction of the step or if the minimum of the cubic
		   is beyond stp. Otherwise the cubic step is defined to be
		   either stpmin or stpmax. The quadratic (secant) step is also
		   computed and if the minimum is bracketed then the the step
		 closest to stx is taken, else the step farthest away is taken.
		 */

		info[0] = 3;
		bound = TRUE;
		theta = 3 * ( fx[0] - fp ) / ( stp[0] - stx[0] ) + dx[0] + dp;
		s = max3 ( fabs ( theta ) , fabs ( dx[0] ) , fabs ( dp ) );
		gamma = s * sqrt ( FMAX ( 0, sqr( theta / s ) - ( dx[0] / s ) * ( dp / s ) ) );
		if ( stp[0] > stx[0] )
		       	gamma = - gamma;
		p = ( gamma - dp ) + theta;
		q = ( gamma + ( dx[0] - dp ) ) + gamma;
		r = p/q;
		if ( r < 0.0 && gamma != 0.0 )
			stpc = stp[0] + r * ( stx[0] - stp[0] );
		else if ( stp[0] > stx[0] )
			stpc = stpmax;
		else
			stpc = stpmin;

		stpq = stp[0] + ( dp / ( dp - dx[0] ) ) * ( stx[0] - stp[0] );
		if ( brackt[0] )
		{
			if ( fabs ( stp[0] - stpc ) < fabs ( stp[0] - stpq ) )
				stpf = stpc;
			else
				stpf = stpq;
		}
		else
		{
			if ( fabs ( stp[0] - stpc ) > fabs ( stp[0] - stpq ) )
				stpf = stpc;
			else
				stpf = stpq;
		}
	}
	else
	{
		/* Fourth case. A lower function value, derivatives of the
		   same sign, and the magnitude of the derivative does
		   not decrease. If the minimum is not bracketed, the step
		   is either stpmin or stpmax, else the cubic step is taken.
		*/

		info[0] = 4;
		bound = FALSE;
		if ( brackt[0] )
		{
			theta = 3 * ( fp - fy[0] ) / ( sty[0] - stp[0] ) + dy[0] + dp;
			s = max3 ( fabs ( theta ) , fabs ( dy[0] ) , fabs ( dp ) );
			gamma = s * sqrt ( sqr( theta / s ) - ( dy[0] / s ) * ( dp / s ) );
			if ( stp[0] > sty[0] ) gamma = - gamma;
			p = ( gamma - dp ) + theta;
			q = ( ( gamma - dp ) + gamma ) + dy[0];
			r = p/q;
			stpc = stp[0] + r * ( sty[0] - stp[0] );
			stpf = stpc;
		}
		else if ( stp[0] > stx[0] )
		{
			stpf = stpmax;
		}
		else
		{
			stpf = stpmin;
		}
	}

	/* Update the interval of uncertainty. This update does not
	   depend on the new step or the case analysis above.
	*/

	if ( fp > fx[0] )
	{
		sty[0] = stp[0];
		fy[0] = fp;
		dy[0] = dp;
	}
	else
	{
		if ( sgnd < 0.0 )
		{
			sty[0] = stx[0];
			fy[0] = fx[0];
			dy[0] = dx[0];
		}
		stx[0] = stp[0];
		fx[0] = fp;
		dx[0] = dp;
	}

	/* Compute the new step and safeguard it.*/

	stpf = FMIN ( stpmax , stpf );
	stpf = FMAX ( stpmin , stpf );
	stp[0] = stpf;

	if ( brackt[0] && bound )
	{
		if ( sty[0] > stx[0] )
		{
			stp[0] = FMIN ( stx[0] + 0.66 * ( sty[0] - stx[0] ) , stp[0] );
		}
		else
		{
			stp[0] = FMAX ( stx[0] + 0.66 * ( sty[0] - stx[0] ) , stp[0] );
		}
	}

	return;
}
/******************************************************************************/
/* Minimize a function along a search direction. */
static void mcsrch ( int n , double x[] , double f , double g[] ,
	      double s[] , int is0 , double stp[] , double ftol , double xtol ,
	      int maxfev , int info[] , int nfev[] , double wa[] )
{

	double LBFGS_gtol = 0.9;
	double LBFGS_stpmin = 1e-16;
	double LBFGS_stpmax = 1e16;
	static int infoc[1];
	int j = 0;
	static double dg = 0, dgm = 0, dginit = 0, dgtest = 0;
	static double dgx[1];
	static double dgxm[1];
	static double dgy[1];
        static double dgym[1];
       	static double finit = 0, ftest1 = 0, fm = 0;
	static double fx[1];
	static double fxm[1];
	static double fy[1];
	static double fym[1];
	static double p5 = 0, p66 = 0;
	static double stx[1];
	static double sty[1];
	static double stmin = 0, stmax = 0, width = 0, width1 = 0, xtrapf = 0;
	static int brackt[1];
	static int stage1 = FALSE;

	p5 = 0.5;
	p66 = 0.66;
	xtrapf = 4;

	if ( info[0] != - 1 )
	{
		infoc[0] = 1;
		if ( 	n <= 0 || stp[0] <= 0 || ftol < 0 || 
			LBFGS_gtol < 0 || xtol < 0 || LBFGS_stpmin < 0 || 
			LBFGS_stpmax < LBFGS_stpmin || maxfev <= 0
		   ) 
			return;

		/* 
		 * Compute the initial gradient in the search direction
		 * and check that s is a descent direction.
		 */

		dginit = 0;

		for ( j = 0 ; j < n ; j++ )
		{
			dginit = dginit + g [j] * s [is0+j];
		}

		if ( dginit >= 0 )
		{
			printf(("The search direction is not a descent direction."));
			return;
		}

		brackt[0] = FALSE;
		stage1 = TRUE;
		nfev[0] = 0;
		finit = f;
		dgtest = ftol*dginit;
		width = LBFGS_stpmax - LBFGS_stpmin;
		width1 = width/p5;

		for ( j = 0 ; j < n ; j++ )
		{
			wa [j] = x [j];
		}

		/*
		 The variables stx, fx, dgx contain the values of the step,
		 function, and directional derivative at the best step.
		 The variables sty, fy, dgy contain the value of the step,
		 function, and derivative at the other endpoint of
		 the interval of uncertainty.
		 The variables stp, f, dg contain the values of the step,
		 function, and derivative at the current step.
		 */

		stx[0] = 0;
		fx[0] = finit;
		dgx[0] = dginit;
		sty[0] = 0;
		fy[0] = finit;
		dgy[0] = dginit;
	}

	while ( TRUE )
	{
		if ( info[0] != -1 )
		{
			/*
			 Set the minimum and maximum steps to correspond
			 to the present interval of uncertainty.
			*/

			if ( brackt[0] )
			{
				stmin = FMIN ( stx[0] , sty[0] );
				stmax = FMAX ( stx[0] , sty[0] );
			}
			else
			{
				stmin = stx[0];
				stmax = stp[0] + xtrapf * ( stp[0] - stx[0] );
			}

			/* Force the step to be within the bounds stpmax and stpmin.*/

			stp[0] = FMAX ( stp[0] , LBFGS_stpmin );
			stp[0] = FMIN ( stp[0] , LBFGS_stpmax );

			/* If an unusual termination is to occur then let
			   stp be the lowest point obtained so far.
			 */

			if ( 	( brackt[0] && ( stp[0] <= stmin || stp[0] >= stmax ) ) ||
			       	nfev[0] >= maxfev - 1 || infoc[0] == 0 || 
				( brackt[0] && stmax - stmin <= xtol * stmax )
			   )
				stp[0] = stx[0];

			/* Evaluate the function and gradient at stp
			   and compute the directional derivative.
			   We return to main program to obtain F and G.
			*/

			for ( j = 0 ; j < n ; j++ )
				x [j] = wa [j] + stp[0] * s [is0+j];

			info[0]=-1;
			return;
		}

		info[0]=0;
		nfev[0] = nfev[0] + 1;
		dg = 0;

		for ( j = 0 ; j < n ; j++ )
		{
			dg = dg + g [j] * s [is0+j];
		}

		ftest1 = finit + stp[0]*dgtest;

		/* Test for convergence.*/

		if ( 	( brackt[0] && ( stp[0] <= stmin || stp[0] >= stmax ) ) || infoc[0] == 0)
		       	info[0] = 6;

		if ( stp[0] == LBFGS_stpmax && f <= ftest1 && dg <= dgtest ) 
			info[0] = 5;

		if ( stp[0] == LBFGS_stpmin && ( f > ftest1 || dg >= dgtest ) ) 
			info[0] = 4;

		if ( nfev[0] >= maxfev )
		       	info[0] = 3;

		if ( brackt[0] && stmax - stmin <= xtol * stmax )
			info[0] = 2;

		if ( f <= ftest1 && fabs ( dg ) <= LBFGS_gtol * ( - dginit ) )
			info[0] = 1;

		/* Check for termination.*/

		if ( info[0] != 0 )
			return;

		/* In the first stage we seek a step for which the modified
		   function has a nonpositive value and nonnegative derivative.
		*/

		if ( stage1 && f <= ftest1 && dg >= FMIN ( ftol , LBFGS_gtol ) * dginit )
			stage1 = FALSE;

		/* 
		 * A modified function is used to predict the step only if
		   we have not obtained a step for which the modified
		   function has a nonpositive function value and nonnegative
		   derivative, and if a lower function value has been
		   obtained but the decrease is not sufficient.
		*/

		if ( stage1 && f <= fx[0] && f > ftest1 )
		{
			/* Define the modified function and derivative values.*/

			fm = f - stp[0]*dgtest;
			fxm[0] = fx[0] - stx[0]*dgtest;
			fym[0] = fy[0] - sty[0]*dgtest;
			dgm = dg - dgtest;
			dgxm[0] = dgx[0] - dgtest;
			dgym[0] = dgy[0] - dgtest;

			/* Call cstep to update the interval of uncertainty
			   and to compute the new step.
			*/

			mcstep ( stx , fxm , dgxm , sty , fym , dgym , stp , fm , dgm , 
					brackt , stmin , stmax , infoc );

			/* Reset the function and gradient values for f.*/

			fx[0] = fxm[0] + stx[0]*dgtest;
			fy[0] = fym[0] + sty[0]*dgtest;
			dgx[0] = dgxm[0] + dgtest;
			dgy[0] = dgym[0] + dgtest;
		}
		else
		{
			/* Call mcstep to update the interval of uncertainty
			   and to compute the new step.
			*/

			mcstep ( stx , fx , dgx , sty , fy , dgy , stp , f , dg ,
					brackt , stmin , stmax , infoc );
		}

		/* Force a sufficient decrease in the size of the
		   interval of uncertainty.
		*/

		if ( brackt[0] )
		{
			if ( fabs ( sty[0] - stx[0] ) >= p66 * width1 )
				stp[0] = stx[0] + p5 * ( sty[0] - stx[0] );
			width1 = width;
			width = fabs ( sty[0] - stx[0] );
		}
	}
}
/**************************************************************************/
static void arrayCopy(double* a,double*b,int n)
{
	int i;
	for(i=0;i<n;i++)
		b[i] = a[i];
}
/************************************************************************************************/
/** Compute the sum of a vector times a scalara plus another vector.
  * Adapted from the subroutine <code>daxpy</code> in <code>lbfgs.f</code>.
  * There could well be faster ways to carry out this operation; this
  * code is a straight translation from the Fortran.
  */ 
static void daxpy ( int n , double da , double dx[] , int ix0, int incx , double dy[] , int iy0, int incy )
{
	int i, ix, iy, m, mp1;

	if ( n <= 0 ) return;

	if ( da == 0 ) return;

	if  ( ! ( incx == 1 && incy == 1 ) )
	{
		ix = 1;
		iy = 1;

		if ( incx < 0 ) ix = ( - n + 1 ) * incx + 1;
		if ( incy < 0 ) iy = ( - n + 1 ) * incy + 1;

		for ( i = 0 ; i < n ; i++ )
		{
			dy [iy0+iy] = dy [iy0+iy] + da * dx [ix0+ix];
			ix = ix + incx;
			iy = iy + incy;
		}

		return;
	}

	m = n % 4;
	if ( m != 0 )
	{
		for ( i = 0 ; i < m ; i++ )
			dy [iy0+i] = dy [iy0+i] + da * dx [ix0+i];

		if ( n < 4 ) return;
	}

	mp1 = m + 1;
	for ( i = mp1-1 ; i < n ; i += 4 )
	{
		dy [iy0+i] = dy [iy0+i] + da * dx [ix0+i];
		dy [iy0+i + 1] = dy [iy0+i + 1] + da * dx [ix0+i + 1];
		dy [iy0+i + 2] = dy [iy0+i + 2] + da * dx [ix0+i + 2];
		dy [iy0+i + 3] = dy [iy0+i + 3] + da * dx [ix0+i + 3];
	}
	return;
}

/** Compute the dot product of two vectors.
  * Adapted from the subroutine <code>ddot</code> in <code>lbfgs.f</code>.
  * There could well be faster ways to carry out this operation; this
  * code is a straight translation from the Fortran.
  */ 
static double ddot ( int n, double dx[], int ix0, int incx, double dy[], int iy0, int incy )
{
	double dtemp;
	int i, ix, iy, m, mp1;

	dtemp = 0;

	if ( n <= 0 ) return 0;

	if ( !( incx == 1 && incy == 1 ) )
	{
		ix = 1;
		iy = 1;
		if ( incx < 0 ) ix = ( - n + 1 ) * incx + 1;
		if ( incy < 0 ) iy = ( - n + 1 ) * incy + 1;
		for ( i = 0 ; i < n ; i++ )
		{
			dtemp = dtemp + dx [ix0+ix] * dy [iy0+iy];
			ix = ix + incx;
			iy = iy + incy;
		}
		return dtemp;
	}

	m = n % 5;
	if ( m != 0 )
	{
		for ( i = 0 ; i < m ; i++ )
			dtemp = dtemp + dx [ix0+i] * dy [iy0+i];
		if ( n < 5 ) return dtemp;
	}

	mp1 = m + 1;
	for ( i = mp1-1 ; i < n ; i += 5 )
	{
		dtemp +=  dx [ix0+i] * dy [ iy0+i] 
			+ dx [ix0+i + 1] * dy [iy0+i + 1] 
			+ dx [ix0+i + 2] * dy [iy0+i + 2] 
			+ dx [ix0+i + 3] * dy [iy0+i + 3] 
			+ dx [ix0+i + 4] * dy [iy0+i + 4];
	}

	return dtemp;
}
/**************************************************************************/
static int lbfgs( 
		int n , int m , double x[] , double f , double g[] ,
		int diagco , double diag[] , double eps ,
		double xtol , int maxLines,int iflag[]
	)
{
	int execute_entire_while_loop = FALSE;
	static double gtol = 0.8;
	static double* solution_cache = NULL;
	static double gnorm = 0, stp1 = 0, ftol = 0;
	static double stp[1];
       	static double ys = 0, yy = 0, sq = 0, yr = 0, beta = 0, xnorm = 0;
	static int iter = 0, nfun = 0, point = 0, ispt = 0, iypt = 0, maxfev = 0;
	static int info[1];
	static int bound = 0, npt = 0, cp = 0, i = 0;
	static int nfev[1];
	static int inmc = 0, iycn = 0, iscn = 0;
	static int finish = FALSE;
	static double* w = NULL;
	static int wlength = 0;
	static int cacheLength = 0;


	if ( w == NULL || wlength != n*(2*m+1)+2*m )
	{
		if(w)
			free(w);

		wlength = n*(2*m+1)+2*m;
		w = malloc(wlength*sizeof(double));
	}
	if ( solution_cache == NULL || cacheLength != n )
	{
		if(solution_cache)
			free(solution_cache);

		cacheLength = n;
		solution_cache = malloc(cacheLength*sizeof(double));
	}

	if ( iflag[0] == 0 )
	{
		/* Initialize.*/

		arrayCopy(x,solution_cache,n);

		iter = 0;

		if ( n <= 0 || m <= 0 )
		{
			iflag[0]= -3;
			printf(("Improper input parameters  (n or m are not positive.)") );
		}

		if ( gtol <= 0.0001 )
		{
			printf(
				(
				"lbfgs: gtol is less than or equal to 0.0001."
				"It has been reset to 0.9."
				)
			      );
			gtol= 0.9;
		}

		nfun= 1;
		point= 0;
		finish= FALSE;
		if ( diagco )
		{
			for ( i = 0 ; i < n ; i++ )
			{
				if ( diag [i] <= 0 )
				{
					iflag[0]=-2;
					printf(
						(
						"The %d-th diagonal element of the inverse"
						" hessian approximation is not positive.")
						,i
					      );
				}
			}
		}
		else
		{
			for ( i = 0 ; i < n ; i++)
				diag [i] = 1;
		}
		ispt= n+2*m;
		iypt= ispt+n*m;

		for ( i = 0 ; i < n ; i++ )
			w [ispt + i] = - g [i] * diag [i];

		gnorm = sqrt ( ddot ( n , g , 0, 1 , g , 0, 1 ) );
		stp1= 1/gnorm;
		ftol= 0.0001; 
		maxfev= maxLines;

		execute_entire_while_loop = TRUE;
	}

	while ( TRUE )
	{
		if ( execute_entire_while_loop )
		{
			iter= iter+1;
			info[0]=0;
			bound=iter-1;
			if ( iter != 1 )
			{
				if ( iter > m ) bound = m;
				ys = ddot ( n , w , iypt + npt , 1 , w , ispt + npt , 1 );
				if ( ! diagco )
				{
					yy = ddot( 
						n , w , iypt + npt , 1 , w , iypt + npt , 1
						);
					for ( i = 0 ; i < n ; i++ )
						diag [i] = ys / yy;
				}
				else
				{
					iflag[0]=2;
					return 1;
				}
			}
		}

		if ( execute_entire_while_loop || iflag[0] == 2 )
		{
			if ( iter != 1 )
			{
				if ( diagco )
				{
					for ( i = 0 ; i < n ; i++ )
					{
						if ( diag [i] <= 0 )
						{
							iflag[0]=-2;
							printf(
							(
							"The %d-th diagonal element"
							" of the inverse hessian approximation"
							" is not positive.")
							, i);
						}
					}
				}
				cp= point;
				if ( point == 0 ) cp = m;
				w [ n + cp -1] = 1 / ys;

				for ( i = 0 ; i < n ; i++ )
					w [i] = - g [i];

				cp= point;

				for ( i = 0 ; i < bound ; i++ )
				{
					cp=cp-1;
					if ( cp == - 1 ) cp = m - 1;
					sq = ddot ( n , w , ispt + cp * n , 1 , w , 0 , 1 );
					inmc=n+m+cp+1;
					iycn=iypt+cp*n;
					w [ inmc -1] = w [ n + cp + 1 -1] * sq;
					daxpy ( n , - w [ inmc -1] , w , iycn , 1 , w , 0 , 1 );
				}

				for ( i = 0 ; i < n ; i++ )
					w [i] = diag [i] * w [i];

				for ( i = 0 ; i < bound ; i++ )
				{
					yr = ddot ( n , w , iypt + cp * n , 1 , w , 0 , 1 );
					beta = w [ n + cp + 1 -1] * yr;
					inmc=n+m+cp+1;
					beta = w [ inmc -1] - beta;
					iscn=ispt+cp*n;
					daxpy ( n , beta , w , iscn , 1 , w , 0 , 1 );
					cp=cp+1;
					if ( cp == m ) cp = 0;
				}

				for ( i = 0 ; i < n ; i++ )
					w [ispt + point * n + i] = w [i];
			}

			nfev[0]=0;
			stp[0]=1;
			if ( iter == 1 ) stp[0] = stp1;

			for ( i = 0 ; i < n ; i++ )
				w [i] = g [i];
		}

		mcsrch(
			n , x , f , g , w , ispt + point * n , stp ,
			ftol , xtol ,maxfev , info , nfev , diag
		      );

		if ( info[0] == - 1 )
		{
			iflag[0]=1;
			return 1;
		}

		if ( info[0] != 1 )
		{
			iflag[0]=-1;
			printf(
			(
			"Line search failed. See documentation of routine mcsrch.\n"
			" Error return of line search: info = %d Possible causes:\n"
			" function or gradient are incorrect, or incorrect tolerances.\n"
			)
			,info[0]);
			return 0;
		}

		nfun= nfun + nfev[0];
		npt=point*n;

		for ( i = 0; i < n ; i++ )
		{
			w [ispt + npt + i] = stp[0] * w [ispt + npt + i];
			w [iypt + npt + i] = g [i] - w [i];
		}

		point=point+1;
		if ( point == m ) point = 0;

		gnorm = sqrt ( ddot ( n , g , 0 , 1 , g , 0 , 1 ) );
		xnorm = sqrt ( ddot ( n , x , 0 , 1 , x , 0 , 1 ) );
		xnorm = FMAX ( 1.0 , xnorm );

		if ( gnorm / xnorm <= eps ) finish = TRUE;

		arrayCopy( x,solution_cache,n);

		if ( finish )
		{
			iflag[0]=0;
			return 0;
		}

		/* from now on, execute whole loop*/
		execute_entire_while_loop = TRUE;
	}
}
/*****************************************************************************************************************************************************/
void setQNOptions(FILE* file, QuasiNewton* quasiNewton)
{
	quasiNewton->maxIterations = 100;
	quasiNewton->updateFrequency = 1;
	quasiNewton->epsilon  = 0.001;
	quasiNewton->tolerence = 1e-16;  
	quasiNewton->maxLines =  25;
	quasiNewton->forceField = NULL;
	readOneInt(file,"quasiNewtonMaxIterations",&quasiNewton->maxIterations);
	readOneInt(file,"quasiNewtonUpdateFrequency",&quasiNewton->updateFrequency);
	readOneReal(file,"quasiNewtonEpsilon",&quasiNewton->epsilon);
	readOneReal(file,"quasiNewtonTolerence",&quasiNewton->tolerence);
	readOneInt(file,"quasiNewtonMaxLines",&quasiNewton->maxLines);
}
File: ./cchemilib/src/MolecularMechanics/MolecularMechanicsDlg.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* MolecularMechanicsDlg.c */
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#ifdef ENABLE_MPI
#include <mpi.h>
#endif

#include "../Utils/Utils.h"
#include "../Utils/AtomsProp.h"
#include "../Utils/Constants.h"
#include "../Utils/Types.h"
#include "../Molecule/Molecule.h"
#include "../MolecularMechanics/ForceField.h"
#include "../MolecularMechanics/MolecularMechanics.h"
#include "../MolecularMechanics/ConjugateGradient.h"
#include "../MolecularMechanics/SteepestDescent.h"
#include "../MolecularMechanics/QuasiNewton.h"
#include "../MolecularMechanics/MolecularDynamics.h"

typedef enum
{
	MMBOND = 0,
	MMBEND = 1,
	MMTORSION = 2,
	MMIMPROPER = 3,
	MMNONBOND = 4,
	MMHBOND  =5 ,
	MMCOULOMB = 6,
	PWCOULOMB = 7,
	PWVANDERWALS = 8
} MMOptions;

typedef enum
{
	GRADQUASINEWTON  = 0,
	GRADSTEEPEST  = 1,
	GRADCONJUGATE = 2,
	GRADHESTENES  = 3,
	GRADFLETCHER  = 4,
	GRADPOLAK     = 5,
	GRADWOLF      = 6
} GradientOptions;

typedef enum
{
	GRADMAXITERATIONS  = 0,
	GRADEPSILON        = 1,
	GRADMAXLINES       = 2,
	GRADINITIALSTEP    = 3,
	GRADFREQUENCY      = 4
} GradientEntrys;

typedef enum
{
	TOLE = 0,
	TOLD = 1
} TOLptions;

#define NGRADENTRYS 5
#define NGRADOPTIONS 7
#define NOPTIONS1 4
#define NOPTIONS2 3
#define NOPTIONS3 2
#define NINTEGOPTIONS 3
#define NTHERMOPTIONS 3
#define NENTRYTOL 2
#define NCONSTRAINTS 3

/*****************************************************************************/
static void checkWallCorrection(FILE* file, ForceField* forceField)
{
	char t[BSIZE];
	char* pos;
	rewind(file);
	forceField->options.addWallCorrection=FALSE;
	while(!feof(file))
  	{
    		if(!fgets(t,BSIZE, file)) break;
		deleteFirstSpaces(t);
		if(t[0]=='#') continue;
		uppercase(t);
		pos = strstr(t,"WALL");
		if(pos && strstr(t,"="))
		{ 
			double E0;
			double rho;
			int nc;
			int n =0;
			pos = strstr(t,"=") + 1;
			n =sscanf(pos,"%lf %lf %d",&E0,&rho,&nc);
			//printf("t=%s\n",t);
			//printf("pos=%s\n",pos);
			if(n==3 && nc%2==0) { forceField->options.addWallCorrection=TRUE; break;}
			else  { 
				fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
				fprintf(stderr,"Error during the reading of Wall parameters\n");
				fprintf(stderr,"You must give E0(au), rho (cutoff radius in angstrom) and nc(even integer)\n");
				fprintf(stderr,"Example : Wall=1000.0 10.0 6\n");
				fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
				exit(1);
			}
			break;
		}
	}
}
/*****************************************************************************/
static void printEnergyAndGradient(ForceField* forceField)
{
	char* str;
	double gradientNorm = 0;
	int i,j;

	//forceField->klass->calculateEnergy(forceField);
	forceField->klass->calculateGradient(forceField);

	gradientNorm = 0;
	for (  i = 0; i < forceField->molecule.nAtoms; i++ )
		for(j=0;j<3;j++)
			gradientNorm += 
			forceField->molecule.atoms[i].gradient[j]
			*forceField->molecule.atoms[i].gradient[j]; 

	str = strdup_printf(("Gradient Norm  = %0.14f energy = %0.14f(kcal/mol)\n"),
		sqrt(gradientNorm),forceField->molecule.potentialEnergy); 

	printf("%s",str);
	free(str);
	forceField->klass->printEnergies(forceField);
}
/*********************************************************************************/
static void getMultiplicityName(int multiplicity, char* buffer)
{
	if(multiplicity==1) sprintf(buffer,"Singlet");
	else if(multiplicity==2) sprintf(buffer,"Doublet");
	else if(multiplicity==3) sprintf(buffer,"Triplet");
	else if(multiplicity==4) sprintf(buffer,"Quartet");
	else if(multiplicity==5) sprintf(buffer,"Quintet");
	else if(multiplicity==6) sprintf(buffer,"Sextet");
	else sprintf(buffer,"UNKNOWN");
}
/*****************************************************************************/
static boolean createCChemIFiles(int numberOfGeometries, ForceField** geometries, double* energies, char* fileNamePrefix, char* keyWords,char* cchemiCommand)
{
	FILE* file = NULL;
	FILE* fileSH = NULL;
	int i;
	int j;
	int nG = 0;
	char* fileName = NULL;
	char* fileNameSH = NULL;

	if(numberOfGeometries<1) return FALSE;
	if(!geometries) return FALSE;
	if(!energies) return FALSE;
	for(i=0;i<numberOfGeometries;i++) if(geometries[i]) nG++;
	if(nG<1) return FALSE;
	fileNameSH = strdup_printf("%scchemi.sh",fileNamePrefix);
#ifndef OS_WIN32
	fileNameSH = strdup_printf("%scchemi.sh",fileNamePrefix);
#else
	fileNameSH = strdup_printf("%sCChemI.bat",fileNamePrefix);
#endif
 	fileSH = fopen(fileNameSH, "w");
	if(!fileSH) return FALSE;


	for(i=0;i<numberOfGeometries;i++)
	{
		if(!geometries[i]) continue;
 		if(fileName) free(fileName);
		fileName = strdup_printf("%sCCHEMI_%d.inp",fileNamePrefix,i+1);
 		file = fopen(fileName, "w");
		if(!file) return FALSE;
		fprintf(file,"# RunType = Energy, Optimization, MD, MDConfo, REMDConfo\n");
		fprintf(file,"RunType=Optimization\n");
		fprintf(file,"OptimizerType=QuasiNewton\n");
		fprintf(file,"Model=Mopac\n");
		fprintf(file,"SEKeys=AM1\n");
		fprintf(file,"mopacCommand=/home/allouche/Softwares/MOPAC2009/MOPAC2009.exe\n");
		fprintf(file,"orcaCommand=orca\n");
		fprintf(file,"fireflyCommand=firefly\n");
		fprintf(file,"gaussianCommand=g03\n");
		fprintf(file,"#gaussianKeywordsPost=B3LYP/aug-cc-pvdz\n");
		fprintf(file,"#QuasiNewton\n");
		fprintf(file,"useQuasiNewton = TRUE\n");
		fprintf(file,"Geometry\n");
		fprintf(file,"%d %d %d\n",geometries[i]->molecule.nAtoms, geometries[i]->molecule.totalCharge, geometries[i]->molecule.spinMultiplicity);
		for(j=0;j<geometries[i]->molecule.nAtoms;j++)
		{
			int nc = 0;
			int k;
			for(k=0;k<geometries[i]->molecule.nAtoms;k++) 
				if(geometries[i]->molecule.atoms[j].typeConnections&&geometries[i]->molecule.atoms[j].typeConnections[k]>0) nc++;

			fprintf(file," %s %s %s %s %d %f %d %d %f %f %f %d ", 
				geometries[i]->molecule.atoms[j].prop.symbol,
				geometries[i]->molecule.atoms[j].mmType,
				geometries[i]->molecule.atoms[j].pdbType,
				geometries[i]->molecule.atoms[j].residueName,
				geometries[i]->molecule.atoms[j].residueNumber,
				geometries[i]->molecule.atoms[j].charge,
				geometries[i]->molecule.atoms[j].layer,
				geometries[i]->molecule.atoms[j].variable,
				geometries[i]->molecule.atoms[j].coordinates[0],
				geometries[i]->molecule.atoms[j].coordinates[1],
				geometries[i]->molecule.atoms[j].coordinates[2],
				nc
				);
			for(k=0;k< geometries[i]->molecule.nAtoms;k++) 
			{
		 		int nk =  geometries[i]->molecule.atoms[k].N-1;
				if(geometries[i]->molecule.atoms[j].typeConnections && geometries[i]->molecule.atoms[j].typeConnections[nk]>0) 
					fprintf(file," %d %d", nk+1, geometries[i]->molecule.atoms[j].typeConnections[nk]);
			}
			fprintf(file,"\n");
		}
		fprintf(file,"Velocities\n");
		for(j=0;j<geometries[i]->molecule.nAtoms;j++)
		{
			fprintf(file,"%f %f %f", 
				geometries[i]->molecule.atoms[j].velocity[0],
				geometries[i]->molecule.atoms[j].velocity[1],
				geometries[i]->molecule.atoms[j].velocity[2]
				);
			fprintf(file,"\n");
		}
		fprintf(file,"Masses\n");
		for(j=0;j<geometries[i]->molecule.nAtoms;j++)
		{
			fprintf(file,"%f", geometries[i]->molecule.atoms[j].mass);
			fprintf(file,"\n");
		}
		fclose(file);
		fprintf(fileSH,"%s %s\n",cchemiCommand,fileName);
	}
	fclose(fileSH);
#ifndef OS_WIN32
	{
		char buffer[1024];
  		sprintf(buffer,"chmod u+x %s",fileNameSH);
		system(buffer);
	}
#endif
 	if(fileName) free(fileName);
 	if(fileNameSH) free(fileNameSH);
	return TRUE;

}
/*****************************************************************************/
static boolean createMopacFiles(int numberOfGeometries, ForceField** geometries, double* energies, char* fileNamePrefix, char* keyWords, char* mopacCommand)
{
	FILE* file = NULL;
	FILE* fileSH = NULL;
	int i;
	int j;
	int nG = 0;
	char* fileName = NULL;
	char* fileNameSH = NULL;
	char multiplicityStr[100];
#ifdef OS_WIN32
	char c='%';
#endif

	if(numberOfGeometries<1) return FALSE;
	if(!geometries) return FALSE;
	if(!energies) return FALSE;
	for(i=0;i<numberOfGeometries;i++) if(geometries[i]) nG++;
	if(nG<1) return FALSE;
#ifndef OS_WIN32
	fileNameSH = strdup_printf("%sMopac.sh",fileNamePrefix);
#else
	fileNameSH = strdup_printf("%sMopac.bat",fileNamePrefix);
#endif
 	fileSH = fopen(fileNameSH, "w");
	if(!fileSH) return FALSE;
#ifdef OS_WIN32
	fprintf(fileSH,"set PATH=%cPATH%c;\"%s\"\n",c,c,mopacDirectory);
#endif


	for(i=0;i<numberOfGeometries;i++)
	{
		getMultiplicityName( geometries[i]->molecule.spinMultiplicity, multiplicityStr);
		if(!geometries[i]) continue;
 		if(fileName) free(fileName);
		fileName = strdup_printf("%s_%d.mop",fileNamePrefix,i+1);
 		file = fopen(fileName, "w");
		if(!file) return FALSE;
		fprintf(file,"* ===============================\n");
		fprintf(file,"* Input file for Mopac\n");
		fprintf(file,"* MM/SE Energy(kCal/mol) =%f\n",energies[i]);
		fprintf(file,"* ===============================\n");
		fprintf(file,"%s CHARGE=%d %s\n",keyWords, geometries[i]->molecule.totalCharge,multiplicityStr);
		fprintf(file,"\n");
		fprintf(file,"Mopac file generated by CChemI\n");

		for(j=0;j<geometries[i]->molecule.nAtoms;j++)
		{
		fprintf(file," %s %f %d %f %d %f %d\n", 
				geometries[i]->molecule.atoms[j].prop.symbol,
				geometries[i]->molecule.atoms[j].coordinates[0],
				1,
				geometries[i]->molecule.atoms[j].coordinates[1],
				1,
				geometries[i]->molecule.atoms[j].coordinates[2],
				1
				);
		}
		fclose(file);
		fprintf(fileSH,"%s %s\n",mopacCommand,fileName);
	}
	fclose(fileSH);
#ifndef OS_WIN32
	{
		char buffer[1024];
  		sprintf(buffer,"chmod u+x %s",fileNameSH);
		system(buffer);
	}
#endif
 	if(fileName) free(fileName);
 	if(fileNameSH) free(fileNameSH);
	return TRUE;

}
/*****************************************************************************/
static boolean createGaussianFiles(int numberOfGeometries, ForceField** geometries, double* energies, char* fileNamePrefix, char* keyWords,char* gaussianCommand)
{
	FILE* file = NULL;
	FILE* fileSH = NULL;
	int i;
	int j;
	int nG = 0;
	char* fileName = NULL;
	char* fileNameSH = NULL;

	if(numberOfGeometries<1) return FALSE;
	if(!geometries) return FALSE;
	if(!energies) return FALSE;
	for(i=0;i<numberOfGeometries;i++) if(geometries[i]) nG++;
	if(nG<1) return FALSE;
	fileNameSH = strdup_printf("%sGauss.sh",fileNamePrefix);
#ifndef OS_WIN32
	fileNameSH = strdup_printf("%sGauss.sh",fileNamePrefix);
#else
	fileNameSH = strdup_printf("%sGauss.bat",fileNamePrefix);
#endif
 	fileSH = fopen(fileNameSH, "w");
	if(!fileSH) return FALSE;


	for(i=0;i<numberOfGeometries;i++)
	{
		if(!geometries[i]) continue;
 		if(fileName) free(fileName);
		fileName = strdup_printf("%s_%d.com",fileNamePrefix,i+1);
 		file = fopen(fileName, "w");
		if(!file) return FALSE;
		fprintf(file,"#P %s\n",keyWords);
		fprintf(file,"#  Units(Ang,Deg)\n");
		fprintf(file,"\n");
		fprintf(file,"File generated by CChemI\n");
		fprintf(file,"MM/SE Energy(kCal/mol) = %f\n",energies[i]);
		fprintf(file,"\n");
		fprintf(file,"%d %d\n", geometries[i]->molecule.totalCharge, geometries[i]->molecule.spinMultiplicity);
		for(j=0;j<geometries[i]->molecule.nAtoms;j++)
		{
		fprintf(file,"%s %f %f %f\n", 
				geometries[i]->molecule.atoms[j].prop.symbol,
				geometries[i]->molecule.atoms[j].coordinates[0],
				geometries[i]->molecule.atoms[j].coordinates[1],
				geometries[i]->molecule.atoms[j].coordinates[2]
				);
		}
		fprintf(file,"\n");
		fclose(file);
		fprintf(fileSH,"%s %s\n",gaussianCommand,fileName);
	}
	fclose(fileSH);
#ifndef OS_WIN32
	{
		char buffer[1024];
  		sprintf(buffer,"chmod u+x %s",fileNameSH);
		system(buffer);
	}
#endif
 	if(fileName) free(fileName);
 	if(fileNameSH) free(fileNameSH);
	return TRUE;

}
/*****************************************************************************/
static boolean createFireFlyFiles(int numberOfGeometries, ForceField** geometries, double* energies, char* fileNamePrefix, char* keyWords, char* fireflyCommand)
{
	FILE* file = NULL;
	FILE* fileSH = NULL;
	int i;
	int j;
	int nG = 0;
	char* fileName = NULL;
	char* fileNameSH = NULL;
	char buffer[1024];
#ifdef OS_WIN32
	char c='%';
#endif

	if(numberOfGeometries<1) return FALSE;
	if(!geometries) return FALSE;
	if(!energies) return FALSE;
	for(i=0;i<numberOfGeometries;i++) if(geometries[i]) nG++;
	if(nG<1) return FALSE;
#ifndef OS_WIN32
	fileNameSH = strdup_printf("%sPCGam.sh",fileNamePrefix);
#else
	fileNameSH = strdup_printf("%sPCGam.bat",fileNamePrefix);
#endif
 	fileSH = fopen(fileNameSH, "w");
	if(!fileSH) return FALSE;
#ifdef OS_WIN32
	fprintf(fileSH,"set PATH=%cPATH%c;\"%s\"\n",c,c,fireflyDirectory);
#endif


	uppercase(keyWords);
	for(i=0;i<numberOfGeometries;i++)
	{
		if(!geometries[i]) continue;
 		if(fileName) free(fileName);
		fileName = strdup_printf("%sFF_%d.inp",fileNamePrefix,i+1);
 		file = fopen(fileName, "w");
		if(!file) return FALSE;
		fprintf(file,"! ======================================================\n");
		fprintf(file,"!  Input file for FireFly\n"); 
		fprintf(file,"! ======================================================\n");
		if(strstr(keyWords,"RUNTYP"))
		{
			sscanf(strstr(keyWords,"RUNTYP"),"%s",buffer);
			fprintf(file," $CONTRL %s $END\n",buffer);
		}
		if(strstr(keyWords,"SCFTYP"))
		{
			sscanf(strstr(keyWords,"SCFTYP"),"%s",buffer);
			fprintf(file," $CONTRL %s $END\n",buffer);
		}
		else
		{
			if(geometries[i]->molecule.spinMultiplicity==1)
				fprintf(file," $CONTRL SCFTYP=RHF $END\n");
			else
				fprintf(file," $CONTRL SCFTYP=UHF $END\n");
		}

		fprintf(file," $CONTRL ICHARG=%d MULT=%d $END\n", geometries[i]->molecule.totalCharge, geometries[i]->molecule.spinMultiplicity);
		if(strstr(keyWords,"GBASIS"))
		{
			sscanf(strstr(keyWords,"GBASIS"),"%s",buffer);
			fprintf(file," $BASIS %s $END\n",buffer);
		}
		fprintf(file," $DATA\n");
		fprintf(file,"Molecule specification\n");
		fprintf(file,"C1\n");
		for(j=0;j<geometries[i]->molecule.nAtoms;j++)
		{
			char* symbol = geometries[i]->molecule.atoms[j].prop.symbol;
			SAtomsProp prop = propAtomGet(symbol);
			fprintf(file,"%s %f %f %f %f\n", 
				symbol,
				(double)prop.atomicNumber,
				geometries[i]->molecule.atoms[j].coordinates[0],
				geometries[i]->molecule.atoms[j].coordinates[1],
				geometries[i]->molecule.atoms[j].coordinates[2]
				);
		}
		fprintf(file," $END\n");
		fclose(file);

#ifndef OS_WIN32
		if(!strcmp(fireflyCommand,"pcgamess") || !strcmp(fireflyCommand,"nohup pcgamess")||
		!strcmp(fireflyCommand,"firefly") || !strcmp(fireflyCommand,"nohup firefly"))
		{
			fprintf(fileSH,"mkdir %stmp%d\n",fileNamePrefix,i+1);
			fprintf(fileSH,"cd %stmp%d\n",fileNamePrefix,i+1);
			fprintf(fileSH,"cp %s input\n",fileName);
			fprintf(fileSH,"%s -p -o %sFF_%d.log\n",fireflyCommand,fileNamePrefix,i+1);
			fprintf(fileSH,"cd ..\n");
			fprintf(fileSH,"mv PUNCH  %sFF_%d.pun\n",fileNamePrefix,i+1);
			fprintf(fileSH,"/bin/rm -r  %stmp%d\n",fileNamePrefix,i+1);
		}
		else
			fprintf(fileSH,"%s %s",fireflyCommand,fileName);
#else
	 	if(!strcmp(fireflyCommand,"pcgamess") ||
	 	!strcmp(fireflyCommand,"firefly") )
		{
         		fprintf(fileSH,"mkdir %stmp%d\n",fileNamePrefix,i+1);
			addUnitDisk(fileSH, fileNamePrefix);
	 		fprintf(fileSH,"cd %stmp%d\n",fileNamePrefix,i+1);
         		fprintf(fileSH,"copy %s input\n",fileName);
         		fprintf(fileSH,"%s -p -o %sFF_%d.log\n",fireflyCommand,fileNamePrefix,i+1);
	 		fprintf(fileSH,"cd ..\n");
         		fprintf(fileSH,"move PUNCH  %sFF_%d.pun\n",fileNamePrefix,i+1);
         		fprintf(fileSH,"del /Q  %stmp%d\n",fileNamePrefix,i+1);
         		fprintf(fileSH,"rmdir  %stmp%d\n",fileNamePrefix,i+1);
		}
		else
			fprintf(fileSH,"%s %s",fireflyCommand,fileName);
#endif
	}
	fclose(fileSH);
#ifndef OS_WIN32
	{
		char buffer[1024];
  		sprintf(buffer,"chmod u+x %s",fileNameSH);
		system(buffer);
	}
#endif
 	if(fileName) free(fileName);
 	if(fileNameSH) free(fileNameSH);
	return TRUE;

}
/*****************************************************************************/
static boolean createOrcaFiles(int numberOfGeometries, ForceField** geometries, double* energies, char* fileNamePrefix, char* keyWords,char* orcaCommand)
{
	FILE* file = NULL;
	FILE* fileSH = NULL;
	int i,j;
	int nG = 0;
	int nV = 0;
	char* fileName = NULL;
	char* fileOut = NULL;
	char* fileNameSH = NULL;
	Molecule* mol = NULL;

	if(numberOfGeometries<1) return FALSE;
	if(!geometries) return FALSE;
	if(!energies) return FALSE;
	for(i=0;i<numberOfGeometries;i++) if(geometries[i]) nG++;
	if(nG<1) return FALSE;
	fileNameSH = strdup_printf("%sOrca.sh",fileNamePrefix);
#ifndef OS_WIN32
	fileNameSH = strdup_printf("%sOrca.sh",fileNamePrefix);
#else
	fileNameSH = strdup_printf("%sOrca.bat",fileNamePrefix);
#endif
 	fileSH = fopen(fileNameSH, "w");
	if(!fileSH) return FALSE;


	for(j=0;j<numberOfGeometries;j++)
	{
		if(!geometries[j]) continue;
 		if(fileName) free(fileName);
 		if(fileOut) free(fileOut);
		fileOut = strdup_printf("%sORCA_%d.out",fileNamePrefix,j+1);
		fileName = strdup_printf("%sORCA_%d.inp",fileNamePrefix,j+1);
 		file = fopen(fileName, "w");
		if(!file) return FALSE;
		fprintf(file,"! %s\n",keyWords);
		mol = &geometries[j]->molecule;
		fprintf(file,"* xyz %d   %d\n",mol->totalCharge,mol->spinMultiplicity);
		nV = 0;
      		for (i=0;i<mol->nAtoms;i++)
		{
			char X[100];
			char Y[100];
			char Z[100];
			sprintf(X,"%20.14f",mol->atoms[i].coordinates[0]);
			sprintf(Y,"%20.14f",mol->atoms[i].coordinates[1]);
			sprintf(Z,"%20.14f",mol->atoms[i].coordinates[2]);

			fprintf(file," %s  %s %s %s\n",mol->atoms[i].prop.symbol, X,Y,Z);
			if(mol->atoms[i].variable) nV+=3;
		}
		fprintf(file,"*\n");
		if(nV>0&&nV!=3*mol->nAtoms) 
		{
			fprintf(file,"%cgeom Constraints\n",'%');
      			for (i=0;i<mol->nAtoms;i++)
			{
				if(mol->atoms[i].variable)
				{
					fprintf(file,"  {C %d C}\n",i);
				}
			}
			fprintf(file," end #Constraints\n");
			fprintf(file," invertConstraints true\n");
			fprintf(file," end #geom\n");
		}
		fprintf(file,"\n");
		fclose(file);
		fprintf(fileSH,"%s %s > %s\n",orcaCommand,fileName, fileOut);
	}
	fclose(fileSH);
#ifndef OS_WIN32
	{
		char buffer[1024];
  		sprintf(buffer,"chmod u+x %s",fileNameSH);
		system(buffer);
	}
#endif
 	if(fileName) free(fileName);
 	if(fileOut) free(fileOut);
 	if(fileNameSH) free(fileNameSH);
	return TRUE;
}
/*****************************************************************************/
static boolean createConfoGabeditGeometries(int numberOfGeometries, ForceField** geometries, double* energies, char* fileNamePrefix)
{
	FILE* file = NULL;
	int i;
	int j;
	int nG = 0;
	int k;
	int form = 1;
	char* fileName = NULL;

	if(numberOfGeometries<1) return FALSE;
	if(!geometries) return FALSE;
	if(!energies) return FALSE;
	for(i=0;i<numberOfGeometries;i++) if(geometries[i]) nG++;
	if(nG<1) return FALSE;

	k = -1;
	for(i=0;i<numberOfGeometries;i++)
	{
		if(!geometries[i]) continue;

 		if(fileName) free(fileName);
		fileName = strdup_printf("%s_%d.gab",fileNamePrefix,i+1);
 		file = fopen(fileName, "w");
		if(!file) continue;
		fprintf(file,"[Gabedit Format]\n");
		fprintf(file,"\n");
		fprintf(file,"[GEOMS] %d\n",form);
		fprintf(file,"%d 2\n",nG);
		fprintf(file,"energy kcal/mol 1\n");
		fprintf(file,"deltaE K 1\n");
		fprintf(file,"Dipole Debye 1\n");

		geometries[i]->molecule.klass->computeDipole(&geometries[i]->molecule);
		if(k<0) k = i;
		fprintf(file,"%f\n",energies[i]);
		if(k>=0) fprintf(file,"%f\n",(energies[i]-energies[k])*503.21892494);
		else fprintf(file,"0\n");
		fprintf(file,"%0.14f %0.14f %0.14f\n",geometries[i]->molecule.dipole[0],geometries[i]->molecule.dipole[1],geometries[i]->molecule.dipole[2]);
		fprintf(file,"%d %d %d\n",geometries[i]->molecule.nAtoms, geometries[i]->molecule.totalCharge, geometries[i]->molecule.spinMultiplicity);
		for(j=0;j<geometries[i]->molecule.nAtoms;j++)
		{
			int nc = 0;
			int k;
			for(k=0;k<geometries[i]->molecule.nAtoms;k++) 
				if(geometries[i]->molecule.atoms[j].typeConnections&&geometries[i]->molecule.atoms[j].typeConnections[k]>0) nc++;

			fprintf(file," %s %s %s %s %d %0.6f %d %d %0.8f %0.8f %0.8f %d ", 
				geometries[i]->molecule.atoms[j].prop.symbol,
				geometries[i]->molecule.atoms[j].mmType,
				geometries[i]->molecule.atoms[j].pdbType,
				geometries[i]->molecule.atoms[j].residueName,
				geometries[i]->molecule.atoms[j].residueNumber,
				geometries[i]->molecule.atoms[j].charge,
				geometries[i]->molecule.atoms[j].layer,
				geometries[i]->molecule.atoms[j].variable,
				geometries[i]->molecule.atoms[j].coordinates[0],
				geometries[i]->molecule.atoms[j].coordinates[1],
				geometries[i]->molecule.atoms[j].coordinates[2],
				nc
				);
			for(k=0;k< geometries[i]->molecule.nAtoms;k++) 
			{
		 		int nk =  geometries[i]->molecule.atoms[k].N-1;
				if(geometries[i]->molecule.atoms[j].typeConnections && geometries[i]->molecule.atoms[j].typeConnections[nk]>0) 
					fprintf(file," %d %d", nk+1, geometries[i]->molecule.atoms[j].typeConnections[nk]);
			}
			fprintf(file,"\n");
		}
		fclose(file);
	}
	return TRUE;
}
/*****************************************************************************/
static boolean saveConfoGeometries(int numberOfGeometries, ForceField** geometries, double* energies, char* fileNameGeom)
{
	FILE* file = NULL;
	int i;
	int j;
	int nG = 0;
	int k;
	int form = 1;
	char* fileNamePrefix = getSuffixNameFile(fileNameGeom);

	if(numberOfGeometries<1) return FALSE;
	if(!geometries) return FALSE;
	if(!energies) return FALSE;
	for(i=0;i<numberOfGeometries;i++) if(geometries[i]) nG++;
	if(nG<1) return FALSE;

 	file = fopen(fileNameGeom, "w");

	if(!file) return FALSE;

	fprintf(file,"[Gabedit Format]\n");
	fprintf(file,"[GEOCONV]\n");
	fprintf(file,"energy\n");
	for(i=0;i<numberOfGeometries;i++)
		if(geometries[i]) fprintf(file,"%f\n",energies[i]);
	fprintf(file,"max-force\n");
	for(i=0;i<numberOfGeometries;i++)
		if(geometries[i]) fprintf(file,"0.0\n");
	fprintf(file,"rms-force\n");
	for(i=0;i<numberOfGeometries;i++)
		if(geometries[i]) fprintf(file,"0.0\n");

	fprintf(file,"\n");
	fprintf(file,"[GEOMETRIES]\n");
	for(i=0;i<numberOfGeometries;i++)
	{
		if(!geometries[i]) continue;
		fprintf(file,"%d\n",geometries[i]->molecule.nAtoms);
		fprintf(file,"\n");
		for(j=0;j<geometries[i]->molecule.nAtoms;j++)
		fprintf(file," %s %0.8f %0.8f %0.8f\n", 
				geometries[i]->molecule.atoms[j].prop.symbol,
				geometries[i]->molecule.atoms[j].coordinates[0],
				geometries[i]->molecule.atoms[j].coordinates[1],
				geometries[i]->molecule.atoms[j].coordinates[2]
				);
	}
	fprintf(file,"\n");
	fprintf(file,"[GEOMS] %d\n",form);
	fprintf(file,"%d 2\n",nG);
	fprintf(file,"energy kcal/mol 1\n");
	fprintf(file,"deltaE K 1\n");
	fprintf(file,"Dipole Debye 1\n");
	k = -1;
	for(i=0;i<numberOfGeometries;i++)
	{
		if(!geometries[i]) continue;
		geometries[i]->molecule.klass->computeDipole(&geometries[i]->molecule);
		if(k<0) k = i;
		fprintf(file,"%f\n",energies[i]);
		if(k>=0) fprintf(file,"%f\n",(energies[i]-energies[k])*503.21892494);
		else fprintf(file,"0\n");
		fprintf(file,"%0.14f %0.14f %0.14f\n",geometries[i]->molecule.dipole[0],geometries[i]->molecule.dipole[1],geometries[i]->molecule.dipole[2]);
		fprintf(file,"%d %d %d\n",geometries[i]->molecule.nAtoms, geometries[i]->molecule.totalCharge, geometries[i]->molecule.spinMultiplicity);
		for(j=0;j<geometries[i]->molecule.nAtoms;j++)
		{
			int nc = 0;
			int k;
			for(k=0;k<geometries[i]->molecule.nAtoms;k++) 
				if(geometries[i]->molecule.atoms[j].typeConnections&&geometries[i]->molecule.atoms[j].typeConnections[k]>0) nc++;

			fprintf(file," %s %s %s %s %d %0.6f %d %d %0.8f %0.8f %0.8f %d ", 
				geometries[i]->molecule.atoms[j].prop.symbol,
				geometries[i]->molecule.atoms[j].mmType,
				geometries[i]->molecule.atoms[j].pdbType,
				geometries[i]->molecule.atoms[j].residueName,
				geometries[i]->molecule.atoms[j].residueNumber,
				geometries[i]->molecule.atoms[j].charge,
				geometries[i]->molecule.atoms[j].layer,
				geometries[i]->molecule.atoms[j].variable,
				geometries[i]->molecule.atoms[j].coordinates[0],
				geometries[i]->molecule.atoms[j].coordinates[1],
				geometries[i]->molecule.atoms[j].coordinates[2],
				nc
				);
			for(k=0;k< geometries[i]->molecule.nAtoms;k++) 
			{
		 		int nk =  geometries[i]->molecule.atoms[k].N-1;
				if(geometries[i]->molecule.atoms[j].typeConnections && geometries[i]->molecule.atoms[j].typeConnections[nk]>0) 
					fprintf(file," %d %d", nk+1, geometries[i]->molecule.atoms[j].typeConnections[nk]);
			}
			fprintf(file,"\n");
		}
	}
	fclose(file);
	createConfoGabeditGeometries(numberOfGeometries, geometries, energies, fileNamePrefix);
	return TRUE;

}
/*****************************************************************************/
static boolean getEnergyMopac(char* fileNameOut, double* energy)
{
	FILE* file = NULL;
	char buffer[1024];
	char* pdest = NULL;

 	file = fopen(fileNameOut, "r");
	if(!file) return FALSE;
	 while(!feof(file))
	 {
		if(!fgets(buffer,BSIZE,file))break;
		pdest = strstr( buffer, " FINAL HEAT OF FORMATION");
		if(pdest) 
		{
			pdest = strstr( buffer, "=");
			if(pdest)
			{
				if(sscanf(pdest+1,"%lf",energy)==1)
				{
					fclose(file);
					return TRUE;
				}
			}
		}
	 }
	fclose(file);
	return FALSE;
}
/*****************************************************************************/
static boolean runOneMopac(ForceField* geometry, double* energy, char* fileNamePrefix, char* keyWords, char* mopacCommand)
{
	FILE* file = NULL;
	FILE* fileSH = NULL;
	int j;
	char* fileNameIn = NULL;
	char* fileNameOut = NULL;
	char* fileNameSH = NULL;
	char multiplicityStr[100];
	char buffer[1024];
#ifdef OS_WIN32
	char c='%';
#endif

	if(!geometry) return FALSE;
#ifndef OS_WIN32
	fileNameSH = strdup_printf("%sMopacOne.sh",fileNamePrefix);
#else
	fileNameSH = strdup_printf("%sMopacOne.bat",fileNamePrefix);
#endif
 	fileSH = fopen(fileNameSH, "w");
	if(!fileSH) return FALSE;
#ifdef OS_WIN32
	fprintf(fileSH,"set PATH=%cPATH%c;\"%s\"\n",c,c,mopacDirectory);
#endif

	getMultiplicityName( geometry->molecule.spinMultiplicity, multiplicityStr);

	fileNameIn = strdup_printf("%sOne.mop",fileNamePrefix);
 	file = fopen(fileNameIn, "w");
	if(!file) 
	{
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		return FALSE;
	}
	fprintf(file,"* ===============================\n");
	fprintf(file,"* Input file for Mopac\n");
	fprintf(file,"* ===============================\n");
	fprintf(file,"%s CHARGE=%d %s\n",keyWords, geometry->molecule.totalCharge,multiplicityStr);
	fprintf(file,"\n");
	fprintf(file,"Mopac file generated by CChemI\n");

	for(j=0;j<geometry->molecule.nAtoms;j++)
	{
	fprintf(file," %s %f %d %f %d %f %d\n", 
			geometry->molecule.atoms[j].prop.symbol,
			geometry->molecule.atoms[j].coordinates[0],
			1,
			geometry->molecule.atoms[j].coordinates[1],
			1,
			geometry->molecule.atoms[j].coordinates[2],
			1
			);
	}
	fclose(file);
#ifndef OS_WIN32
	fprintf(fileSH,"%s %s\n",mopacCommand,fileNameIn);
	fclose(fileSH);
	sprintf(buffer,"chmod u+x %s",fileNameSH);
	system(buffer);
	system(fileNameSH);
#else
	fprintf(fileSH,"\"%s\" \"%s\"\n",mopacCommand,fileNameIn);
	fclose(fileSH);
	sprintf(buffer,"\"%s\"",fileNameSH);
	system(buffer);
#endif

	fileNameOut = strdup_printf("%sOne.out",fileNamePrefix);
	if(getEnergyMopac(fileNameOut,energy))
	{
		char* str = NULL;

		geometry->molecule.klass->readGeomFromMopacOutputFile(&geometry->molecule, fileNameOut, -1);
		if(strstr(keyWords,"AM1")) str = strdup_printf("Energy by AM1/Mopac = %f", *energy);
		else str = strdup_printf("Energy by PM6/Mopac = %f", *energy);
		printf("%s\n",str);
		if(str) free(str);
	}
	else
	{
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		return FALSE;
	}

 	if(fileNameIn) free(fileNameIn);
 	if(fileNameOut) free(fileNameOut);
 	if(fileNameSH) free(fileNameSH);
	return TRUE;
}
/*****************************************************************************/
static boolean runMopacFiles(int numberOfGeometries, ForceField** geometries, double* energies, char* fileNamePrefix, char* keyWords, char* mopacCommand)
{
	int i;
	int nG = 0;
	int nM = 0;
	char* str = NULL;
	for(i=0;i<numberOfGeometries;i++)
	{
		if(!geometries[i]) continue;
		nG++;
		if(str) free(str);
		if(strstr(keyWords,"AM1"))
		str = strdup_printf("Minimization by AM1/Mopac of geometry n = %d... Please wait\n", i+1);
		else
		str = strdup_printf("Minimization by PM6/Mopac of geometry n = %d... Please wait\n", i+1);
		printf("%s",str);
		runOneMopac(geometries[i], &energies[i], fileNamePrefix, keyWords, mopacCommand);
		nM++;
	}
	if(str) free(str);
	if(nM==nG) return TRUE;
	return FALSE;

}
/*****************************************************************************/
static boolean getEnergyFireFly(char* fileNameOut, double* energy)
{
	FILE* file = NULL;
	char buffer[1024];
	char* pdest = NULL;
	boolean OK = FALSE;

 	file = fopen(fileNameOut, "r");
	if(!file) return FALSE;
	 while(!feof(file))
	 {
		if(!fgets(buffer,BSIZE,file))break;
		pdest = strstr( buffer, "HEAT OF FORMATION IS");
		if(pdest) 
		{
			pdest = strstr( buffer, "S");
			if(pdest)
			{
				if(sscanf(pdest+1,"%lf",energy)==1)
					OK = TRUE;
			}
		}
	 }
	fclose(file);
	return OK;
}
/*****************************************************************************/
static boolean runOneFireFly(ForceField* geometry, double* energy, char* fileNamePrefix, char* keyWords, char* fireflyCommand)
{
	FILE* file = NULL;
	FILE* fileSH = NULL;
	int j;
	char* fileNameIn = NULL;
	char* fileNameOut = NULL;
	char* fileNameSH = NULL;
	char multiplicityStr[100];
	char buffer[1024];
#ifdef OS_WIN32
	char c='%';
#endif

	if(!geometry) return FALSE;
#ifndef OS_WIN32
	fileNameSH = strdup_printf("%sPCGOne.sh",fileNamePrefix);
#else
	fileNameSH = strdup_printf("%sPCGOne.bat",fileNamePrefix);
#endif
 	fileSH = fopen(fileNameSH, "w");
	if(!fileSH) return FALSE;
#ifdef OS_WIN32
	fprintf(fileSH,"set PATH=%cPATH%c;\"%s\"\n",c,c,fireflyDirectory);
#endif

	getMultiplicityName(geometry->molecule.spinMultiplicity, multiplicityStr);

	fileNameIn = strdup_printf("%sOne.inp",fileNamePrefix);
 	file = fopen(fileNameIn, "w");
	if(!file) 
	{
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		return FALSE;
	}
	fprintf(file,"! ======================================================\n");
	fprintf(file,"!  Input file for FireFly\n"); 
	fprintf(file,"! ======================================================\n");
	if(strstr(keyWords,"RUNTYP"))
	{
		sscanf(strstr(keyWords,"RUNTYP"),"%s",buffer);
		fprintf(file," $CONTRL %s $END\n",buffer);
	}
	if(strstr(keyWords,"SCFTYP"))
	{
		sscanf(strstr(keyWords,"SCFTYP"),"%s",buffer);
		fprintf(file," $CONTRL %s $END\n",buffer);
	}
	else
	{
		if(geometry->molecule.spinMultiplicity==1)
			fprintf(file," $CONTRL SCFTYP=RHF $END\n");
		else
			fprintf(file," $CONTRL SCFTYP=UHF $END\n");
	}

	fprintf(file," $CONTRL ICHARG=%d MULT=%d $END\n", geometry->molecule.totalCharge, geometry->molecule.spinMultiplicity);
	if(strstr(keyWords,"GBASIS"))
	{
		sscanf(strstr(keyWords,"GBASIS"),"%s",buffer);
		fprintf(file," $BASIS %s $END\n",buffer);
	}
	fprintf(file," $DATA\n");
	fprintf(file,"Molecule specification\n");
	fprintf(file,"C1\n");
	for(j=0;j<geometry->molecule.nAtoms;j++)
	{
		char* symbol = geometry->molecule.atoms[j].prop.symbol;
		SAtomsProp prop = propAtomGet(symbol);
		fprintf(file,"%s %f %f %f %f\n", 
			symbol,
			(double)prop.atomicNumber,
			geometry->molecule.atoms[j].coordinates[0],
			geometry->molecule.atoms[j].coordinates[1],
			geometry->molecule.atoms[j].coordinates[2]
			);
	}
	fprintf(file," $END\n");
	fclose(file);
	fileNameOut = strdup_printf("%sOne.out",fileNamePrefix);
#ifndef OS_WIN32
	if(!strcmp(fireflyCommand,"pcgamess") || !strcmp(fireflyCommand,"nohup pcgamess")||
	!strcmp(fireflyCommand,"firefly") || !strcmp(fireflyCommand,"nohup firefly"))
	{
		fprintf(fileSH,"mkdir %stmp\n",fileNamePrefix);
		fprintf(fileSH,"cd %stmp\n",fileNamePrefix);
		fprintf(fileSH,"cp %s input\n",fileNameIn);
		fprintf(fileSH,"%s -p -o %s\n",fireflyCommand,fileNameOut);
		fprintf(fileSH,"cd ..\n");
		fprintf(fileSH,"rm PUNCH\n");
		fprintf(fileSH,"/bin/rm -r  %stmp\n",fileNamePrefix);
	}
	else
		fprintf(fileSH,"%s %s",fireflyCommand,fileNameIn);
#else
	if(!strcmp(fireflyCommand,"pcgamess") ||
	!strcmp(fireflyCommand,"firefly") )
	{
        	fprintf(fileSH,"mkdir \"%stmp\"\n",fileNamePrefix);
		addUnitDisk(fileSH, fileNamePrefix);
	 	fprintf(fileSH,"cd \"%stmp\"\n",fileNamePrefix);
         	fprintf(fileSH,"copy \"%s\" input\n",fileNameIn);
         	fprintf(fileSH,"%s -p -o \"%s\"\n",fireflyCommand,fileNameOut);
	 	fprintf(fileSH,"cd ..\n");
         	fprintf(fileSH,"del PUNCH\n");
         	fprintf(fileSH,"del /Q  \"%stmp\"\n",fileNamePrefix);
         	fprintf(fileSH,"rmdir  \"%stmp\"\n",fileNamePrefix);
	}
	else
		fprintf(fileSH,"%s %s",fireflyCommand,fileNameIn);
#endif
	fclose(fileSH);
#ifndef OS_WIN32
	sprintf(buffer,"chmod u+x %s",fileNameSH);
	system(buffer);
	system(fileNameSH);
#else
	sprintf(buffer,"\"%s\"",fileNameSH);
	system(buffer);
#endif
	if(getEnergyFireFly(fileNameOut,energy))
	{
		char* str = NULL;

		geometry->molecule.klass->readGeomFromGamessOutputFile(&geometry->molecule, fileNameOut, -1);
		str = strdup_printf("Energy by FireFly = %f", *energy);
		printf("%s\n",str);
		if(str) free(str);
	}
	else
	{
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		return FALSE;
	}

 	if(fileNameIn) free(fileNameIn);
 	if(fileNameOut) free(fileNameOut);
 	if(fileNameSH) free(fileNameSH);
	return TRUE;
}
/*****************************************************************************/
static boolean runFireFlyFiles(int numberOfGeometries, ForceField** geometries, double* energies, char* fileNamePrefix, char* keyWords, char* fireflyCommand)
{
	int i;
	int nG = 0;
	int nM = 0;
	char* str = NULL;
	for(i=0;i<numberOfGeometries;i++)
	{
		if(!geometries[i]) continue;
		nG++;
		if(str) free(str);
		str = strdup_printf("Minimization by FireFly of geometry n = %d... Please wait\n", i+1);
		printf("%s",str);
		runOneFireFly(geometries[i], &energies[i], fileNamePrefix, keyWords, fireflyCommand);
		nM++;
	}
	if(str) free(str);
	if(nM==nG) return TRUE;
	return FALSE;

}
/*************************************************************************************************************/
static boolean getEnergyGaussian(char* fileNameOut, double* energy)
{
	FILE* file = NULL;
	char buffer[1024];
	char* pdest = NULL;
	boolean OK = FALSE;

 	file = fopen(fileNameOut, "r");
	if(!file) return FALSE;
	 while(!feof(file))
	 {
		if(!fgets(buffer,BSIZE,file))break;
		pdest = strstr( buffer, "SCF Done:  E(");
		if(!pdest) if(strstr( buffer, "Energy=") && !strstr( buffer, "hange") ) pdest = strstr( buffer, "Energy=");
		if(pdest) 
		{
			pdest = strstr( buffer, "=");
			if(pdest)
			{
				int l = strlen(pdest);
				int i;
				for(i=0;i<l;i++) if(pdest[i]=='D' || pdest[i]=='E') pdest[i] ='E';
				if(sscanf(pdest+1,"%lf",energy)==1)
				{
					OK = TRUE;
					/* break;*/
				}
			}
		}
	 }
	fclose(file);
	return OK;
}
/*****************************************************************************/
static boolean runOneGaussian(ForceField* geom, double* energy, char* fileNamePrefix, char* keyWords, char* gaussianCommand)
{
	FILE* file = NULL;
	FILE* fileSH = NULL;
	int j;
	char* fileNameIn = NULL;
	char* fileNameOut = NULL;
	char* fileNameSH = NULL;
	char buffer[1024];
	Molecule* mol = &geom->molecule;
	*energy = 0;
#ifdef OS_WIN32
	char c='%';
#endif

	if(!geom) return FALSE;
	if(geom->molecule.nAtoms<1) return FALSE;
#ifndef OS_WIN32
	fileNameSH = strdup_printf("%sGaussOne.sh",fileNamePrefix);
#else
	fileNameSH = strdup_printf("%sGaussOne.bat",fileNamePrefix);
#endif
 	fileSH = fopen(fileNameSH, "w");
	if(!fileSH) return FALSE;
#ifdef OS_WIN32
	fprintf(fileSH,"set PATH=%cPATH%c;\"%s\"\n",c,c,gaussianDirectory);
#endif

	fileNameIn = strdup_printf("%sOne.inp",fileNamePrefix);
 	file = fopen(fileNameIn, "w");
	if(!file) 
	{
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		return FALSE;
	}
 	file = fopen(fileNameIn, "w");
	if(!file) 
	{
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		return FALSE;
	}
	fprintf(file,"# %s\n",keyWords);
	fprintf(file,"\n");
	fprintf(file,"! ======================================================\n");
	fprintf(file,"!  Input file for Gaussian\n"); 
	fprintf(file,"! ======================================================\n");
	fprintf(file,"\n");

	fprintf(file,"%d %d\n",mol->totalCharge,mol->spinMultiplicity);
	for(j=0;j<mol->nAtoms;j++)
	{
		char* symbol = mol->atoms[j].prop.symbol;
		fprintf(file,"%s %f %f %f\n", 
			symbol,
			mol->atoms[j].coordinates[0],
			mol->atoms[j].coordinates[1],
			mol->atoms[j].coordinates[2]
			);
	}
	fprintf(file,"\n");
	fclose(file);
	fileNameOut = strdup_printf("%sOne.out",fileNamePrefix);
#ifndef OS_WIN32
	fprintf(fileSH,"%s %s",gaussianCommand,fileNameIn);
#else
	fprintf(fileSH,"%s %s",gaussianCommand,fileNameIn);
#endif
	fclose(fileSH);
	{
		char* str = NULL;
		if(strstr(keyWords,"OPT")) str = strdup_printf("Minimization by Gaussian ... Please wait");
		else str = strdup_printf("Computing of energy by Gaussian .... Please wait");
		printf("%s",str);
	}
#ifndef OS_WIN32
	sprintf(buffer,"chmod u+x %s",fileNameSH);
	system(buffer);
	system(fileNameSH);
#else
	sprintf(buffer,"\"%s\"",fileNameSH);
	system(buffer);
#endif
	if(getEnergyGaussian(fileNameOut,energy))
	{
		printf("Energy by Gaussian = %f\n", *energy);
		mol->klass->readGeomFromGaussianOutputFile(mol, fileNameOut, -1);
	}
	else
	{
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		return FALSE;
	}

 	if(fileNameIn) free(fileNameIn);
 	if(fileNameOut) free(fileNameOut);
 	if(fileNameSH) free(fileNameSH);
	return TRUE;
}
/*****************************************************************************/
static boolean runGaussianFiles(int numberOfGeometries, ForceField** geometries, double* energies, char* fileNamePrefix, char* keyWords, char* gaussianCommand)
{
	int i;
	int nG = 0;
	int nM = 0;
	char* str = NULL;
	for(i=0;i<numberOfGeometries;i++)
	{
		if(!geometries[i]) continue;
		nG++;
		if(str) free(str);
		printf("Minimization by Gaussian of geometry n = %d... Please wait\n", i+1);
		if(runOneGaussian(geometries[i], &energies[i], fileNamePrefix, keyWords,gaussianCommand)) 
		{
			nM++;
		}
	}
	if(str) free(str);
	if(nM==nG) return TRUE;
	return FALSE;

}
/*****************************************************************************/
static boolean getEnergyOrca(char* fileNameOut, double* energy)
{
	FILE* file = NULL;
	char buffer[1024];
	char* pdest = NULL;
	char* energyTag = "FINAL SINGLE POINT ENERGY";

 	file = fopen(fileNameOut, "r");
	if(!file) return FALSE;
	 while(!feof(file))
	 {
		if(!fgets(buffer,BSIZE,file))break;
		pdest = strstr( buffer, energyTag);
		if(pdest)
		{
			int l = strlen(pdest);
			int i;
			for(i=0;i<l;i++) if(pdest[i]=='D' || pdest[i]=='E') pdest[i] ='E';
		}
		if(pdest &&sscanf(pdest+strlen(energyTag)+1,"%lf",energy)==1)
		{
			fclose(file);
			*energy *=AUTOKCAL;
			return TRUE;
		}
	 }
	fclose(file);
	return FALSE;
}
/*****************************************************************************/
static boolean runOneOrca(ForceField* geom, double* energy, char* fileNamePrefix, char* keyWords, char* orcaCommand)
{
	FILE* file = NULL;
	FILE* fileSH = NULL;
	char* fileNameIn = NULL;
	char* fileNameOut = NULL;
	char* fileNameSH = NULL;
	char multiplicityStr[100];
	char buffer[1024];
	int i;
	int nV;
	Molecule* mol = &geom->molecule;

	if(!mol) return FALSE;
        if(mol->nAtoms<2)return FALSE;
#ifndef OS_WIN32
	fileNameSH = strdup_printf("%sOne.sh",fileNamePrefix);
#else
	fileNameSH = strdup_printf("%sOne.bat",fileNamePrefix);
#endif
 	fileSH = fopen(fileNameSH, "w");
	if(!fileSH) return FALSE;
#ifdef OS_WIN32
	fprintf(fileSH,"@echo off\n");
#endif

	getMultiplicityName(mol->spinMultiplicity, multiplicityStr);

	fileNameIn = strdup_printf("%sOne.inp",fileNamePrefix);
 	file = fopen(fileNameIn, "w");
	if(!file) 
	{
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		return FALSE;
	}
	fprintf(file,"# ======================================================\n");
	fprintf(file,"#  Orca input file made in Gabedit\n"); 
	fprintf(file,"# ======================================================\n");
	fprintf(file,"! %s\n",keyWords);
	{
		fprintf(file,"* xyz %d   %d\n",mol->totalCharge,mol->spinMultiplicity);
		nV = 0;
      		for (i=0;i<mol->nAtoms;i++)
		{
			char X[100];
			char Y[100];
			char Z[100];
			sprintf(X,"%20.14f",mol->atoms[i].coordinates[0]);
			sprintf(Y,"%20.14f",mol->atoms[i].coordinates[1]);
			sprintf(Z,"%20.14f",mol->atoms[i].coordinates[2]);

			fprintf(file," %s  %s %s %s\n",mol->atoms[i].prop.symbol, X,Y,Z);
			if(mol->atoms[i].variable) nV+=3;
		}
		fprintf(file,"*\n");
		if(nV>0&&nV!=3*mol->nAtoms) 
		{
			fprintf(file,"%cgeom Constraints\n",'%');
      			for (i=0;i<mol->nAtoms;i++)
			{
				if(mol->atoms[i].variable)
				{
					fprintf(file,"  {C %d C}\n",i);
				}
			}
			fprintf(file," end #Constraints\n");
			fprintf(file," invertConstraints true\n");
			fprintf(file," end #geom\n");
		}
	}

	fclose(file);
	fileNameOut = strdup_printf("%sOne.out",fileNamePrefix);
#ifndef OS_WIN32
	if(!strcmp(orcaCommand,"orca") || !strcmp(orcaCommand,"nohup orca"))
	{
		fprintf(fileSH,"%s %s > %s\n",orcaCommand,fileNameIn,fileNameOut);
		fprintf(fileSH,"exit\n");
	}
	else
		fprintf(fileSH,"%s %s",orcaCommand,fileNameIn);
#else
	 if(!strcmp(orcaCommand,"orca") )
	{
		if(strstr(orcaDirectory,"\"")) fprintf(fileSH,"set PATH=%s;%cPATH%c\n",orcaDirectory,'%','%');
		else fprintf(fileSH,"set PATH=\"%s\";%cPATH%c\n",orcaDirectory,'%','%');
		fprintf(fileSH,"%s %s > %s\n",orcaCommand,fileNameIn,fileNameOut);
		fprintf(fileSH,"exit\n");
	}
	else
		fprintf(fileSH,"%s %s",orcaCommand,fileNameIn);
#endif
	fclose(fileSH);
	{
		char* str = NULL;
		if(strstr(keyWords,"Opt")) str = strdup_printf("Minimization by Orca ... Please wait");
		else str = strdup_printf("Computing of energy by Orca .... Please wait");
		printf("%s\n",str);
		if(str) free(str);
	}
#ifndef OS_WIN32
	sprintf(buffer,"chmod u+x %s",fileNameSH);
	system(buffer);
	system(fileNameSH);
#else
	sprintf(buffer,"\"%s\"",fileNameSH);
	system(buffer);
#endif
	if(getEnergyOrca(fileNameOut,energy))
	{
		printf("Energy by Orca = %f\n", *energy);
		mol->klass->readGeomFromOrcaOutputFile(mol, fileNameOut, -1);
	}
	else
	{
 		if(fileNameIn) free(fileNameIn);
 		if(fileNameOut) free(fileNameOut);
 		if(fileNameSH) free(fileNameSH);
		return FALSE;
	}

 	if(fileNameIn) free(fileNameIn);
 	if(fileNameOut) free(fileNameOut);
 	if(fileNameSH) free(fileNameSH);
	return TRUE;
}
/*****************************************************************************/
static boolean runOrcaFiles(int numberOfGeometries, ForceField** geometries, double* energies, char* fileNamePrefix, char* keyWords, char* orcaCommand)
{
	int i;
	int nG = 0;
	int nM = 0;
	char* str = NULL;
	for(i=0;i<numberOfGeometries;i++)
	{
		if(!geometries[i]) continue;
		nG++;
		if(str) free(str);
		printf("Minimization by Orca of geometry n = %d... Please wait\n", i+1);
		if(runOneOrca(geometries[i], &energies[i], fileNamePrefix, keyWords,orcaCommand)) 
		{
			nM++;
		}
	}
	if(str) free(str);
	if(nM==nG) return TRUE;
	return FALSE;

}
/*****************************************************************************/
static boolean testEqualDistances(double* distancesI, double* distancesJ, int n, double tol)
{
	int k;
	if(!distancesI) return FALSE;
	if(!distancesJ) return FALSE;
	if(n<1) return FALSE;
	for (  k = 0; k < n; k++ )
		if(fabs(distancesI[k]-distancesJ[k])>tol) return FALSE;
	return TRUE;
}
/*****************************************************************************/
static double* getDistancesBetweenAtoms(ForceField* forceField)
{
	double* distances = NULL;
	int i;
	int j;
	int n;
	int k;
	if(forceField->molecule.nAtoms<1) return distances;
	n = forceField->molecule.nAtoms*(forceField->molecule.nAtoms-1)/2;
	distances = malloc(n*sizeof(double));
	n = 0;
	for (  i = 0; i < forceField->molecule.nAtoms-1; i++ )
	for (  j = i+1; j < forceField->molecule.nAtoms; j++ )
	{
		double x = forceField->molecule.atoms[i].coordinates[0]-forceField->molecule.atoms[j].coordinates[0];
		double y = forceField->molecule.atoms[i].coordinates[1]-forceField->molecule.atoms[j].coordinates[1];
		double z = forceField->molecule.atoms[i].coordinates[2]-forceField->molecule.atoms[j].coordinates[2];
		distances[n++] = x*x + y*y + z*z;
	}
	for(i=0;i<n-1;i++)
	{
		k = i;
		for(j=i+1;j<n;j++)
			if(distances[j]<distances[k]) k= j;
		if(k!=i)
		{
			double d = distances[i];
			distances[i] = distances[k];
			distances[k] = d;
		}
	}
	return distances;
}
/*****************************************************************************/
static void removedsToEnd(int numberOfGeometries, ForceField** geometries, double* energies, boolean* removeds)
{
	if(geometries && energies && removeds)
	{
		int i;
		int j;
		int k;
		for(i=0;i<numberOfGeometries-1;i++)
		{
			if(!removeds[i]) continue;
			k = i;
			for(j=i+1;j<numberOfGeometries;j++)
				if(!removeds[j]) { k= j; break;}
			if(k!=i)
			{
				double energy = energies[i];
				boolean r = removeds[i];
				ForceField* g = geometries[i];

				energies[i] = energies[k];
				energies[k] = energy;
				geometries[i] = geometries[k];
				geometries[k] = g;
				removeds[i] = removeds[k];
				removeds[k] = r;
			}
		}
	}
}
/*****************************************************************************/
static void computeRemoveds(int numberOfGeometries, ForceField** geometries, double* energies, boolean *removeds, 
		double tolEnergy, double tolDistance)
{
	int i;
	int j;
	double* distancesI = NULL;
	double* distancesJ = NULL;
	if(tolDistance<=0 && tolEnergy<=0) return;
	if(!geometries || !energies) return;
	if(numberOfGeometries<1) return;
	i = numberOfGeometries-1;
	if(!geometries[i]){ removeds[i]=TRUE;}
	for(i=0;i<numberOfGeometries-1;i++)
	{
		int n;
		if(removeds[i]) continue;
		if(!geometries[i]){ removeds[i]=TRUE; continue;}
		if(tolDistance>0) distancesI =  getDistancesBetweenAtoms(geometries[i]);
		n = geometries[i]->molecule.nAtoms*(geometries[i]->molecule.nAtoms-1)/2;
		for(j=i+1;j<numberOfGeometries;j++)
		{
			if(removeds[j]) continue;
			if(!geometries[j]){ removeds[j]=TRUE; continue;}
			if(tolEnergy>0 && fabs(energies[j]-energies[i])<tolEnergy && geometries[i]->molecule.nAtoms==geometries[j]->molecule.nAtoms)
			{
				if(tolDistance>0) 
				{
					distancesJ =  getDistancesBetweenAtoms(geometries[j]);
					if(testEqualDistances(distancesI, distancesJ, n, tolDistance))
						removeds[j] = TRUE;
					if(distancesJ) free(distancesJ);
					distancesJ = NULL;
				}
				else
					removeds[j] = TRUE;
			}
			if(tolEnergy<0 && tolDistance>0 && geometries[i]->molecule.nAtoms==geometries[j]->molecule.nAtoms)
			{
				distancesJ =  getDistancesBetweenAtoms(geometries[j]);
				if(testEqualDistances(distancesI, distancesJ, n, tolDistance))
					removeds[j] = TRUE;
				if(distancesJ) free(distancesJ);
				distancesJ = NULL;
			}
		}
		if(distancesI) free(distancesI);
		distancesI = NULL;
	}

}
/*****************************************************************************/
static void removeIdenticalGeometries(int* nG, ForceField*** geoms, double** eners, double tolEnergy, double tolDistance)
{
	int i;
	int numberOfGeometries =*nG;
	ForceField** geometries = *geoms; 
	double* energies = *eners;
	boolean* removeds = NULL;
	int newN = 0;
	if(numberOfGeometries<1) return;
	removeds = malloc(numberOfGeometries*sizeof(boolean));
	for(i=0;i<numberOfGeometries;i++) removeds[i] = FALSE;
	computeRemoveds(numberOfGeometries, geometries, energies, removeds, tolEnergy, tolDistance);
	removedsToEnd(numberOfGeometries, geometries, energies, removeds);

	for(i=0;i<numberOfGeometries;i++) 
	{
		if(removeds[i]) 
		{
			if(geometries[i]) freeForceField(geometries[i]);
		}
		else newN++;
	}
	free(removeds);
	if(newN==0) { *nG = newN; return;}
	if(newN==numberOfGeometries) return;
	*nG = newN;
	*eners = realloc(*eners,newN*sizeof(double));
	*geoms = realloc(*geoms,newN*sizeof(ForceField**));

}
/*****************************************************************************/
/*
static int removeIdenticalGeometriesNULL(int numberOfGeometries, ForceField** geometries, double* energies, double tolEnergy, double tolDistance)
{
	int i;
	boolean* removeds = NULL;
	int newN = 0;
	if(numberOfGeometries<1) return 0;
	removeds = malloc(numberOfGeometries*sizeof(boolean));
	for(i=0;i<numberOfGeometries;i++) removeds[i] = FALSE;
	computeRemoveds(numberOfGeometries, geometries, energies, removeds, tolEnergy, tolDistance);
	removedsToEnd(numberOfGeometries, geometries, energies, removeds);

	for(i=0;i<numberOfGeometries;i++) 
	{
		if(removeds[i]) 
		{
			if(geometries[i]) freeForceField(geometries[i]);
			geometries[i] = NULL;
			energies[i] = 1e30;
		}
		else newN++;
	}
	free(removeds);
	return newN;
}
*/
/*****************************************************************************/
static void sortGeometries(int numberOfGeometries, ForceField** geometries, double* energies)
{
	if(geometries && energies)
	{
		int i;
		int j;
		int k;
		for(i=0;i<numberOfGeometries-1;i++)
		{
			k = i;
			for(j=i+1;j<numberOfGeometries;j++)
				if(energies[j]<energies[k]) k= j;
			if(k!=i)
			{
				double energy = energies[i];
				ForceField* g = geometries[i];

				energies[i] = energies[k];
				energies[k] = energy;
				geometries[i] = geometries[k];
				geometries[k] = g;
			}
		}
	}
}
/*****************************************************************************/
static void createPostProcessingFiles(int numberOfGeometries, ForceField** geometries,double* energies,char* fileNameGeom, char* mopacKeywords, char* gaussianKeywords, char* fireflyKeywords, char* orcaKeywords, char* cchemiKeywords, char* message, char* mopacCommand, char* gaussianCommand, char* fireflyCommand, char* orcaCommand, char* cchemiCommand)
{
	if(mopacKeywords)
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		createMopacFiles(numberOfGeometries, geometries, energies, fileNamePrefix, mopacKeywords,mopacCommand);
		strcat(message,fileNamePrefix);
		strcat(message,("_*.mop\n\tFiles for a post processing by Mopac\n\n"));
		if(fileNamePrefix) free(fileNamePrefix);
	}
	if(gaussianKeywords)
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		createGaussianFiles(numberOfGeometries, geometries, energies, fileNamePrefix, gaussianKeywords,gaussianCommand);
		strcat(message,fileNamePrefix);
		strcat(message,("_*.com\n\tFiles for a post processing by Gaussian\n\n"));
		if(fileNamePrefix) free(fileNamePrefix);
	}
	if(orcaKeywords)
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		createOrcaFiles(numberOfGeometries, geometries, energies, fileNamePrefix, orcaKeywords,orcaCommand);
		strcat(message,fileNamePrefix);
		strcat(message,("ORCA_*.inp\n\tFiles for a post processing by Orca\n\n"));
		if(fileNamePrefix) free(fileNamePrefix);
	}
	if(fireflyKeywords)
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		createFireFlyFiles(numberOfGeometries, geometries, energies, fileNamePrefix, fireflyKeywords,fireflyCommand);
		strcat(message,fileNamePrefix);
		strcat(message,("FF_*.inp\n\tFiles for a post processing by FireFly\n\n"));
		if(fileNamePrefix) free(fileNamePrefix);
	}
	if(cchemiKeywords)
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		createCChemIFiles(numberOfGeometries, geometries, energies, fileNamePrefix, cchemiKeywords,cchemiCommand);
		strcat(message,fileNamePrefix);
		strcat(message,("CCHEMI_*.inp\n\tFiles for a post processing by CChemI\n\n"));
		if(fileNamePrefix) free(fileNamePrefix);
	}
}
/*****************************************************************************/
char*  setOptOptions(FILE* file, ConjugateGradientOptions* conjugateGradientOptions, QuasiNewton* quasiNewton)
{
	char* optimizerType = strdup("QuasiNewton");
	readOneString(file,"OptimizerType",&optimizerType);
	if(strstr(optimizerType,"Gradient")) setCGOptions(file, conjugateGradientOptions);
	else if(strstr(optimizerType,"Quasi")) setQNOptions(file, quasiNewton);
	else if(strstr(optimizerType,"Steep")) setCGOptions(file, conjugateGradientOptions);
	else if(strstr(optimizerType,"External"))
	{
		printf("Sorry, ExternalOptimizer with a MM potential is not implemented\n");
		exit(1);
	}
	return optimizerType;
}
/*****************************************************************************/
static int collectGeometriesFromProcessors(int nproc, ForceField** geometriesAll, int numberOfGeometriesMax, double* energiesAll, ForceField** geometries, int numberOfGeometries, double* energies,  double* coords,  double* enerDum, ForceField* forceField, double tolEnergy, double tolDistance)
{
		int numberOfGeometriesAll = 0;
#ifdef ENABLE_MPI
#ifdef DEBUG
		printf("Begin collectGeometriesFromProcessors\n");
#endif
		int j;
		int i;
		int code,tag;
		for(i=0;i<numberOfGeometriesMax;i++) 
		{
			energiesAll[i] = 1e30;
			if(geometriesAll[i]) freeForceField(geometriesAll[i]);
			geometriesAll[i] = NULL;
		}
		for(i=0;i<numberOfGeometries;i++) 
		{
			if(geometries[i])
			{
				geometriesAll[i] = malloc(sizeof(ForceField));
               			*geometriesAll[i] = copyForceField(geometries[i]);
				energiesAll[i] = energies[i];
			}
		}
		numberOfGeometriesAll = numberOfGeometries;
		// get geometries from other proc
		for(j=1;j<nproc;j++)
		{
			int nG = 0;
			tag = 1000;
			MPI_Status status ;
#ifdef DEBUG
			printf("get nGeometries from proc n %d\n", j);
#endif
			code = MPI_Recv(&nG,1,MPI_INT,j,tag,MPI_COMM_WORLD,&status) ;
#ifdef DEBUG
			printf("nGeometries=%d from proc n %d\n",nG, j);
#endif
			if(nG>0) 
			{
				int k;
				int a,b;
				tag = 2000;
				code = MPI_Recv(enerDum,nG,MPI_DOUBLE,j,tag,MPI_COMM_WORLD,&status) ;
				for(k=0;k<nG;k++)
				{
					int nA = forceField->molecule.nAtoms;
					energiesAll[i+k] = enerDum[k];
					tag = 3000+k;
					code = MPI_Recv(coords,nA*3,MPI_DOUBLE,j,tag,MPI_COMM_WORLD,&status) ;
					geometriesAll[i+k] = malloc(sizeof(ForceField));
               				*geometriesAll[i+k] = copyForceField(forceField);
					b = 0;
					for(a=0;a<nA;a++)
					{
#ifdef DEBUG
						printf(" atoms %d C = %f %f %f\n",a,coords[b], coords[b+1], coords[b+2]);
#endif
						geometriesAll[i+k]->molecule.atoms[a].coordinates[0] = coords[b++];
						geometriesAll[i+k]->molecule.atoms[a].coordinates[1] = coords[b++];
						geometriesAll[i+k]->molecule.atoms[a].coordinates[2] = coords[b++];
					}
				}
				i += nG;
				numberOfGeometriesAll += nG;
			}
		}
		sortGeometries(numberOfGeometriesAll, geometriesAll, energiesAll);
		numberOfGeometriesAll = removeIdenticalGeometriesNULL(numberOfGeometriesAll, geometriesAll, energiesAll, tolEnergy, tolDistance);
#ifdef DEBUG
		printf("End collectGeometriesFromProcessors\n");
#endif

#endif /* ENABLE_MPI */
		return numberOfGeometriesAll;
}
/*********************************************************************************************************************************/
static void sendGeometriesToMaster(int rank, ForceField** geometries, int numberOfGeometries, double* energies,  double* coords, int nAtoms)
{
#ifdef ENABLE_MPI
	int j;
	int code,tag;
	j = 0;
	tag = 1000;
#ifdef DEBUG
	printf("Begin sendGeometriesToMaster from proc n %d\n",rank);
#endif
	code = MPI_Send(&numberOfGeometries,1,MPI_INT,j,tag,MPI_COMM_WORLD) ;
	if(numberOfGeometries>0)
	{
		int k;
		int a,b;
		tag = 2000;
		code = MPI_Send(energies,numberOfGeometries,MPI_DOUBLE,j,tag,MPI_COMM_WORLD) ;
		for(k=0;k<numberOfGeometries;k++)
		{
			tag = 3000+k;
			b = 0;
			for(a=0;a<nAtoms;a++)
			{
				coords[b++] = geometries[k]->molecule.atoms[a].coordinates[0];
				coords[b++] = geometries[k]->molecule.atoms[a].coordinates[1];
				coords[b++] = geometries[k]->molecule.atoms[a].coordinates[2];
			}
			code = MPI_Send(coords,nAtoms*3,MPI_DOUBLE,j,tag,MPI_COMM_WORLD);
		}
	}
#ifdef DEBUG
	printf("End sendGeometriesToMaster from proc n %d\n",rank);
#endif
#endif /* ENABLE_MPI */
}
/*****************************************************************************/
void molecularMechanicsDynamicsREMDConfoDlg(char* inputFileName)
{
	ForceField forceField; 
	ForceFieldOptions forceFieldOptions;
	MolecularDynamics molecularDynamics;
	int updateFrequency = 1;
	double heatTime;
	double equiTime;
	double runTime;
	double coolTime;
	double heatTemp; 
	double equiTemp; 
	double runTemp; 
	double coolTemp; 
	double stepSize;
	MDIntegratorType integrator = VERLET;
	char* fileNameGeom = NULL;
	char* fileNameTraj = NULL;
	char* fileNameProp = NULL;
	char* mopacKeywordsPost = NULL;
	char* gaussianKeywordsPost = NULL;
	char* fireflyKeywordsPost = NULL;
	char* orcaKeywordsPost = NULL;
	char* cchemiKeywordsPost = NULL;
	double friction=-1;
	double omegaMax = 4000;
	int Nf = 50;
	double collide = 20;
	double qNH = 20;
	MDThermostatType thermostat = NONE;
	int numberOfGeometries = 2;
	ForceField** geometries = NULL; 
	double* energies = NULL;
	char* optMopacMethod=strdup("PM6");
	char* optGaussianMethod=strdup("AM1");
	char* optFireFlyMethod=strdup("AM1");
	char* optOrcaMethod=strdup("AM1");
	boolean optMopac = FALSE;
	boolean optFireFly = FALSE;
	boolean optGaussian = FALSE;
	boolean optOrca = FALSE;
	boolean optMM = FALSE;
	Molecule mol = *(readMolecule(inputFileName,TRUE));
	char* optimizerType= strdup("QuasiNewton");

	QuasiNewton quasiNewton;
	ConjugateGradientOptions conjugateGradientOptions;
	SteepestDescent steepestDescent;
	ConjugateGradient conjugateGradient;
	int i;
	char message[BSIZE]=" ";
	double tolEnergy = -1;
	double tolDistance = -1;
	char* mopacCommand = strdup("mopac");
	char* gaussianCommand=strdup("g03"); 
	char* orcaCommand=strdup("orca"); 
	char* fireflyCommand=strdup("firefly");
	char* cchemiCommand=strdup("cchemi");
	FILE* file = fopen(inputFileName,"rb");
	double runTempMax = 700;
	int nTemperatures = 10;
	int numberOfExchanges = 10;
	double timeExchange = 1;
	int nproc;
	int rank;
	ForceField** geometriesAll = NULL; 
	int numberOfGeometriesAll = 2;
	int numberOfGeometriesMax = 2;
	double* energiesAll = NULL;
	double* coords = NULL;
	double* enerDum = NULL;
	FILE* logfile = NULL;
#ifdef ENABLE_MPI
	MPI_Comm_rank( MPI_COMM_WORLD,&rank);
	MPI_Comm_size( MPI_COMM_WORLD,&nproc );
#else
	rank = 0;
	nproc = 1;
#endif

	logfile = stdout;
	if(rank!=0)
	{
		char* fileNamePrefix = getSuffixNameFile(inputFileName);
		char* tmp = strdup_printf("%s_%d.log",fileNamePrefix, rank);
		logfile = fopen(tmp,"w");
		free(tmp);
		free(fileNamePrefix);
	}
	fprintf(logfile, "MolecularMechanicsDynamicsREMDConfoDlg Rank#=%d  nproc = %d\n", rank, nproc );
#ifdef DEBUG
	fprintf(logfile, "MolecularMechanicsDynamicsREMDConfoDlg Rank#=%d  nproc = %d\n", rank, nproc );
#endif
	setForceFieldOptions(file, &forceFieldOptions);
	mol.klass->buildMMTypes(&mol, file);

	setMDOptions(file, &updateFrequency, 
		&heatTime, &equiTime, &runTime, &coolTime,
		&heatTemp, &runTemp, &equiTemp, &coolTemp, &stepSize, 
		&integrator, &thermostat, &friction, &omegaMax, &Nf, &collide,&qNH);
	if(thermostat == NONE) 
	{
		fprintf(logfile,"Warning....................\n");
		fprintf(logfile," A thermostat is required for a REMD calculation\n");
		fprintf(logfile," I set it to Berendsen\n");
		thermostat = BERENDSEN;
	}
	readOneReal(file,"runTempMax",&runTempMax);
	if(runTempMax<=runTemp) runTempMax=10*runTemp;
	readOneInt(file,"nTemperatures",&nTemperatures);
	if(nTemperatures<1) nTemperatures=10;

	if(readOneReal(file,"timeExchange",&timeExchange))
	{
		if(timeExchange>=runTime)
		{
			fprintf(logfile, "Error : time of exchange cannot be larger than run time \n");
			fprintf(logfile, "      : check your input file\n");
			exit(1);
		}
	}
	else timeExchange = runTime/10;

	numberOfExchanges = (int)(runTime/timeExchange+0.5);
	fprintf(logfile, "Number of exchanges = %d\n",numberOfExchanges);

	if(numberOfExchanges<1) numberOfExchanges=2;
	readOneString(file,"mopacCommand",&mopacCommand);
	readOneString(file,"gaussianCommand",&gaussianCommand);
	readOneString(file,"fireflyCommand",&fireflyCommand);
	readOneString(file,"orcaCommand",&orcaCommand);
	readOneString(file,"cchemiCommand",&cchemiCommand);
	readOneReal(file,"tolEnergy",&tolEnergy);
	readOneReal(file,"tolDistance",&tolDistance);
	readOneBoolean(file,"ConfoOptMM",&optMM);
	readOneBoolean(file,"ConfoOptMopac",&optMopac);
	readOneString(file,"ConfoOptMopacMethod",&optMopacMethod);
	readOneBoolean(file,"ConfoOptGaussian",&optGaussian);
	readOneString(file,"ConfoOptGaussianMethod",&optGaussianMethod);
	readOneBoolean(file,"ConfoOptFireFly",&optFireFly);
	readOneString(file,"ConfoOptFireFlyMethod",&optFireFlyMethod);
	readOneBoolean(file,"ConfoOptOrac",&optOrca);
	readOneString(file,"ConfoOptOrcaMethod",&optOrcaMethod);

	readOneString(file,"mopacKeywordsPost",&mopacKeywordsPost);
	readOneString(file,"gaussianKeywordsPost",&gaussianKeywordsPost);
	readOneString(file,"fireflyKeywordsPost",&fireflyKeywordsPost);
	readOneString(file,"orcaKeywordsPost",&orcaKeywordsPost);
	readOneString(file,"cchemiKeywordsPost",&cchemiKeywordsPost);
	optimizerType = setOptOptions(file, &conjugateGradientOptions, &quasiNewton);
	if(strstr(optimizerType,"External")  && (optMopac||optFireFly || optGaussian || optOrca))
	{
		printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		printf("Sorry, The optimization using the internal optimizer after a MD conformational search is not yes implemented in this software\n");
		printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		exit(1);
	}
	/* number for geometries */
	{
		numberOfGeometries = 10;
		readOneInt(file,"numberOfGeometries",&numberOfGeometries);
		if(numberOfGeometries<2) numberOfGeometries = 2;
	}
	/* fileNames  */
	{
		char* suff = getSuffixNameFile(inputFileName);
		fileNameGeom = strdup_printf("%s%s",suff, "Geoms.gab");
		fileNameTraj = strdup_printf("%s%s",suff, "Traj.gab");
		fileNameProp = strdup_printf("%s%s",suff, "Prop.txt");
		free(suff);
	}

/* Optimsation options */ 

	/* Molecule to read */
	if(forceFieldOptions.type==AMBER) forceField = createAmberModel(&mol,forceFieldOptions, logfile);
	else if(forceFieldOptions.type==PAIRWISE) forceField = createPairWiseModel(&mol,forceFieldOptions,logfile);
	setH4CorrectionMM(file, &forceField);
	checkWallCorrection(file, &forceField);

	geometries = runREMD(&molecularDynamics, &forceField,
		updateFrequency, heatTime, equiTime, runTime, heatTemp, runTemp, runTempMax, stepSize, 
		integrator, thermostat, friction, omegaMax, Nf, collide, qNH, numberOfGeometries, nTemperatures, numberOfExchanges, fileNameTraj, fileNameProp);

	if(geometries) 
	{
		int k = 0;
		int i = 0;
#ifdef DEBUG
		fprintf(logfile, "number max of Geometries in rank n %d = %d\n",rank,numberOfGeometries );
#endif
		for(i=0;i<numberOfGeometries;i++) if(geometries[i])k++;
		fprintf(logfile, "number of selected geometries on rank n %d = %d\n",rank, k);
		if(k>0) fprintf(logfile, "fileNameGeom = %s\n",fileNameGeom);
	}
	else fprintf(logfile, "No selected geometriy in rank n %d\n",rank);
	fflush(logfile);

	if(geometries && numberOfGeometries>0) energies = malloc(numberOfGeometries*sizeof(double));
	numberOfGeometriesAll = numberOfGeometries+1;
	numberOfGeometriesMax = numberOfGeometries+1;
	if(nproc>1)
	{
		coords =  malloc(forceField.molecule.nAtoms*3*sizeof(double));
		enerDum =  malloc(numberOfGeometriesMax*sizeof(double));
		if(geometries && numberOfGeometries>0) energiesAll = malloc(numberOfGeometriesMax*sizeof(double));
		if(geometries && numberOfGeometries>0) 
		{
			geometriesAll = malloc(numberOfGeometriesMax*sizeof(ForceField*));
			for(i=0;i<numberOfGeometriesMax;i++) 
			{
				geometriesAll[i] = NULL;
			/*
				geometriesAll[i] = malloc(sizeof(ForceField));
                		*geometries[i] = copyForceField(&forceField);
			*/
			}
		}
	}

	if(geometries && optMM)
	for(i=0;i<numberOfGeometries;i++)
	{
		char* str = NULL;
		energies[i] = 1e30;
		if(!geometries[i]) continue;
		if(str) free(str);
		str = strdup_printf("Minimization of geometry number %d\n", i+1);
		fprintf(logfile,"%s",str);
		fflush(logfile);
		if(str) free(str);


		if(strstr(optimizerType,"Grad"))
		{
			conjugateGradient.logfile= logfile;
			runConjugateGradient(&conjugateGradient, geometries[i], conjugateGradientOptions); 
			energies[i] = conjugateGradient.forceField->klass->calculateEnergyTmp
				(conjugateGradient.forceField, &conjugateGradient.forceField->molecule );
			freeConjugateGradient(&conjugateGradient);
		}
		else if(strstr(optimizerType,"Quasi"))
		{
			QuasiNewton tmpQuasiNewton = quasiNewton;
			tmpQuasiNewton.forceField = geometries[i];
                	tmpQuasiNewton.logfile = logfile;
                	runQuasiNewton(&tmpQuasiNewton);
			energies[i] = tmpQuasiNewton.forceField->klass->calculateEnergyTmp
				(tmpQuasiNewton.forceField, &tmpQuasiNewton.forceField->molecule );
			freeQuasiNewton(&tmpQuasiNewton);

		}
		else
		{
			steepestDescent.logfile= logfile;
			runSteepestDescent(&steepestDescent, geometries[i],
			       	conjugateGradientOptions.updateFrequency,
			       conjugateGradientOptions.maxIterations,
			       conjugateGradientOptions.gradientNorm,
			       conjugateGradientOptions.maxLines);
			energies[i] = steepestDescent.forceField->klass->calculateEnergyTmp
				(steepestDescent.forceField, &steepestDescent.forceField->molecule );
			freeSteepestDescent(&steepestDescent);
		}
		str = strdup_printf("End Minimization of geometry number %d\n", i+1);
		fprintf(logfile,"%s",str);
		fflush(logfile);
		if(str) free(str);
	}
	else 
	{
		for(i=0;i<numberOfGeometries;i++)
		{
			energies[i] = 1e30;
			if(!geometries[i]) continue;
			energies[i] = geometries[i]->klass->calculateEnergyTmp (geometries[i], &geometries[i]->molecule );
		}

	}

	/*  sort by energies */
	{
//#ifdef DEBUG
		fprintf(logfile, "begin sort geometry rank = %d\n",rank);
		fflush(logfile);
//#endif
		sortGeometries(numberOfGeometries, geometries, energies);
//#ifdef DEBUG
		fprintf(logfile, "end sort geometry rank = %d\n",rank);
		fflush(logfile);
//#endif
		removeIdenticalGeometries(&numberOfGeometries, &geometries, &energies,tolEnergy,tolDistance);
//#ifdef DEBUG
		fprintf(logfile, "end removeIdenticalGeometries geometry rank = %d, numberOfGeometries= %d\n",rank, numberOfGeometries);
		fflush(logfile);
//#endif
	}
	if(nproc==1)
	{
		numberOfGeometriesAll = numberOfGeometries;
		geometriesAll = geometries;
		energiesAll = energies;
	}
	else
	{
//#ifdef DEBUG
		fprintf(logfile, "MolecularMechanicsDynamicsREMDConfoDlg Rank#=%d  nproc = %d\n", rank, nproc );
//#endif
		if(rank==0) 
		numberOfGeometriesAll = collectGeometriesFromProcessors(nproc, geometriesAll, numberOfGeometriesMax, energiesAll, geometries, numberOfGeometries, energies,  coords,  enerDum, &forceField,tolEnergy,tolDistance);
		else sendGeometriesToMaster(rank, geometries, numberOfGeometries, energies,  coords, forceField.molecule.nAtoms);
		fprintf(logfile, "End collect&send nGeoms = %d\n", numberOfGeometriesAll );
		fflush(logfile);
	}
	if(rank==0 && saveConfoGeometries(numberOfGeometriesAll, geometriesAll, energiesAll, fileNameGeom))
	{
		sprintf(message,"Created files :\n");
		createPostProcessingFiles(numberOfGeometriesAll, geometriesAll,energiesAll,fileNameGeom, mopacKeywordsPost, gaussianKeywordsPost, fireflyKeywordsPost, orcaKeywordsPost, cchemiKeywordsPost, message, mopacCommand, gaussianCommand, fireflyCommand, orcaCommand, cchemiCommand);
		strcat(message,fileNameGeom);
		strcat(message,("\n\tGeometries selected and optimized using your MM potentials"));
		strcat(message,("\n\tTo read this file through Gabedit: 'Read/CChemI file'\n\n"));
	}
	fprintf(logfile, "End saveConfoGeometries\n" );
	fflush(logfile);
	/* minimazation by mopac*/
	if(optMopac)
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		char* keys = strdup_printf("%s XYZ",optMopacMethod);
		if(runMopacFiles(numberOfGeometries, geometries, energies, fileNamePrefix, keys, mopacCommand) )
		{
			char* fileNameGeomMop = strdup_printf("%sMop.gab",fileNamePrefix);
			sortGeometries(numberOfGeometries, geometries, energies);
			removeIdenticalGeometries(&numberOfGeometries, &geometries, &energies,tolEnergy,tolDistance);
			if(nproc==1)
			{
				numberOfGeometriesAll = numberOfGeometries;
				geometriesAll = geometries;
				energiesAll = energies;
			}
			else
			{
				if(rank==0) 
				numberOfGeometriesAll = collectGeometriesFromProcessors(nproc, geometriesAll, numberOfGeometriesMax, energiesAll, geometries, numberOfGeometries, energies,  coords,  enerDum, &forceField, tolEnergy,tolDistance);
				else sendGeometriesToMaster(rank, geometries, numberOfGeometries, energies,  coords, forceField.molecule.nAtoms);
			}
			if(rank==0 && saveConfoGeometries(numberOfGeometriesAll, geometriesAll, energiesAll, fileNameGeomMop))
			{
				createPostProcessingFiles(numberOfGeometriesAll, geometriesAll,energiesAll,fileNameGeomMop, mopacKeywordsPost, gaussianKeywordsPost, fireflyKeywordsPost, orcaKeywordsPost, cchemiKeywordsPost, message, mopacCommand, gaussianCommand, fireflyCommand, orcaCommand, cchemiCommand);
				strcat(message,fileNameGeomMop);
				strcat(message,("\n\tGeometries after minimization by Mopac/"));
				strcat(message,optMopacMethod);
				strcat(message,("\n\tTo read this file through Gabedit : 'Read/CChemI file'\n\n"));
			}

			free(fileNameGeomMop);
		}
		if(fileNamePrefix) free(fileNamePrefix);
	}
	/* minimazation by FireFly*/
	if(optFireFly)
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		char* keys = strdup_printf("RUNTYP=Optimize GBASIS=%s",optFireFlyMethod);
		if(runFireFlyFiles(numberOfGeometries, geometries, energies, fileNamePrefix, keys,fireflyCommand) )
		{
			char* fileNameGeomFireFly = strdup_printf("%sFireFly.gab",fileNamePrefix);
			sortGeometries(numberOfGeometries, geometries, energies);
			removeIdenticalGeometries(&numberOfGeometries, &geometries, &energies,tolEnergy,tolDistance);
			if(nproc==1)
			{
				numberOfGeometriesAll = numberOfGeometries;
				geometriesAll = geometries;
				energiesAll = energies;
			}
			else
			{
				if(rank==0) numberOfGeometriesAll = collectGeometriesFromProcessors(nproc, geometriesAll, numberOfGeometriesMax, energiesAll, geometries, numberOfGeometries, energies,  coords,  enerDum, &forceField, tolEnergy,tolDistance);
				else sendGeometriesToMaster(rank, geometries, numberOfGeometries, energies,  coords, forceField.molecule.nAtoms);
			}
			if(rank==0 && saveConfoGeometries(numberOfGeometriesAll, geometriesAll, energiesAll, fileNameGeomFireFly))
			{
				createPostProcessingFiles(numberOfGeometriesAll, geometriesAll,energiesAll, fileNameGeomFireFly, mopacKeywordsPost, gaussianKeywordsPost, fireflyKeywordsPost, orcaKeywordsPost, cchemiKeywordsPost, message, mopacCommand, gaussianCommand, fireflyCommand, orcaCommand, cchemiCommand);
				strcat(message,fileNameGeomFireFly);
				strcat(message,("\n\tGeometries after minimization by FireFly"));
				strcat(message,("\n\tTo read this file through Gabedit : 'Read/CChemI file'\n\n"));
			}

			free(fileNameGeomFireFly);
		}
		if(fileNamePrefix) free(fileNamePrefix);
	}
	/* minimazation by Gaussian*/
	if(optGaussian)
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		char* keys = strdup_printf("%s Opt",optGaussianMethod);
		if(runGaussianFiles(numberOfGeometries, geometries, energies, fileNamePrefix, keys,orcaCommand) )
		{
			char* fileNameGeomGaussian = strdup_printf("%sGaussian.gab",fileNamePrefix);
			sortGeometries(numberOfGeometries, geometries, energies);
			removeIdenticalGeometries(&numberOfGeometries, &geometries, &energies,tolEnergy,tolDistance);
			if(saveConfoGeometries(numberOfGeometries, geometries, energies, fileNameGeomGaussian))
			{
				createPostProcessingFiles(numberOfGeometriesAll, geometriesAll,energiesAll, fileNameGeomGaussian, mopacKeywordsPost, gaussianKeywordsPost, fireflyKeywordsPost, orcaKeywordsPost, cchemiKeywordsPost, message, mopacCommand, gaussianCommand, fireflyCommand, orcaCommand, cchemiCommand);
				strcat(message,fileNameGeomGaussian);
				strcat(message,("\n\tGeometries after minimization by Gaussian"));
				strcat(message,("\n\tTo read this file through Gabedit : 'Read/CChemI file'\n\n"));
			}

			free(fileNameGeomGaussian);
		}
		if(fileNamePrefix) free(fileNamePrefix);
	}
	/* minimazation by Orca*/
	if(optOrca)
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		char* keys = strdup_printf("%s Opt",optOrcaMethod);
		if(runOrcaFiles(numberOfGeometries, geometries, energies, fileNamePrefix, keys,orcaCommand) )
		{
			char* fileNameGeomOrca = strdup_printf("%sOrca.gab",fileNamePrefix);
			sortGeometries(numberOfGeometries, geometries, energies);
			removeIdenticalGeometries(&numberOfGeometries, &geometries, &energies,tolEnergy,tolDistance);
			if(saveConfoGeometries(numberOfGeometries, geometries, energies, fileNameGeomOrca))
			{
				createPostProcessingFiles(numberOfGeometriesAll, geometriesAll,energiesAll, fileNameGeomOrca, mopacKeywordsPost, gaussianKeywordsPost, fireflyKeywordsPost, orcaKeywordsPost, cchemiKeywordsPost, message, mopacCommand, gaussianCommand, fireflyCommand, orcaCommand, cchemiCommand);
				strcat(message,fileNameGeomOrca);
				strcat(message,("\n\tGeometries after minimization by Orca"));
				strcat(message,("\n\tTo read this file through Gabedit : 'Read/CChemI file'\n\n"));
			}

			free(fileNameGeomOrca);
		}
		if(fileNamePrefix) free(fileNamePrefix);
	}

	fprintf(logfile, "Begin freegeometriesAll\n" );
	fflush(logfile);
	if(geometriesAll && geometriesAll!=geometries)
	{
		for(i=0;i<numberOfGeometriesAll;i++)
			if(geometriesAll[i]) freeForceField(geometriesAll[i]);
		free(geometriesAll);
	}
	fprintf(logfile, "End freegeometriesAll\n" );
	fflush(logfile);
	if(energiesAll && energiesAll!= energies)
	{
		free(energiesAll);
	}
	fprintf(logfile, "End free energiesAll\n" );
	fflush(logfile);

	if(geometries)
	{
		for(i=0;i<numberOfGeometries;i++)
			if(geometries[i]) freeForceField(geometries[i]);
		free(geometries);
	}
	if(energies) free(energies);
	fprintf(logfile, "%s\n",message);
	if(logfile!=stdout) fclose(logfile);
	fclose(file);
	freeForceField(&forceField);
}
/*****************************************************************************/
void molecularMechanicsDynamicsConfoDlg(char* inputFileName)
{
	ForceField forceField; 
	ForceFieldOptions forceFieldOptions;
	MolecularDynamics molecularDynamics;
	int updateFrequency = 1;
	double heatTime;
	double equiTime;
	double runTime;
	double coolTime;
	double heatTemp; 
	double equiTemp; 
	double runTemp; 
	double coolTemp; 
	double stepSize;
	MDIntegratorType integrator = VERLET;
	char* fileNameGeom = NULL;
	char* fileNameTraj = NULL;
	char* fileNameProp = NULL;
	char* mopacKeywordsPost = NULL;
	char* gaussianKeywordsPost = NULL;
	char* fireflyKeywordsPost = NULL;
	char* orcaKeywordsPost = NULL;
	char* cchemiKeywordsPost = NULL;
	double friction=-1;
	double omegaMax = 4000;
	int Nf = 50;
	double collide = 20;
	double qNH = 20;
	MDThermostatType thermostat = NONE;
	int numberOfGeometries = 2;
	ForceField** geometries = NULL; 
	double* energies = NULL;
	boolean optMM = FALSE;
	boolean optMopac = FALSE;
	boolean optGaussian = FALSE;
	boolean optFireFly = FALSE;
	boolean optOrca = FALSE;
	char* optMopacMethod=strdup("PM6");
	char* optGaussianMethod=strdup("AM1");
	char* optFireFlyMethod=strdup("AM1");
	char* optOrcaMethod=strdup("AM1");
	Molecule mol = *(readMolecule(inputFileName,TRUE));

	QuasiNewton quasiNewton;
	ConjugateGradientOptions conjugateGradientOptions;
	SteepestDescent steepestDescent;
	ConjugateGradient conjugateGradient;
	int i;
	char message[BSIZE]="Created files :\n";
	double tolEnergy = -1;
	double tolDistance = -1;
	char* mopacCommand = strdup("mopac");
	char* gaussianCommand=strdup("g03"); 
	char* orcaCommand=strdup("orca"); 
	char* fireflyCommand=strdup("firefly");
	char* cchemiCommand=strdup("cchemi");
	FILE* file = fopen(inputFileName,"rb");
	char* optimizerType= strdup("QuasiNewton");

	setForceFieldOptions(file, &forceFieldOptions);
	mol.klass->buildMMTypes(&mol, file);

	setMDOptions(file, &updateFrequency, 
		&heatTime, &equiTime, &runTime, &coolTime,
		&heatTemp, &runTemp, &equiTemp, &coolTemp, &stepSize, 
		&integrator, &thermostat, &friction,  &omegaMax, &Nf, &collide,&qNH);
	readOneString(file,"mopacCommand",&mopacCommand);
	readOneString(file,"gaussianCommand",&gaussianCommand);
	readOneString(file,"fireflyCommand",&fireflyCommand);
	readOneString(file,"cchemiCommand",&cchemiCommand);
	readOneString(file,"orcaCommand",&orcaCommand);
	readOneReal(file,"tolEnergy",&tolEnergy);
	readOneReal(file,"tolDistance",&tolDistance);
	readOneBoolean(file,"ConfoOptMM",&optMM);
	readOneBoolean(file,"ConfoOptMopac",&optMopac);
	readOneString(file,"ConfoOptMopacMethod",&optMopacMethod);
	readOneBoolean(file,"ConfoOptGaussian",&optGaussian);
	readOneString(file,"ConfoOptGaussianMethod",&optGaussianMethod);
	readOneBoolean(file,"ConfoOptFireFly",&optFireFly);
	readOneString(file,"ConfoOptFireFlyMethod",&optFireFlyMethod);
	readOneBoolean(file,"ConfoOptOrac",&optOrca);
	readOneString(file,"ConfoOptOrcaMethod",&optOrcaMethod);

	readOneString(file,"mopacKeywordsPost",&mopacKeywordsPost);
	readOneString(file,"gaussianKeywordsPost",&gaussianKeywordsPost);
	readOneString(file,"fireflyKeywordsPost",&fireflyKeywordsPost);
	readOneString(file,"cchemiKeywordsPost",&cchemiKeywordsPost);
	readOneString(file,"orcaKeywordsPost",&orcaKeywordsPost);
	optimizerType = setOptOptions(file, &conjugateGradientOptions, &quasiNewton);
	if(strstr(optimizerType,"External")  && (optMopac||optFireFly || optGaussian || optOrca))
	{
		printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		printf("Sorry, The optimization using the internal optimizer after a MD conformational search is not yes implemented in this software\n");
		printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		exit(1);
	}
	/* number for geometries */
	{
		numberOfGeometries = 10;
		readOneInt(file,"numberOfGeometries",&numberOfGeometries);
		if(numberOfGeometries<2) numberOfGeometries = 2;
	}
	/* fileName for geometries */
	{
		char* suff = getSuffixNameFile(inputFileName);
		fileNameGeom = strdup_printf("%s%s",suff, "Geoms.gab");
		fileNameTraj = strdup_printf("%s%s",suff, "Traj.gab");
		fileNameProp = strdup_printf("%s%s",suff, "Prop.txt");
		free(suff);
	}

/* Optimsation options */ 

	/* Molecule to read */
	if(forceFieldOptions.type==AMBER) forceField = createAmberModel(&mol,forceFieldOptions, stdout);
	else if(forceFieldOptions.type==PAIRWISE) forceField = createPairWiseModel(&mol,forceFieldOptions, stdout);
	setH4CorrectionMM(file, &forceField);
	checkWallCorrection(file, &forceField);


	geometries = runMolecularDynamicsConfo(&molecularDynamics, &forceField,
		updateFrequency, heatTime, equiTime, runTime, heatTemp, equiTemp, runTemp, stepSize, 
		integrator, thermostat, friction, omegaMax, Nf, collide, qNH, numberOfGeometries, fileNameTraj, fileNameProp);
	printf("End runMolecularDynamicsConfo\n");

	freeForceField(&forceField);
	if(geometries && numberOfGeometries>0) energies = malloc(numberOfGeometries*sizeof(double));

	if(geometries && optMM)
	for(i=0;i<numberOfGeometries;i++)
	{
		char* str = NULL;
		energies[i] = 1e30;
		if(!geometries[i]) continue;
		if(str) free(str);
		str = strdup_printf("Minimization of geometry number %d\n", i+1);
		printf("%s",str);
		if(str) free(str);


		if(strstr(optimizerType,"Grad"))
		{
			conjugateGradient.logfile= stdout;
			runConjugateGradient(&conjugateGradient, geometries[i], conjugateGradientOptions); 
			energies[i] = conjugateGradient.forceField->klass->calculateEnergyTmp
				(conjugateGradient.forceField, &conjugateGradient.forceField->molecule );
			freeConjugateGradient(&conjugateGradient);
		}
		else if(strstr(optimizerType,"Quasi"))
		{
			QuasiNewton tmpQuasiNewton = quasiNewton;
			tmpQuasiNewton.forceField = geometries[i];
                	tmpQuasiNewton.logfile = stdout;
                	runQuasiNewton(&tmpQuasiNewton);
			energies[i] = tmpQuasiNewton.forceField->klass->calculateEnergyTmp
				(tmpQuasiNewton.forceField, &tmpQuasiNewton.forceField->molecule );
			freeQuasiNewton(&tmpQuasiNewton);

		}
		else
		{
			steepestDescent.logfile= stdout;
			runSteepestDescent(&steepestDescent, geometries[i],
			       	conjugateGradientOptions.updateFrequency,
			       conjugateGradientOptions.maxIterations,
			       conjugateGradientOptions.gradientNorm,
			       conjugateGradientOptions.maxLines);
			energies[i] = steepestDescent.forceField->klass->calculateEnergyTmp
				(steepestDescent.forceField, &steepestDescent.forceField->molecule );
			freeSteepestDescent(&steepestDescent);
		}
	}
	else 
	{
		for(i=0;i<numberOfGeometries;i++)
		{
			energies[i] = 1e30;
			if(!geometries[i]) continue;
			energies[i] = geometries[i]->klass->calculateEnergyTmp
				(geometries[i], &geometries[i]->molecule );
		}

	}

	/*  sort by energies */
	{
		printf("sortGeometries\n");
		sortGeometries(numberOfGeometries, geometries, energies);
		printf("removeIdenticalGeometries\n");
		removeIdenticalGeometries(&numberOfGeometries, &geometries, &energies,tolEnergy,tolDistance);
	}
	printf("fileNameGeom = %s\n",fileNameGeom);
	if(saveConfoGeometries(numberOfGeometries, geometries, energies, fileNameGeom))
	{
		createPostProcessingFiles(numberOfGeometries, geometries,energies, fileNameGeom, mopacKeywordsPost, gaussianKeywordsPost, fireflyKeywordsPost, orcaKeywordsPost, cchemiKeywordsPost, message, mopacCommand, gaussianCommand, fireflyCommand, orcaCommand, cchemiCommand);
		strcat(message,fileNameGeom);
		strcat(message,("\n\tGeometries selected and optimized using your MM potentials"));
		strcat(message,("\n\tTo read this file through Gabedit: 'Read/CChemI file'\n\n"));
	}
	/* minimazation by mopac*/
	if(optMopac)
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		char* keys = strdup_printf("%s XYZ",optMopacMethod);
		if(runMopacFiles(numberOfGeometries, geometries, energies, fileNamePrefix, keys, mopacCommand) )
		{
			char* fileNameGeomMop = strdup_printf("%sMop.gab",fileNamePrefix);
			sortGeometries(numberOfGeometries, geometries, energies);
			removeIdenticalGeometries(&numberOfGeometries, &geometries, &energies,tolEnergy,tolDistance);
			if(saveConfoGeometries(numberOfGeometries, geometries, energies, fileNameGeomMop))
			{
				createPostProcessingFiles(numberOfGeometries, geometries,energies, fileNameGeomMop, mopacKeywordsPost, gaussianKeywordsPost, fireflyKeywordsPost, orcaKeywordsPost, cchemiKeywordsPost, message, mopacCommand, gaussianCommand, fireflyCommand, orcaCommand, cchemiCommand);
				strcat(message,fileNameGeomMop);
				strcat(message,("\n\tGeometries after minimization by Mopac/"));
				strcat(message,optMopacMethod);
				strcat(message,("\n\tTo read this file through Gabedit : 'Read/CChemI file'\n\n"));
			}

			free(fileNameGeomMop);
		}
		if(fileNamePrefix) free(fileNamePrefix);
	}
	/* minimazation by FireFly*/
	if(optFireFly)
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		char* keys = strdup_printf("RUNTYP=Optimize GBASIS=%s",optFireFlyMethod);
		if(runFireFlyFiles(numberOfGeometries, geometries, energies, fileNamePrefix, keys,fireflyCommand) )
		{
			char* fileNameGeomFireFly = strdup_printf("%sFireFly.gab",fileNamePrefix);
			sortGeometries(numberOfGeometries, geometries, energies);
			removeIdenticalGeometries(&numberOfGeometries, &geometries, &energies,tolEnergy,tolDistance);
			if(saveConfoGeometries(numberOfGeometries, geometries, energies, fileNameGeomFireFly))
			{
				createPostProcessingFiles(numberOfGeometries, geometries,energies, fileNameGeomFireFly, mopacKeywordsPost, gaussianKeywordsPost, fireflyKeywordsPost, orcaKeywordsPost, cchemiKeywordsPost, message, mopacCommand, gaussianCommand, fireflyCommand, orcaCommand, cchemiCommand);
				strcat(message,fileNameGeomFireFly);
				strcat(message,("\n\tGeometries after minimization by FireFly"));
				strcat(message,("\n\tTo read this file through Gabedit : 'Read/CChemI file'\n\n"));
			}

			free(fileNameGeomFireFly);
		}
		if(fileNamePrefix) free(fileNamePrefix);
	}
	/* minimazation by Orca*/
	if(optOrca)
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		char* keys = strdup_printf("%s Opt",optOrcaMethod);
		if(runOrcaFiles(numberOfGeometries, geometries, energies, fileNamePrefix, keys,fireflyCommand) )
		{
			char* fileNameGeomOrca = strdup_printf("%sOrca.gab",fileNamePrefix);
			sortGeometries(numberOfGeometries, geometries, energies);
			removeIdenticalGeometries(&numberOfGeometries, &geometries, &energies,tolEnergy,tolDistance);
			if(saveConfoGeometries(numberOfGeometries, geometries, energies, fileNameGeomOrca))
			{
				createPostProcessingFiles(numberOfGeometries, geometries,energies, fileNameGeomOrca, mopacKeywordsPost, gaussianKeywordsPost, fireflyKeywordsPost, orcaKeywordsPost, cchemiKeywordsPost, message, mopacCommand, gaussianCommand, fireflyCommand, orcaCommand, cchemiCommand);
				strcat(message,fileNameGeomOrca);
				strcat(message,("\n\tGeometries after minimization by Orca"));
				strcat(message,("\n\tTo read this file through Gabedit : 'Read/CChemI file'\n\n"));
			}

			free(fileNameGeomOrca);
		}
		if(fileNamePrefix) free(fileNamePrefix);
	}
	/* minimazation by Gaussian*/
	if(optGaussian)
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		char* keys = strdup_printf("%s Opt",optGaussianMethod);
		if(runGaussianFiles(numberOfGeometries, geometries, energies, fileNamePrefix, keys,fireflyCommand) )
		{
			char* fileNameGeomGaussian = strdup_printf("%sGaussian.gab",fileNamePrefix);
			sortGeometries(numberOfGeometries, geometries, energies);
			removeIdenticalGeometries(&numberOfGeometries, &geometries, &energies,tolEnergy,tolDistance);
			if(saveConfoGeometries(numberOfGeometries, geometries, energies, fileNameGeomGaussian))
			{
				createPostProcessingFiles(numberOfGeometries, geometries,energies, fileNameGeomGaussian, mopacKeywordsPost, gaussianKeywordsPost, fireflyKeywordsPost, orcaKeywordsPost, cchemiKeywordsPost, message, mopacCommand, gaussianCommand, fireflyCommand, orcaCommand, cchemiCommand);
				strcat(message,fileNameGeomGaussian);
				strcat(message,("\n\tGeometries after minimization by Gaussian"));
				strcat(message,("\n\tTo read this file through Gabedit : 'Read/CChemI file'\n\n"));
			}

			free(fileNameGeomGaussian);
		}
		if(fileNamePrefix) free(fileNamePrefix);
	}

	if(geometries)
	{
		for(i=0;i<numberOfGeometries;i++)
			if(geometries[i]) freeForceField(geometries[i]);
		free(geometries);
	}
	if(energies) free(energies);
	printf("%s\n",message);
	fclose(file);
}
/***********************************************************************************************************************/
static ForceField** getMolecularMechanicsRDConfo(ForceField* forceField, int numberOfGeometries)
{
	int i;
	char* str = NULL;
	ForceField** geometries = NULL;

	if(forceField->molecule.nAtoms<1) return NULL;
	if(numberOfGeometries<2) return NULL;
	geometries = malloc(numberOfGeometries*sizeof(ForceField*));
	for (i = 0; i < numberOfGeometries; i++ )
	{
		geometries[i] = NULL;
		if(i>0) forceField->molecule.klass->setRandomPositions(&forceField->molecule);
		forceField->klass->calculateEnergy(forceField);
		if(str) free(str);
		str = strdup_printf(("Geometry # %d Potential energy =  %0.4f"), i+1, forceField->molecule.potentialEnergy);
		printf("%s\n",str);
		geometries[i] = malloc(sizeof(ForceField));
		*geometries[i] = copyForceField(forceField);
	}
	if(str) free(str);
	return geometries;
}
/*****************************************************************************/
void molecularMechanicsRandomConfoDlg(char* inputFileName)
{
	ForceField forceField; 
	ForceFieldOptions forceFieldOptions;
	int updateFrequency = 1;
	double heatTime;
	double equiTime;
	double runTime;
	double coolTime;
	double heatTemp; 
	double equiTemp; 
	double runTemp; 
	double coolTemp; 
	double stepSize;
	MDIntegratorType integrator = VERLET;
	char* fileNameGeom = NULL;
	//char* fileNameTraj = NULL;
	//char* fileNameProp = NULL;
	char* mopacKeywordsPost = NULL;
	char* gaussianKeywordsPost = NULL;
	char* fireflyKeywordsPost = NULL;
	char* orcaKeywordsPost = NULL;
	char* cchemiKeywordsPost = NULL;
	double friction=-1;
	double omegaMax = 4000;
	int Nf = 50;
	double collide = 20;
	double qNH = 20;
	MDThermostatType thermostat = NONE;
	int numberOfGeometries = 2;
	ForceField** geometries = NULL; 
	double* energies = NULL;
	boolean optMM = FALSE;
	boolean optMopac = FALSE;
	boolean optGaussian = FALSE;
	boolean optFireFly = FALSE;
	boolean optOrca = FALSE;
	char* optMopacMethod=strdup("PM6");
	char* optGaussianMethod=strdup("AM1");
	char* optFireFlyMethod=strdup("AM1");
	char* optOrcaMethod=strdup("AM1");
	Molecule mol = *(readMolecule(inputFileName,TRUE));

	QuasiNewton quasiNewton;
	ConjugateGradientOptions conjugateGradientOptions;
	SteepestDescent steepestDescent;
	ConjugateGradient conjugateGradient;
	int i;
	char message[BSIZE]="Created files :\n";
	double tolEnergy = -1;
	double tolDistance = -1;
	char* mopacCommand = strdup("mopac");
	char* gaussianCommand=strdup("g03"); 
	char* orcaCommand=strdup("orca"); 
	char* fireflyCommand=strdup("firefly");
	char* cchemiCommand=strdup("cchemi");
	FILE* file = fopen(inputFileName,"rb");
	char* optimizerType= strdup("QuasiNewton");

	setForceFieldOptions(file, &forceFieldOptions);
	mol.klass->buildMMTypes(&mol, file);

	setMDOptions(file, &updateFrequency, 
		&heatTime, &equiTime, &runTime, &coolTime,
		&heatTemp, &runTemp, &equiTemp, &coolTemp, &stepSize, 
		&integrator, &thermostat, &friction,  &omegaMax, &Nf, &collide,&qNH);
	readOneString(file,"mopacCommand",&mopacCommand);
	readOneString(file,"gaussianCommand",&gaussianCommand);
	readOneString(file,"fireflyCommand",&fireflyCommand);
	readOneString(file,"cchemiCommand",&cchemiCommand);
	readOneString(file,"orcaCommand",&orcaCommand);
	readOneReal(file,"tolEnergy",&tolEnergy);
	readOneReal(file,"tolDistance",&tolDistance);
	readOneBoolean(file,"ConfoOptMM",&optMM);
	readOneBoolean(file,"ConfoOptMopac",&optMopac);
	readOneString(file,"ConfoOptMopacMethod",&optMopacMethod);
	readOneBoolean(file,"ConfoOptGaussian",&optGaussian);
	readOneString(file,"ConfoOptGaussianMethod",&optGaussianMethod);
	readOneBoolean(file,"ConfoOptFireFly",&optFireFly);
	readOneString(file,"ConfoOptFireFlyMethod",&optFireFlyMethod);
	readOneBoolean(file,"ConfoOptOrac",&optOrca);
	readOneString(file,"ConfoOptOrcaMethod",&optOrcaMethod);

	readOneString(file,"mopacKeywordsPost",&mopacKeywordsPost);
	readOneString(file,"gaussianKeywordsPost",&gaussianKeywordsPost);
	readOneString(file,"fireflyKeywordsPost",&fireflyKeywordsPost);
	readOneString(file,"cchemiKeywordsPost",&cchemiKeywordsPost);
	readOneString(file,"orcaKeywordsPost",&orcaKeywordsPost);
	optimizerType = setOptOptions(file, &conjugateGradientOptions, &quasiNewton);
	if(strstr(optimizerType,"External")  && (optMopac||optFireFly || optGaussian || optOrca))
	{
		printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		printf("Sorry, The optimization using the internal optimizer after a MD conformational search is not yes implemented in this software\n");
		printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		exit(1);
	}
	/* number for geometries */
	{
		numberOfGeometries = 10;
		readOneInt(file,"numberOfGeometries",&numberOfGeometries);
		if(numberOfGeometries<2) numberOfGeometries = 2;
	}
	/* fileName for geometries */
	{
		char* suff = getSuffixNameFile(inputFileName);
		fileNameGeom = strdup_printf("%s%s",suff, "Geoms.gab");
		//fileNameTraj = strdup_printf("%s%s",suff, "Traj.gab");
		//fileNameProp = strdup_printf("%s%s",suff, "Prop.txt");
		free(suff);
	}

/* Optimsation options */ 

	/* Molecule to read */
	if(forceFieldOptions.type==AMBER) forceField = createAmberModel(&mol,forceFieldOptions, stdout);
	else if(forceFieldOptions.type==PAIRWISE) forceField = createPairWiseModel(&mol,forceFieldOptions, stdout);
	setH4CorrectionMM(file, &forceField);
	checkWallCorrection(file, &forceField);


	geometries = getMolecularMechanicsRDConfo(&forceField, numberOfGeometries);
	printf("End getMolecularMechanicsRDConfo\n");

	freeForceField(&forceField);
	if(geometries && numberOfGeometries>0) energies = malloc(numberOfGeometries*sizeof(double));

	if(geometries && optMM)
	for(i=0;i<numberOfGeometries;i++)
	{
		char* str = NULL;
		energies[i] = 1e30;
		if(!geometries[i]) continue;
		if(str) free(str);
		str = strdup_printf("Minimization of geometry number %d\n", i+1);
		printf("%s",str);
		if(str) free(str);


		if(strstr(optimizerType,"Grad"))
		{
			conjugateGradient.logfile= stdout;
			runConjugateGradient(&conjugateGradient, geometries[i], conjugateGradientOptions); 
			energies[i] = conjugateGradient.forceField->klass->calculateEnergyTmp
				(conjugateGradient.forceField, &conjugateGradient.forceField->molecule );
			freeConjugateGradient(&conjugateGradient);
		}
		else if(strstr(optimizerType,"Quasi"))
		{
			QuasiNewton tmpQuasiNewton = quasiNewton;
			tmpQuasiNewton.forceField = geometries[i];
                	tmpQuasiNewton.logfile = stdout;
                	runQuasiNewton(&tmpQuasiNewton);
			energies[i] = tmpQuasiNewton.forceField->klass->calculateEnergyTmp
				(tmpQuasiNewton.forceField, &tmpQuasiNewton.forceField->molecule );
			freeQuasiNewton(&tmpQuasiNewton);

		}
		else
		{
			steepestDescent.logfile= stdout;
			runSteepestDescent(&steepestDescent, geometries[i],
			       	conjugateGradientOptions.updateFrequency,
			       conjugateGradientOptions.maxIterations,
			       conjugateGradientOptions.gradientNorm,
			       conjugateGradientOptions.maxLines);
			energies[i] = steepestDescent.forceField->klass->calculateEnergyTmp
				(steepestDescent.forceField, &steepestDescent.forceField->molecule );
			freeSteepestDescent(&steepestDescent);
		}
	}
	else 
	{
		for(i=0;i<numberOfGeometries;i++)
		{
			energies[i] = 1e30;
			if(!geometries[i]) continue;
			energies[i] = geometries[i]->klass->calculateEnergyTmp
				(geometries[i], &geometries[i]->molecule );
		}

	}

	/*  sort by energies */
	{
		printf("sortGeometries\n");
		sortGeometries(numberOfGeometries, geometries, energies);
		printf("removeIdenticalGeometries\n");
		removeIdenticalGeometries(&numberOfGeometries, &geometries, &energies,tolEnergy,tolDistance);
	}
	printf("fileNameGeom = %s\n",fileNameGeom);
	if(saveConfoGeometries(numberOfGeometries, geometries, energies, fileNameGeom))
	{
		createPostProcessingFiles(numberOfGeometries, geometries,energies, fileNameGeom, mopacKeywordsPost, gaussianKeywordsPost, fireflyKeywordsPost, orcaKeywordsPost, cchemiKeywordsPost, message, mopacCommand, gaussianCommand, fireflyCommand, orcaCommand, cchemiCommand);
		strcat(message,fileNameGeom);
		strcat(message,("\n\tGeometries selected and optimized using your MM potentials"));
		strcat(message,("\n\tTo read this file through Gabedit: 'Read/CChemI file'\n\n"));
	}
	/* minimazation by mopac*/
	if(optMopac)
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		char* keys = strdup_printf("%s XYZ",optMopacMethod);
		if(runMopacFiles(numberOfGeometries, geometries, energies, fileNamePrefix, keys, mopacCommand) )
		{
			char* fileNameGeomMop = strdup_printf("%sMop.gab",fileNamePrefix);
			sortGeometries(numberOfGeometries, geometries, energies);
			removeIdenticalGeometries(&numberOfGeometries, &geometries, &energies,tolEnergy,tolDistance);
			if(saveConfoGeometries(numberOfGeometries, geometries, energies, fileNameGeomMop))
			{
				createPostProcessingFiles(numberOfGeometries, geometries,energies, fileNameGeomMop, mopacKeywordsPost, gaussianKeywordsPost, fireflyKeywordsPost, orcaKeywordsPost, cchemiKeywordsPost, message, mopacCommand, gaussianCommand, fireflyCommand, orcaCommand, cchemiCommand);
				strcat(message,fileNameGeomMop);
				strcat(message,("\n\tGeometries after minimization by Mopac/"));
				strcat(message,optMopacMethod);
				strcat(message,("\n\tTo read this file through Gabedit : 'Read/CChemI file'\n\n"));
			}

			free(fileNameGeomMop);
		}
		if(fileNamePrefix) free(fileNamePrefix);
	}
	/* minimazation by FireFly*/
	if(optFireFly)
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		char* keys = strdup_printf("RUNTYP=Optimize GBASIS=%s",optFireFlyMethod);
		if(runFireFlyFiles(numberOfGeometries, geometries, energies, fileNamePrefix, keys,fireflyCommand) )
		{
			char* fileNameGeomFireFly = strdup_printf("%sFireFly.gab",fileNamePrefix);
			sortGeometries(numberOfGeometries, geometries, energies);
			removeIdenticalGeometries(&numberOfGeometries, &geometries, &energies,tolEnergy,tolDistance);
			if(saveConfoGeometries(numberOfGeometries, geometries, energies, fileNameGeomFireFly))
			{
				createPostProcessingFiles(numberOfGeometries, geometries,energies, fileNameGeomFireFly, mopacKeywordsPost, gaussianKeywordsPost, fireflyKeywordsPost, orcaKeywordsPost, cchemiKeywordsPost, message, mopacCommand, gaussianCommand, fireflyCommand, orcaCommand, cchemiCommand);
				strcat(message,fileNameGeomFireFly);
				strcat(message,("\n\tGeometries after minimization by FireFly"));
				strcat(message,("\n\tTo read this file through Gabedit : 'Read/CChemI file'\n\n"));
			}

			free(fileNameGeomFireFly);
		}
		if(fileNamePrefix) free(fileNamePrefix);
	}
	/* minimazation by Orca*/
	if(optOrca)
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		char* keys = strdup_printf("%s Opt",optOrcaMethod);
		if(runOrcaFiles(numberOfGeometries, geometries, energies, fileNamePrefix, keys,fireflyCommand) )
		{
			char* fileNameGeomOrca = strdup_printf("%sOrca.gab",fileNamePrefix);
			sortGeometries(numberOfGeometries, geometries, energies);
			removeIdenticalGeometries(&numberOfGeometries, &geometries, &energies,tolEnergy,tolDistance);
			if(saveConfoGeometries(numberOfGeometries, geometries, energies, fileNameGeomOrca))
			{
				createPostProcessingFiles(numberOfGeometries, geometries,energies, fileNameGeomOrca, mopacKeywordsPost, gaussianKeywordsPost, fireflyKeywordsPost, orcaKeywordsPost, cchemiKeywordsPost, message, mopacCommand, gaussianCommand, fireflyCommand, orcaCommand, cchemiCommand);
				strcat(message,fileNameGeomOrca);
				strcat(message,("\n\tGeometries after minimization by Orca"));
				strcat(message,("\n\tTo read this file through Gabedit : 'Read/CChemI file'\n\n"));
			}

			free(fileNameGeomOrca);
		}
		if(fileNamePrefix) free(fileNamePrefix);
	}
	/* minimazation by Gaussian*/
	if(optGaussian)
	{
		char* fileNamePrefix = getSuffixNameFile(fileNameGeom);
		char* keys = strdup_printf("%s Opt",optGaussianMethod);
		if(runGaussianFiles(numberOfGeometries, geometries, energies, fileNamePrefix, keys,fireflyCommand) )
		{
			char* fileNameGeomGaussian = strdup_printf("%sGaussian.gab",fileNamePrefix);
			sortGeometries(numberOfGeometries, geometries, energies);
			removeIdenticalGeometries(&numberOfGeometries, &geometries, &energies,tolEnergy,tolDistance);
			if(saveConfoGeometries(numberOfGeometries, geometries, energies, fileNameGeomGaussian))
			{
				createPostProcessingFiles(numberOfGeometries, geometries,energies, fileNameGeomGaussian, mopacKeywordsPost, gaussianKeywordsPost, fireflyKeywordsPost, orcaKeywordsPost, cchemiKeywordsPost, message, mopacCommand, gaussianCommand, fireflyCommand, orcaCommand, cchemiCommand);
				strcat(message,fileNameGeomGaussian);
				strcat(message,("\n\tGeometries after minimization by Gaussian"));
				strcat(message,("\n\tTo read this file through Gabedit : 'Read/CChemI file'\n\n"));
			}

			free(fileNameGeomGaussian);
		}
		if(fileNamePrefix) free(fileNamePrefix);
	}

	if(geometries)
	{
		for(i=0;i<numberOfGeometries;i++)
			if(geometries[i]) freeForceField(geometries[i]);
		free(geometries);
	}
	if(energies) free(energies);
	printf("%s\n",message);
	fclose(file);
}
/*****************************************************************************/
void molecularMechanicsDynamicsDlg(char* inputFileName)
{
	ForceField forceField; 
	ForceFieldOptions forceFieldOptions;
	MolecularDynamics molecularDynamics;
	int updateFrequency = 1;
	double heatTime;
	double equiTime;
	double runTime;
	double coolTime; 
	double heatTemp; 
	double equiTemp; 
	double runTemp; 
	double coolTemp; 
	double stepSize;
	MDIntegratorType integrator = VERLET;
	char* fileNameTraj = NULL;
	char* fileNameProp = NULL;
	double friction=-1;
	double omegaMax = 4000;
	int Nf = 50;
	double collide = 20;
	double qNH = 20;
	Molecule* mol = readMolecule(inputFileName,TRUE);
	MDThermostatType thermostat = NONE;
	FILE* file = fopen(inputFileName,"rb");

	setForceFieldOptions(file, &forceFieldOptions);
	mol->klass->buildMMTypes(mol, file);

	setMDOptions(file, &updateFrequency, 
		&heatTime, &equiTime, &runTime, &coolTime,
		&heatTemp, &runTemp, &equiTemp, &coolTemp, &stepSize, 
		&integrator, &thermostat, &friction,  &omegaMax, &Nf, &collide,&qNH);

	{
		char* suff = getSuffixNameFile(inputFileName);
		fileNameTraj = strdup_printf("%s%s",suff, "Traj.gab");
		fileNameProp = strdup_printf("%s%s",suff, "Prop.txt");
		free(suff);
	}

	if(forceFieldOptions.type==AMBER) forceField = createAmberModel(mol,forceFieldOptions, stdout);
	else if(forceFieldOptions.type==PAIRWISE) forceField = createPairWiseModel(mol,forceFieldOptions, stdout);
	setH4CorrectionMM(file, &forceField);
	checkWallCorrection(file, &forceField);

	runMolecularDynamics(&molecularDynamics, &forceField,
		updateFrequency, heatTime, equiTime, runTime, coolTime, heatTemp, equiTemp, runTemp, coolTemp, stepSize, 
		integrator, thermostat, friction, omegaMax, Nf, collide, qNH, fileNameTraj, fileNameProp);

	freeForceField(&forceField);
	fclose(file);
}
/********************************************************************************/
void molecularMechanicsMinimizeDlg(char* inputFileName)
{
	ForceField forceField; 
	ForceFieldOptions forceFieldOptions;
	SteepestDescent steepestDescent;
	ConjugateGradient conjugateGradient;
	QuasiNewton quasiNewton;
	ConjugateGradientOptions conjugateGradientOptions;
	char* optimizerType = NULL;
	Molecule* mol = readMolecule(inputFileName,TRUE);
	FILE* file = fopen(inputFileName,"rb");
	char* fileNameOut = strdup_printf("%sOpt.gab",getSuffixNameFile(inputFileName));

	setForceFieldOptions(file, &forceFieldOptions);
	mol->klass->buildMMTypes(mol, file);
	optimizerType = setOptOptions(file, &conjugateGradientOptions, &quasiNewton);


/* Molecule to read */
	if(forceFieldOptions.type==AMBER) forceField = createAmberModel(mol,forceFieldOptions, stdout);
	else if(forceFieldOptions.type==PAIRWISE) forceField = createPairWiseModel(mol,forceFieldOptions,stdout);
	setH4CorrectionMM(file, &forceField);
	checkWallCorrection(file, &forceField);

	if(strstr(optimizerType,"Grad"))
	{
		printf("Minimization by Conjugate Gradient method\n");
		conjugateGradient.logfile= stdout;
		runConjugateGradient(&conjugateGradient, &forceField, conjugateGradientOptions); 
		printf("Optimized geometry saved in %s file\n",fileNameOut);
		forceField.molecule.klass->computeDipole(&forceField.molecule);
		forceField.molecule.klass->save(&forceField.molecule, fileNameOut);
		freeConjugateGradient(&conjugateGradient);
	}
	else if(strstr(optimizerType,"Quasi"))
	{
		printf("Minimization by QuasiNewton method\n");
		quasiNewton.forceField = &forceField; 
               	quasiNewton.logfile = stdout;
                runQuasiNewton(&quasiNewton);
		printf("Optimized geometry saved in %s file\n",fileNameOut);
		forceField.molecule.klass->computeDipole(&forceField.molecule);
		forceField.molecule.klass->save(&forceField.molecule, fileNameOut);
		freeQuasiNewton(&quasiNewton);
	}
	else
	{
		printf("Minimization by steepest descent method\n");
		steepestDescent.logfile= stdout;
		runSteepestDescent(&steepestDescent, &forceField,
			       	conjugateGradientOptions.updateFrequency,
			       conjugateGradientOptions.maxIterations,
			       conjugateGradientOptions.gradientNorm,
			       conjugateGradientOptions.maxLines);
		printf("Optimized geometry saved in %s file\n",fileNameOut);
		forceField.molecule.klass->computeDipole(&forceField.molecule);
		forceField.molecule.klass->save(&forceField.molecule, fileNameOut);
		freeSteepestDescent(&steepestDescent);
	}
	printEnergyAndGradient(&forceField);
	freeForceField(&forceField);
	fclose(file);
	free(fileNameOut);
}
/*****************************************************************************/
void molecularMechanicsEnergyDlg(char* inputFileName)
{
	ForceField forceField;
	ForceFieldOptions forceFieldOptions;
	Molecule* mol = readMolecule(inputFileName,TRUE);
	FILE* file = fopen(inputFileName,"rb");
	char* fileNameOut = strdup_printf("%s.gab",getSuffixNameFile(inputFileName));

	setForceFieldOptions(file, &forceFieldOptions);
	mol->klass->buildMMTypes(mol, file);

/* Molecule to read */
	if(forceFieldOptions.type==AMBER) forceField = createAmberModel(mol,forceFieldOptions, stdout);
	else if(forceFieldOptions.type==PAIRWISE) forceField = createPairWiseModel(mol,forceFieldOptions,stdout);
	setH4CorrectionMM(file, &forceField);
	checkWallCorrection(file, &forceField);

	printEnergyAndGradient(&forceField);
	printf("Geometry saved in %s file\n",fileNameOut);
	forceField.molecule.klass->computeDipole(&forceField.molecule);
	forceField.molecule.klass->save(&forceField.molecule, fileNameOut);
	freeForceField(&forceField);
	fclose(file);
	free(fileNameOut);
}
/*****************************************************************************/
void molecularMechanicsGradientDlg(char* inputFileName)
{
	ForceField forceField;
	ForceFieldOptions forceFieldOptions;
	Molecule* mol = readMolecule(inputFileName,TRUE);
	FILE* file = fopen(inputFileName,"rb");
	char* fileNameOut = strdup_printf("%s.gab",getSuffixNameFile(inputFileName));

	setForceFieldOptions(file, &forceFieldOptions);
	mol->klass->buildMMTypes(mol, file);

/* Molecule to read */
	if(forceFieldOptions.type==AMBER) forceField = createAmberModel(mol,forceFieldOptions, stdout);
	else if(forceFieldOptions.type==PAIRWISE) forceField = createPairWiseModel(mol,forceFieldOptions,stdout);
	setH4CorrectionMM(file, &forceField);
	checkWallCorrection(file, &forceField);

	printEnergyAndGradient(&forceField);
	printf("Geometry saved in %s file\n",fileNameOut);
	forceField.molecule.klass->computeDipole(&forceField.molecule);
	forceField.molecule.klass->save(&forceField.molecule, fileNameOut);
	freeForceField(&forceField);
	fclose(file);
	free(fileNameOut);
}
/*****************************************************************************/
void molecularMechanicsFrequenciesDlg(char* inputFileName)
{
	ForceField forceField;
	ForceFieldOptions forceFieldOptions;
	Molecule* mol = readMolecule(inputFileName,TRUE);
	FILE* file = fopen(inputFileName,"rb");
	char* fileNameOut = strdup_printf("%sFreq.gab",getSuffixNameFile(inputFileName));
	double* frequencies = NULL;
	double* reducedMasses = NULL;
	double* IRIntensities = NULL;
	double** modes = NULL;
	int nModes = 0;
	int i;

	setForceFieldOptions(file, &forceFieldOptions);
	mol->klass->buildMMTypes(mol, file);

/* Molecule to read */
	if(forceFieldOptions.type==AMBER) forceField = createAmberModel(mol,forceFieldOptions, stdout);
	else if(forceFieldOptions.type==PAIRWISE) forceField = createPairWiseModel(mol,forceFieldOptions,stdout);
	printf("Appel de setH4CorrectionMM\n");
	setH4CorrectionMM(file, &forceField);
	printf("Appel de checkWallCorrection\n");
	checkWallCorrection(file, &forceField);
	fclose(file);

	//forceField.klass->calculateEnergy(&forceField);//alrady calculated in calculateGradient
	//forceField.klass->calculateGradient(&forceField); // already in printEnergyAndGrad

	printf("Appelr de computeMMFrequencies\n");
	nModes = computeMMFrequencies(&forceField, &frequencies, & modes, &reducedMasses, &IRIntensities);
	

	printEnergyAndGradient(&forceField);
	printf("Frequencies and modes in the %s file\n",fileNameOut);
	mol->klass->saveFrequencies(mol, fileNameOut, nModes, frequencies, modes, reducedMasses, IRIntensities);
	addHarmonicVelocities(inputFileName, nModes, frequencies, modes, reducedMasses, IRIntensities);
	printHarmonicVelocities(inputFileName, nModes, frequencies, modes, reducedMasses);
	if(frequencies) free(frequencies);
	if(reducedMasses) free(reducedMasses);
	for(i=0;i<nModes;i++) free(modes[i]);
	if(modes) free(modes);
	freeForceField(&forceField);
}
/*****************************************************************************/
void molecularMechanicsOptFrequenciesDlg(char* inputFileName)
{
	ForceField forceField;
	ForceFieldOptions forceFieldOptions;
	Molecule* mol;
	FILE* file;
	char* fileNameFreq = strdup_printf("%sFreq.gab",getSuffixNameFile(inputFileName));
	char* fileNameOpt = strdup_printf("%sOpt.gab",getSuffixNameFile(inputFileName));
	double* frequencies = NULL;
	double* reducedMasses = NULL;
	double* IRIntensities = NULL;
	double** modes = NULL;
	int nModes = 0;
	int i;

	molecularMechanicsMinimizeDlg(inputFileName);

	file = fopen(inputFileName,"rb");
	setForceFieldOptions(file, &forceFieldOptions);
	mol = readMoleculeFromGabeditFile(fileNameOpt);
	mol->klass->setConnections(mol);
	mol->klass->buildMMTypes(mol, file);
	//mol = readMolecule(inputFileName,TRUE);

/* Molecule to read */
	if(forceFieldOptions.type==AMBER) forceField = createAmberModel(mol,forceFieldOptions, stdout);
	else if(forceFieldOptions.type==PAIRWISE) forceField = createPairWiseModel(mol,forceFieldOptions,stdout);
	setH4CorrectionMM(file, &forceField);
	checkWallCorrection(file, &forceField);
	fclose(file);

	nModes = computeMMFrequencies(&forceField, &frequencies, & modes, &reducedMasses, &IRIntensities);

	printEnergyAndGradient(&forceField);
	printf("Frequencies and modes in the %s file\n",fileNameFreq);
	mol->klass->saveFrequencies(mol, fileNameFreq, nModes, frequencies, modes, reducedMasses, IRIntensities);
	addHarmonicVelocities(inputFileName, nModes, frequencies, modes, reducedMasses, IRIntensities);
	printHarmonicVelocities(inputFileName, nModes, frequencies, modes, reducedMasses);
	if(frequencies) free(frequencies);
	if(reducedMasses) free(reducedMasses);
	for(i=0;i<nModes;i++) free(modes[i]);
	if(modes) free(modes);
	freeForceField(&forceField);
	free(fileNameOpt);
	free(fileNameFreq);
}
File: ./cchemilib/src/InterfaceTensorMol/InterfaceTM.c
/********************************************************************************
 cchemi is an interface to ab initio computational chemistry programs 
 designed for add them many functionalities non available in these packages.
 Copyright (C) 2010 Abdulrahman Allouche (University Lyon 1)

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
********************************************************************************/

/* InterfacTM.c */


#ifndef OS_WIN32
#include <unistd.h>
#endif

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#ifdef ENABLE_MPI
#include <mpi.h>
#endif

#include "../Utils/Utils.h"
#include "../Utils/AtomsProp.h"
#include "../Utils/Constants.h"
#include "../Utils/Types.h"
#include "../Molecule/Molecule.h"
#include "InterfaceTM.h"

#ifdef ENABLE_PYTHON

PyObject* vectorToList_Str(char** data, int size)
{
	int i;
	PyObject* listObj = PyList_New(size);
	if (!listObj) fprintf(stderr," Unable to allocate memory for Python list");
	for (i = 0; i < size; i++)
	{
		PyObject *num = PyUnicode_FromString(data[i]);
		if (!num) {
			Py_DECREF(listObj);
			fprintf(stderr," Unable to allocate memory for Python list");
		}
		PyList_SET_ITEM(listObj, i, num);
	}
	return listObj;
}

PyObject* vectorToList_Float(double* data, int size)
{
	int i;
	PyObject* listObj = PyList_New(size);
	if (!listObj) fprintf(stderr," Unable to allocate memory for Python list");
	for (i = 0; i < size; i++)
	{
		PyObject *num = PyFloat_FromDouble(data[i]);
		if (!num) {
			Py_DECREF(listObj);
			fprintf(stderr," Unable to allocate memory for Python list");
		}
		PyList_SET_ITEM(listObj, i, num);
	}
	return listObj;
}
// PyObject -> Vector
double* listToVector_Float(PyObject* incoming)
{
	double* data = NULL;
	if (PyList_Check(incoming))
	{
		int i;
		Py_ssize_t j = 0;
		int size = PyList_Size(incoming);
		data = malloc(size*sizeof(double));
		for(j = 0, i=0; j < PyList_Size(incoming); j++,i++)
				data[i] = PyFloat_AsDouble(PyList_GetItem(incoming, j));
	}
	else fprintf(stderr," Passed PyObject pointer was not a list or tuple!");

	return data;
}
static int initManager(InterfaceTM* interfaceTM, Molecule* mol)
{
	int i;

	/* fprintf(stderr,"initManager ================== \n");*/
	if (interfaceTM->pSetData && PyCallable_Check(interfaceTM->pSetData))
	{
		PyObject *pname = PyUnicode_FromString("Test");
		PyObject *pnatoms = PyLong_FromLongLong((long long) mol->nAtoms);
		PyObject *pmult = PyLong_FromLongLong((long long) mol->spinMultiplicity);
		PyObject *pcharge = PyLong_FromLongLong((long long) mol->totalCharge);
		double *X = malloc(mol->nAtoms*sizeof(double));
		double *Y = malloc(mol->nAtoms*sizeof(double));
		double *Z = malloc(mol->nAtoms*sizeof(double));
		char** symbols = malloc(mol->nAtoms*sizeof(char*));
		PyObject *pArgs = PyTuple_New(8);
		PyObject* pX = NULL;
		PyObject* pY = NULL;
		PyObject* pZ = NULL;
		PyObject* pSymbols = NULL;

		for(i=0;i<mol->nAtoms;i++) symbols[i] = strdup(mol->atoms[i].prop.symbol);
		pSymbols = vectorToList_Str(symbols, mol->nAtoms);

		for(i=0;i<mol->nAtoms;i++) X[i] = mol->atoms[i].coordinates[0];
		pX = vectorToList_Float(X, mol->nAtoms);
		for(i=0;i<mol->nAtoms;i++) Y[i] = mol->atoms[i].coordinates[1];
		pY = vectorToList_Float(Y, mol->nAtoms);
		for(i=0;i<mol->nAtoms;i++) Z[i] = mol->atoms[i].coordinates[2];
		pZ = vectorToList_Float(Z, mol->nAtoms);


                PyTuple_SetItem(pArgs, 0, pname);
                PyTuple_SetItem(pArgs, 1, pnatoms);
                PyTuple_SetItem(pArgs, 2, pcharge);
                PyTuple_SetItem(pArgs, 3, pmult);
                PyTuple_SetItem(pArgs, 4, pSymbols);
                PyTuple_SetItem(pArgs, 5, pX);
                PyTuple_SetItem(pArgs, 6, pY);
                PyTuple_SetItem(pArgs, 7, pZ);
		interfaceTM->pa = PyObject_CallObject(interfaceTM->pSetData, pArgs);

		if(interfaceTM->pa && interfaceTM->pGetManager && PyCallable_Check(interfaceTM->pGetManager))
		{
			PyObject *pArgs = PyTuple_New(1);
                	PyTuple_SetItem(pArgs, 0, interfaceTM->pa);
			/* fprintf(stderr,"Call getManager\n");*/
			interfaceTM->pManager = PyObject_CallObject(interfaceTM->pGetManager, pArgs);
			/* if(interfaceTM->pManager) fprintf(stderr,"pManager != NULL\n");*/
			if(!interfaceTM->pManager) 
			{
				fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
				fprintf(stderr,"I cannot get Manager from tmModule\n");
				fprintf(stderr,"Program stopped\n");
				fprintf(stderr,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
			}
			//if(pArgs) Py_DECREF(pArgs);
		}

		if(pSymbols) Py_DECREF(pSymbols);
		if(pX) Py_DECREF(pX);
		if(pY) Py_DECREF(pY);
		if(pZ) Py_DECREF(pZ);
		for(i=0;i<mol->nAtoms;i++) if(symbols[i]) free(symbols[i]);
		free(symbols);
		free(X);
		free(Y);
		free(Z);
        }

	interfaceTM->initialized = 1;
	/* fprintf(stderr,"END initManager ================== \n");*/
	return 0;
}
static int setCoordinates(InterfaceTM* interfaceTM, Molecule* mol)
{

	if(!interfaceTM->pa) initManager(interfaceTM, mol);
	if(interfaceTM->pa && interfaceTM->pManager) 
	{
               	/* fprintf(stderr,"ok pa & pManage in setCoordinates\n");*/
		if (interfaceTM->pSetCoordinates && PyCallable_Check(interfaceTM->pSetCoordinates))
		{
			int i;
			double *X = malloc(mol->nAtoms*sizeof(double));
			double *Y = malloc(mol->nAtoms*sizeof(double));
			double *Z = malloc(mol->nAtoms*sizeof(double));
			PyObject* pX = NULL;
			PyObject* pY = NULL;
			PyObject* pZ = NULL;
			PyObject* a= NULL;

			for(i=0;i<mol->nAtoms;i++) X[i] = mol->atoms[i].coordinates[0];
			pX = vectorToList_Float(X, mol->nAtoms);
			for(i=0;i<mol->nAtoms;i++) Y[i] = mol->atoms[i].coordinates[1];
			pY = vectorToList_Float(Y, mol->nAtoms);
			for(i=0;i<mol->nAtoms;i++) Z[i] = mol->atoms[i].coordinates[2];
			pZ = vectorToList_Float(Z, mol->nAtoms);

                	/* fprintf(stderr,"ok pGetEnergy in interfaceTMComputeEnergy\n");*/
			a= PyObject_CallFunctionObjArgs(interfaceTM->pSetCoordinates, interfaceTM->pa,  pX, pY, pZ,  NULL);
			if(pX) Py_DECREF(pX);
			if(pY) Py_DECREF(pY);
			if(pZ) Py_DECREF(pZ);
            		if (a != NULL)
			{
                		/* fprintf(stderr,"Ok setCoordinates\n");*/
				return 0;
			}
			else
			{
                		fprintf(stderr,"a = NULL in setCoordinates\n");
				return 1;
			}
		}
	}
	return 0;
}


/*
static void printDebug(int nAtoms, char** symbols, double** coordinates, double** forces, double* energy)
{
	int i;
	fprintf(stderr," printDebug\n");
	fprintf(stderr," nAtoms = %d\n", nAtoms);
	fprintf(stderr," Energy = %f\n", *energy);
	for(i=0;i<nAtoms;i++)
	{
		fprintf(stderr," %s %f %f %f %f %f %f\n",symbols[i],
		coordinates[i][0], coordinates[i][1], coordinates[i][2], 
		forces[i][0], forces[i][1], forces[i][2]); 
	}
}
static void printDebug2(Molecule* mol)
{
	int i;
	fprintf(stderr," printDebug\n");
	fprintf(stderr," nAtoms = %d\n", mol->nAtoms);
	fprintf(stderr," Energy = %f\n", mol->potentialEnergy);
	for(i=0;i<mol->nAtoms;i++)
	{
		fprintf(stderr," %s %f %f %f %f %f %f\n",mol->atoms[i].prop.symbol,
		mol->atoms[i].coordinates[0],
		mol->atoms[i].coordinates[1],
		mol->atoms[i].coordinates[2],
		mol->atoms[i].gradient[0],
		mol->atoms[i].gradient[1],
		mol->atoms[i].gradient[2]);
	}
}
*/
static void interfaceTMInitialize(InterfaceTM* interfaceTM, char* tmModule)
{
	if(!Py_IsInitialized()) Py_Initialize();
	/*
	fprintf(stderr," End Py_Initialize\n");
	fprintf(stderr,"tmModule =%s\n",tmModule);
	*/
	interfaceTM->pName = PyUnicode_DecodeFSDefault(tmModule);
	if(interfaceTM->pName) 
	{
		/* fprintf(stderr," ok pName\n");*/
		interfaceTM->pModule = PyImport_Import(interfaceTM->pName);
		Py_DECREF(interfaceTM->pName);
		interfaceTM->pName = NULL;
	}
	if (interfaceTM->pModule)
	{
		/* fprintf(stderr," ok pModule\n");*/
        	interfaceTM->pGetManager = PyObject_GetAttrString(interfaceTM->pModule, "getManager");
        	/* pGet is a new reference */
		/* if(interfaceTM->pGetManager) fprintf(stderr," ok getManager\n");*/
		if(!interfaceTM->pGetManager) fprintf(stderr," problem getManager\n");
	}
	if (interfaceTM->pGetManager)
	{
        	interfaceTM->pGetEnergy = PyObject_GetAttrString(interfaceTM->pModule, "getEnergy");
		/* if(interfaceTM->pGetEnergy) fprintf(stderr,"ok getEnergy\n");*/
		if(!interfaceTM->pGetEnergy) fprintf(stderr," problem getEnergy\n");
	}
	if (interfaceTM->pGetEnergy)
	{
        	interfaceTM->pGetEnergyAndForces = PyObject_GetAttrString(interfaceTM->pModule, "getEnergyAndForces");
		/* if(interfaceTM->pGetEnergyAndForces) fprintf(stderr,"ok getEnergyAndForces\n");*/
		if(!interfaceTM->pGetEnergyAndForces) fprintf(stderr," problem with getEnergyAndForces\n");
	}
	if (interfaceTM->pGetEnergyAndForces)
	{
        	interfaceTM->pSetData = PyObject_GetAttrString(interfaceTM->pModule, "setData");
		/* if(interfaceTM->pSetData) fprintf(stderr,"ok setData\n");*/
		if(!interfaceTM->pSetData) fprintf(stderr," problem with setData\n");
	}
	if (interfaceTM->pSetData)
	{
        	interfaceTM->pSetCoordinates = PyObject_GetAttrString(interfaceTM->pModule, "setCoordinates");
		/* if(interfaceTM->pSetCoordinates) fprintf(stderr,"ok pSetCoordinates\n");*/
		if(!interfaceTM->pSetCoordinates) fprintf(stderr," problem with pSetCoordinates\n");
	}
	if (interfaceTM->pSetCoordinates)
	{
        	interfaceTM->pCloseSession = PyObject_GetAttrString(interfaceTM->pModule, "closeSession");
		/* if(interfaceTM->pCloseSession) fprintf(stderr,"ok pCloseSession\n");*/
		if(!interfaceTM->pCloseSession) fprintf(stderr," problem with pCloseSession\n");
	}
	if (interfaceTM->pCloseSession)
	{
        	interfaceTM->pOptGeom = PyObject_GetAttrString(interfaceTM->pModule, "optGeom");
		/* if(interfaceTM->pOptGeom) fprintf(stderr,"ok pOptGeom\n");*/
		if(!interfaceTM->pOptGeom) fprintf(stderr," problem with pOptGeom\n");
	}
	interfaceTM->initialized = 1;
}
InterfaceTM *newInterfaceTM(char* tmModule)
{
	InterfaceTM *interfaceTM= malloc(sizeof(InterfaceTM));
	interfaceTM->pName = NULL;
	interfaceTM->pModule = NULL;
	interfaceTM->pManager = NULL;
	interfaceTM->pGetManager = NULL;
	interfaceTM->pGetEnergy = NULL;
	interfaceTM->pGetEnergyAndForces = NULL;
	interfaceTM->pSetData = NULL;
	interfaceTM->pSetCoordinates = NULL;
	interfaceTM->pOptGeom = NULL;
	interfaceTM->pa = NULL;
	interfaceTM->initialized = 0;
	interfaceTMInitialize(interfaceTM,tmModule);
	return interfaceTM;
}
int interfaceTMComputeGradients(InterfaceTM* interfaceTM, Molecule* mol)
{
	if(!interfaceTM->pa) initManager(interfaceTM, mol);
	if(interfaceTM->pa && interfaceTM->pManager) 
	{
               	/* fprintf(stderr,"ok pa & pManage in interfaceTMComputeGradients\n");*/
		if (interfaceTM->pGetEnergyAndForces && PyCallable_Check(interfaceTM->pGetEnergyAndForces))
		{
			PyObject* listRes = NULL;
                	/* fprintf(stderr,"ok pGetEnergyAndForces in interfaceTMComputeGradients\n");*/
			/*
			PyObject *pArgs = PyTuple_New(2);
                	PyTuple_SetItem(pArgs, 0, interfaceTM->pa );
                	PyTuple_SetItem(pArgs, 1, interfaceTM->pManager );
			PyObject* pEner = PyObject_CallObject(interfaceTM->pGetEnergy, pArgs);
			Py_DECREF(pArgs);
			*/
			setCoordinates(interfaceTM, mol);
               		/* fprintf(stderr,"End setCoordinates in interfaceTMComputeGradients\n");*/
			listRes = PyObject_CallFunctionObjArgs(interfaceTM->pGetEnergyAndForces, interfaceTM->pa,  interfaceTM->pManager,  NULL);
               		/* fprintf(stderr,"End PyObject_CallFunctionObjArgs in interfaceTMComputeGradients\n");*/
            		if (listRes != NULL)
			{
				int i,j,k;
				double energy = PyFloat_AsDouble(PyList_GetItem(listRes, 0));
				double dipole[3];
				for(k=0;k<3;k++) dipole[k] = PyFloat_AsDouble(PyList_GetItem(listRes, k+1));
                		/* fprintf(stderr,"Result of call: Ener = %0.14lf dipole= %0.14lf %0.14lf %0.14lf\n", energy,dipole[0], dipole[1],dipole[2]);*/
                		//Py_DECREF(pEner);
				mol->potentialEnergy = energy*AUTOKCAL;
				for(k=0;k<3;k++) mol->dipole[k] = dipole[k]*AUTODEB;
				j=4;
				for(i=0;i<mol->nAtoms;i++)
					for(k=0;k<3;k++) 
					{
						mol->atoms[i].gradient[k] = AUTOKCAL/BOHRTOANG*PyFloat_AsDouble(PyList_GetItem(listRes, j));
						j++;
					}
				for(i=0;i<mol->nAtoms;i++)
				{
					mol->atoms[i].charge =PyFloat_AsDouble(PyList_GetItem(listRes, j));
					j++;
				}

        		}
			else
                		fprintf(stderr,"listRed of pGetEnergyAndForces = NULL in interfaceTMComputeGradients\n");
		}
	}
	/* fprintf(stderr," interfaceTMComputeGradients\n");*/
	return 0;
}
int interfaceTMComputeEnergy(InterfaceTM* interfaceTM, Molecule* mol)
{
	if(!interfaceTM->pa) initManager(interfaceTM, mol);
	if(interfaceTM->pa && interfaceTM->pManager) 
	{
               	/* fprintf(stderr,"ok pa & pManage in interfaceTMComputeEnergy\n");*/
		if (interfaceTM->pGetEnergy && PyCallable_Check(interfaceTM->pGetEnergy))
		{
			PyObject* listRes = NULL;
                	/* fprintf(stderr,"ok pGetEnergy in interfaceTMComputeEnergy\n");*/
			/*
			PyObject *pArgs = PyTuple_New(2);
                	PyTuple_SetItem(pArgs, 0, interfaceTM->pa );
                	PyTuple_SetItem(pArgs, 1, interfaceTM->pManager );
			PyObject* pEner = PyObject_CallObject(interfaceTM->pGetEnergy, pArgs);
			Py_DECREF(pArgs);
			*/
			setCoordinates(interfaceTM, mol);
               		/* fprintf(stderr,"End setCoordinates in interfaceTMComputeEnergy\n");*/
			listRes = PyObject_CallFunctionObjArgs(interfaceTM->pGetEnergy, interfaceTM->pa,  interfaceTM->pManager,  NULL);
            		if (listRes != NULL)
			{
				int i,j,k;
				double energy = PyFloat_AsDouble(PyList_GetItem(listRes, 0));
				double dipole[3];
				for(k=0;k<3;k++) dipole[k] = PyFloat_AsDouble(PyList_GetItem(listRes, k+1));
                		/* fprintf(stderr,"Result of call: Ener = %0.14lf dipole= %0.14lf %0.14lf %0.14lf\n", energy,dipole[0], dipole[1],dipole[2]);*/
				mol->potentialEnergy = energy*AUTOKCAL;
				for(k=0;k<3;k++) mol->dipole[k] = dipole[k]*AUTODEB;
				for(i=0;i<mol->nAtoms;i++) for(k=0;k<3;k++) mol->atoms[i].gradient[k] = 0;
				j=4;
				for(i=0;i<mol->nAtoms;i++)
				{
					mol->atoms[i].charge =PyFloat_AsDouble(PyList_GetItem(listRes, j));
					j++;
				}

        		}
			else
			{
                		fprintf(stderr,"pEnergy = NULL in interfaceTMComputeEnergy\n");
				return 1;
			}
		}
	}
	/* fprintf(stderr," interfaceTMComputeEnergy\n");*/
	return 0;
}
int interfaceTMOpt(InterfaceTM* interfaceTM, Molecule* mol)
{
	if(!interfaceTM->pa) initManager(interfaceTM, mol);
	if(interfaceTM->pa && interfaceTM->pManager) 
	{
               	/* fprintf(stderr,"ok pa & pManage in interfaceTMComputeGradients\n");*/
		if (interfaceTM->pOptGeom && PyCallable_Check(interfaceTM->pOptGeom))
		{
			PyObject* listRes = NULL;
                	/* fprintf(stderr,"ok pOptGeom in interfaceTMOpt\n");*/
			setCoordinates(interfaceTM, mol);
			listRes = PyObject_CallFunctionObjArgs(interfaceTM->pOptGeom, interfaceTM->pa,  interfaceTM->pManager,  NULL);
            		if (listRes != NULL)
			{
				int i,j,k;
				double energy = PyFloat_AsDouble(PyList_GetItem(listRes, 0));
				double dipole[3];
				for(k=0;k<3;k++) dipole[k] = PyFloat_AsDouble(PyList_GetItem(listRes, k+1));
                		/* fprintf(stderr,"Result of call: Ener = %0.14lf dipole= %0.14lf %0.14lf %0.14lf\n", energy,dipole[0], dipole[1],dipole[2]);*/
                		//Py_DECREF(pEner);
				mol->potentialEnergy = energy*AUTOKCAL;
				for(k=0;k<3;k++) mol->dipole[k] = dipole[k]*AUTODEB;
				j=4;
				for(i=0;i<mol->nAtoms;i++)
					for(k=0;k<3;k++) 
					{
						mol->atoms[i].coordinates[k] = PyFloat_AsDouble(PyList_GetItem(listRes, j));
						j++;
					}
				for(i=0;i<mol->nAtoms;i++)
					for(k=0;k<3;k++) 
					{
						mol->atoms[i].gradient[k] = AUTOKCAL/BOHRTOANG*PyFloat_AsDouble(PyList_GetItem(listRes, j));
						j++;
					}
				for(i=0;i<mol->nAtoms;i++)
				{
					mol->atoms[i].charge =PyFloat_AsDouble(PyList_GetItem(listRes, j));
					j++;
				}

        		}
			else
                		fprintf(stderr,"listRed of pOptGeom = NULL in iinterfaceTMOpt\n");
		}
	}
	/* fprintf(stderr," interfaceTMOpt\n");*/
	return 0;
}
static int interfaceCloseSession(InterfaceTM* interfaceTM)
{
	if(interfaceTM->pa && interfaceTM->pManager) 
	{
		if (interfaceTM->pCloseSession && PyCallable_Check(interfaceTM->pCloseSession))
			PyObject_CallFunctionObjArgs(interfaceTM->pCloseSession, NULL);
	}
	/* fprintf(stderr," interfaceCloseSession\n");*/
	return 0;
}
void interfaceTMDestroy(InterfaceTM* interfaceTM)
{
	interfaceCloseSession(interfaceTM);
	/* Py_FinalizeEx();*/
}
int runTensorMol(Molecule* mol, char* moduleName, int computeGradients)
{
	InterfaceTM* interfaceTM = newInterfaceTM(moduleName);
	int err = 0;
	if(computeGradients) interfaceTMComputeGradients(interfaceTM, mol);
	else err = interfaceTMComputeEnergy(interfaceTM, mol);
	interfaceTMDestroy(interfaceTM);
	/* fprintf(stderr," runTensorMol\n");*/
	return err;
}
int runTM(Molecule* mol, char* moduleName, int computeGradients)
{
	return runTensorMol(mol,moduleName,computeGradients);
}
int runOptTensorMol(Molecule* mol, char* moduleName)
{
	InterfaceTM* interfaceTM = newInterfaceTM(moduleName);
	int err = interfaceTMOpt(interfaceTM, mol);
	interfaceTMDestroy(interfaceTM);
	/* fprintf(stderr," runOptTensorMol\n");*/
	return err;
}
#else
int runTM(Molecule* mol, char* moduleName, int computeGradients)
{
	exit(1);/* compilatation with python is required for TensorMol interface */
	return 1;
}
int runOptTensorMol(Molecule* mol, char* moduleName)
{
	exit(1);/* compilatation with python is required for TensorMol interface */
	return 1;
}
#endif  /* ENABLE_PYTHON*/
